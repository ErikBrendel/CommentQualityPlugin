# id;timestamp;commentText;codeText;commentWords;codeWords
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1412630983;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (AccessException ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,access,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,access,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1414434951;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (AccessException ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,access,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,access,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1431524748;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (AccessException ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,access,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,access,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1432125256;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (AccessException ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,access,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,access,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1437390274;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (Exception ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (Exception ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1467730834;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (Exception ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (Exception ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1468948866;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (Exception ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (Exception ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1477660538;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (Exception ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									evalContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(evalContext, contextObject.getValue(), name)__					}_				}_			}_			catch (Exception ex) {_				throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1496837955;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (Exception ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1498780456;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(evalContext, contextObject.getValue(), name)__			}_			catch (Exception ex) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1500038285;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {_				try {_					return accessorToUse.read(evalContext, contextObject.getValue(), name)__				}_				catch (Exception ex) {_					_					_				}_			}_			this.cachedReadAccessor = null__		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,if,eval,context,get,property,accessors,contains,accessor,to,use,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1520895539;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {_				try {_					return accessorToUse.read(evalContext, contextObject.getValue(), name)__				}_				catch (Exception ex) {_					_					_				}_			}_			this.cachedReadAccessor = null__		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,if,eval,context,get,property,accessors,contains,accessor,to,use,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1521044698;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {_				try {_					return accessorToUse.read(evalContext, contextObject.getValue(), name)__				}_				catch (Exception ex) {_					_					_				}_			}_			this.cachedReadAccessor = null__		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,if,eval,context,get,property,accessors,contains,accessor,to,use,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1530174524;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {_				try {_					return accessorToUse.read(evalContext, contextObject.getValue(), name)__				}_				catch (Exception ex) {_					_					_				}_			}_			this.cachedReadAccessor = null__		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,if,eval,context,get,property,accessors,contains,accessor,to,use,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1532978875;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {_				try {_					return accessorToUse.read(evalContext, contextObject.getValue(), name)__				}_				catch (Exception ex) {_					_					_				}_			}_			this.cachedReadAccessor = null__		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,if,eval,context,get,property,accessors,contains,accessor,to,use,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name) 			throws EvaluationException;1548712256;Attempt to read the named property from the current context object._@return the value of the property_@throws EvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext evalContext, String name)_			throws EvaluationException {__		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			if (evalContext.getPropertyAccessors().contains(accessorToUse)) {_				try {_					return accessorToUse.read(evalContext, contextObject.getValue(), name)__				}_				catch (Exception ex) {_					_					_				}_			}_			this.cachedReadAccessor = null__		}__		List<PropertyAccessor> accessorsToTry =_				getPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors())__		_		_		_		try {_			for (PropertyAccessor accessor : accessorsToTry) {_				if (accessor.canRead(evalContext, contextObject.getValue(), name)) {_					if (accessor instanceof ReflectivePropertyAccessor) {_						accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_								evalContext, contextObject.getValue(), name)__					}_					this.cachedReadAccessor = accessor__					return accessor.read(evalContext, contextObject.getValue(), name)__				}_			}_		}_		catch (Exception ex) {_			throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ex.getMessage())__		}__		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,eval,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,if,eval,context,get,property,accessors,contains,accessor,to,use,try,return,accessor,to,use,read,eval,context,context,object,get,value,name,catch,exception,ex,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,eval,context,get,property,accessors,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,eval,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,eval,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,eval,context,context,object,get,value,name,catch,exception,ex,throw,new,spel,evaluation,exception,ex,spel,message,name,ex,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1496837955;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1498780456;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1500038285;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1520895539;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1521044698;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1530174524;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1532978875;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry( 			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors);1548712256;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(_			@Nullable Object contextObject, List<PropertyAccessor> propertyAccessors) {__		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,nullable,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1351041784;Attempt to read the named property from the current context object._@param state the evaluation state_@param name the name of the property_@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()___		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		Class<?> contextObjectClass = getObjectClass(contextObject.getValue())__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObjectClass, eContext.getPropertyAccessors())___		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(contextObjectClass))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,param,state,the,evaluation,state,param,name,the,name,of,the,property,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,class,context,object,class,get,object,class,context,object,get,value,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,class,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,context,object,class
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1356735495;Attempt to read the named property from the current context object._@param state the evaluation state_@param name the name of the property_@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()___		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		Class<?> contextObjectClass = getObjectClass(contextObject.getValue())__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObjectClass, eContext.getPropertyAccessors())___		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(contextObjectClass))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,param,state,the,evaluation,state,param,name,the,name,of,the,property,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,class,context,object,class,get,object,class,context,object,get,value,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,class,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,context,object,class
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1357119239;Attempt to read the named property from the current context object._@param state the evaluation state_@param name the name of the property_@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()___		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		Class<?> contextObjectClass = getObjectClass(contextObject.getValue())__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObjectClass, eContext.getPropertyAccessors())___		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(contextObjectClass))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,param,state,the,evaluation,state,param,name,the,name,of,the,property,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,class,context,object,class,get,object,class,context,object,get,value,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,class,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,context,object,class
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1368482696;Attempt to read the named property from the current context object._@param state the evaluation state_@param name the name of the property_@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()___		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		Class<?> contextObjectClass = getObjectClass(contextObject.getValue())__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObjectClass, eContext.getPropertyAccessors())___		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(contextObjectClass))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,param,state,the,evaluation,state,param,name,the,name,of,the,property,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,class,context,object,class,get,object,class,context,object,get,value,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,class,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,context,object,class
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1372363092;Attempt to read the named property from the current context object._@param state the evaluation state_@param name the name of the property_@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()___		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		Class<?> contextObjectClass = getObjectClass(contextObject.getValue())__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObjectClass, eContext.getPropertyAccessors())___		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(contextObjectClass))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,param,state,the,evaluation,state,param,name,the,name,of,the,property,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,class,context,object,class,get,object,class,context,object,get,value,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,class,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,context,object,class
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1382738491;Attempt to read the named property from the current context object._@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		Class<?> contextObjectClass = getObjectClass(contextObject.getValue())__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObjectClass, eContext.getPropertyAccessors())___		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(contextObjectClass))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,class,context,object,class,get,object,class,context,object,get,value,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,class,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,context,object,class
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1395866798;Attempt to read the named property from the current context object._@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1405011154;Attempt to read the named property from the current context object._@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1405514506;Attempt to read the named property from the current context object._@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException;1406039079;Attempt to read the named property from the current context object._@return the value of the property_@throws SpelEvaluationException if any problem accessing the property or it cannot be found;private TypedValue readProperty(TypedValue contextObject, EvaluationContext eContext, String name) throws EvaluationException {_		Object targetObject = contextObject.getValue()__		if (targetObject == null && this.nullSafe) {_			return TypedValue.NULL__		}__		PropertyAccessor accessorToUse = this.cachedReadAccessor__		if (accessorToUse != null) {_			try {_				return accessorToUse.read(eContext, contextObject.getValue(), name)__			}_			catch (AccessException ae) {_				_				_				this.cachedReadAccessor = null__			}_		}__		List<PropertyAccessor> accessorsToTry = getPropertyAccessorsToTry(contextObject.getValue(), eContext.getPropertyAccessors())__		_		_		_		if (accessorsToTry != null) {_			try {_				for (PropertyAccessor accessor : accessorsToTry) {_					if (accessor.canRead(eContext, contextObject.getValue(), name)) {_						if (accessor instanceof ReflectivePropertyAccessor) {_							accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(_									eContext, contextObject.getValue(), name)__						}_						this.cachedReadAccessor = accessor__						return accessor.read(eContext, contextObject.getValue(), name)__					}_				}_			}_			catch (AccessException ae) {_				throw new SpelEvaluationException(ae, SpelMessage.EXCEPTION_DURING_PROPERTY_READ, name, ae.getMessage())__			}_		}_		if (contextObject.getValue() == null) {_			throw new SpelEvaluationException(SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE_ON_NULL, name)__		}_		else {_			throw new SpelEvaluationException(getStartPosition(), SpelMessage.PROPERTY_OR_FIELD_NOT_READABLE, name,_					FormatHelper.formatClassNameForMessage(getObjectClass(contextObject.getValue())))__		}_	};attempt,to,read,the,named,property,from,the,current,context,object,return,the,value,of,the,property,throws,spel,evaluation,exception,if,any,problem,accessing,the,property,or,it,cannot,be,found;private,typed,value,read,property,typed,value,context,object,evaluation,context,e,context,string,name,throws,evaluation,exception,object,target,object,context,object,get,value,if,target,object,null,this,null,safe,return,typed,value,null,property,accessor,accessor,to,use,this,cached,read,accessor,if,accessor,to,use,null,try,return,accessor,to,use,read,e,context,context,object,get,value,name,catch,access,exception,ae,this,cached,read,accessor,null,list,property,accessor,accessors,to,try,get,property,accessors,to,try,context,object,get,value,e,context,get,property,accessors,if,accessors,to,try,null,try,for,property,accessor,accessor,accessors,to,try,if,accessor,can,read,e,context,context,object,get,value,name,if,accessor,instanceof,reflective,property,accessor,accessor,reflective,property,accessor,accessor,create,optimal,accessor,e,context,context,object,get,value,name,this,cached,read,accessor,accessor,return,accessor,read,e,context,context,object,get,value,name,catch,access,exception,ae,throw,new,spel,evaluation,exception,ae,spel,message,name,ae,get,message,if,context,object,get,value,null,throw,new,spel,evaluation,exception,spel,message,name,else,throw,new,spel,evaluation,exception,get,start,position,spel,message,name,format,helper,format,class,name,for,message,get,object,class,context,object,get,value
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1395866798;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1405011154;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1405514506;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1406039079;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1411076938;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1412630983;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1414434951;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1431524748;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1432125256;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1437390274;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1467730834;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1468948866;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors);1477660538;Determines the set of property resolvers that should be used to try and access a property_on the specified target type. The resolvers are considered to be in an ordered list,_however in the returned list any that are exact matches for the input target type (as_opposed to 'general' resolvers that could work for any type) are placed at the start of the_list. In addition, there are specific resolvers that exactly name the class in question_and resolvers that name a specific class but it is a supertype of the class we have._These are put at the end of the specific resolvers set and will be tried after exactly_matching accessors but before generic accessors._@param contextObject the object upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Object contextObject, List<PropertyAccessor> propertyAccessors) {_		Class<?> targetType = (contextObject != null ? contextObject.getClass() : null)___		List<PropertyAccessor> specificAccessors = new ArrayList<>()__		List<PropertyAccessor> generalAccessors = new ArrayList<>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) {_				_				generalAccessors.add(resolver)__			}_			else if (targetType != null) {_				for (Class<?> clazz : targets) {_					if (clazz == targetType) {_						specificAccessors.add(resolver)__						break__					}_					else if (clazz.isAssignableFrom(targetType)) {_						generalAccessors.add(resolver)__					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,context,object,the,object,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,object,context,object,list,property,accessor,property,accessors,class,target,type,context,object,null,context,object,get,class,null,list,property,accessor,specific,accessors,new,array,list,list,property,accessor,general,accessors,new,array,list,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1351041784;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					for (Class<?> clazz : targets) {_						if (clazz == targetType) {_							specificAccessors.add( resolver)__							break__						}_						else if (clazz.isAssignableFrom(targetType)) { _							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1356735495;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					for (Class<?> clazz : targets) {_						if (clazz == targetType) {_							specificAccessors.add( resolver)__							break__						}_						else if (clazz.isAssignableFrom(targetType)) {_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1357119239;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					for (Class<?> clazz : targets) {_						if (clazz == targetType) {_							specificAccessors.add( resolver)__							break__						}_						else if (clazz.isAssignableFrom(targetType)) {_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1368482696;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					for (Class<?> clazz : targets) {_						if (clazz == targetType) {_							specificAccessors.add( resolver)__							break__						}_						else if (clazz.isAssignableFrom(targetType)) {_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1372363092;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					for (Class<?> clazz : targets) {_						if (clazz == targetType) {_							specificAccessors.add( resolver)__							break__						}_						else if (clazz.isAssignableFrom(targetType)) {_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
PropertyOrFieldReference -> private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors);1382738491;Determines the set of property resolvers that should be used to try and access a property on the specified target_type. The resolvers are considered to be in an ordered list, however in the returned list any that are exact_matches for the input target type (as opposed to 'general' resolvers that could work for any type) are placed at_the start of the list. In addition, there are specific resolvers that exactly name the class in question and_resolvers that name a specific class but it is a supertype of the class we have. These are put at the end of the_specific resolvers set and will be tried after exactly matching accessors but before generic accessors._@param targetType the type upon which property access is being attempted_@return a list of resolvers that should be tried in order to access the property;private List<PropertyAccessor> getPropertyAccessorsToTry(Class<?> targetType, List<PropertyAccessor> propertyAccessors) {_		List<PropertyAccessor> specificAccessors = new ArrayList<PropertyAccessor>()__		List<PropertyAccessor> generalAccessors = new ArrayList<PropertyAccessor>()__		for (PropertyAccessor resolver : propertyAccessors) {_			Class<?>[] targets = resolver.getSpecificTargetClasses()__			if (targets == null) { _				generalAccessors.add(resolver)__			}_			else {_				if (targetType != null) {_					for (Class<?> clazz : targets) {_						if (clazz == targetType) {_							specificAccessors.add( resolver)__							break__						}_						else if (clazz.isAssignableFrom(targetType)) {_							generalAccessors.add(resolver)__						}_					}_				}_			}_		}_		List<PropertyAccessor> resolvers = new ArrayList<PropertyAccessor>()__		resolvers.addAll(specificAccessors)__		generalAccessors.removeAll(specificAccessors)__		resolvers.addAll(generalAccessors)__		return resolvers__	};determines,the,set,of,property,resolvers,that,should,be,used,to,try,and,access,a,property,on,the,specified,target,type,the,resolvers,are,considered,to,be,in,an,ordered,list,however,in,the,returned,list,any,that,are,exact,matches,for,the,input,target,type,as,opposed,to,general,resolvers,that,could,work,for,any,type,are,placed,at,the,start,of,the,list,in,addition,there,are,specific,resolvers,that,exactly,name,the,class,in,question,and,resolvers,that,name,a,specific,class,but,it,is,a,supertype,of,the,class,we,have,these,are,put,at,the,end,of,the,specific,resolvers,set,and,will,be,tried,after,exactly,matching,accessors,but,before,generic,accessors,param,target,type,the,type,upon,which,property,access,is,being,attempted,return,a,list,of,resolvers,that,should,be,tried,in,order,to,access,the,property;private,list,property,accessor,get,property,accessors,to,try,class,target,type,list,property,accessor,property,accessors,list,property,accessor,specific,accessors,new,array,list,property,accessor,list,property,accessor,general,accessors,new,array,list,property,accessor,for,property,accessor,resolver,property,accessors,class,targets,resolver,get,specific,target,classes,if,targets,null,general,accessors,add,resolver,else,if,target,type,null,for,class,clazz,targets,if,clazz,target,type,specific,accessors,add,resolver,break,else,if,clazz,is,assignable,from,target,type,general,accessors,add,resolver,list,property,accessor,resolvers,new,array,list,property,accessor,resolvers,add,all,specific,accessors,general,accessors,remove,all,specific,accessors,resolvers,add,all,general,accessors,return,resolvers
