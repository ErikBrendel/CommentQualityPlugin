commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;4;;@Nullable public final String getOriginalValue() {     return this.originalValue. }
false;public,final;1;4;;@Override public final TypedValue getValueInternal(ExpressionState state) throws SpelEvaluationException {     return getLiteralValue(). }
false;public;0;4;;@Override public String toString() {     return String.valueOf(getLiteralValue().getValue()). }
false;public;0;4;;@Override public String toStringAST() {     return toString(). }
false;public,abstract;0;1;;public abstract TypedValue getLiteralValue().
true;public,static;4;9;/**  * Process the string form of a number, using the specified base if supplied  * and return an appropriate literal to hold it. Any suffix to indicate a  * long will be taken into account (either 'l' or 'L' is supported).  * @param numberToken the token holding the number as its payload (eg. 1234 or 0xCAFE)  * @param radix the base of number  * @return a subtype of Literal that can represent it  */ ;/**  * Process the string form of a number, using the specified base if supplied  * and return an appropriate literal to hold it. Any suffix to indicate a  * long will be taken into account (either 'l' or 'L' is supported).  * @param numberToken the token holding the number as its payload (eg. 1234 or 0xCAFE)  * @param radix the base of number  * @return a subtype of Literal that can represent it  */ public static Literal getIntLiteral(String numberToken, int startPos, int endPos, int radix) {     try {         int value = Integer.parseInt(numberToken, radix).         return new IntLiteral(numberToken, startPos, endPos, value).     } catch (NumberFormatException ex) {         throw new InternalParseException(new SpelParseException(startPos, ex, SpelMessage.NOT_AN_INTEGER, numberToken)).     } }
false;public,static;4;9;;public static Literal getLongLiteral(String numberToken, int startPos, int endPos, int radix) {     try {         long value = Long.parseLong(numberToken, radix).         return new LongLiteral(numberToken, startPos, endPos, value).     } catch (NumberFormatException ex) {         throw new InternalParseException(new SpelParseException(startPos, ex, SpelMessage.NOT_A_LONG, numberToken)).     } }
false;public,static;4;15;;public static Literal getRealLiteral(String numberToken, int startPos, int endPos, boolean isFloat) {     try {         if (isFloat) {             float value = Float.parseFloat(numberToken).             return new FloatLiteral(numberToken, startPos, endPos, value).         } else {             double value = Double.parseDouble(numberToken).             return new RealLiteral(numberToken, startPos, endPos, value).         }     } catch (NumberFormatException ex) {         throw new InternalParseException(new SpelParseException(startPos, ex, SpelMessage.NOT_A_REAL, numberToken)).     } }
