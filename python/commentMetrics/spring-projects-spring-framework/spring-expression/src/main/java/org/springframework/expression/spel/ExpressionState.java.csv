commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * The active context object is what unqualified references to properties/etc are resolved against.  */ ;/**  * The active context object is what unqualified references to properties/etc are resolved against.  */ public TypedValue getActiveContextObject() {     if (CollectionUtils.isEmpty(this.contextObjects)) {         return this.rootObject.     }     return this.contextObjects.element(). }
false;public;1;6;;public void pushActiveContextObject(TypedValue obj) {     if (this.contextObjects == null) {         this.contextObjects = new ArrayDeque<>().     }     this.contextObjects.push(obj). }
false;public;0;11;;public void popActiveContextObject() {     if (this.contextObjects == null) {         this.contextObjects = new ArrayDeque<>().     }     try {         this.contextObjects.pop().     } catch (NoSuchElementException ex) {         throw new IllegalStateException("Cannot pop active context object: stack is empty").     } }
false;public;0;3;;public TypedValue getRootContextObject() {     return this.rootObject. }
false;public;0;6;;public TypedValue getScopeRootContextObject() {     if (CollectionUtils.isEmpty(this.scopeRootObjects)) {         return this.rootObject.     }     return this.scopeRootObjects.element(). }
false;public;2;3;;public void setVariable(String name, @Nullable Object value) {     this.relatedContext.setVariable(name, value). }
false;public;1;4;;public TypedValue lookupVariable(String name) {     Object value = this.relatedContext.lookupVariable(name).     return (value != null ? new TypedValue(value) : TypedValue.NULL). }
false;public;0;3;;public TypeComparator getTypeComparator() {     return this.relatedContext.getTypeComparator(). }
false;public;1;3;;public Class<?> findType(String type) throws EvaluationException {     return this.relatedContext.getTypeLocator().findType(type). }
false;public;2;8;;public Object convertValue(Object value, TypeDescriptor targetTypeDescriptor) throws EvaluationException {     Object result = this.relatedContext.getTypeConverter().convertValue(value, TypeDescriptor.forObject(value), targetTypeDescriptor).     if (result == null) {         throw new IllegalStateException("Null conversion result for value [" + value + "]").     }     return result. }
false;public;0;3;;public TypeConverter getTypeConverter() {     return this.relatedContext.getTypeConverter(). }
false;public;2;6;;@Nullable public Object convertValue(TypedValue value, TypeDescriptor targetTypeDescriptor) throws EvaluationException {     Object val = value.getValue().     return this.relatedContext.getTypeConverter().convertValue(val, TypeDescriptor.forObject(val), targetTypeDescriptor). }
true;public;1;4;/* 	 * A new scope is entered when a function is invoked. 	 */ ;/* 	 * A new scope is entered when a function is invoked. 	 */ public void enterScope(Map<String, Object> argMap) {     initVariableScopes().push(new VariableScope(argMap)).     initScopeRootObjects().push(getActiveContextObject()). }
false;public;0;4;;public void enterScope() {     initVariableScopes().push(new VariableScope(Collections.emptyMap())).     initScopeRootObjects().push(getActiveContextObject()). }
false;public;2;4;;public void enterScope(String name, Object value) {     initVariableScopes().push(new VariableScope(name, value)).     initScopeRootObjects().push(getActiveContextObject()). }
false;public;0;4;;public void exitScope() {     initVariableScopes().pop().     initScopeRootObjects().pop(). }
false;public;2;3;;public void setLocalVariable(String name, Object value) {     initVariableScopes().element().setVariable(name, value). }
false;public;1;9;;@Nullable public Object lookupLocalVariable(String name) {     for (VariableScope scope : initVariableScopes()) {         if (scope.definesVariable(name)) {             return scope.lookupVariable(name).         }     }     return null. }
false;private;0;8;;private Deque<VariableScope> initVariableScopes() {     if (this.variableScopes == null) {         this.variableScopes = new ArrayDeque<>().         // top-level empty variable scope         this.variableScopes.add(new VariableScope()).     }     return this.variableScopes. }
false;private;0;6;;private Deque<TypedValue> initScopeRootObjects() {     if (this.scopeRootObjects == null) {         this.scopeRootObjects = new ArrayDeque<>().     }     return this.scopeRootObjects. }
false;public;3;12;;public TypedValue operate(Operation op, @Nullable Object left, @Nullable Object right) throws EvaluationException {     OperatorOverloader overloader = this.relatedContext.getOperatorOverloader().     if (overloader.overridesOperation(op, left, right)) {         Object returnValue = overloader.operate(op, left, right).         return new TypedValue(returnValue).     } else {         String leftType = (left == null ? "null" : left.getClass().getName()).         String rightType = (right == null ? "null" : right.getClass().getName()).         throw new SpelEvaluationException(SpelMessage.OPERATOR_NOT_SUPPORTED_BETWEEN_TYPES, op, leftType, rightType).     } }
false;public;0;3;;public List<PropertyAccessor> getPropertyAccessors() {     return this.relatedContext.getPropertyAccessors(). }
false;public;0;3;;public EvaluationContext getEvaluationContext() {     return this.relatedContext. }
false;public;0;3;;public SpelParserConfiguration getConfiguration() {     return this.configuration. }
false;public;1;3;;public Object lookupVariable(String name) {     return this.vars.get(name). }
false;public;2;3;;public void setVariable(String name, Object value) {     this.vars.put(name, value). }
false;public;1;3;;public boolean definesVariable(String name) {     return this.vars.containsKey(name). }
