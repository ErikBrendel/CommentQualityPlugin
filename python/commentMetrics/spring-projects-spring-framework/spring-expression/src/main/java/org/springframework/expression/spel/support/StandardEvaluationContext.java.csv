commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public void setRootObject(Object rootObject, TypeDescriptor typeDescriptor) {     this.rootObject = new TypedValue(rootObject, typeDescriptor). }
false;public;1;3;;public void setRootObject(@Nullable Object rootObject) {     this.rootObject = (rootObject != null ? new TypedValue(rootObject) : TypedValue.NULL). }
false;public;0;4;;@Override public TypedValue getRootObject() {     return this.rootObject. }
false;public;1;3;;public void setPropertyAccessors(List<PropertyAccessor> propertyAccessors) {     this.propertyAccessors = propertyAccessors. }
false;public;0;4;;@Override public List<PropertyAccessor> getPropertyAccessors() {     return initPropertyAccessors(). }
false;public;1;3;;public void addPropertyAccessor(PropertyAccessor accessor) {     addBeforeDefault(initPropertyAccessors(), accessor). }
false;public;1;3;;public boolean removePropertyAccessor(PropertyAccessor accessor) {     return initPropertyAccessors().remove(accessor). }
false;public;1;3;;public void setConstructorResolvers(List<ConstructorResolver> constructorResolvers) {     this.constructorResolvers = constructorResolvers. }
false;public;0;4;;@Override public List<ConstructorResolver> getConstructorResolvers() {     return initConstructorResolvers(). }
false;public;1;3;;public void addConstructorResolver(ConstructorResolver resolver) {     addBeforeDefault(initConstructorResolvers(), resolver). }
false;public;1;3;;public boolean removeConstructorResolver(ConstructorResolver resolver) {     return initConstructorResolvers().remove(resolver). }
false;public;1;3;;public void setMethodResolvers(List<MethodResolver> methodResolvers) {     this.methodResolvers = methodResolvers. }
false;public;0;4;;@Override public List<MethodResolver> getMethodResolvers() {     return initMethodResolvers(). }
false;public;1;3;;public void addMethodResolver(MethodResolver resolver) {     addBeforeDefault(initMethodResolvers(), resolver). }
false;public;1;3;;public boolean removeMethodResolver(MethodResolver methodResolver) {     return initMethodResolvers().remove(methodResolver). }
false;public;1;3;;public void setBeanResolver(BeanResolver beanResolver) {     this.beanResolver = beanResolver. }
false;public;0;5;;@Override @Nullable public BeanResolver getBeanResolver() {     return this.beanResolver. }
false;public;1;4;;public void setTypeLocator(TypeLocator typeLocator) {     Assert.notNull(typeLocator, "TypeLocator must not be null").     this.typeLocator = typeLocator. }
false;public;0;7;;@Override public TypeLocator getTypeLocator() {     if (this.typeLocator == null) {         this.typeLocator = new StandardTypeLocator().     }     return this.typeLocator. }
false;public;1;4;;public void setTypeConverter(TypeConverter typeConverter) {     Assert.notNull(typeConverter, "TypeConverter must not be null").     this.typeConverter = typeConverter. }
false;public;0;7;;@Override public TypeConverter getTypeConverter() {     if (this.typeConverter == null) {         this.typeConverter = new StandardTypeConverter().     }     return this.typeConverter. }
false;public;1;4;;public void setTypeComparator(TypeComparator typeComparator) {     Assert.notNull(typeComparator, "TypeComparator must not be null").     this.typeComparator = typeComparator. }
false;public;0;4;;@Override public TypeComparator getTypeComparator() {     return this.typeComparator. }
false;public;1;4;;public void setOperatorOverloader(OperatorOverloader operatorOverloader) {     Assert.notNull(operatorOverloader, "OperatorOverloader must not be null").     this.operatorOverloader = operatorOverloader. }
false;public;0;4;;@Override public OperatorOverloader getOperatorOverloader() {     return this.operatorOverloader. }
false;public;2;14;;@Override public void setVariable(@Nullable String name, @Nullable Object value) {     // as a remove from the Map (with the same result from lookupVariable below).     if (name != null) {         if (value != null) {             this.variables.put(name, value).         } else {             this.variables.remove(name).         }     } }
false;public;1;3;;public void setVariables(Map<String, Object> variables) {     variables.forEach(this::setVariable). }
false;public;2;3;;public void registerFunction(String name, Method method) {     this.variables.put(name, method). }
false;public;1;5;;@Override @Nullable public Object lookupVariable(String name) {     return this.variables.get(name). }
true;public;2;9;/**  * Register a {@code MethodFilter} which will be called during method resolution  * for the specified type.  * <p>The {@code MethodFilter} may remove methods and/or sort the methods which  * will then be used by SpEL as the candidates to look through for a match.  * @param type the type for which the filter should be called  * @param filter a {@code MethodFilter}, or {@code null} to unregister a filter for the type  * @throws IllegalStateException if the {@link ReflectiveMethodResolver} is not in use  */ ;/**  * Register a {@code MethodFilter} which will be called during method resolution  * for the specified type.  * <p>The {@code MethodFilter} may remove methods and/or sort the methods which  * will then be used by SpEL as the candidates to look through for a match.  * @param type the type for which the filter should be called  * @param filter a {@code MethodFilter}, or {@code null} to unregister a filter for the type  * @throws IllegalStateException if the {@link ReflectiveMethodResolver} is not in use  */ public void registerMethodFilter(Class<?> type, MethodFilter filter) throws IllegalStateException {     initMethodResolvers().     ReflectiveMethodResolver resolver = this.reflectiveMethodResolver.     if (resolver == null) {         throw new IllegalStateException("Method filter cannot be set as the reflective method resolver is not in use").     }     resolver.registerMethodFilter(type, filter). }
false;private;0;9;;private List<PropertyAccessor> initPropertyAccessors() {     List<PropertyAccessor> accessors = this.propertyAccessors.     if (accessors == null) {         accessors = new ArrayList<>(5).         accessors.add(new ReflectivePropertyAccessor()).         this.propertyAccessors = accessors.     }     return accessors. }
false;private;0;9;;private List<ConstructorResolver> initConstructorResolvers() {     List<ConstructorResolver> resolvers = this.constructorResolvers.     if (resolvers == null) {         resolvers = new ArrayList<>(1).         resolvers.add(new ReflectiveConstructorResolver()).         this.constructorResolvers = resolvers.     }     return resolvers. }
false;private;0;10;;private List<MethodResolver> initMethodResolvers() {     List<MethodResolver> resolvers = this.methodResolvers.     if (resolvers == null) {         resolvers = new ArrayList<>(1).         this.reflectiveMethodResolver = new ReflectiveMethodResolver().         resolvers.add(this.reflectiveMethodResolver).         this.methodResolvers = resolvers.     }     return resolvers. }
false;private,static;2;3;;private static <T> void addBeforeDefault(List<T> resolvers, T resolver) {     resolvers.add(resolvers.size() - 1, resolver). }
