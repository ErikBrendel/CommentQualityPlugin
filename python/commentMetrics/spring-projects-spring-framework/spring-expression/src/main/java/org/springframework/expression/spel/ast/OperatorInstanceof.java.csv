commented;modifiers;parameterAmount;loc;comment;code
true;public;1;28;/**  * Compare the left operand to see it is an instance of the type specified as the  * right operand. The right operand must be a class.  * @param state the expression state  * @return {@code true} if the left operand is an instanceof of the right operand,  * otherwise {@code false}  * @throws EvaluationException if there is a problem evaluating the expression  */ ;/**  * Compare the left operand to see it is an instance of the type specified as the  * right operand. The right operand must be a class.  * @param state the expression state  * @return {@code true} if the left operand is an instanceof of the right operand,  * otherwise {@code false}  * @throws EvaluationException if there is a problem evaluating the expression  */ @Override public BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {     SpelNodeImpl rightOperand = getRightOperand().     TypedValue left = getLeftOperand().getValueInternal(state).     TypedValue right = rightOperand.getValueInternal(state).     Object leftValue = left.getValue().     Object rightValue = right.getValue().     BooleanTypedValue result.     if (rightValue == null || !(rightValue instanceof Class)) {         throw new SpelEvaluationException(getRightOperand().getStartPosition(), SpelMessage.INSTANCEOF_OPERATOR_NEEDS_CLASS_OPERAND, (rightValue == null ? "null" : rightValue.getClass().getName())).     }     Class<?> rightClass = (Class<?>) rightValue.     if (leftValue == null) {         // null is not an instanceof anything         result = BooleanTypedValue.FALSE.     } else {         result = BooleanTypedValue.forValue(rightClass.isAssignableFrom(leftValue.getClass())).     }     this.type = rightClass.     if (rightOperand instanceof TypeReference) {         // Can only generate bytecode where the right operand is a direct type reference,         // not if it is indirect (for example when right operand is a variable reference)         this.exitTypeDescriptor = "Z".     }     return result. }
false;public;0;4;;@Override public boolean isCompilable() {     return (this.exitTypeDescriptor != null && getLeftOperand().isCompilable()). }
false;public;2;16;;@Override public void generateCode(MethodVisitor mv, CodeFlow cf) {     getLeftOperand().generateCode(mv, cf).     CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor()).     Assert.state(this.type != null, "No type available").     if (this.type.isPrimitive()) {         // always false - but left operand code always driven         // in case it had side effects         mv.visitInsn(POP).         // value of false         mv.visitInsn(ICONST_0).     } else {         mv.visitTypeInsn(INSTANCEOF, Type.getInternalName(this.type)).     }     cf.pushDescriptor(this.exitTypeDescriptor). }
