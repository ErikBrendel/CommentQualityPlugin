# id;timestamp;commentText;codeText;commentWords;codeWords
CodeFlow -> public static String createSignatureDescriptor(Method method);1405514506;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")")__		sb.append(toJVMDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,sb,append,to,jvmdescriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1405696918;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")")__		sb.append(toJVMDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,sb,append,to,jvmdescriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1406039079;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")")__		sb.append(toJVMDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,sb,append,to,jvmdescriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1406656976;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")")__		sb.append(toJVMDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,sb,append,to,jvmdescriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1412180765;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")")__		sb.append(toJVMDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,sb,append,to,jvmdescriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1412630983;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1413486529;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1413566814;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1414261335;Create the JVM signature descriptor for a method. This consists of the descriptors_for the constructor parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1424355957;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1425666762;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1425759378;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1430935722;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1432857824;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1436919586;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1458843770;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1467730834;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1467808333;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1467811755;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1478032943;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1478087052;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1495868221;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1496837955;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1498780456;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1515777832;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1518167476;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1518380146;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1520895539;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1522332300;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1522360217;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1530174524;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1530174524;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1530174524;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1530174524;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1530198749;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Method method);1530304568;Create the JVM signature descriptor for a method. This consists of the descriptors_for the method parameters surrounded with parentheses, followed by the_descriptor for the return type. Note the descriptors here are JVM descriptors,_unlike the other descriptor forms the compiler is using which do not include the_trailing semicolon._@param method the method_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Method method) {_		Class<?>[] params = method.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")")__		sb.append(toJvmDescriptor(method.getReturnType()))__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,method,this,consists,of,the,descriptors,for,the,method,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,method,the,method,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,method,method,class,params,method,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,sb,append,to,jvm,descriptor,method,get,return,type,return,sb,to,string
CodeFlow -> public void exitCompilationScope();1405514506;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1405696918;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1406039079;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1406656976;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1412180765;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1412630983;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1413486529;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1413566814;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1414261335;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1424355957;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1425666762;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1425759378;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1430935722;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1432857824;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1436919586;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1458843770;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1467730834;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1467808333;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1467811755;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1478032943;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1478087052;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1495868221;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1496837955;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1498780456;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1515777832;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1518167476;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1518380146;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1520895539;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1522332300;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1522360217;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1530174524;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1530174524;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1530174524;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1530174524;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1530198749;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public void exitCompilationScope();1530304568;Exit a compilation scope, usually after a nested expression has been evaluated. For_example after an argument for a method invocation has been evaluated this method_returns us to the previous (outer) scope.;public void exitCompilationScope() {_		this.compilationScopes.pop()__	};exit,a,compilation,scope,usually,after,a,nested,expression,has,been,evaluated,for,example,after,an,argument,for,a,method,invocation,has,been,evaluated,this,method,returns,us,to,the,previous,outer,scope;public,void,exit,compilation,scope,this,compilation,scopes,pop
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1413486529;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1413566814;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1414261335;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1424355957;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1425666762;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1425759378;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1430935722;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1432857824;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1436919586;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1458843770;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1467730834;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1467808333;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1467811755;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1478032943;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1478087052;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1495868221;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1496837955;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1498780456;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1515777832;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1518167476;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1518380146;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1520895539;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1522332300;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1522360217;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1530174524;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1530174524;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1530174524;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I': mv.visitInsn(IASTORE)_ break__				case 'J': mv.visitInsn(LASTORE)_ break__				case 'F': mv.visitInsn(FASTORE)_ break__				case 'D': mv.visitInsn(DASTORE)_ break__				case 'B': mv.visitInsn(BASTORE)_ break__				case 'C': mv.visitInsn(CASTORE)_ break__				case 'S': mv.visitInsn(SASTORE)_ break__				case 'Z': mv.visitInsn(BASTORE)_ break__				default:_					throw new IllegalArgumentException("Unexpected arraytype "+arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1530174524;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I':_					mv.visitInsn(IASTORE)__					break__				case 'J':_					mv.visitInsn(LASTORE)__					break__				case 'F':_					mv.visitInsn(FASTORE)__					break__				case 'D':_					mv.visitInsn(DASTORE)__					break__				case 'B':_					mv.visitInsn(BASTORE)__					break__				case 'C':_					mv.visitInsn(CASTORE)__					break__				case 'S':_					mv.visitInsn(SASTORE)__					break__				case 'Z':_					mv.visitInsn(BASTORE)__					break__				default:_					throw new IllegalArgumentException(_							"Unexpected arraytype " + arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1530198749;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I':_					mv.visitInsn(IASTORE)__					break__				case 'J':_					mv.visitInsn(LASTORE)__					break__				case 'F':_					mv.visitInsn(FASTORE)__					break__				case 'D':_					mv.visitInsn(DASTORE)__					break__				case 'B':_					mv.visitInsn(BASTORE)__					break__				case 'C':_					mv.visitInsn(CASTORE)__					break__				case 'S':_					mv.visitInsn(SASTORE)__					break__				case 'Z':_					mv.visitInsn(BASTORE)__					break__				default:_					throw new IllegalArgumentException(_							"Unexpected arraytype " + arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static void insertArrayStore(MethodVisitor mv, String arrayElementType);1530304568;Produce appropriate bytecode to store a stack item in an array. The_instruction to use varies depending on whether the type_is a primitive or reference type._@param mv where to insert the bytecode_@param arrayElementType the type of the array elements;public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {_		if (arrayElementType.length()==1) {_			switch (arrayElementType.charAt(0)) {_				case 'I':_					mv.visitInsn(IASTORE)__					break__				case 'J':_					mv.visitInsn(LASTORE)__					break__				case 'F':_					mv.visitInsn(FASTORE)__					break__				case 'D':_					mv.visitInsn(DASTORE)__					break__				case 'B':_					mv.visitInsn(BASTORE)__					break__				case 'C':_					mv.visitInsn(CASTORE)__					break__				case 'S':_					mv.visitInsn(SASTORE)__					break__				case 'Z':_					mv.visitInsn(BASTORE)__					break__				default:_					throw new IllegalArgumentException(_							"Unexpected arraytype " + arrayElementType.charAt(0))__			}_		}_		else {_			mv.visitInsn(AASTORE)__		}_	};produce,appropriate,bytecode,to,store,a,stack,item,in,an,array,the,instruction,to,use,varies,depending,on,whether,the,type,is,a,primitive,or,reference,type,param,mv,where,to,insert,the,bytecode,param,array,element,type,the,type,of,the,array,elements;public,static,void,insert,array,store,method,visitor,mv,string,array,element,type,if,array,element,type,length,1,switch,array,element,type,char,at,0,case,i,mv,visit,insn,iastore,break,case,j,mv,visit,insn,lastore,break,case,f,mv,visit,insn,fastore,break,case,d,mv,visit,insn,dastore,break,case,b,mv,visit,insn,bastore,break,case,c,mv,visit,insn,castore,break,case,s,mv,visit,insn,sastore,break,case,z,mv,visit,insn,bastore,break,default,throw,new,illegal,argument,exception,unexpected,arraytype,array,element,type,char,at,0,else,mv,visit,insn,aastore
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1405514506;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc2,length,1,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1405696918;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc2,length,1,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1406039079;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc2,length,1,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1406656976;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc2,length,1,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1412180765;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc2,length,1,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1412630983;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1413486529;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1413566814;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1414261335;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1424355957;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1425666762;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1425759378;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1430935722;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1432857824;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1436919586;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1458843770;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1467730834;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1467808333;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1467811755;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1478032943;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1478087052;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1495868221;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1496837955;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1498780456;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1515777832;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1518167476;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1518380146;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1520895539;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1522332300;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1522360217;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1530174524;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1530174524;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1530174524;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1530174524;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1530198749;Determine if boxing/unboxing can get from one type to the other. Assumes at least_one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,if,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static boolean areBoxingCompatible(String desc1, String desc2);1530304568;Determine whether boxing/unboxing can get from one type to the other._Assumes at least one of the types is in boxed form (i.e. single char descriptor)._@return {@code true} if it is possible to get (via boxing) from one descriptor to the other;public static boolean areBoxingCompatible(String desc1, String desc2) {_		if (desc1.equals(desc2)) {_			return true__		}_		if (desc1.length() == 1) {_			if (desc1.equals("Z")) {_				return desc2.equals("Ljava/lang/Boolean")__			}_			else if (desc1.equals("D")) {_				return desc2.equals("Ljava/lang/Double")__			}_			else if (desc1.equals("F")) {_				return desc2.equals("Ljava/lang/Float")__			}_			else if (desc1.equals("I")) {_				return desc2.equals("Ljava/lang/Integer")__			}_			else if (desc1.equals("J")) {_				return desc2.equals("Ljava/lang/Long")__			}_		}_		else if (desc2.length() == 1) {_			if (desc2.equals("Z")) {_				return desc1.equals("Ljava/lang/Boolean")__			}_			else if (desc2.equals("D")) {_				return desc1.equals("Ljava/lang/Double")__			}_			else if (desc2.equals("F")) {_				return desc1.equals("Ljava/lang/Float")__			}_			else if (desc2.equals("I")) {_				return desc1.equals("Ljava/lang/Integer")__			}_			else if (desc2.equals("J")) {_				return desc1.equals("Ljava/lang/Long")__			}_		}_		return false__	};determine,whether,boxing,unboxing,can,get,from,one,type,to,the,other,assumes,at,least,one,of,the,types,is,in,boxed,form,i,e,single,char,descriptor,return,code,true,if,it,is,possible,to,get,via,boxing,from,one,descriptor,to,the,other;public,static,boolean,are,boxing,compatible,string,desc1,string,desc2,if,desc1,equals,desc2,return,true,if,desc1,length,1,if,desc1,equals,z,return,desc2,equals,ljava,lang,boolean,else,if,desc1,equals,d,return,desc2,equals,ljava,lang,double,else,if,desc1,equals,f,return,desc2,equals,ljava,lang,float,else,if,desc1,equals,i,return,desc2,equals,ljava,lang,integer,else,if,desc1,equals,j,return,desc2,equals,ljava,lang,long,else,if,desc2,length,1,if,desc2,equals,z,return,desc1,equals,ljava,lang,boolean,else,if,desc2,equals,d,return,desc1,equals,ljava,lang,double,else,if,desc2,equals,f,return,desc1,equals,ljava,lang,float,else,if,desc2,equals,i,return,desc1,equals,ljava,lang,integer,else,if,desc2,equals,j,return,desc1,equals,ljava,lang,long,return,false
CodeFlow -> public static String[] toParamDescriptors(Method method);1405514506;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1405696918;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1406039079;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1406656976;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1412180765;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1412630983;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1413486529;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1413566814;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1414261335;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1424355957;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1425666762;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1425759378;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1430935722;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1432857824;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1436919586;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1458843770;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1467730834;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1467808333;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1467811755;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1478032943;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1478087052;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1495868221;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1496837955;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1498780456;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1515777832;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1518167476;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1518380146;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1520895539;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1522332300;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1522360217;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1530174524;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1530174524;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1530174524;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1530174524;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1530198749;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Method method);1530304568;Create an array of descriptors representing the parameter types for the supplied_method. Returns a zero sized array if there are no parameters._@param method a Method_@return a String array of descriptors, one entry for each method parameter;public static String[] toParamDescriptors(Method method) {_		return toDescriptors(method.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,method,returns,a,zero,sized,array,if,there,are,no,parameters,param,method,a,method,return,a,string,array,of,descriptors,one,entry,for,each,method,parameter;public,static,string,to,param,descriptors,method,method,return,to,descriptors,method,get,parameter,types
CodeFlow -> public static int arrayCodeFor(String arraytype);1413486529;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG_ _			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1413566814;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG_ _			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1414261335;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG_ _			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1424355957;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG_ _			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1425666762;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG_ _			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1425759378;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1430935722;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1432857824;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1436919586;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1458843770;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1467730834;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1467808333;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1467811755;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1478032943;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1478087052;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1495868221;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1496837955;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1498780456;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1515777832;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1518167476;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1518380146;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1520895539;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1522332300;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1522360217;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1530174524;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1530174524;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1530174524;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1530174524;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1530198749;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype "+arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static int arrayCodeFor(String arraytype);1530304568;Determine the appropriate T tag to use for the NEWARRAY bytecode._@param arraytype the array primitive component type_@return the T tag to use for NEWARRAY;public static int arrayCodeFor(String arraytype) {_		switch (arraytype.charAt(0)) {_			case 'I': return T_INT__			case 'J': return T_LONG__			case 'F': return T_FLOAT__			case 'D': return T_DOUBLE__			case 'B': return T_BYTE__			case 'C': return T_CHAR__			case 'S': return T_SHORT__			case 'Z': return T_BOOLEAN__			default:_				throw new IllegalArgumentException("Unexpected arraytype " + arraytype.charAt(0))__		}_	};determine,the,appropriate,t,tag,to,use,for,the,newarray,bytecode,param,arraytype,the,array,primitive,component,type,return,the,t,tag,to,use,for,newarray;public,static,int,array,code,for,string,arraytype,switch,arraytype,char,at,0,case,i,return,case,j,return,case,f,return,case,d,return,case,b,return,case,c,return,case,s,return,case,z,return,default,throw,new,illegal,argument,exception,unexpected,arraytype,arraytype,char,at,0
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1496837955;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1498780456;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1515777832;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1518167476;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1518380146;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1520895539;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1522332300;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1522360217;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1530174524;Returns if the descriptor is for a boolean primitive or boolean reference type._@param descriptor type descriptor_@return {@code true} if the descriptor is boolean compatible;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};returns,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type,param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,boolean,compatible;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1530174524;Returns if the descriptor is for a boolean primitive or boolean reference type._@param descriptor type descriptor_@return {@code true} if the descriptor is boolean compatible;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};returns,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type,param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,boolean,compatible;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1530174524;Returns if the descriptor is for a boolean primitive or boolean reference type._@param descriptor type descriptor_@return {@code true} if the descriptor is boolean compatible;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};returns,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type,param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,boolean,compatible;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1530174524;Returns if the descriptor is for a boolean primitive or boolean reference type._@param descriptor type descriptor_@return {@code true} if the descriptor is boolean compatible;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};returns,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type,param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,boolean,compatible;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1530198749;Returns if the descriptor is for a boolean primitive or boolean reference type._@param descriptor type descriptor_@return {@code true} if the descriptor is boolean compatible;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};returns,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type,param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,boolean,compatible;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(@Nullable String descriptor);1530304568;Determine whether the descriptor is for a boolean primitive or boolean reference type._@param descriptor type descriptor_@return {@code true} if the descriptor is boolean compatible;public static boolean isBooleanCompatible(@Nullable String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};determine,whether,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type,param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,boolean,compatible;public,static,boolean,is,boolean,compatible,nullable,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public void enterCompilationScope();1405514506;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1405696918;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1406039079;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1406656976;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1412180765;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1412630983;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1413486529;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1413566814;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1414261335;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1424355957;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1425666762;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1425759378;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1430935722;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1432857824;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1436919586;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1458843770;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<String>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list,string
CodeFlow -> public void enterCompilationScope();1467730834;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1467808333;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1467811755;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1478032943;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1478087052;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1495868221;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1496837955;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1498780456;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1515777832;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1518167476;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1518380146;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1520895539;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1522332300;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1522360217;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1530174524;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1530174524;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1530174524;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1530174524;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1530198749;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public void enterCompilationScope();1530304568;Enter a new compilation scope, usually due to nested expression evaluation. For_example when the arguments for a method invocation expression are being evaluated,_each argument will be evaluated in a new scope.;public void enterCompilationScope() {_		this.compilationScopes.push(new ArrayList<>())__	};enter,a,new,compilation,scope,usually,due,to,nested,expression,evaluation,for,example,when,the,arguments,for,a,method,invocation,expression,are,being,evaluated,each,argument,will,be,evaluated,in,a,new,scope;public,void,enter,compilation,scope,this,compilation,scopes,push,new,array,list
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1425666762;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break_				_			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1425759378;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break_		_			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1430935722;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break_	_			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1432857824;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1436919586;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1458843770;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1467730834;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1467808333;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1467811755;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1478032943;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1478087052;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1495868221;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1496837955;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,string,stack,descriptor,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static String toDescriptor(Class<?> type);1405514506;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,long,return,j,else,if,name,equals,char,return,c,else,if,name,equals,byte,return,b,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1405696918;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,long,return,j,else,if,name,equals,char,return,c,else,if,name,equals,byte,return,b,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1406039079;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,long,return,j,else,if,name,equals,char,return,c,else,if,name,equals,byte,return,b,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1406656976;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,long,return,j,else,if,name,equals,char,return,c,else,if,name,equals,byte,return,b,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1412180765;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,long,return,j,else,if,name,equals,char,return,c,else,if,name,equals,byte,return,b,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1412630983;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1413486529;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1413566814;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1414261335;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1424355957;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1425666762;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1425759378;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1430935722;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1432857824;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1436919586;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1458843770;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1467730834;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1467808333;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1467811755;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1478032943;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1478087052;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static String toDescriptor(Class<?> type);1498780456;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1515777832;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1518167476;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1518380146;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1520895539;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1522332300;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1522360217;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1530174524;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1530174524;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1530174524;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1530174524;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1530198749;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static String toDescriptor(Class<?> type);1530304568;Deduce the descriptor for a type. Descriptors are like JVM type names but missing the_trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is "I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return ""__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1405514506;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1405696918;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1406039079;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1406656976;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1412180765;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1412630983;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1413486529;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1413566814;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1414261335;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1424355957;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1425666762;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1425759378;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1430935722;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1432857824;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1436919586;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1458843770;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1467730834;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1467808333;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1467811755;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1478032943;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1478087052;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isBooleanCompatible(String descriptor);1495868221;@param descriptor type descriptor_@return {@code true} if the descriptor is for a boolean primitive or boolean reference type;public static boolean isBooleanCompatible(String descriptor) {_		return (descriptor != null && (descriptor.equals("Z") || descriptor.equals("Ljava/lang/Boolean")))__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,boolean,primitive,or,boolean,reference,type;public,static,boolean,is,boolean,compatible,string,descriptor,return,descriptor,null,descriptor,equals,z,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1405514506;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1405696918;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1406039079;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1406656976;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1412180765;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1412630983;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1413486529;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1413566814;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1414261335;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1424355957;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1425666762;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1425759378;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1430935722;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1432857824;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1436919586;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1458843770;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1467730834;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1467808333;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1467811755;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1478032943;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1478087052;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1495868221;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(String descriptor);1496837955;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(String descriptor) {_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,string,descriptor,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1413486529;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1413566814;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1414261335;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1424355957;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1425666762;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1425759378;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1430935722;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1432857824;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1436919586;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1458843770;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<ClinitAdder>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adder,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1467730834;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1467808333;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (clinitAdders == null) {_			clinitAdders = new ArrayList<>()__		}_		clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,clinit,adders,null,clinit,adders,new,array,list,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1467811755;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1478032943;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1478087052;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1495868221;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1496837955;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1498780456;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1515777832;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1518167476;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1518380146;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1520895539;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1522332300;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1522360217;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1530174524;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1530174524;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1530174524;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1530174524;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1530198749;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public void registerNewClinit(ClinitAdder clinitAdder);1530304568;Register a ClinitAdder which will add code to the static_initializer in the generated class to support the code_produced by an ast nodes primary generateCode() method.;public void registerNewClinit(ClinitAdder clinitAdder) {_		if (this.clinitAdders == null) {_			this.clinitAdders = new ArrayList<>()__		}_		this.clinitAdders.add(clinitAdder)__	};register,a,clinit,adder,which,will,add,code,to,the,static,initializer,in,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,clinit,clinit,adder,clinit,adder,if,this,clinit,adders,null,this,clinit,adders,new,array,list,this,clinit,adders,add,clinit,adder
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1498780456;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1515777832;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1518167476;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1518380146;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1520895539;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1522332300;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1522360217;@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor is for a primitive array (e.g. "[[I");public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,is,for,a,primitive,array,e,g,i;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive array (e.g. "[[I")._@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor a primitive array;public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};returns,if,the,descriptor,is,for,a,primitive,array,e,g,i,param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,a,primitive,array;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive array (e.g. "[[I")._@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor a primitive array;public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};returns,if,the,descriptor,is,for,a,primitive,array,e,g,i,param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,a,primitive,array;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive array (e.g. "[[I")._@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor a primitive array;public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};returns,if,the,descriptor,is,for,a,primitive,array,e,g,i,param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,a,primitive,array;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive array (e.g. "[[I")._@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor a primitive array;public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};returns,if,the,descriptor,is,for,a,primitive,array,e,g,i,param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,a,primitive,array;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1530198749;Returns if the descriptor is for a primitive array (e.g. "[[I")._@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor a primitive array;public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};returns,if,the,descriptor,is,for,a,primitive,array,e,g,i,param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,a,primitive,array;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public static boolean isPrimitiveArray(@Nullable String descriptor);1530304568;Determine whether the descriptor is for a primitive array (e.g. "[[I")._@param descriptor the descriptor for a possible primitive array_@return {@code true} if the descriptor a primitive array;public static boolean isPrimitiveArray(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		boolean primitive = true__		for (int i = 0, max = descriptor.length()_ i < max_ i++) {_			char ch = descriptor.charAt(i)__			if (ch == '[') {_				continue__			}_			primitive = (ch != 'L')__			break__		}_		return primitive__	};determine,whether,the,descriptor,is,for,a,primitive,array,e,g,i,param,descriptor,the,descriptor,for,a,possible,primitive,array,return,code,true,if,the,descriptor,a,primitive,array;public,static,boolean,is,primitive,array,nullable,string,descriptor,if,descriptor,null,return,false,boolean,primitive,true,for,int,i,0,max,descriptor,length,i,max,i,char,ch,descriptor,char,at,i,if,ch,continue,primitive,ch,l,break,return,primitive
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1405514506;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1405696918;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1406039079;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1406656976;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1412180765;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1412630983;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1413486529;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1413566814;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1414261335;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1424355957;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1425666762;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1425759378;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1430935722;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1432857824;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1436919586;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1458843770;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1467730834;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1467808333;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1467811755;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1478032943;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1478087052;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1495868221;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if (lastDescriptor().equals("Ljava/lang/Boolean")) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,last,descriptor,equals,ljava,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1496837955;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1498780456;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1515777832;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1518167476;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1518380146;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1520895539;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1522332300;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1522360217;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1530174524;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1530174524;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1530174524;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1530174524;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1530198749;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public void unboxBooleanIfNecessary(MethodVisitor mv);1530304568;If the codeflow shows the last expression evaluated to java.lang.Boolean then_insert the necessary instructions to unbox that to a boolean primitive._@param mv the visitor into which new instructions should be inserted;public void unboxBooleanIfNecessary(MethodVisitor mv) {_		if ("Ljava/lang/Boolean".equals(lastDescriptor())) {_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__		}_	};if,the,codeflow,shows,the,last,expression,evaluated,to,java,lang,boolean,then,insert,the,necessary,instructions,to,unbox,that,to,a,boolean,primitive,param,mv,the,visitor,into,which,new,instructions,should,be,inserted;public,void,unbox,boolean,if,necessary,method,visitor,mv,if,ljava,lang,boolean,equals,last,descriptor,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1406656976;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_		case 'I':_			if (!stackDescriptor.equals("Ljava/lang/Integer")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__			break__		case 'Z':_			if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__			break__		case 'B':_			if (!stackDescriptor.equals("Ljava/lang/Byte")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__			break__		case 'C':_			if (!stackDescriptor.equals("Ljava/lang/Character")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__			break__		case 'D':_			if (!stackDescriptor.equals("Ljava/lang/Double")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__			break__		case 'S':_			if (!stackDescriptor.equals("Ljava/lang/Short")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__			break__		case 'F':_			if (!stackDescriptor.equals("Ljava/lang/Float")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__			break__		case 'J':_			if (!stackDescriptor.equals("Ljava/lang/Long")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__			break__		default:_			throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1412180765;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_		case 'I':_			if (!stackDescriptor.equals("Ljava/lang/Integer")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__			break__		case 'Z':_			if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__			break__		case 'B':_			if (!stackDescriptor.equals("Ljava/lang/Byte")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__			break__		case 'C':_			if (!stackDescriptor.equals("Ljava/lang/Character")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__			break__		case 'D':_			if (!stackDescriptor.equals("Ljava/lang/Double")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__			break__		case 'S':_			if (!stackDescriptor.equals("Ljava/lang/Short")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__			break__		case 'F':_			if (!stackDescriptor.equals("Ljava/lang/Float")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__			break__		case 'J':_			if (!stackDescriptor.equals("Ljava/lang/Long")) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__			break__		default:_			throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1412630983;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1413486529;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1413566814;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1414261335;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1424355957;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1425666762;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1425759378;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1430935722;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1432857824;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1436919586;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1458843770;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1467730834;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1467808333;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1467811755;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1478032943;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1478087052;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1495868221;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor);1496837955;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, String stackDescriptor) {_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,string,stack,descriptor,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1498780456;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1515777832;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1518167476;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1518380146;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1520895539;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1522332300;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1522360217;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1530174524;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1530174524;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1530174524;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1530174524;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1530198749;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor);1530304568;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,nullable,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1436919586;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1458843770;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1467730834;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1467808333;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1467811755;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1478032943;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1478087052;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1495868221;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion( 			MethodVisitor mv, String stackDescriptor, char targetDescriptor);1496837955;For use in mathematical operators, handles converting from a (possibly boxed)_number on the stack to a primitive numeric type._<p>For example, from a Integer to a double, just need to call 'Number.doubleValue()'_but from an int to a double, need to use the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(_			MethodVisitor mv, String stackDescriptor, char targetDescriptor) {__		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor)__		}_		else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,p,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,descriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,descriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,descriptor,stack,descriptor
CodeFlow -> public static boolean isPrimitive(String descriptor);1405514506;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1405696918;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1406039079;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1406656976;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1412180765;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1412630983;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1413486529;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1413566814;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1414261335;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1424355957;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1425666762;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1425759378;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1430935722;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1432857824;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1436919586;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1458843770;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1467730834;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1467808333;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1467811755;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1478032943;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1478087052;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(String descriptor);1495868221;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject);1405514506;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param isObject indicates whether the type on the stack is being thought of_as Object (and so requires a cast);public static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject) {_		switch (ch) {_		case 'I':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__			break__		case 'Z':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__			break__		case 'B':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__			break__		case 'C':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__			break__		case 'D':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__			break__		case 'S':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__			break__		case 'F':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__			break__		case 'J':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__			break__		default:_			throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,is,object,indicates,whether,the,type,on,the,stack,is,being,thought,of,as,object,and,so,requires,a,cast;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,boolean,is,object,switch,ch,case,i,if,is,object,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,z,if,is,object,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,is,object,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,is,object,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,is,object,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,s,if,is,object,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,case,f,if,is,object,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,j,if,is,object,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject);1405696918;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param isObject indicates whether the type on the stack is being thought of_as Object (and so requires a cast);public static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject) {_		switch (ch) {_		case 'I':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__			break__		case 'Z':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__			break__		case 'B':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__			break__		case 'C':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__			break__		case 'D':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__			break__		case 'S':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__			break__		case 'F':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__			break__		case 'J':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__			break__		default:_			throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,is,object,indicates,whether,the,type,on,the,stack,is,being,thought,of,as,object,and,so,requires,a,cast;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,boolean,is,object,switch,ch,case,i,if,is,object,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,z,if,is,object,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,is,object,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,is,object,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,is,object,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,s,if,is,object,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,case,f,if,is,object,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,j,if,is,object,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject);1406039079;Insert any necessary cast and value call to convert from a boxed type to a_primitive value_@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param isObject indicates whether the type on the stack is being thought of_as Object (and so requires a cast);public static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject) {_		switch (ch) {_		case 'I':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__			break__		case 'Z':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__			break__		case 'B':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__			break__		case 'C':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__			break__		case 'D':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__			break__		case 'S':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__			break__		case 'F':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__			break__		case 'J':_			if (isObject) {_				mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__			}_			mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__			break__		default:_			throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,is,object,indicates,whether,the,type,on,the,stack,is,being,thought,of,as,object,and,so,requires,a,cast;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,boolean,is,object,switch,ch,case,i,if,is,object,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,z,if,is,object,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,is,object,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,is,object,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,is,object,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,s,if,is,object,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,case,f,if,is,object,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,j,if,is,object,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static String toJVMDescriptor(Class<?> clazz);1405514506;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJVMDescriptor(Class<?> clazz) {_		StringBuilder s= new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				s.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				s.append('V')__			}_			else if (clazz == Integer.TYPE) {_				s.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				s.append('Z')__			}_			else if (clazz == Character.TYPE) {_				s.append('C')__			}_			else if (clazz == Long.TYPE) {_				s.append('J')__			}_			else if (clazz == Double.TYPE) {_				s.append('D')__			}_			else if (clazz == Float.TYPE) {_				s.append('F')__			}_			else if (clazz == Byte.TYPE) {_				s.append('B')__			}_			else if (clazz == Short.TYPE) {_				s.append('S')__			}_		} else {_			s.append("L")__			s.append(clazz.getName().replace('.', '/'))__			s.append("_")__		}_		return s.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvmdescriptor,class,clazz,string,builder,s,new,string,builder,if,clazz,is,array,while,clazz,is,array,s,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,s,append,v,else,if,clazz,integer,type,s,append,i,else,if,clazz,boolean,type,s,append,z,else,if,clazz,character,type,s,append,c,else,if,clazz,long,type,s,append,j,else,if,clazz,double,type,s,append,d,else,if,clazz,float,type,s,append,f,else,if,clazz,byte,type,s,append,b,else,if,clazz,short,type,s,append,s,else,s,append,l,s,append,clazz,get,name,replace,s,append,return,s,to,string
CodeFlow -> public static String toJVMDescriptor(Class<?> clazz);1405696918;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJVMDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvmdescriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJVMDescriptor(Class<?> clazz);1406039079;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJVMDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvmdescriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJVMDescriptor(Class<?> clazz);1406656976;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJVMDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvmdescriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJVMDescriptor(Class<?> clazz);1412180765;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJVMDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvmdescriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1414261335;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1424355957;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1425666762;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1425759378;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1430935722;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1432857824;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1436919586;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1458843770;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1467730834;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1467808333;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1467811755;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1478032943;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1478087052;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1495868221;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1496837955;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1498780456;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1515777832;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1518167476;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1518380146;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1520895539;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1522332300;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1522360217;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1530174524;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1530174524;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1530174524;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1530174524;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1530198749;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String[] toDescriptors(Class<?>[] types);1530304568;Create an array of descriptors from an array of classes._@param types the input array of classes_@return an array of descriptors;public static String[] toDescriptors(Class<?>[] types) {_		int typesCount = types.length__		String[] descriptors = new String[typesCount]__		for (int p = 0_ p < typesCount_ p++) {_			descriptors[p] = toDescriptor(types[p])__		}_		return descriptors__	};create,an,array,of,descriptors,from,an,array,of,classes,param,types,the,input,array,of,classes,return,an,array,of,descriptors;public,static,string,to,descriptors,class,types,int,types,count,types,length,string,descriptors,new,string,types,count,for,int,p,0,p,types,count,p,descriptors,p,to,descriptor,types,p,return,descriptors
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1405514506;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1405696918;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1406039079;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1406656976;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1412180765;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJVMDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvmdescriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1412630983;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1413486529;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1413566814;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1414261335;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses. Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1424355957;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1425666762;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1425759378;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1430935722;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1432857824;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1436919586;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1458843770;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1467730834;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1467808333;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1467811755;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1478032943;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1478087052;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1495868221;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1496837955;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1498780456;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1515777832;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1518167476;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1518380146;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1520895539;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1522332300;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1522360217;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1530174524;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1530174524;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1530174524;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1530174524;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1530198749;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public static String createSignatureDescriptor(Constructor<?> ctor);1530304568;Create the JVM signature descriptor for a constructor. This consists of the_descriptors for the constructor parameters surrounded with parentheses, followed by_the descriptor for the return type, which is always "V". Note the_descriptors here are JVM descriptors, unlike the other descriptor forms the_compiler is using which do not include the trailing semicolon._@param ctor the constructor_@return a String signature descriptor (e.g. "(ILjava/lang/String_)V");public static String createSignatureDescriptor(Constructor<?> ctor) {_		Class<?>[] params = ctor.getParameterTypes()__		StringBuilder sb = new StringBuilder()__		sb.append("(")__		for (Class<?> param : params) {_			sb.append(toJvmDescriptor(param))__		}_		sb.append(")V")__		return sb.toString()__	};create,the,jvm,signature,descriptor,for,a,constructor,this,consists,of,the,descriptors,for,the,constructor,parameters,surrounded,with,parentheses,followed,by,the,descriptor,for,the,return,type,which,is,always,v,note,the,descriptors,here,are,jvm,descriptors,unlike,the,other,descriptor,forms,the,compiler,is,using,which,do,not,include,the,trailing,semicolon,param,ctor,the,constructor,return,a,string,signature,descriptor,e,g,iljava,lang,string,v;public,static,string,create,signature,descriptor,constructor,ctor,class,params,ctor,get,parameter,types,string,builder,sb,new,string,builder,sb,append,for,class,param,params,sb,append,to,jvm,descriptor,param,sb,append,v,return,sb,to,string
CodeFlow -> public String lastDescriptor();1405514506;@return the descriptor for the item currently on top of the stack (in the current scope);public String lastDescriptor() {_		if (this.compilationScopes.peek().size() == 0) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,size,0,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1405696918;@return the descriptor for the item currently on top of the stack (in the current scope);public String lastDescriptor() {_		if (this.compilationScopes.peek().size() == 0) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,size,0,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1406039079;@return the descriptor for the item currently on top of the stack (in the current scope);public String lastDescriptor() {_		if (this.compilationScopes.peek().size() == 0) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,size,0,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1406656976;@return the descriptor for the item currently on top of the stack (in the current scope);public String lastDescriptor() {_		if (this.compilationScopes.peek().size() == 0) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,size,0,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1412180765;@return the descriptor for the item currently on top of the stack (in the current scope);public String lastDescriptor() {_		if (this.compilationScopes.peek().size() == 0) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,size,0,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1412630983;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1413486529;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1413566814;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1414261335;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1424355957;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1425666762;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1425759378;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1430935722;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1432857824;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1436919586;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1458843770;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1467730834;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1467808333;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1467811755;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1478032943;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> public String lastDescriptor();1478087052;Return the descriptor for the item currently on top of the stack (in the current scope).;public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> @Nullable 	public static String toDescriptor(Class<?> type);1495868221;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;@Nullable_	public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;nullable,public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> @Nullable 	public static String toDescriptor(Class<?> type);1496837955;Deduce the descriptor for a type. Descriptors are like JVM type names but missing_the trailing '_' so for Object the descriptor is "Ljava/lang/Object" for int it is_"I"._@param type the type (may be primitive) for which to determine the descriptor_@return the descriptor;@Nullable_	public static String toDescriptor(Class<?> type) {_		String name = type.getName()__		if (type.isPrimitive()) {_			switch (name.length()) {_				case 3:_					return "I"__				case 4:_					if (name.equals("byte")) {_						return "B"__					}_					else if (name.equals("char")) {_						return "C"__					}_					else if (name.equals("long")) {_						return "J"__					}_					else if (name.equals("void")) {_						return "V"__					}_					break__				case 5:_					if (name.equals("float")) {_						return "F"__					}_					else if (name.equals("short")) {_						return "S"__					}_					break__				case 6:_					if (name.equals("double")) {_						return "D"__					}_					break__				case 7:_					if (name.equals("boolean")) {_						return "Z"__					}_					break__			}_		}_		else {_			if (name.charAt(0) != '[') {_				return "L" + type.getName().replace('.', '/')__			}_			else {_				if (name.endsWith("_")) {_					return name.substring(0, name.length() - 1).replace('.', '/')__				}_				else {_					return name_  _				}_			}_		}_		return null__	};deduce,the,descriptor,for,a,type,descriptors,are,like,jvm,type,names,but,missing,the,trailing,so,for,object,the,descriptor,is,ljava,lang,object,for,int,it,is,i,param,type,the,type,may,be,primitive,for,which,to,determine,the,descriptor,return,the,descriptor;nullable,public,static,string,to,descriptor,class,type,string,name,type,get,name,if,type,is,primitive,switch,name,length,case,3,return,i,case,4,if,name,equals,byte,return,b,else,if,name,equals,char,return,c,else,if,name,equals,long,return,j,else,if,name,equals,void,return,v,break,case,5,if,name,equals,float,return,f,else,if,name,equals,short,return,s,break,case,6,if,name,equals,double,return,d,break,case,7,if,name,equals,boolean,return,z,break,else,if,name,char,at,0,return,l,type,get,name,replace,else,if,name,ends,with,return,name,substring,0,name,length,1,replace,else,return,name,return,null
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1496837955;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1498780456;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1515777832;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1518167476;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1518380146;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1520895539;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1522332300;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1522360217;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1530198749;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor);1530304568;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1498780456;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.peek().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1515777832;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.peek().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1518167476;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.peek().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1518380146;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.peek().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1520895539;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.peek().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1522332300;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.peek().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1522360217;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1530174524;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1530174524;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1530174524;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1530174524;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1530198749;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public void pushDescriptor(@Nullable String descriptor);1530304568;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(@Nullable String descriptor) {_		if (descriptor != null) {_			this.compilationScopes.element().add(descriptor)__		}_	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,nullable,string,descriptor,if,descriptor,null,this,compilation,scopes,element,add,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1425666762;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1425759378;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1430935722;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1432857824;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1436919586;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1458843770;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1467730834;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1467808333;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1467811755;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1478032943;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1478087052;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1495868221;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1496837955;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1498780456;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1515777832;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1518167476;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1518380146;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1520895539;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1522332300;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1522360217;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1530174524;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1530174524;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1530174524;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1530174524;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1530198749;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop=='I' || stackTop=='B' || stackTop=='S' || stackTop=='C') {_				if (targetDescriptor=='D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor=='I') {_					_				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='J') {_				if (targetDescriptor=='D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor=='J') {_					_				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='F') {_				if (targetDescriptor=='D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor=='F') {_					_				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackTop+" to "+targetDescriptor)__				}_			}_			else if (stackTop=='D') {_				if (targetDescriptor=='D') {_					_				}_				else if (targetDescriptor=='F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor=='J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor=='I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("cannot get from "+stackDescriptor+" to "+targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor);1530304568;Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type._@param mv the method visitor into which instructions should be placed_@param targetDescriptor the (primitive) descriptor of the target type_@param stackDescriptor the descriptor of the operand on top of the stack;public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {_		if (CodeFlow.isPrimitive(stackDescriptor)) {_			char stackTop = stackDescriptor.charAt(0)__			if (stackTop == 'I' || stackTop == 'B' || stackTop == 'S' || stackTop == 'C') {_				if (targetDescriptor == 'D') {_					mv.visitInsn(I2D)__				}_				else if (targetDescriptor == 'F') {_					mv.visitInsn(I2F)__				}_				else if (targetDescriptor == 'J') {_					mv.visitInsn(I2L)__				}_				else if (targetDescriptor == 'I') {_					_				}_				else {_					throw new IllegalStateException("Cannot get from " + stackTop + " to " + targetDescriptor)__				}_			}_			else if (stackTop == 'J') {_				if (targetDescriptor == 'D') {_					mv.visitInsn(L2D)__				}_				else if (targetDescriptor == 'F') {_					mv.visitInsn(L2F)__				}_				else if (targetDescriptor == 'J') {_					_				}_				else if (targetDescriptor == 'I') {_					mv.visitInsn(L2I)__				}_				else {_					throw new IllegalStateException("Cannot get from " + stackTop + " to " + targetDescriptor)__				}_			}_			else if (stackTop == 'F') {_				if (targetDescriptor == 'D') {_					mv.visitInsn(F2D)__				}_				else if (targetDescriptor == 'F') {_					_				}_				else if (targetDescriptor == 'J') {_					mv.visitInsn(F2L)__				}_				else if (targetDescriptor == 'I') {_					mv.visitInsn(F2I)__				}_				else {_					throw new IllegalStateException("Cannot get from " + stackTop + " to " + targetDescriptor)__				}_			}_			else if (stackTop == 'D') {_				if (targetDescriptor == 'D') {_					_				}_				else if (targetDescriptor == 'F') {_					mv.visitInsn(D2F)__				}_				else if (targetDescriptor == 'J') {_					mv.visitInsn(D2L)__				}_				else if (targetDescriptor == 'I') {_					mv.visitInsn(D2I)__				}_				else {_					throw new IllegalStateException("Cannot get from " + stackDescriptor + " to " + targetDescriptor)__				}_			}_		}_	};insert,any,necessary,numeric,conversion,bytecodes,based,upon,what,is,on,the,stack,and,the,desired,target,type,param,mv,the,method,visitor,into,which,instructions,should,be,placed,param,target,descriptor,the,primitive,descriptor,of,the,target,type,param,stack,descriptor,the,descriptor,of,the,operand,on,top,of,the,stack;public,static,void,insert,any,necessary,type,conversion,bytecodes,method,visitor,mv,char,target,descriptor,string,stack,descriptor,if,code,flow,is,primitive,stack,descriptor,char,stack,top,stack,descriptor,char,at,0,if,stack,top,i,stack,top,b,stack,top,s,stack,top,c,if,target,descriptor,d,mv,visit,insn,i2d,else,if,target,descriptor,f,mv,visit,insn,i2f,else,if,target,descriptor,j,mv,visit,insn,i2l,else,if,target,descriptor,i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,j,if,target,descriptor,d,mv,visit,insn,l2d,else,if,target,descriptor,f,mv,visit,insn,l2f,else,if,target,descriptor,j,else,if,target,descriptor,i,mv,visit,insn,l2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,f,if,target,descriptor,d,mv,visit,insn,f2d,else,if,target,descriptor,f,else,if,target,descriptor,j,mv,visit,insn,f2l,else,if,target,descriptor,i,mv,visit,insn,f2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,top,to,target,descriptor,else,if,stack,top,d,if,target,descriptor,d,else,if,target,descriptor,f,mv,visit,insn,d2f,else,if,target,descriptor,j,mv,visit,insn,d2l,else,if,target,descriptor,i,mv,visit,insn,d2i,else,throw,new,illegal,state,exception,cannot,get,from,stack,descriptor,to,target,descriptor
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1496837955;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1498780456;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1515777832;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1518167476;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1518380146;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1520895539;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1522332300;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1522360217;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1530198749;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor);1530304568;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,nullable,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1413486529;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1413566814;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1414261335;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1424355957;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1425666762;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1425759378;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1430935722;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1432857824;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				} else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1436919586;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1458843770;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1467730834;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1467808333;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1467811755;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1478032943;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1478087052;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1495868221;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1496837955;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1498780456;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1515777832;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1518167476;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1518380146;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1520895539;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1522332300;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1522360217;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1530174524;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1530174524;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1530174524;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1530174524;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1530198749;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype+"_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype);1530304568;Produce the correct bytecode to build an array. The opcode to use and the_signature to pass along with the opcode can vary depending on the signature_of the array type._@param mv the methodvisitor into which code should be inserted_@param size the size of the array_@param arraytype the type of the array;public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {_		insertOptimalLoad(mv, size)__		if (arraytype.length() == 1) {_			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype))__		}_		else {_			if (arraytype.charAt(0) == '[') {_				_				_				if (CodeFlow.isReferenceTypeArray(arraytype)) {_					mv.visitTypeInsn(ANEWARRAY, arraytype + "_")__				}_				else {_					mv.visitTypeInsn(ANEWARRAY, arraytype)__				}_			}_			else {_				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1))__			}_		}_	};produce,the,correct,bytecode,to,build,an,array,the,opcode,to,use,and,the,signature,to,pass,along,with,the,opcode,can,vary,depending,on,the,signature,of,the,array,type,param,mv,the,methodvisitor,into,which,code,should,be,inserted,param,size,the,size,of,the,array,param,arraytype,the,type,of,the,array;public,static,void,insert,new,array,code,method,visitor,mv,int,size,string,arraytype,insert,optimal,load,mv,size,if,arraytype,length,1,mv,visit,int,insn,newarray,code,flow,array,code,for,arraytype,else,if,arraytype,char,at,0,if,code,flow,is,reference,type,array,arraytype,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,else,mv,visit,type,insn,anewarray,arraytype,substring,1
CodeFlow -> @Nullable 	public String lastDescriptor();1495868221;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> @Nullable 	public String lastDescriptor();1496837955;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> @Nullable 	public String lastDescriptor();1498780456;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		if (this.compilationScopes.peek().isEmpty()) {_			return null__		}_		return this.compilationScopes.peek().get(this.compilationScopes.peek().size() - 1)__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,if,this,compilation,scopes,peek,is,empty,return,null,return,this,compilation,scopes,peek,get,this,compilation,scopes,peek,size,1
CodeFlow -> @Nullable 	public String lastDescriptor();1515777832;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1518167476;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1518380146;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1520895539;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1522332300;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1522360217;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1530174524;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1530174524;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1530174524;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1530174524;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1530198749;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> @Nullable 	public String lastDescriptor();1530304568;Return the descriptor for the item currently on top of the stack (in the current scope).;@Nullable_	public String lastDescriptor() {_		return CollectionUtils.lastElement(this.compilationScopes.peek())__	};return,the,descriptor,for,the,item,currently,on,top,of,the,stack,in,the,current,scope;nullable,public,string,last,descriptor,return,collection,utils,last,element,this,compilation,scopes,peek
CodeFlow -> public void finish();1413486529;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1413566814;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1414261335;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1424355957;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1425666762;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1425759378;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1430935722;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1432857824;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1436919586;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1458843770;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1467730834;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1467808333;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (fieldAdders != null) {_			for (FieldAdder fieldAdder: fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder: clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,field,adders,null,for,field,adder,field,adder,field,adders,field,adder,generate,field,cw,this,if,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,next,free,variable,id,0,for,clinit,adder,clinit,adder,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1467811755;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,cw,this,if,this,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1478032943;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(cw,this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_ _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_ _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,cw,this,if,this,clinit,adders,null,method,visitor,mv,cw,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1478087052;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1495868221;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1496837955;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1498780456;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1515777832;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1518167476;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1518380146;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1520895539;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1522332300;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1522360217;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1530174524;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1530174524;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1530174524;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1530174524;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1530198749;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void finish();1530304568;Called after the main expression evaluation method has been generated, this_method will callback any registered FieldAdders or ClinitAdders to add any_extra information to the class representing the compiled expression.;public void finish() {_		if (this.fieldAdders != null) {_			for (FieldAdder fieldAdder : this.fieldAdders) {_				fieldAdder.generateField(this.classWriter, this)__			}_		}_		if (this.clinitAdders != null) {_			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", "()V", null, null)__			mv.visitCode()__			this.nextFreeVariableId = 0_  _			for (ClinitAdder clinitAdder : this.clinitAdders) {_				clinitAdder.generateCode(mv, this)__			}_			mv.visitInsn(RETURN)__			mv.visitMaxs(0,0)_  _			mv.visitEnd()__		}_	};called,after,the,main,expression,evaluation,method,has,been,generated,this,method,will,callback,any,registered,field,adders,or,clinit,adders,to,add,any,extra,information,to,the,class,representing,the,compiled,expression;public,void,finish,if,this,field,adders,null,for,field,adder,field,adder,this,field,adders,field,adder,generate,field,this,class,writer,this,if,this,clinit,adders,null,method,visitor,mv,this,class,writer,visit,method,clinit,v,null,null,mv,visit,code,this,next,free,variable,id,0,for,clinit,adder,clinit,adder,this,clinit,adders,clinit,adder,generate,code,mv,this,mv,visit,insn,return,mv,visit,maxs,0,0,mv,visit,end
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1413486529;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1413566814;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1414261335;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1424355957;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1425666762;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1425759378;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1430935722;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1432857824;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1436919586;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1458843770;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<FieldAdder>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adder,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1467730834;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1467808333;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (fieldAdders == null) {_			fieldAdders = new ArrayList<>()__		}_		fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,field,adders,null,field,adders,new,array,list,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1467811755;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1478032943;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1478087052;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1495868221;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1496837955;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1498780456;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1515777832;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1518167476;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1518380146;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1520895539;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1522332300;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1522360217;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1530174524;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1530174524;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1530174524;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1530174524;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1530198749;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public void registerNewField(FieldAdder fieldAdder);1530304568;Register a FieldAdder which will add a new field to the generated_class to support the code produced by an ast nodes primary_generateCode() method.;public void registerNewField(FieldAdder fieldAdder) {_		if (this.fieldAdders == null) {_			this.fieldAdders = new ArrayList<>()__		}_		this.fieldAdders.add(fieldAdder)__	};register,a,field,adder,which,will,add,a,new,field,to,the,generated,class,to,support,the,code,produced,by,an,ast,nodes,primary,generate,code,method;public,void,register,new,field,field,adder,field,adder,if,this,field,adders,null,this,field,adders,new,array,list,this,field,adders,add,field,adder
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1413486529;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}		_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1413566814;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}		_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1414261335;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}		_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1424355957;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}		_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1425666762;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}		_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1425759378;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1430935722;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1432857824;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1436919586;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1458843770;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1467730834;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1467808333;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1467811755;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1478032943;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1478087052;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1495868221;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1496837955;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1498780456;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1515777832;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1518167476;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1518380146;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1520895539;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1522332300;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1522360217;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1530174524;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1530174524;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1530174524;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1530174524;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1530198749;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public static void insertOptimalLoad(MethodVisitor mv, int value);1530304568;Create the optimal instruction for loading a number on the stack._@param mv where to insert the bytecode_@param value the value to be loaded;public static void insertOptimalLoad(MethodVisitor mv, int value) {_		if (value < 6) {_			mv.visitInsn(ICONST_0+value)__		}_		else if (value < Byte.MAX_VALUE) {_			mv.visitIntInsn(BIPUSH, value)__		}_		else if (value < Short.MAX_VALUE) {_			mv.visitIntInsn(SIPUSH, value)__		}_		else {_			mv.visitLdcInsn(value)__		}_	};create,the,optimal,instruction,for,loading,a,number,on,the,stack,param,mv,where,to,insert,the,bytecode,param,value,the,value,to,be,loaded;public,static,void,insert,optimal,load,method,visitor,mv,int,value,if,value,6,mv,visit,insn,value,else,if,value,byte,mv,visit,int,insn,bipush,value,else,if,value,short,mv,visit,int,insn,sipush,value,else,mv,visit,ldc,insn,value
CodeFlow -> public void loadTarget(MethodVisitor mv);1405514506;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1405696918;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1406039079;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1406656976;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1412180765;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1412630983;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1413486529;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1413566814;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1414261335;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1424355957;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1425666762;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1425759378;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1430935722;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1432857824;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1436919586;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1458843770;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1467730834;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1467808333;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1467811755;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1478032943;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1478087052;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1495868221;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1496837955;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1498780456;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1515777832;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1518167476;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1518380146;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1520895539;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1522332300;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1522360217;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1530174524;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1530174524;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1530174524;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1530174524;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1530198749;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public void loadTarget(MethodVisitor mv);1530304568;Push the byte code to load the target (i.e. what was passed as the first argument_to CompiledExpression.getValue(target, context))_@param mv the visitor into which the load instruction should be inserted;public void loadTarget(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 1)__	};push,the,byte,code,to,load,the,target,i,e,what,was,passed,as,the,first,argument,to,compiled,expression,get,value,target,context,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,target,method,visitor,mv,mv,visit,var,insn,aload,1
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1498780456;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1515777832;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1518167476;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1518380146;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1520895539;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1522332300;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1522360217;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1530174524;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1530174524;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1530174524;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1530174524;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1530198749;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void insertUnboxNumberInsns( 			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor);1530304568;For numbers, use the appropriate method on the number to convert it to the primitive type requested._@param mv the method visitor into which instructions should be inserted_@param targetDescriptor the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxNumberInsns(_			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {__		if (stackDescriptor == null) {_			return__		}__		switch (targetDescriptor) {_			case 'D':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false)__				break__			case 'F':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false)__				break__			case 'J':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false)__				break__			case 'I':_				if (stackDescriptor.equals("Ljava/lang/Object")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Number")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)__				break__			_			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + targetDescriptor + "'")__		}_	};for,numbers,use,the,appropriate,method,on,the,number,to,convert,it,to,the,primitive,type,requested,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,target,descriptor,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,number,insns,method,visitor,mv,char,target,descriptor,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,target,descriptor,case,d,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,float,value,f,false,break,case,j,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,long,value,j,false,break,case,i,if,stack,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,java,lang,number,mv,visit,method,insn,invokevirtual,java,lang,number,int,value,i,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,target,descriptor
CodeFlow -> public static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDescriptor);1413486529;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;public static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDescriptor) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		boolean primitiveOnStack = CodeFlow.isPrimitive(cf.lastDescriptor())__		_		if (primitiveOnStack && paramDescriptor.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor().charAt(0))__		}_		else if (paramDescriptor.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDescriptor.charAt(0), cf.lastDescriptor())__		}_		else if (!cf.lastDescriptor().equals(paramDescriptor)) {_			_			CodeFlow.insertCheckCast(mv, paramDescriptor)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;public,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,descriptor,cf,enter,compilation,scope,argument,generate,code,mv,cf,boolean,primitive,on,stack,code,flow,is,primitive,cf,last,descriptor,if,primitive,on,stack,param,descriptor,char,at,0,l,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,char,at,0,else,if,param,descriptor,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,descriptor,char,at,0,cf,last,descriptor,else,if,cf,last,descriptor,equals,param,descriptor,code,flow,insert,check,cast,mv,param,descriptor,cf,exit,compilation,scope
CodeFlow -> public static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDescriptor);1413566814;Ask an argument to generate its bytecode and then follow it up_with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.;public static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDescriptor) {_		cf.enterCompilationScope()__		argument.generateCode(mv, cf)__		boolean primitiveOnStack = CodeFlow.isPrimitive(cf.lastDescriptor())__		_		if (primitiveOnStack && paramDescriptor.charAt(0) == 'L') {_			CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor().charAt(0))__		}_		else if (paramDescriptor.length() == 1 && !primitiveOnStack) {_			CodeFlow.insertUnboxInsns(mv, paramDescriptor.charAt(0), cf.lastDescriptor())__		}_		else if (!cf.lastDescriptor().equals(paramDescriptor)) {_			_			CodeFlow.insertCheckCast(mv, paramDescriptor)__		}_		cf.exitCompilationScope()__	};ask,an,argument,to,generate,its,bytecode,and,then,follow,it,up,with,any,boxing,unboxing,checkcasting,to,ensure,it,matches,the,expected,parameter,descriptor;public,static,void,generate,code,for,argument,method,visitor,mv,code,flow,cf,spel,node,impl,argument,string,param,descriptor,cf,enter,compilation,scope,argument,generate,code,mv,cf,boolean,primitive,on,stack,code,flow,is,primitive,cf,last,descriptor,if,primitive,on,stack,param,descriptor,char,at,0,l,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,char,at,0,else,if,param,descriptor,length,1,primitive,on,stack,code,flow,insert,unbox,insns,mv,param,descriptor,char,at,0,cf,last,descriptor,else,if,cf,last,descriptor,equals,param,descriptor,code,flow,insert,check,cast,mv,param,descriptor,cf,exit,compilation,scope
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1478087052;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new Stack<ArrayList<String>>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,stack,array,list,string,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1495868221;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new Stack<ArrayList<String>>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,stack,array,list,string,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1496837955;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new Stack<ArrayList<String>>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,stack,array,list,string,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1498780456;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new Stack<ArrayList<String>>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,stack,array,list,string,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1515777832;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new Stack<ArrayList<String>>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,stack,array,list,string,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1518167476;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new Stack<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,stack,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1518380146;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1520895539;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1522332300;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1522360217;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1530174524;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1530174524;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1530174524;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1530174524;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1530198749;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public CodeFlow(String className, ClassWriter classWriter);1530304568;Construct a new {@code CodeFlow} for the given class._@param className the name of the class_@param classWriter the corresponding ASM {@code ClassWriter};public CodeFlow(String className, ClassWriter classWriter) {_		this.className = className__		this.classWriter = classWriter__		this.compilationScopes = new ArrayDeque<>()__		this.compilationScopes.add(new ArrayList<String>())__	};construct,a,new,code,code,flow,for,the,given,class,param,class,name,the,name,of,the,class,param,class,writer,the,corresponding,asm,code,class,writer;public,code,flow,string,class,name,class,writer,class,writer,this,class,name,class,name,this,class,writer,class,writer,this,compilation,scopes,new,array,deque,this,compilation,scopes,add,new,array,list,string
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1496837955;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1498780456;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1515777832;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1518167476;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1518380146;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1520895539;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1522332300;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1522360217;@param descriptor type descriptor_@return {@code true} if the descriptor is for a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};param,descriptor,type,descriptor,return,code,true,if,the,descriptor,is,for,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive type._@param descriptor type descriptor_@return {@code true} if a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};returns,if,the,descriptor,is,for,a,primitive,type,param,descriptor,type,descriptor,return,code,true,if,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive type._@param descriptor type descriptor_@return {@code true} if a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};returns,if,the,descriptor,is,for,a,primitive,type,param,descriptor,type,descriptor,return,code,true,if,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive type._@param descriptor type descriptor_@return {@code true} if a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};returns,if,the,descriptor,is,for,a,primitive,type,param,descriptor,type,descriptor,return,code,true,if,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1530174524;Returns if the descriptor is for a primitive type._@param descriptor type descriptor_@return {@code true} if a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};returns,if,the,descriptor,is,for,a,primitive,type,param,descriptor,type,descriptor,return,code,true,if,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1530198749;Returns if the descriptor is for a primitive type._@param descriptor type descriptor_@return {@code true} if a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};returns,if,the,descriptor,is,for,a,primitive,type,param,descriptor,type,descriptor,return,code,true,if,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitive(@Nullable String descriptor);1530304568;Determine whether the descriptor is for a primitive type._@param descriptor type descriptor_@return {@code true} if a primitive type;public static boolean isPrimitive(@Nullable String descriptor) {_		return (descriptor != null && descriptor.length() == 1)__	};determine,whether,the,descriptor,is,for,a,primitive,type,param,descriptor,type,descriptor,return,code,true,if,a,primitive,type;public,static,boolean,is,primitive,nullable,string,descriptor,return,descriptor,null,descriptor,length,1
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1405514506;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return ("DFJI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfji,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1405696918;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return ("DFJI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfji,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1406039079;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return ("DFJI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfji,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1406656976;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return ("DFJI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfji,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1412180765;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return ("DFJI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfji,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1412630983;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1413486529;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1413566814;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1414261335;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1424355957;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1425666762;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1425759378;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1430935722;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1432857824;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1436919586;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1458843770;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1467730834;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1467808333;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1467811755;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1478032943;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1478087052;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor);1495868221;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1412630983;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1413486529;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1413566814;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1414261335;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1424355957;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1425666762;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1425759378;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1430935722;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1432857824;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1436919586;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1458843770;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1467730834;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1467808333;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1467811755;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1478032943;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1478087052;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1495868221;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1496837955;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1498780456;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1515777832;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1518167476;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1518380146;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1520895539;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1522332300;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1522360217;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1530174524;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1530174524;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1530174524;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1530174524;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1530198749;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static boolean isIntegerForNumericOp(Number number);1530304568;Determine whether the given number is to be considered as an integer_for the purposes of a numeric operation at the bytecode level._@param number the number to check_@return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte};public static boolean isIntegerForNumericOp(Number number) {_		return (number instanceof Integer || number instanceof Short || number instanceof Byte)__	};determine,whether,the,given,number,is,to,be,considered,as,an,integer,for,the,purposes,of,a,numeric,operation,at,the,bytecode,level,param,number,the,number,to,check,return,code,true,if,it,is,an,link,integer,link,short,or,link,byte;public,static,boolean,is,integer,for,numeric,op,number,number,return,number,instanceof,integer,number,instanceof,short,number,instanceof,byte
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1412630983;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1413486529;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1413566814;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1414261335;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1424355957;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1425666762;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1425759378;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1430935722;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1432857824;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1436919586;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1458843770;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1467730834;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1467808333;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1467811755;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1478032943;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1478087052;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1495868221;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1496837955;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1498780456;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1515777832;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1518167476;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1518380146;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1520895539;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Void.TYPE) {_				sb.append('V')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,void,type,sb,append,v,else,if,clazz,integer,type,sb,append,i,else,if,clazz,boolean,type,sb,append,z,else,if,clazz,character,type,sb,append,c,else,if,clazz,long,type,sb,append,j,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,byte,type,sb,append,b,else,if,clazz,short,type,sb,append,s,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1522332300;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1522360217;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1530174524;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1530174524;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1530174524;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1530174524;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1530198749;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public static String toJvmDescriptor(Class<?> clazz);1530304568;Determine the JVM descriptor for a specified class. Unlike the other descriptors_used in the compilation process, this is the one the JVM wants, so this one_includes any necessary trailing semicolon (e.g. Ljava/lang/String_ rather than_Ljava/lang/String)_@param clazz a class_@return the JVM descriptor for the class;public static String toJvmDescriptor(Class<?> clazz) {_		StringBuilder sb = new StringBuilder()__		if (clazz.isArray()) {_			while (clazz.isArray()) {_				sb.append("[")__				clazz = clazz.getComponentType()__			}_		}_		if (clazz.isPrimitive()) {_			if (clazz == Boolean.TYPE) {_				sb.append('Z')__			}_			else if (clazz == Byte.TYPE) {_				sb.append('B')__			}_			else if (clazz == Character.TYPE) {_				sb.append('C')__			}_			else if (clazz == Double.TYPE) {_				sb.append('D')__			}_			else if (clazz == Float.TYPE) {_				sb.append('F')__			}_			else if (clazz == Integer.TYPE) {_				sb.append('I')__			}_			else if (clazz == Long.TYPE) {_				sb.append('J')__			}_			else if (clazz == Short.TYPE) {_				sb.append('S')__			}_			else if (clazz == Void.TYPE) {_				sb.append('V')__			}_		}_		else {_			sb.append("L")__			sb.append(clazz.getName().replace('.', '/'))__			sb.append("_")__		}_		return sb.toString()__	};determine,the,jvm,descriptor,for,a,specified,class,unlike,the,other,descriptors,used,in,the,compilation,process,this,is,the,one,the,jvm,wants,so,this,one,includes,any,necessary,trailing,semicolon,e,g,ljava,lang,string,rather,than,ljava,lang,string,param,clazz,a,class,return,the,jvm,descriptor,for,the,class;public,static,string,to,jvm,descriptor,class,clazz,string,builder,sb,new,string,builder,if,clazz,is,array,while,clazz,is,array,sb,append,clazz,clazz,get,component,type,if,clazz,is,primitive,if,clazz,boolean,type,sb,append,z,else,if,clazz,byte,type,sb,append,b,else,if,clazz,character,type,sb,append,c,else,if,clazz,double,type,sb,append,d,else,if,clazz,float,type,sb,append,f,else,if,clazz,integer,type,sb,append,i,else,if,clazz,long,type,sb,append,j,else,if,clazz,short,type,sb,append,s,else,if,clazz,void,type,sb,append,v,else,sb,append,l,sb,append,clazz,get,name,replace,sb,append,return,sb,to,string
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1478032943;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1478087052;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1495868221;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1496837955;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1498780456;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1515777832;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1518167476;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1518380146;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1520895539;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1522332300;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1522360217;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1530174524;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1530174524;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1530174524;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1530174524;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1530198749;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public void loadEvaluationContext(MethodVisitor mv);1530304568;Push the bytecode to load the EvaluationContext (the second parameter passed to_the compiled expression method)._@param mv the visitor into which the load instruction should be inserted_@since 4.3.4;public void loadEvaluationContext(MethodVisitor mv) {_		mv.visitVarInsn(ALOAD, 2)__	};push,the,bytecode,to,load,the,evaluation,context,the,second,parameter,passed,to,the,compiled,expression,method,param,mv,the,visitor,into,which,the,load,instruction,should,be,inserted,since,4,3,4;public,void,load,evaluation,context,method,visitor,mv,mv,visit,var,insn,aload,2
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1413486529;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1413566814;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1414261335;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1424355957;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1425666762;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1425759378;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1430935722;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1432857824;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1436919586;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i=0_i<length_i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1458843770;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1467730834;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1467808333;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1467811755;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1478032943;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1478087052;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1495868221;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1496837955;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1498780456;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1515777832;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1518167476;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1518380146;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1520895539;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1522332300;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1522360217;@return true if the supplied array type has a core component reference type;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};return,true,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1530174524;Returns if the supplied array type has a core component reference type.;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') continue__			return ch=='L'__		}_		return false__	};returns,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1530174524;Returns if the supplied array type has a core component reference type.;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') {_				continue__			}_			return ch=='L'__		}_		return false__	};returns,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1530174524;Returns if the supplied array type has a core component reference type.;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') {_				continue__			}_			return ch=='L'__		}_		return false__	};returns,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1530174524;Returns if the supplied array type has a core component reference type.;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') {_				continue__			}_			return ch=='L'__		}_		return false__	};returns,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1530198749;Return if the supplied array type has a core component reference type.;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') {_				continue__			}_			return ch=='L'__		}_		return false__	};return,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static boolean isReferenceTypeArray(String arraytype);1530304568;Return if the supplied array type has a core component reference type.;public static boolean isReferenceTypeArray(String arraytype) {_		int length = arraytype.length()__		for (int i = 0_ i < length_ i++) {_			char ch = arraytype.charAt(i)__			if (ch == '[') {_				continue__			}_			return (ch == 'L')__		}_		return false__	};return,if,the,supplied,array,type,has,a,core,component,reference,type;public,static,boolean,is,reference,type,array,string,arraytype,int,length,arraytype,length,for,int,i,0,i,length,i,char,ch,arraytype,char,at,i,if,ch,continue,return,ch,l,return,false
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1405514506;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else {_			throw new IllegalStateException("No primitive for '"+descriptor+"'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1405696918;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else {_			throw new IllegalStateException("No primitive for '"+descriptor+"'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1406039079;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else {_			throw new IllegalStateException("No primitive for '"+descriptor+"'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1406656976;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else {_			throw new IllegalStateException("No primitive for '"+descriptor+"'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1412180765;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else {_			throw new IllegalStateException("No primitive for '"+descriptor+"'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1412630983;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1413486529;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1413566814;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1414261335;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1424355957;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1425666762;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1425759378;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1430935722;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1432857824;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1436919586;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1458843770;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1467730834;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1467808333;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1467811755;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1478032943;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1478087052;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1495868221;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1496837955;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1498780456;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1515777832;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1518167476;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1518380146;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1520895539;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1522332300;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1522360217;@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1530174524;Convert a type descriptor to the single character primitive descriptor._@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};convert,a,type,descriptor,to,the,single,character,primitive,descriptor,param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1530174524;Convert a type descriptor to the single character primitive descriptor._@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};convert,a,type,descriptor,to,the,single,character,primitive,descriptor,param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1530174524;Convert a type descriptor to the single character primitive descriptor._@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};convert,a,type,descriptor,to,the,single,character,primitive,descriptor,param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1530174524;Convert a type descriptor to the single character primitive descriptor._@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};convert,a,type,descriptor,to,the,single,character,primitive,descriptor,param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1530198749;Convert a type descriptor to the single character primitive descriptor._@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};convert,a,type,descriptor,to,the,single,character,primitive,descriptor,param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static char toPrimitiveTargetDesc(String descriptor);1530304568;Convert a type descriptor to the single character primitive descriptor._@param descriptor a descriptor for a type that should have a primitive representation_@return the single character descriptor for a primitive input descriptor;public static char toPrimitiveTargetDesc(String descriptor) {_		if (descriptor.length() == 1) {_			return descriptor.charAt(0)__		}_		else if (descriptor.equals("Ljava/lang/Boolean")) {_			return 'Z'__		}_		else if (descriptor.equals("Ljava/lang/Byte")) {_			return 'B'__		}_		else if (descriptor.equals("Ljava/lang/Character")) {_			return 'C'__		}_		else if (descriptor.equals("Ljava/lang/Double")) {_			return 'D'__		}_		else if (descriptor.equals("Ljava/lang/Float")) {_			return 'F'__		}_		else if (descriptor.equals("Ljava/lang/Integer")) {_			return 'I'__		}_		else if (descriptor.equals("Ljava/lang/Long")) {_			return 'J'__		}_		else if (descriptor.equals("Ljava/lang/Short")) {_			return 'S'__		}_		else {_			throw new IllegalStateException("No primitive for '" + descriptor + "'")__		}_	};convert,a,type,descriptor,to,the,single,character,primitive,descriptor,param,descriptor,a,descriptor,for,a,type,that,should,have,a,primitive,representation,return,the,single,character,descriptor,for,a,primitive,input,descriptor;public,static,char,to,primitive,target,desc,string,descriptor,if,descriptor,length,1,return,descriptor,char,at,0,else,if,descriptor,equals,ljava,lang,boolean,return,z,else,if,descriptor,equals,ljava,lang,byte,return,b,else,if,descriptor,equals,ljava,lang,character,return,c,else,if,descriptor,equals,ljava,lang,double,return,d,else,if,descriptor,equals,ljava,lang,float,return,f,else,if,descriptor,equals,ljava,lang,integer,return,i,else,if,descriptor,equals,ljava,lang,long,return,j,else,if,descriptor,equals,ljava,lang,short,return,s,else,throw,new,illegal,state,exception,no,primitive,for,descriptor
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1498780456;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1515777832;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1518167476;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1518380146;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1520895539;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1522332300;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1522360217;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1530174524;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1530174524;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1530174524;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1530174524;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1530198749;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor);1530304568;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {_		if (descriptor != null && descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,nullable,string,descriptor,if,descriptor,null,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public void pushDescriptor(String descriptor);1405514506;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor)__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1405696918;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor)__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1406039079;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1406656976;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1412180765;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1412630983;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1413486529;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1413566814;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1414261335;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1424355957;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1425666762;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1425759378;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1430935722;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1432857824;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1436919586;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1458843770;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1467730834;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1467808333;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1467811755;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1478032943;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1478087052;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1495868221;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public void pushDescriptor(String descriptor);1496837955;Record the descriptor for the most recently evaluated expression element._@param descriptor type descriptor for most recently evaluated element;public void pushDescriptor(String descriptor) {_		Assert.notNull(descriptor, "Descriptor must not be null")__		this.compilationScopes.peek().add(descriptor)__	};record,the,descriptor,for,the,most,recently,evaluated,expression,element,param,descriptor,type,descriptor,for,most,recently,evaluated,element;public,void,push,descriptor,string,descriptor,assert,not,null,descriptor,descriptor,must,not,be,null,this,compilation,scopes,peek,add,descriptor
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1498780456;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1515777832;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1518167476;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1518380146;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1520895539;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1522332300;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1522360217;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1530174524;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1530174524;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1530174524;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1530174524;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1530198749;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(@Nullable Object value);1530304568;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1496837955;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1498780456;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1515777832;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1518167476;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1518380146;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1520895539;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1522332300;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1522360217;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1530174524;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1530198749;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor);1530304568;Determine if the supplied descriptor is for a supported number. The compilation_process only (currently) supports certain number types. These are double, float,_long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type;public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length() == 1) {_			return "DFIJ".contains(descriptor)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			String name = descriptor.substring("Ljava/lang/".length())__			if (name.equals("Double") || name.equals("Float") || name.equals("Integer") || name.equals("Long")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type;public,static,boolean,is,primitive,or,unboxable,supported,number,nullable,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfij,contains,descriptor,if,descriptor,starts,with,ljava,lang,string,name,descriptor,substring,ljava,lang,length,if,name,equals,double,name,equals,float,name,equals,integer,name,equals,long,return,true,return,false
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1405514506;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1405696918;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1406039079;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1406656976;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1412180765;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1412630983;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1413486529;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1413566814;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1414261335;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1424355957;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1425666762;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1425759378;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1430935722;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1432857824;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1436919586;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1458843770;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1467730834;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1467808333;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1467811755;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1478032943;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1478087052;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor);1495868221;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param descriptor the descriptor of a type that may or may not need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {_		if (descriptor.length() == 1) {_			insertBoxIfNecessary(mv, descriptor.charAt(0))__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,descriptor,the,descriptor,of,a,type,that,may,or,may,not,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,string,descriptor,if,descriptor,length,1,insert,box,if,necessary,mv,descriptor,char,at,0
CodeFlow -> @Nullable 	public static String toDescriptorFromObject(@Nullable Object value);1495868221;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);@Nullable_	public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;nullable,public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> @Nullable 	public static String toDescriptorFromObject(@Nullable Object value);1496837955;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);@Nullable_	public static String toDescriptorFromObject(@Nullable Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;nullable,public,static,string,to,descriptor,from,object,nullable,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1405514506;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_		case 'I':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__			break__		case 'F':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__			break__		case 'S':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__			break__		case 'Z':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__			break__		case 'J':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__			break__		case 'D':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__			break__		case 'C':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__			break__		case 'B':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__			break__		case 'L':_			case 'V':_		case '[':_			_			break__		default:_			throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1405696918;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_		case 'I':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__			break__		case 'F':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__			break__		case 'S':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__			break__		case 'Z':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__			break__		case 'J':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__			break__		case 'D':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__			break__		case 'C':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__			break__		case 'B':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__			break__		case 'L':_			case 'V':_		case '[':_			_			break__		default:_			throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1406039079;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_		case 'I':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__			break__		case 'F':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__			break__		case 'S':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__			break__		case 'Z':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__			break__		case 'J':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__			break__		case 'D':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__			break__		case 'C':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__			break__		case 'B':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__			break__		case 'L':_			case 'V':_		case '[':_			_			break__		default:_			throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1406656976;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_		case 'I':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__			break__		case 'F':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__			break__		case 'S':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__			break__		case 'Z':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__			break__		case 'J':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__			break__		case 'D':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__			break__		case 'C':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__			break__		case 'B':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__			break__		case 'L':_			case 'V':_		case '[':_			_			break__		default:_			throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1412180765;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_		case 'I':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__			break__		case 'F':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__			break__		case 'S':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__			break__		case 'Z':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__			break__		case 'J':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__			break__		case 'D':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__			break__		case 'C':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__			break__		case 'B':_			mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__			break__		case 'L':_			case 'V':_		case '[':_			_			break__		default:_			throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1412630983;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1413486529;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1413566814;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1414261335;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1424355957;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1425666762;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1425759378;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1430935722;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1432857824;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1436919586;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1458843770;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1467730834;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1467808333;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1467811755;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1478032943;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1478087052;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1495868221;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1496837955;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1498780456;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1515777832;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1518167476;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1518380146;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1520895539;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1522332300;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1522360217;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1530174524;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1530198749;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertBoxIfNecessary(MethodVisitor mv, char ch);1530304568;Determine the appropriate boxing instruction for a specific type (if it needs_boxing) and insert the instruction into the supplied visitor._@param mv the target visitor for the new instructions_@param ch the descriptor of the type that might need boxing;public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {_		switch (ch) {_			case 'Z':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean_", false)__				break__			case 'B':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte_", false)__				break__			case 'C':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character_", false)__				break__			case 'D':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double_", false)__				break__			case 'F':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float_", false)__				break__			case 'I':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer_", false)__				break__			case 'J':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long_", false)__				break__			case 'S':_				mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short_", false)__				break__			case 'L':_			case 'V':_			case '[':_				_				break__			default:_				throw new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'")__		}_	};determine,the,appropriate,boxing,instruction,for,a,specific,type,if,it,needs,boxing,and,insert,the,instruction,into,the,supplied,visitor,param,mv,the,target,visitor,for,the,new,instructions,param,ch,the,descriptor,of,the,type,that,might,need,boxing;public,static,void,insert,box,if,necessary,method,visitor,mv,char,ch,switch,ch,case,z,mv,visit,method,insn,invokestatic,java,lang,boolean,value,of,z,ljava,lang,boolean,false,break,case,b,mv,visit,method,insn,invokestatic,java,lang,byte,value,of,b,ljava,lang,byte,false,break,case,c,mv,visit,method,insn,invokestatic,java,lang,character,value,of,c,ljava,lang,character,false,break,case,d,mv,visit,method,insn,invokestatic,java,lang,double,value,of,d,ljava,lang,double,false,break,case,f,mv,visit,method,insn,invokestatic,java,lang,float,value,of,f,ljava,lang,float,false,break,case,i,mv,visit,method,insn,invokestatic,java,lang,integer,value,of,i,ljava,lang,integer,false,break,case,j,mv,visit,method,insn,invokestatic,java,lang,long,value,of,j,ljava,lang,long,false,break,case,s,mv,visit,method,insn,invokestatic,java,lang,short,value,of,s,ljava,lang,short,false,break,case,l,case,v,case,break,default,throw,new,illegal,argument,exception,boxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, 			String stackDescriptor, char targetDecriptor);1425666762;For use in mathematical operators, handles converting from a (possibly boxed) number on the stack to a primitive numeric type._For example, from a Integer to a double, just need to call 'Number.doubleValue()' but from an int to a double, need to use_the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv,_			String stackDescriptor, char targetDecriptor) {_		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDecriptor, stackDescriptor)__		} else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDecriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,decriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,decriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,decriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, 			String stackDescriptor, char targetDecriptor);1425759378;For use in mathematical operators, handles converting from a (possibly boxed) number on the stack to a primitive numeric type._For example, from a Integer to a double, just need to call 'Number.doubleValue()' but from an int to a double, need to use_the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv,_			String stackDescriptor, char targetDecriptor) {_		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDecriptor, stackDescriptor)__		} else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDecriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,decriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,decriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,decriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, 			String stackDescriptor, char targetDecriptor);1430935722;For use in mathematical operators, handles converting from a (possibly boxed) number on the stack to a primitive numeric type._For example, from a Integer to a double, just need to call 'Number.doubleValue()' but from an int to a double, need to use_the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv,_			String stackDescriptor, char targetDecriptor) {_		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDecriptor, stackDescriptor)__		} else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDecriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,decriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,decriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,decriptor,stack,descriptor
CodeFlow -> public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, 			String stackDescriptor, char targetDecriptor);1432857824;For use in mathematical operators, handles converting from a (possibly boxed) number on the stack to a primitive numeric type._For example, from a Integer to a double, just need to call 'Number.doubleValue()' but from an int to a double, need to use_the bytecode 'i2d'._@param mv the method visitor when instructions should be appended_@param stackDescriptor a descriptor of the operand on the stack_@param targetDescriptor a primitive type descriptor;public static void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv,_			String stackDescriptor, char targetDecriptor) {_		if (!CodeFlow.isPrimitive(stackDescriptor)) {_			CodeFlow.insertUnboxNumberInsns(mv, targetDecriptor, stackDescriptor)__		} else {_			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDecriptor, stackDescriptor)__		}_	};for,use,in,mathematical,operators,handles,converting,from,a,possibly,boxed,number,on,the,stack,to,a,primitive,numeric,type,for,example,from,a,integer,to,a,double,just,need,to,call,number,double,value,but,from,an,int,to,a,double,need,to,use,the,bytecode,i2d,param,mv,the,method,visitor,when,instructions,should,be,appended,param,stack,descriptor,a,descriptor,of,the,operand,on,the,stack,param,target,descriptor,a,primitive,type,descriptor;public,static,void,insert,numeric,unbox,or,primitive,type,coercion,method,visitor,mv,string,stack,descriptor,char,target,decriptor,if,code,flow,is,primitive,stack,descriptor,code,flow,insert,unbox,number,insns,mv,target,decriptor,stack,descriptor,else,code,flow,insert,any,necessary,type,conversion,bytecodes,mv,target,decriptor,stack,descriptor
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1405514506;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1405696918;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1406039079;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1406656976;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1412180765;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1412630983;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1413486529;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1413566814;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1414261335;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1424355957;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1425666762;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1425759378;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1430935722;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1432857824;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1436919586;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1458843770;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1467730834;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1467808333;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1467811755;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1478032943;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1478087052;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1495868221;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1496837955;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1498780456;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1515777832;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1518167476;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1518380146;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1520895539;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1522332300;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1522360217;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1530174524;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1530174524;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1530174524;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1530174524;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1530198749;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static String[] toParamDescriptors(Constructor<?> ctor);1530304568;Create an array of descriptors representing the parameter types for the supplied_constructor. Returns a zero sized array if there are no parameters._@param ctor a Constructor_@return a String array of descriptors, one entry for each constructor parameter;public static String[] toParamDescriptors(Constructor<?> ctor) {_		return toDescriptors(ctor.getParameterTypes())__	};create,an,array,of,descriptors,representing,the,parameter,types,for,the,supplied,constructor,returns,a,zero,sized,array,if,there,are,no,parameters,param,ctor,a,constructor,return,a,string,array,of,descriptors,one,entry,for,each,constructor,parameter;public,static,string,to,param,descriptors,constructor,ctor,return,to,descriptors,ctor,get,parameter,types
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1405514506;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				_				mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1405696918;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				_				mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1406039079;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				_				mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1406656976;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				_				mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1412180765;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1412630983;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1413486529;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1413566814;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1414261335;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1424355957;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1425666762;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1425759378;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1430935722;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1432857824;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1436919586;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1458843770;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1467730834;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1467808333;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1467811755;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1478032943;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1478087052;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1495868221;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertCheckCast(MethodVisitor mv, String descriptor);1496837955;Insert the appropriate CHECKCAST instruction for the supplied descriptor._@param mv the target visitor into which the instruction should be inserted_@param descriptor the descriptor of the type to cast to;public static void insertCheckCast(MethodVisitor mv, String descriptor) {_		if (descriptor.length() != 1) {_			if (descriptor.charAt(0) == '[') {_				if (isPrimitiveArray(descriptor)) {_					mv.visitTypeInsn(CHECKCAST, descriptor)__				}_				else {_					mv.visitTypeInsn(CHECKCAST, descriptor + "_")__				}_			}_			else {_				if (!descriptor.equals("Ljava/lang/Object")) {_					_					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1))__				}_			}_		}_	};insert,the,appropriate,checkcast,instruction,for,the,supplied,descriptor,param,mv,the,target,visitor,into,which,the,instruction,should,be,inserted,param,descriptor,the,descriptor,of,the,type,to,cast,to;public,static,void,insert,check,cast,method,visitor,mv,string,descriptor,if,descriptor,length,1,if,descriptor,char,at,0,if,is,primitive,array,descriptor,mv,visit,type,insn,checkcast,descriptor,else,mv,visit,type,insn,checkcast,descriptor,else,if,descriptor,equals,ljava,lang,object,mv,visit,type,insn,checkcast,descriptor,substring,1
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1498780456;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1515777832;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1518167476;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1518380146;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1520895539;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1522332300;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1522360217;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1530174524;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1530174524;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1530174524;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1530174524;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1530198749;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor);1530304568;Insert any necessary cast and value call to convert from a boxed type to a_primitive value._@param mv the method visitor into which instructions should be inserted_@param ch the primitive type desired as output_@param stackDescriptor the descriptor of the type on top of the stack;public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {_		if (stackDescriptor == null) {_			return__		}_		switch (ch) {_			case 'Z':_				if (!stackDescriptor.equals("Ljava/lang/Boolean")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false)__				break__			case 'B':_				if (!stackDescriptor.equals("Ljava/lang/Byte")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Byte")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false)__				break__			case 'C':_				if (!stackDescriptor.equals("Ljava/lang/Character")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Character")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false)__				break__			case 'D':_				if (!stackDescriptor.equals("Ljava/lang/Double")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Double")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false)__				break__			case 'F':_				if (!stackDescriptor.equals("Ljava/lang/Float")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Float")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false)__				break__			case 'I':_				if (!stackDescriptor.equals("Ljava/lang/Integer")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Integer")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false)__				break__			case 'J':_				if (!stackDescriptor.equals("Ljava/lang/Long")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Long")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false)__				break__			case 'S':_				if (!stackDescriptor.equals("Ljava/lang/Short")) {_					mv.visitTypeInsn(CHECKCAST, "java/lang/Short")__				}_				mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false)__				break__			default:_				throw new IllegalArgumentException("Unboxing should not be attempted for descriptor '" + ch + "'")__		}_	};insert,any,necessary,cast,and,value,call,to,convert,from,a,boxed,type,to,a,primitive,value,param,mv,the,method,visitor,into,which,instructions,should,be,inserted,param,ch,the,primitive,type,desired,as,output,param,stack,descriptor,the,descriptor,of,the,type,on,top,of,the,stack;public,static,void,insert,unbox,insns,method,visitor,mv,char,ch,nullable,string,stack,descriptor,if,stack,descriptor,null,return,switch,ch,case,z,if,stack,descriptor,equals,ljava,lang,boolean,mv,visit,type,insn,checkcast,java,lang,boolean,mv,visit,method,insn,invokevirtual,java,lang,boolean,boolean,value,z,false,break,case,b,if,stack,descriptor,equals,ljava,lang,byte,mv,visit,type,insn,checkcast,java,lang,byte,mv,visit,method,insn,invokevirtual,java,lang,byte,byte,value,b,false,break,case,c,if,stack,descriptor,equals,ljava,lang,character,mv,visit,type,insn,checkcast,java,lang,character,mv,visit,method,insn,invokevirtual,java,lang,character,char,value,c,false,break,case,d,if,stack,descriptor,equals,ljava,lang,double,mv,visit,type,insn,checkcast,java,lang,double,mv,visit,method,insn,invokevirtual,java,lang,double,double,value,d,false,break,case,f,if,stack,descriptor,equals,ljava,lang,float,mv,visit,type,insn,checkcast,java,lang,float,mv,visit,method,insn,invokevirtual,java,lang,float,float,value,f,false,break,case,i,if,stack,descriptor,equals,ljava,lang,integer,mv,visit,type,insn,checkcast,java,lang,integer,mv,visit,method,insn,invokevirtual,java,lang,integer,int,value,i,false,break,case,j,if,stack,descriptor,equals,ljava,lang,long,mv,visit,type,insn,checkcast,java,lang,long,mv,visit,method,insn,invokevirtual,java,lang,long,long,value,j,false,break,case,s,if,stack,descriptor,equals,ljava,lang,short,mv,visit,type,insn,checkcast,java,lang,short,mv,visit,method,insn,invokevirtual,java,lang,short,short,value,s,false,break,default,throw,new,illegal,argument,exception,unboxing,should,not,be,attempted,for,descriptor,ch
CodeFlow -> public static String toDescriptorFromObject(Object value);1405514506;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1405696918;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1406039079;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1406656976;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1412180765;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1412630983;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1413486529;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1413566814;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1414261335;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1424355957;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1425666762;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1425759378;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1430935722;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1432857824;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1436919586;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1458843770;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1467730834;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1467808333;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1467811755;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1478032943;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static String toDescriptorFromObject(Object value);1478087052;Determine the descriptor for an object instance (or {@code null})._@param value an object (possibly {@code null})_@return the type descriptor for the object_(descriptor is "Ljava/lang/Object" for {@code null} value);public static String toDescriptorFromObject(Object value) {_		if (value == null) {_			return "Ljava/lang/Object"__		}_		else {_			return toDescriptor(value.getClass())__		}_	};determine,the,descriptor,for,an,object,instance,or,code,null,param,value,an,object,possibly,code,null,return,the,type,descriptor,for,the,object,descriptor,is,ljava,lang,object,for,code,null,value;public,static,string,to,descriptor,from,object,object,value,if,value,null,return,ljava,lang,object,else,return,to,descriptor,value,get,class
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1405514506;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length( )== 1) {_			return ("DFJZI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long") ||_				descriptor.equals("Ljava/lang/Boolean")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfjzi,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,descriptor,equals,ljava,lang,boolean,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1405696918;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length( )== 1) {_			return ("DFJZI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long") ||_				descriptor.equals("Ljava/lang/Boolean")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfjzi,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,descriptor,equals,ljava,lang,boolean,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1406039079;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length( )== 1) {_			return ("DFJZI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long") ||_				descriptor.equals("Ljava/lang/Boolean")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfjzi,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,descriptor,equals,ljava,lang,boolean,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1406656976;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length( )== 1) {_			return ("DFJZI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long") ||_				descriptor.equals("Ljava/lang/Boolean")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfjzi,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,descriptor,equals,ljava,lang,boolean,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1412180765;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (descriptor.length( )== 1) {_			return ("DFJZI".indexOf(descriptor.charAt(0)) != -1)__		}_		if (descriptor.startsWith("Ljava/lang/")) {_			if (descriptor.equals("Ljava/lang/Double") || descriptor.equals("Ljava/lang/Integer") ||_				descriptor.equals("Ljava/lang/Float") || descriptor.equals("Ljava/lang/Long") ||_				descriptor.equals("Ljava/lang/Boolean")) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,descriptor,length,1,return,dfjzi,index,of,descriptor,char,at,0,1,if,descriptor,starts,with,ljava,lang,if,descriptor,equals,ljava,lang,double,descriptor,equals,ljava,lang,integer,descriptor,equals,ljava,lang,float,descriptor,equals,ljava,lang,long,descriptor,equals,ljava,lang,boolean,return,true,return,false
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1412630983;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1413486529;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1413566814;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1414261335;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1424355957;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1425666762;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1425759378;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1430935722;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1432857824;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1436919586;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1458843770;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1467730834;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1467808333;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1467811755;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1478032943;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1478087052;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
CodeFlow -> public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor);1495868221;Determine if the supplied descriptor is for a supported number type or boolean. The_compilation process only (currently) supports certain number types. These are_double, float, long and int._@param descriptor the descriptor for a type_@return {@code true} if the descriptor is for a supported numeric type or boolean;public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {_		if (descriptor == null) {_			return false__		}_		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {_			return true__		}_		return ("Z".equals(descriptor) || descriptor.equals("Ljava/lang/Boolean"))__	};determine,if,the,supplied,descriptor,is,for,a,supported,number,type,or,boolean,the,compilation,process,only,currently,supports,certain,number,types,these,are,double,float,long,and,int,param,descriptor,the,descriptor,for,a,type,return,code,true,if,the,descriptor,is,for,a,supported,numeric,type,or,boolean;public,static,boolean,is,primitive,or,unboxable,supported,number,or,boolean,string,descriptor,if,descriptor,null,return,false,if,is,primitive,or,unboxable,supported,number,descriptor,return,true,return,z,equals,descriptor,descriptor,equals,ljava,lang,boolean
