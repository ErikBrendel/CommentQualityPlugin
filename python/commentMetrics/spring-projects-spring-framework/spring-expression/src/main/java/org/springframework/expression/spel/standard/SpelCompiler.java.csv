commented;modifiers;parameterAmount;loc;comment;code
true;public;1;22;/**  * Attempt compilation of the supplied expression. A check is made to see  * if it is compilable before compilation proceeds. The check involves  * visiting all the nodes in the expression Ast and ensuring enough state  * is known about them that bytecode can be generated for them.  * @param expression the expression to compile  * @return an instance of the class implementing the compiled expression,  * or {@code null} if compilation is not possible  */ ;/**  * Attempt compilation of the supplied expression. A check is made to see  * if it is compilable before compilation proceeds. The check involves  * visiting all the nodes in the expression Ast and ensuring enough state  * is known about them that bytecode can be generated for them.  * @param expression the expression to compile  * @return an instance of the class implementing the compiled expression,  * or {@code null} if compilation is not possible  */ @Nullable public CompiledExpression compile(SpelNodeImpl expression) {     if (expression.isCompilable()) {         if (logger.isDebugEnabled()) {             logger.debug("SpEL: compiling " + expression.toStringAST()).         }         Class<? extends CompiledExpression> clazz = createExpressionClass(expression).         if (clazz != null) {             try {                 return ReflectionUtils.accessibleConstructor(clazz).newInstance().             } catch (Throwable ex) {                 throw new IllegalStateException("Failed to instantiate CompiledExpression", ex).             }         }     }     if (logger.isDebugEnabled()) {         logger.debug("SpEL: unable to compile " + expression.toStringAST()).     }     return null. }
false;private;0;3;;private int getNextSuffix() {     return this.suffixId.incrementAndGet(). }
true;private;1;54;/**  * Generate the class that encapsulates the compiled expression and define it.  * The  generated class will be a subtype of CompiledExpression.  * @param expressionToCompile the expression to be compiled  * @return the expression call, or {@code null} if the decision was to opt out of  * compilation during code generation  */ ;/**  * Generate the class that encapsulates the compiled expression and define it.  * The  generated class will be a subtype of CompiledExpression.  * @param expressionToCompile the expression to be compiled  * @return the expression call, or {@code null} if the decision was to opt out of  * compilation during code generation  */ @Nullable private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {     // Create class outline 'spel/ExNNN extends org.springframework.expression.spel.CompiledExpression'     String className = "spel/Ex" + getNextSuffix().     ClassWriter cw = new ExpressionClassWriter().     cw.visit(V1_5, ACC_PUBLIC, className, null, "org/springframework/expression/spel/CompiledExpression", null).     // Create default constructor     MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null).     mv.visitCode().     mv.visitVarInsn(ALOAD, 0).     mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression", "<init>", "()V", false).     mv.visitInsn(RETURN).     mv.visitMaxs(1, 1).     mv.visitEnd().     // Create getValue() method     mv = cw.visitMethod(ACC_PUBLIC, "getValue", "(Ljava/lang/Object.Lorg/springframework/expression/EvaluationContext.)Ljava/lang/Object.", null, new String[] { "org/springframework/expression/EvaluationException" }).     mv.visitCode().     CodeFlow cf = new CodeFlow(className, cw).     // Ask the expression AST to generate the body of the method     try {         expressionToCompile.generateCode(mv, cf).     } catch (IllegalStateException ex) {         if (logger.isDebugEnabled()) {             logger.debug(expressionToCompile.getClass().getSimpleName() + ".generateCode opted out of compilation: " + ex.getMessage()).         }         return null.     }     CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor()).     if ("V".equals(cf.lastDescriptor())) {         mv.visitInsn(ACONST_NULL).     }     mv.visitInsn(ARETURN).     // not supplied due to COMPUTE_MAXS     mv.visitMaxs(0, 0).     mv.visitEnd().     cw.visitEnd().     cf.finish().     byte[] data = cw.toByteArray().     // dump(expressionToCompile.toStringAST(), clazzName, data).     return loadClass(StringUtils.replace(className, "/", "."), data). }
true;private;2;7;/**  * Load a compiled expression class. Makes sure the classloaders aren't used too much  * because they anchor compiled classes in memory and prevent GC.  If you have expressions  * continually recompiling over time then by replacing the classloader periodically  * at least some of the older variants can be garbage collected.  * @param name name of the class  * @param bytes bytecode for the class  * @return the Class object for the compiled expression  */ ;/**  * Load a compiled expression class. Makes sure the classloaders aren't used too much  * because they anchor compiled classes in memory and prevent GC.  If you have expressions  * continually recompiling over time then by replacing the classloader periodically  * at least some of the older variants can be garbage collected.  * @param name name of the class  * @param bytes bytecode for the class  * @return the Class object for the compiled expression  */ @SuppressWarnings("unchecked") private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {     if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {         this.ccl = new ChildClassLoader(this.ccl.getParent()).     }     return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes). }
true;public,static;1;11;/**  * Factory method for compiler instances. The returned SpelCompiler will  * attach a class loader as the child of the given class loader and this  * child will be used to load compiled expressions.  * @param classLoader the ClassLoader to use as the basis for compilation  * @return a corresponding SpelCompiler instance  */ ;/**  * Factory method for compiler instances. The returned SpelCompiler will  * attach a class loader as the child of the given class loader and this  * child will be used to load compiled expressions.  * @param classLoader the ClassLoader to use as the basis for compilation  * @return a corresponding SpelCompiler instance  */ public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {     ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader()).     synchronized (compilers) {         SpelCompiler compiler = compilers.get(clToUse).         if (compiler == null) {             compiler = new SpelCompiler(clToUse).             compilers.put(clToUse, compiler).         }         return compiler.     } }
true;public,static;1;3;/**  * Request that an attempt is made to compile the specified expression. It may fail if  * components of the expression are not suitable for compilation or the data types  * involved are not suitable for compilation. Used for testing.  * @return true if the expression was successfully compiled  */ ;/**  * Request that an attempt is made to compile the specified expression. It may fail if  * components of the expression are not suitable for compilation or the data types  * involved are not suitable for compilation. Used for testing.  * @return true if the expression was successfully compiled  */ public static boolean compile(Expression expression) {     return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression()). }
true;public,static;1;5;/**  * Request to revert to the interpreter for expression evaluation.  * Any compiled form is discarded but can be recreated by later recompiling again.  * @param expression the expression  */ ;/**  * Request to revert to the interpreter for expression evaluation.  * Any compiled form is discarded but can be recreated by later recompiling again.  * @param expression the expression  */ public static void revertToInterpreted(Expression expression) {     if (expression instanceof SpelExpression) {         ((SpelExpression) expression).revertToInterpreted().     } }
false;;0;3;;int getClassesDefinedCount() {     return this.classesDefinedCount. }
false;public;2;5;;public Class<?> defineClass(String name, byte[] bytes) {     Class<?> clazz = super.defineClass(name, bytes, 0, bytes.length).     this.classesDefinedCount++.     return clazz. }
false;protected;0;4;;@Override protected ClassLoader getClassLoader() {     return ccl. }
