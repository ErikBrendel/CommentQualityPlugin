# id;timestamp;commentText;codeText;commentWords;codeWords
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1495868221;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1496837955;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1498496357;Attempt compilation of the supplied expression. A check is made to see_if it is compilable before compilation proceeds. The check involves_visiting all the nodes in the expression Ast and ensuring enough state_is known about them that bytecode can be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression,_or {@code null} if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,code,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1500332081;Attempt compilation of the supplied expression. A check is made to see_if it is compilable before compilation proceeds. The check involves_visiting all the nodes in the expression Ast and ensuring enough state_is known about them that bytecode can be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression,_or {@code null} if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,code,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1520528267;Attempt compilation of the supplied expression. A check is made to see_if it is compilable before compilation proceeds. The check involves_visiting all the nodes in the expression Ast and ensuring enough state_is known about them that bytecode can be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression,_or {@code null} if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,code,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1530174524;Attempt compilation of the supplied expression. A check is made to see_if it is compilable before compilation proceeds. The check involves_visiting all the nodes in the expression Ast and ensuring enough state_is known about them that bytecode can be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression,_or {@code null} if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,code,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1530174524;Attempt compilation of the supplied expression. A check is made to see_if it is compilable before compilation proceeds. The check involves_visiting all the nodes in the expression Ast and ensuring enough state_is known about them that bytecode can be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression,_or {@code null} if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,code,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @Nullable 	public CompiledExpression compile(SpelNodeImpl expression);1537186939;Attempt compilation of the supplied expression. A check is made to see_if it is compilable before compilation proceeds. The check involves_visiting all the nodes in the expression Ast and ensuring enough state_is known about them that bytecode can be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression,_or {@code null} if compilation is not possible;@Nullable_	public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,code,null,if,compilation,is,not,possible;nullable,public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1405011154;Generate the class that encapsulates the compiled expression and define it. The_generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {__		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null,_				"org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression", "<init>", "()V",false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue", "(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow codeflow = new CodeFlow()___		_		expressionToCompile.generateCode(mv,codeflow)___		CodeFlow.insertBoxIfNecessary(mv,codeflow.lastDescriptor())__		if (codeflow.lastDescriptor() == "V") {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0,0)_ _		mv.visitEnd()__		cw.visitEnd()__		byte[] data = cw.toByteArray()__		_		_		Class<? extends CompiledExpression> clazz = (Class<? extends CompiledExpression>) ccl.defineClass(clazzName.replaceAll("/","."),data)__		return clazz__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,codeflow,new,code,flow,expression,to,compile,generate,code,mv,codeflow,code,flow,insert,box,if,necessary,mv,codeflow,last,descriptor,if,codeflow,last,descriptor,v,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,byte,data,cw,to,byte,array,class,extends,compiled,expression,clazz,class,extends,compiled,expression,ccl,define,class,clazz,name,replace,all,data,return,clazz
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1405514506;Generate the class that encapsulates the compiled expression and define it. The_generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null,_				"org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression", "<init>", "()V",false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue", "(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow codeflow = new CodeFlow()___		_		expressionToCompile.generateCode(mv,codeflow)___		CodeFlow.insertBoxIfNecessary(mv,codeflow.lastDescriptor())__		if ("V".equals(codeflow.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0,0)_ _		mv.visitEnd()__		cw.visitEnd()__		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) ccl.defineClass(clazzName.replaceAll("/","."),data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,codeflow,new,code,flow,expression,to,compile,generate,code,mv,codeflow,code,flow,insert,box,if,necessary,mv,codeflow,last,descriptor,if,v,equals,codeflow,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1410558554;Generate the class that encapsulates the compiled expression and define it. The_generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression", "<init>", "()V",false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue", "(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow codeflow = new CodeFlow()___		_		expressionToCompile.generateCode(mv,codeflow)___		CodeFlow.insertBoxIfNecessary(mv,codeflow.lastDescriptor())__		if ("V".equals(codeflow.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0,0)_ _		mv.visitEnd()__		cw.visitEnd()__		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) ccl.defineClass(clazzName.replaceAll("/","."),data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,codeflow,new,code,flow,expression,to,compile,generate,code,mv,codeflow,code,flow,insert,box,if,necessary,mv,codeflow,last,descriptor,if,v,equals,codeflow,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1412004673;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression", "<init>", "()V",false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue", "(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow codeflow = new CodeFlow()___		_		try {_			expressionToCompile.generateCode(mv, codeflow)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor())__		if ("V".equals(codeflow.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0,0)_ _		mv.visitEnd()__		cw.visitEnd()__		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) ccl.defineClass(clazzName.replaceAll("/","."),data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,codeflow,new,code,flow,try,expression,to,compile,generate,code,mv,codeflow,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,codeflow,last,descriptor,if,v,equals,codeflow,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1412630983;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow()___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()__		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,this,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1413486529;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()__		_		cf.finish()__		_		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,this,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1425759378;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES)__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,class,writer,class,writer,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,this,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1448383082;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,this,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1467730834;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,this,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1468948866;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;suppress,warnings,unchecked,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,class,extends,compiled,expression,this,ccl,define,class,clazz,name,replace,all,data
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1496837955;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1498496357;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1500332081;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1520528267;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1530174524;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1530174524;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader);1537186939;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,nullable,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1405011154;For debugging purposes, dump the specified byte code into a file on the disk. Not_yet hooked in, needs conditionally calling based on a sys prop.__@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		name = name.replace('.', '/')__		String dir = ""__		if (name.indexOf('/') != -1) {_			dir = name.substring(0, name.lastIndexOf('/'))__		}_		String dumplocation = null__		try {_			File tempfile = null__			tempfile = File.createTempFile("tmp", null)__			tempfile.delete()__			File f = new File(tempfile, dir)__			f.mkdirs()__			dumplocation = tempfile + File.separator + name + ".class"__			System.out.println("Expression '" + expressionText + "' compiled code dumped to "_					+ dumplocation)__			f = new File(dumplocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ioe) {_			throw new IllegalStateException("Unexpected problem dumping class "_					+ name + " into " + dumplocation, ioe)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,name,name,replace,string,dir,if,name,index,of,1,dir,name,substring,0,name,last,index,of,string,dumplocation,null,try,file,tempfile,null,tempfile,file,create,temp,file,tmp,null,tempfile,delete,file,f,new,file,tempfile,dir,f,mkdirs,dumplocation,tempfile,file,separator,name,class,system,out,println,expression,expression,text,compiled,code,dumped,to,dumplocation,f,new,file,dumplocation,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ioe,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,into,dumplocation,ioe
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1405514506;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException("Unexpected problem dumping class " + nameToUse + " into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1410558554;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException("Unexpected problem dumping class " + nameToUse + " into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1412004673;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException("Unexpected problem dumping class " + nameToUse + " into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1412630983;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class " + nameToUse + " into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1413486529;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class " + nameToUse + " into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1425759378;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class " + nameToUse + " into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1448383082;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1467730834;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1468948866;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1493317916;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1495868221;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1496837955;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> @SuppressWarnings("unused") 	private static void dump(String expressionText, String name, byte[] bytecode);1498496357;For debugging purposes, dump the specified byte code into a file on the disk._Not yet hooked in, needs conditionally calling based on a sys prop._@param expressionText the text of the expression compiled_@param name the name of the class being used for the compiled expression_@param bytecode the bytecode for the generated class;@SuppressWarnings("unused")_	private static void dump(String expressionText, String name, byte[] bytecode) {_		String nameToUse = name.replace('.', '/')__		String dir = (nameToUse.indexOf('/') != -1 ? nameToUse.substring(0, nameToUse.lastIndexOf('/')) : "")__		String dumpLocation = null__		try {_			File tempFile = File.createTempFile("tmp", null)__			dumpLocation = tempFile + File.separator + nameToUse + ".class"__			tempFile.delete()__			File f = new File(tempFile, dir)__			f.mkdirs()__			_			if (logger.isDebugEnabled()) {_				logger.debug("Expression '" + expressionText + "' compiled code dumped to " + dumpLocation)__			}_			f = new File(dumpLocation)__			FileOutputStream fos = new FileOutputStream(f)__			fos.write(bytecode)__			fos.flush()__			fos.close()__		}_		catch (IOException ex) {_			throw new IllegalStateException(_					"Unexpected problem dumping class '" + nameToUse + "' into " + dumpLocation, ex)__		}_	};for,debugging,purposes,dump,the,specified,byte,code,into,a,file,on,the,disk,not,yet,hooked,in,needs,conditionally,calling,based,on,a,sys,prop,param,expression,text,the,text,of,the,expression,compiled,param,name,the,name,of,the,class,being,used,for,the,compiled,expression,param,bytecode,the,bytecode,for,the,generated,class;suppress,warnings,unused,private,static,void,dump,string,expression,text,string,name,byte,bytecode,string,name,to,use,name,replace,string,dir,name,to,use,index,of,1,name,to,use,substring,0,name,to,use,last,index,of,string,dump,location,null,try,file,temp,file,file,create,temp,file,tmp,null,dump,location,temp,file,file,separator,name,to,use,class,temp,file,delete,file,f,new,file,temp,file,dir,f,mkdirs,if,logger,is,debug,enabled,logger,debug,expression,expression,text,compiled,code,dumped,to,dump,location,f,new,file,dump,location,file,output,stream,fos,new,file,output,stream,f,fos,write,bytecode,fos,flush,fos,close,catch,ioexception,ex,throw,new,illegal,state,exception,unexpected,problem,dumping,class,name,to,use,into,dump,location,ex
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1405514506;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1410558554;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1412004673;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1412630983;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1413486529;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1425759378;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1448383082;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1467730834;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1468948866;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1493317916;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static SpelCompiler getCompiler(ClassLoader classLoader);1495868221;Factory method for compiler instances. The returned SpelCompiler will_attach a class loader as the child of the given class loader and this_child will be used to load compiled expressions._@param classLoader the ClassLoader to use as the basis for compilation_@return a corresponding SpelCompiler instance;public static SpelCompiler getCompiler(ClassLoader classLoader) {_		ClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader())__		synchronized (compilers) {_			SpelCompiler compiler = compilers.get(clToUse)__			if (compiler == null) {_				compiler = new SpelCompiler(clToUse)__				compilers.put(clToUse, compiler)__			}_			return compiler__		}_	};factory,method,for,compiler,instances,the,returned,spel,compiler,will,attach,a,class,loader,as,the,child,of,the,given,class,loader,and,this,child,will,be,used,to,load,compiled,expressions,param,class,loader,the,class,loader,to,use,as,the,basis,for,compilation,return,a,corresponding,spel,compiler,instance;public,static,spel,compiler,get,compiler,class,loader,class,loader,class,loader,cl,to,use,class,loader,null,class,loader,class,utils,get,default,class,loader,synchronized,compilers,spel,compiler,compiler,compilers,get,cl,to,use,if,compiler,null,compiler,new,spel,compiler,cl,to,use,compilers,put,cl,to,use,compiler,return,compiler
SpelCompiler -> public static void revertToInterpreted(Expression expression);1405011154;Request to revert to the interpreter for expression evaluation. Any compiled form_is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			SpelExpression spelExpression = (SpelExpression)expression__			spelExpression.revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,spel,expression,spel,expression,expression,spel,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1405514506;Request to revert to the interpreter for expression evaluation. Any compiled form_is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1410558554;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1412004673;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1412630983;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1413486529;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1425759378;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1448383082;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1467730834;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1468948866;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1493317916;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1495868221;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1496837955;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1498496357;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1500332081;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1520528267;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1530174524;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1530174524;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static void revertToInterpreted(Expression expression);1537186939;Request to revert to the interpreter for expression evaluation._Any compiled form is discarded but can be recreated by later recompiling again._@param expression the expression;public static void revertToInterpreted(Expression expression) {_		if (expression instanceof SpelExpression) {_			((SpelExpression) expression).revertToInterpreted()__		}_	};request,to,revert,to,the,interpreter,for,expression,evaluation,any,compiled,form,is,discarded,but,can,be,recreated,by,later,recompiling,again,param,expression,the,expression;public,static,void,revert,to,interpreted,expression,expression,if,expression,instanceof,spel,expression,spel,expression,expression,revert,to,interpreted
SpelCompiler -> public static boolean compile(Expression expression);1405011154;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		if (expression instanceof SpelExpression) {_			SpelExpression spelExpression = (SpelExpression)expression__			return spelExpression.compileExpression()__		}_		return false__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,if,expression,instanceof,spel,expression,spel,expression,spel,expression,spel,expression,expression,return,spel,expression,compile,expression,return,false
SpelCompiler -> public static boolean compile(Expression expression);1405514506;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1410558554;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1412004673;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1412630983;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1413486529;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1425759378;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1448383082;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1467730834;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1468948866;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1493317916;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1495868221;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1496837955;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1498496357;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1500332081;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1520528267;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1530174524;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1530174524;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public static boolean compile(Expression expression);1537186939;Request that an attempt is made to compile the specified expression. It may fail if_components of the expression are not suitable for compilation or the data types_involved are not suitable for compilation. Used for testing._@return true if the expression was successfully compiled;public static boolean compile(Expression expression) {_		return (expression instanceof SpelExpression && ((SpelExpression) expression).compileExpression())__	};request,that,an,attempt,is,made,to,compile,the,specified,expression,it,may,fail,if,components,of,the,expression,are,not,suitable,for,compilation,or,the,data,types,involved,are,not,suitable,for,compilation,used,for,testing,return,true,if,the,expression,was,successfully,compiled;public,static,boolean,compile,expression,expression,return,expression,instanceof,spel,expression,spel,expression,expression,compile,expression
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1405011154;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (verbose) {_				System.out.println("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			try {_				CompiledExpression instance = clazz.newInstance()__				return instance__			}_			catch (InstantiationException ie) {_				ie.printStackTrace()__			}_			catch (IllegalAccessException iae) {_				iae.printStackTrace()__			}_		}_		else {_			if (verbose) {_				System.out.println("SpEL: unable to compile " + expression.toStringAST())__			}_		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,verbose,system,out,println,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,try,compiled,expression,instance,clazz,new,instance,return,instance,catch,instantiation,exception,ie,ie,print,stack,trace,catch,illegal,access,exception,iae,iae,print,stack,trace,else,if,verbose,system,out,println,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1405514506;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			try {_				return clazz.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__			}_		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: unable to compile " + expression.toStringAST())__			}_		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,try,return,clazz,new,instance,catch,exception,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,else,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1410558554;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			try {_				return clazz.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__			}_		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: unable to compile " + expression.toStringAST())__			}_		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,try,return,clazz,new,instance,catch,exception,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,else,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1412004673;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return clazz.newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1412630983;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return clazz.newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1413486529;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return clazz.newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1425759378;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return clazz.newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1448383082;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return clazz.newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1467730834;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return clazz.newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1468948866;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> public CompiledExpression compile(SpelNodeImpl expression);1493317916;Attempt compilation of the supplied expression. A check is_made to see if it is compilable before compilation proceeds. The_check involves visiting all the nodes in the expression Ast and_ensuring enough state is known about them that bytecode can_be generated for them._@param expression the expression to compile_@return an instance of the class implementing the compiled expression, or null_if compilation is not possible;public CompiledExpression compile(SpelNodeImpl expression) {_		if (expression.isCompilable()) {_			if (logger.isDebugEnabled()) {_				logger.debug("SpEL: compiling " + expression.toStringAST())__			}_			Class<? extends CompiledExpression> clazz = createExpressionClass(expression)__			if (clazz != null) {_				try {_					return ReflectionUtils.accessibleConstructor(clazz).newInstance()__				}_				catch (Throwable ex) {_					throw new IllegalStateException("Failed to instantiate CompiledExpression", ex)__				}_			}_		}__		if (logger.isDebugEnabled()) {_			logger.debug("SpEL: unable to compile " + expression.toStringAST())__		}_		return null__	};attempt,compilation,of,the,supplied,expression,a,check,is,made,to,see,if,it,is,compilable,before,compilation,proceeds,the,check,involves,visiting,all,the,nodes,in,the,expression,ast,and,ensuring,enough,state,is,known,about,them,that,bytecode,can,be,generated,for,them,param,expression,the,expression,to,compile,return,an,instance,of,the,class,implementing,the,compiled,expression,or,null,if,compilation,is,not,possible;public,compiled,expression,compile,spel,node,impl,expression,if,expression,is,compilable,if,logger,is,debug,enabled,logger,debug,sp,el,compiling,expression,to,string,ast,class,extends,compiled,expression,clazz,create,expression,class,expression,if,clazz,null,try,return,reflection,utils,accessible,constructor,clazz,new,instance,catch,throwable,ex,throw,new,illegal,state,exception,failed,to,instantiate,compiled,expression,ex,if,logger,is,debug,enabled,logger,debug,sp,el,unable,to,compile,expression,to,string,ast,return,null
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1493317916;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected.__@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1495868221;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected.__@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1496837955;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected.__@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1498496357;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected._@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1500332081;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected._@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1520528267;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected._@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1530174524;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected._@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1530174524;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected._@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @SuppressWarnings("unchecked") 	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes);1537186939;Load a compiled expression class. Makes sure the classloaders aren't used too much_because they anchor compiled classes in memory and prevent GC.  If you have expressions_continually recompiling over time then by replacing the classloader periodically_at least some of the older variants can be garbage collected._@param name name of the class_@param bytes bytecode for the class_@return the Class object for the compiled expression;@SuppressWarnings("unchecked")_	private Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {_		if (this.ccl.getClassesDefinedCount() > CLASSES_DEFINED_LIMIT) {_			this.ccl = new ChildClassLoader(this.ccl.getParent())__		}_		return (Class<? extends CompiledExpression>) this.ccl.defineClass(name, bytes)__	};load,a,compiled,expression,class,makes,sure,the,classloaders,aren,t,used,too,much,because,they,anchor,compiled,classes,in,memory,and,prevent,gc,if,you,have,expressions,continually,recompiling,over,time,then,by,replacing,the,classloader,periodically,at,least,some,of,the,older,variants,can,be,garbage,collected,param,name,name,of,the,class,param,bytes,bytecode,for,the,class,return,the,class,object,for,the,compiled,expression;suppress,warnings,unchecked,private,class,extends,compiled,expression,load,class,string,name,byte,bytes,if,this,ccl,get,classes,defined,count,this,ccl,new,child,class,loader,this,ccl,get,parent,return,class,extends,compiled,expression,this,ccl,define,class,name,bytes
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1495868221;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1496837955;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1498496357;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1500332081;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1520528267;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1530174524;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1530174524;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String clazzName = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, clazzName, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(clazzName, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(clazzName.replaceAll("/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,clazz,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,clazz,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,clazz,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,clazz,name,replace,all,data
SpelCompiler -> @Nullable 	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile);1537186939;Generate the class that encapsulates the compiled expression and define it._The  generated class will be a subtype of CompiledExpression._@param expressionToCompile the expression to be compiled_@return the expression call, or {@code null} if the decision was to opt out of_compilation during code generation;@Nullable_	private Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {_		_		String className = "spel/Ex" + getNextSuffix()__		ClassWriter cw = new ExpressionClassWriter()__		cw.visit(V1_5, ACC_PUBLIC, className, null, "org/springframework/expression/spel/CompiledExpression", null)___		_		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null)__		mv.visitCode()__		mv.visitVarInsn(ALOAD, 0)__		mv.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",_				"<init>", "()V", false)__		mv.visitInsn(RETURN)__		mv.visitMaxs(1, 1)__		mv.visitEnd()___		_		mv = cw.visitMethod(ACC_PUBLIC, "getValue",_				"(Ljava/lang/Object_Lorg/springframework/expression/EvaluationContext_)Ljava/lang/Object_", null,_				new String[ ]{"org/springframework/expression/EvaluationException"})__		mv.visitCode()___		CodeFlow cf = new CodeFlow(className, cw)___		_		try {_			expressionToCompile.generateCode(mv, cf)__		}_		catch (IllegalStateException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug(expressionToCompile.getClass().getSimpleName() +_						".generateCode opted out of compilation: " + ex.getMessage())__			}_			return null__		}__		CodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor())__		if ("V".equals(cf.lastDescriptor())) {_			mv.visitInsn(ACONST_NULL)__		}_		mv.visitInsn(ARETURN)___		mv.visitMaxs(0, 0)_  _		mv.visitEnd()__		cw.visitEnd()___		cf.finish()___		byte[] data = cw.toByteArray()__		_		_		return loadClass(StringUtils.replace(className, "/", "."), data)__	};generate,the,class,that,encapsulates,the,compiled,expression,and,define,it,the,generated,class,will,be,a,subtype,of,compiled,expression,param,expression,to,compile,the,expression,to,be,compiled,return,the,expression,call,or,code,null,if,the,decision,was,to,opt,out,of,compilation,during,code,generation;nullable,private,class,extends,compiled,expression,create,expression,class,spel,node,impl,expression,to,compile,string,class,name,spel,ex,get,next,suffix,class,writer,cw,new,expression,class,writer,cw,visit,class,name,null,org,springframework,expression,spel,compiled,expression,null,method,visitor,mv,cw,visit,method,init,v,null,null,mv,visit,code,mv,visit,var,insn,aload,0,mv,visit,method,insn,invokespecial,org,springframework,expression,spel,compiled,expression,init,v,false,mv,visit,insn,return,mv,visit,maxs,1,1,mv,visit,end,mv,cw,visit,method,get,value,ljava,lang,object,lorg,springframework,expression,evaluation,context,ljava,lang,object,null,new,string,org,springframework,expression,evaluation,exception,mv,visit,code,code,flow,cf,new,code,flow,class,name,cw,try,expression,to,compile,generate,code,mv,cf,catch,illegal,state,exception,ex,if,logger,is,debug,enabled,logger,debug,expression,to,compile,get,class,get,simple,name,generate,code,opted,out,of,compilation,ex,get,message,return,null,code,flow,insert,box,if,necessary,mv,cf,last,descriptor,if,v,equals,cf,last,descriptor,mv,visit,insn,mv,visit,insn,areturn,mv,visit,maxs,0,0,mv,visit,end,cw,visit,end,cf,finish,byte,data,cw,to,byte,array,return,load,class,string,utils,replace,class,name,data
