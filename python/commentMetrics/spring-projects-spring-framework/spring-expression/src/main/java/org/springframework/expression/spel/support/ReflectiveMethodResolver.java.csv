# id;timestamp;commentText;codeText;commentWords;codeWords
ReflectiveMethodResolver -> @Override 	@Nullable 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1502974979;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	@Nullable_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				methods.sort((m1, m2) -> {_					int m1pl = m1.getParameterCount()__					int m2pl = m2.getParameterCount()__					_					if (m1pl == m2pl) {_						if (!m1.isVarArgs() && m2.isVarArgs()) {_							return -1__						}_						else if (m1.isVarArgs() && !m2.isVarArgs()) {_							return 1__						}_						else {_							return 0__						}_					}_					return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,nullable,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,methods,sort,m1,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	@Nullable 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1509094364;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	@Nullable_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				methods.sort((m1, m2) -> {_					int m1pl = m1.getParameterCount()__					int m2pl = m2.getParameterCount()__					_					if (m1pl == m2pl) {_						if (!m1.isVarArgs() && m2.isVarArgs()) {_							return -1__						}_						else if (m1.isVarArgs() && !m2.isVarArgs()) {_							return 1__						}_						else {_							return 0__						}_					}_					return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,nullable,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,methods,sort,m1,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	@Nullable 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1519514499;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	@Nullable_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				methods.sort((m1, m2) -> {_					int m1pl = m1.getParameterCount()__					int m2pl = m2.getParameterCount()__					_					if (m1pl == m2pl) {_						if (!m1.isVarArgs() && m2.isVarArgs()) {_							return -1__						}_						else if (m1.isVarArgs() && !m2.isVarArgs()) {_							return 1__						}_						else {_							return 0__						}_					}_					return Integer.compare(m1pl, m2pl)__				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,nullable,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,methods,sort,m1,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,integer,compare,m1pl,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	@Nullable 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1521905437;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	@Nullable_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			ArrayList<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? (ArrayList<Method>) filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				methods.sort((m1, m2) -> {_					int m1pl = m1.getParameterCount()__					int m2pl = m2.getParameterCount()__					_					if (m1pl == m2pl) {_						if (!m1.isVarArgs() && m2.isVarArgs()) {_							return -1__						}_						else if (m1.isVarArgs() && !m2.isVarArgs()) {_							return 1__						}_						else {_							return 0__						}_					}_					return Integer.compare(m1pl, m2pl)__				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,nullable,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,array,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,array,list,method,filtered,new,array,list,filtered,if,methods,size,1,methods,sort,m1,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,integer,compare,m1pl,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1328020251;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			Method[] methods = type.getMethods()__			_			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_			    List<Method> methodsForFiltering = new ArrayList<Method>()__			    for (Method method: methods) {_			    	methodsForFiltering.add(method)__			    }_				List<Method> methodsFiltered = filter.filter(methodsForFiltering)__				if (CollectionUtils.isEmpty(methodsFiltered)) {_					methods = NO_METHODS__				}_				else {_					methods = methodsFiltered.toArray(new Method[methodsFiltered.size()])__				}_			}__			Arrays.sort(methods, new Comparator<Method>() {_				public int compare(Method m1, Method m2) {_					int m1pl = m1.getParameterTypes().length__					int m2pl = m2.getParameterTypes().length__					return (new Integer(m1pl)).compareTo(m2pl)__				}_			})___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.isBridge()) {_					continue__				}_				if (method.getName().equals(name)) {_					Class[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,method,methods,type,get,methods,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,methods,for,filtering,new,array,list,method,for,method,method,methods,methods,for,filtering,add,method,list,method,methods,filtered,filter,filter,methods,for,filtering,if,collection,utils,is,empty,methods,filtered,methods,else,methods,methods,filtered,to,array,new,method,methods,filtered,size,arrays,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,is,bridge,continue,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1329142650;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			Method[] methods = getMethods(type)___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> methodsForFiltering = new ArrayList<Method>()__				for (Method method: methods) {_					methodsForFiltering.add(method)__				}_				List<Method> methodsFiltered = filter.filter(methodsForFiltering)__				if (CollectionUtils.isEmpty(methodsFiltered)) {_					methods = NO_METHODS__				}_				else {_					methods = methodsFiltered.toArray(new Method[methodsFiltered.size()])__				}_			}__			Arrays.sort(methods, new Comparator<Method>() {_				public int compare(Method m1, Method m2) {_					int m1pl = m1.getParameterTypes().length__					int m2pl = m2.getParameterTypes().length__					return (new Integer(m1pl)).compareTo(m2pl)__				}_			})___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.isBridge()) {_					continue__				}_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,method,methods,get,methods,type,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,methods,for,filtering,new,array,list,method,for,method,method,methods,methods,for,filtering,add,method,list,method,methods,filtered,filter,filter,methods,for,filtering,if,collection,utils,is,empty,methods,filtered,methods,else,methods,methods,filtered,to,array,new,method,methods,filtered,size,arrays,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,is,bridge,continue,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1350072056;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			Method[] methods = getMethods(type, targetObject)___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> methodsForFiltering = new ArrayList<Method>()__				for (Method method: methods) {_					methodsForFiltering.add(method)__				}_				List<Method> methodsFiltered = filter.filter(methodsForFiltering)__				if (CollectionUtils.isEmpty(methodsFiltered)) {_					methods = NO_METHODS__				}_				else {_					methods = methodsFiltered.toArray(new Method[methodsFiltered.size()])__				}_			}__			Arrays.sort(methods, new Comparator<Method>() {_				public int compare(Method m1, Method m2) {_					int m1pl = m1.getParameterTypes().length__					int m2pl = m2.getParameterTypes().length__					return (new Integer(m1pl)).compareTo(m2pl)__				}_			})___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.isBridge()) {_					continue__				}_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,method,methods,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,methods,for,filtering,new,array,list,method,for,method,method,methods,methods,for,filtering,add,method,list,method,methods,filtered,filter,filter,methods,for,filtering,if,collection,utils,is,empty,methods,filtered,methods,else,methods,methods,filtered,to,array,new,method,methods,filtered,size,arrays,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,is,bridge,continue,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1357119239;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			Method[] methods = getMethods(type, targetObject)___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> methodsForFiltering = new ArrayList<Method>()__				for (Method method: methods) {_					methodsForFiltering.add(method)__				}_				List<Method> methodsFiltered = filter.filter(methodsForFiltering)__				if (CollectionUtils.isEmpty(methodsFiltered)) {_					methods = NO_METHODS__				}_				else {_					methods = methodsFiltered.toArray(new Method[methodsFiltered.size()])__				}_			}__			Arrays.sort(methods, new Comparator<Method>() {_				public int compare(Method m1, Method m2) {_					int m1pl = m1.getParameterTypes().length__					int m2pl = m2.getParameterTypes().length__					return (new Integer(m1pl)).compareTo(m2pl)__				}_			})___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.isBridge()) {_					continue__				}_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,method,methods,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,methods,for,filtering,new,array,list,method,for,method,method,methods,methods,for,filtering,add,method,list,method,methods,filtered,filter,filter,methods,for,filtering,if,collection,utils,is,empty,methods,filtered,methods,else,methods,methods,filtered,to,array,new,method,methods,filtered,size,arrays,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,is,bridge,continue,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1362408075;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				methods = filter.filter(methods)__			}__			_			Collections.sort(methods, new Comparator<Method>() {_				public int compare(Method m1, Method m2) {_					int m1pl = m1.getParameterTypes().length__					int m2pl = m2.getParameterTypes().length__					return (new Integer(m1pl)).compareTo(m2pl)__				}_			})___			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			methods = new ArrayList<Method>(new LinkedHashSet<Method>(methods))___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,methods,filter,filter,methods,collections,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,methods,new,array,list,method,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1365871149;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				methods = filter.filter(methods)__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			methods = new ArrayList<Method>(new LinkedHashSet<Method>(methods))___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,methods,filter,filter,methods,if,methods,size,1,collections,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,methods,new,array,list,method,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1367956577;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!this.useDistance) {_								closeMatch = method__							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,this,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1328020251;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1329142650;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1350072056;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1356735495;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1357119239;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1362408075;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1365871149;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1367956577;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1368482696;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1372363092;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1389789410;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1389796100;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches).  Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1390507193;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches). Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1413907042;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches). Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1414498942;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches). Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1417644204;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches). Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1419930256;This constructors allows the ReflectiveMethodResolver to be configured such that it will_use a distance computation to check which is the better of two close matches (when there_are multiple matches). Using the distance computation is intended to ensure matches_are more closely representative of what a Java compiler would do when taking into_account boxing/unboxing and whether the method candidates are declared to handle a_supertype of the type (of the argument) being passed in._@param useDistance true if distance computation should be used when calculating matches;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructors,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,true,if,distance,computation,should,be,used,when,calculating,matches;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1426108143;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1454934182;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1467730834;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1467846264;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1496837955;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1497341397;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1498780456;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1502974979;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1509094364;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1519514499;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> public ReflectiveMethodResolver(boolean useDistance);1521905437;This constructor allows the ReflectiveMethodResolver to be configured such that it_will use a distance computation to check which is the better of two close matches_(when there are multiple matches). Using the distance computation is intended to_ensure matches are more closely representative of what a Java compiler would do_when taking into account boxing/unboxing and whether the method candidates are_declared to handle a supertype of the type (of the argument) being passed in._@param useDistance {@code true} if distance computation should be used when_calculating matches_ {@code false} otherwise;public ReflectiveMethodResolver(boolean useDistance) {_		this.useDistance = useDistance__	};this,constructor,allows,the,reflective,method,resolver,to,be,configured,such,that,it,will,use,a,distance,computation,to,check,which,is,the,better,of,two,close,matches,when,there,are,multiple,matches,using,the,distance,computation,is,intended,to,ensure,matches,are,more,closely,representative,of,what,a,java,compiler,would,do,when,taking,into,account,boxing,unboxing,and,whether,the,method,candidates,are,declared,to,handle,a,supertype,of,the,type,of,the,argument,being,passed,in,param,use,distance,code,true,if,distance,computation,should,be,used,when,calculating,matches,code,false,otherwise;public,reflective,method,resolver,boolean,use,distance,this,use,distance,use,distance
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1356735495;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			Method[] methods = getMethods(type, targetObject)___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> methodsForFiltering = new ArrayList<Method>()__				for (Method method: methods) {_					methodsForFiltering.add(method)__				}_				List<Method> methodsFiltered = filter.filter(methodsForFiltering)__				if (CollectionUtils.isEmpty(methodsFiltered)) {_					methods = NO_METHODS__				}_				else {_					methods = methodsFiltered.toArray(new Method[methodsFiltered.size()])__				}_			}__			Arrays.sort(methods, new Comparator<Method>() {_				@Override_				public int compare(Method m1, Method m2) {_					int m1pl = m1.getParameterTypes().length__					int m2pl = m2.getParameterTypes().length__					return (new Integer(m1pl)).compareTo(m2pl)__				}_			})___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methods) {_				if (method.isBridge()) {_					continue__				}_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!useDistance) {_								closeMatch = method__							} else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,method,methods,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,methods,for,filtering,new,array,list,method,for,method,method,methods,methods,for,filtering,add,method,list,method,methods,filtered,filter,filter,methods,for,filtering,if,collection,utils,is,empty,methods,filtered,methods,else,methods,methods,filtered,to,array,new,method,methods,filtered,size,arrays,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,if,method,is,bridge,continue,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1368482696;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!this.useDistance) {_								closeMatch = method__							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,this,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1372363092;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method, null)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!this.useDistance) {_								closeMatch = method__							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance<closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							argsToConvert = matchInfo.argsRequiringConversion__							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch, null)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion, argsToConvert)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,null,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,this,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,args,to,convert,match,info,args,requiring,conversion,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,null,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,args,to,convert,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1389789410;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			int[] argsToConvert = null__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {_							if (!this.useDistance) {_								closeMatch = method__							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,int,args,to,convert,null,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,kind,reflection,helper,args,match,kind,exact,return,new,reflective,method,executor,method,else,if,match,info,kind,reflection,helper,args,match,kind,close,if,this,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,kind,reflection,helper,args,match,kind,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1389796100;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (!this.useDistance) {_								closeMatch = method__							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1390507193;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (!this.useDistance) {_								closeMatch = method__							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1413907042;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (new Integer(m1pl)).compareTo(m2pl)__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (!this.useDistance) {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,new,integer,m1pl,compare,to,m2pl,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,if,close,match,null,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1414498942;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (!this.useDistance) {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,arrays,as,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,if,close,match,null,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1417644204;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>An exact match where the types of the arguments match the types of the constructor_<li>An in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>A match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter._</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>((getMethods(type, targetObject)))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (!this.useDistance) {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,if,close,match,null,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1419930256;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (!this.useDistance) {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_							else {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (matchDistance < closeMatchDistance) {_									_									closeMatchDistance = matchDistance__									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,if,close,match,null,close,match,method,else,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,match,distance,close,match,distance,close,match,distance,match,distance,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1426108143;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1454934182;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<Method>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<Method>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<Method>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,method,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,method,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,method,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,type,descriptor,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1467730834;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterTypes().length__						int m2pl = m2.getParameterTypes().length__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,types,length,int,m2pl,m2,get,parameter,types,length,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1467846264;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterCount()__						int m2pl = m2.getParameterCount()__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1496837955;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				Collections.sort(methods, new Comparator<Method>() {_					@Override_					public int compare(Method m1, Method m2) {_						int m1pl = m1.getParameterCount()__						int m2pl = m2.getParameterCount()__						_						if (m1pl == m2pl) {_						    if (!m1.isVarArgs() && m2.isVarArgs()) {_						    	return -1__						    }_						    else if (m1.isVarArgs() && !m2.isVarArgs()) {_						    	return 1__						    }_						    else {_						    	return 0__						    }_						}_						return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__					}_				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,collections,sort,methods,new,comparator,method,override,public,int,compare,method,m1,method,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1497341397;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				methods.sort((m1, m2) -> {_					int m1pl = m1.getParameterCount()__					int m2pl = m2.getParameterCount()__					_					if (m1pl == m2pl) {_						if (!m1.isVarArgs() && m2.isVarArgs()) {_							return -1__						}_						else if (m1.isVarArgs() && !m2.isVarArgs()) {_							return 1__						}_						else {_							return 0__						}_					}_					return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,methods,sort,m1,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> @Override 	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List<TypeDescriptor> argumentTypes) throws AccessException;1498780456;Locate a method on a type. There are three kinds of match that might occur:_<ol>_<li>an exact match where the types of the arguments match the types of the constructor_<li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor_<li>a match where we are able to convert the arguments into those expected by the constructor,_according to the registered type converter_</ol>;@Override_	public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,_			List<TypeDescriptor> argumentTypes) throws AccessException {__		try {_			TypeConverter typeConverter = context.getTypeConverter()__			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass())__			List<Method> methods = new ArrayList<>(getMethods(type, targetObject))___			_			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null)__			if (filter != null) {_				List<Method> filtered = filter.filter(methods)__				methods = (filtered instanceof ArrayList ? filtered : new ArrayList<>(filtered))__			}__			_			if (methods.size() > 1) {_				methods.sort((m1, m2) -> {_					int m1pl = m1.getParameterCount()__					int m2pl = m2.getParameterCount()__					_					if (m1pl == m2pl) {_						if (!m1.isVarArgs() && m2.isVarArgs()) {_							return -1__						}_						else if (m1.isVarArgs() && !m2.isVarArgs()) {_							return 1__						}_						else {_							return 0__						}_					}_					return (m1pl < m2pl ? -1 : (m1pl > m2pl ? 1 : 0))__				})__			}__			_			for (int i = 0_ i < methods.size()_ i++) {_				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)))__			}__			_			Set<Method> methodsToIterate = new LinkedHashSet<>(methods)___			Method closeMatch = null__			int closeMatchDistance = Integer.MAX_VALUE__			Method matchRequiringConversion = null__			boolean multipleOptions = false___			for (Method method : methodsToIterate) {_				if (method.getName().equals(name)) {_					Class<?>[] paramTypes = method.getParameterTypes()__					List<TypeDescriptor> paramDescriptors = new ArrayList<>(paramTypes.length)__					for (int i = 0_ i < paramTypes.length_ i++) {_						paramDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)))__					}_					ReflectionHelper.ArgumentsMatchInfo matchInfo = null__					if (method.isVarArgs() && argumentTypes.size() >= (paramTypes.length - 1)) {_						_						matchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter)__					}_					else if (paramTypes.length == argumentTypes.size()) {_						_						matchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter)__					}_					if (matchInfo != null) {_						if (matchInfo.isExactMatch()) {_							return new ReflectiveMethodExecutor(method)__						}_						else if (matchInfo.isCloseMatch()) {_							if (this.useDistance) {_								int matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes)__								if (closeMatch == null || matchDistance < closeMatchDistance) {_									_									closeMatch = method__									closeMatchDistance = matchDistance__								}_							}_							else {_								_								if (closeMatch == null) {_									closeMatch = method__								}_							}_						}_						else if (matchInfo.isMatchRequiringConversion()) {_							if (matchRequiringConversion != null) {_								multipleOptions = true__							}_							matchRequiringConversion = method__						}_					}_				}_			}_			if (closeMatch != null) {_				return new ReflectiveMethodExecutor(closeMatch)__			}_			else if (matchRequiringConversion != null) {_				if (multipleOptions) {_					throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name)__				}_				return new ReflectiveMethodExecutor(matchRequiringConversion)__			}_			else {_				return null__			}_		}_		catch (EvaluationException ex) {_			throw new AccessException("Failed to resolve method", ex)__		}_	};locate,a,method,on,a,type,there,are,three,kinds,of,match,that,might,occur,ol,li,an,exact,match,where,the,types,of,the,arguments,match,the,types,of,the,constructor,li,an,in,exact,match,where,the,types,we,are,looking,for,are,subtypes,of,those,defined,on,the,constructor,li,a,match,where,we,are,able,to,convert,the,arguments,into,those,expected,by,the,constructor,according,to,the,registered,type,converter,ol;override,public,method,executor,resolve,evaluation,context,context,object,target,object,string,name,list,type,descriptor,argument,types,throws,access,exception,try,type,converter,type,converter,context,get,type,converter,class,type,target,object,instanceof,class,class,target,object,target,object,get,class,list,method,methods,new,array,list,get,methods,type,target,object,method,filter,filter,this,filters,null,this,filters,get,type,null,if,filter,null,list,method,filtered,filter,filter,methods,methods,filtered,instanceof,array,list,filtered,new,array,list,filtered,if,methods,size,1,methods,sort,m1,m2,int,m1pl,m1,get,parameter,count,int,m2pl,m2,get,parameter,count,if,m1pl,m2pl,if,m1,is,var,args,m2,is,var,args,return,1,else,if,m1,is,var,args,m2,is,var,args,return,1,else,return,0,return,m1pl,m2pl,1,m1pl,m2pl,1,0,for,int,i,0,i,methods,size,i,methods,set,i,bridge,method,resolver,find,bridged,method,methods,get,i,set,method,methods,to,iterate,new,linked,hash,set,methods,method,close,match,null,int,close,match,distance,integer,method,match,requiring,conversion,null,boolean,multiple,options,false,for,method,method,methods,to,iterate,if,method,get,name,equals,name,class,param,types,method,get,parameter,types,list,type,descriptor,param,descriptors,new,array,list,param,types,length,for,int,i,0,i,param,types,length,i,param,descriptors,add,new,type,descriptor,new,method,parameter,method,i,reflection,helper,arguments,match,info,match,info,null,if,method,is,var,args,argument,types,size,param,types,length,1,match,info,reflection,helper,compare,arguments,varargs,param,descriptors,argument,types,type,converter,else,if,param,types,length,argument,types,size,match,info,reflection,helper,compare,arguments,param,descriptors,argument,types,type,converter,if,match,info,null,if,match,info,is,exact,match,return,new,reflective,method,executor,method,else,if,match,info,is,close,match,if,this,use,distance,int,match,distance,reflection,helper,get,type,difference,weight,param,descriptors,argument,types,if,close,match,null,match,distance,close,match,distance,close,match,method,close,match,distance,match,distance,else,if,close,match,null,close,match,method,else,if,match,info,is,match,requiring,conversion,if,match,requiring,conversion,null,multiple,options,true,match,requiring,conversion,method,if,close,match,null,return,new,reflective,method,executor,close,match,else,if,match,requiring,conversion,null,if,multiple,options,throw,new,spel,evaluation,exception,spel,message,name,return,new,reflective,method,executor,match,requiring,conversion,else,return,null,catch,evaluation,exception,ex,throw,new,access,exception,failed,to,resolve,method,ex
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1329142650;Return the set of methods for this type. The default implementation returns the_result of Class#getMethods for the given {@code type}, but subclasses may override_in order to alter the results, e.g. specifying static methods declared elsewhere.__@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1350072056;Return the set of methods for this type. The default implementation returns the_result of Class#getMethods for the given {@code type}, but subclasses may override_in order to alter the results, e.g. specifying static methods declared elsewhere.__@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1356735495;Return the set of methods for this type. The default implementation returns the_result of Class#getMethods for the given {@code type}, but subclasses may override_in order to alter the results, e.g. specifying static methods declared elsewhere.__@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1357119239;Return the set of methods for this type. The default implementation returns the_result of Class#getMethods for the given {@code type}, but subclasses may override_in order to alter the results, e.g. specifying static methods declared elsewhere.__@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1362408075;Return the set of methods for this type. The default implementation returns the_result of Class#getMethods for the given {@code type}, but subclasses may override_in order to alter the results, e.g. specifying static methods declared elsewhere.__@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1365871149;Return the set of methods for this type. The default implementation returns the_result of Class#getMethods for the given {@code type}, but subclasses may override_in order to alter the results, e.g. specifying static methods declared elsewhere.__@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1367956577;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1368482696;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1372363092;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1389789410;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1389796100;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1390507193;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1413907042;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1414498942;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1417644204;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1419930256;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1426108143;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1454934182;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1467730834;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1467846264;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1496837955;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1497341397;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1498780456;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1502974979;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1509094364;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1519514499;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
ReflectiveMethodResolver -> protected Method[] getMethods(Class<?> type);1521905437;Return the set of methods for this type. The default implementation returns the_result of {@link Class#getMethods()} for the given {@code type}, but subclasses_may override in order to alter the results, e.g. specifying static methods_declared elsewhere._@param type the class for which to return the methods_@since 3.1.1;protected Method[] getMethods(Class<?> type) {_		return type.getMethods()__	};return,the,set,of,methods,for,this,type,the,default,implementation,returns,the,result,of,link,class,get,methods,for,the,given,code,type,but,subclasses,may,override,in,order,to,alter,the,results,e,g,specifying,static,methods,declared,elsewhere,param,type,the,class,for,which,to,return,the,methods,since,3,1,1;protected,method,get,methods,class,type,return,type,get,methods
