commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the specified root object, if any.  */ ;/**  * Return the specified root object, if any.  */ @Override public TypedValue getRootObject() {     return this.rootObject. }
true;public;0;4;/**  * Return the specified {@link PropertyAccessor} delegates, if any.  * @see #forPropertyAccessors  */ ;/**  * Return the specified {@link PropertyAccessor} delegates, if any.  * @see #forPropertyAccessors  */ @Override public List<PropertyAccessor> getPropertyAccessors() {     return this.propertyAccessors. }
true;public;0;4;/**  * Return an empty list, always, since this context does not support the  * use of type references.  */ ;/**  * Return an empty list, always, since this context does not support the  * use of type references.  */ @Override public List<ConstructorResolver> getConstructorResolvers() {     return Collections.emptyList(). }
true;public;0;4;/**  * Return the specified {@link MethodResolver} delegates, if any.  * @see Builder#withMethodResolvers  */ ;/**  * Return the specified {@link MethodResolver} delegates, if any.  * @see Builder#withMethodResolvers  */ @Override public List<MethodResolver> getMethodResolvers() {     return this.methodResolvers. }
true;public;0;5;/**  * {@code SimpleEvaluationContext} does not support the use of bean references.  * @return always {@code null}  */ ;/**  * {@code SimpleEvaluationContext} does not support the use of bean references.  * @return always {@code null}  */ @Override @Nullable public BeanResolver getBeanResolver() {     return null. }
true;public;0;4;/**  * {@code SimpleEvaluationContext} does not support use of type references.  * @return {@code TypeLocator} implementation that raises a  * {@link SpelEvaluationException} with {@link SpelMessage#TYPE_NOT_FOUND}.  */ ;/**  * {@code SimpleEvaluationContext} does not support use of type references.  * @return {@code TypeLocator} implementation that raises a  * {@link SpelEvaluationException} with {@link SpelMessage#TYPE_NOT_FOUND}.  */ @Override public TypeLocator getTypeLocator() {     return typeNotFoundTypeLocator. }
true;public;0;4;/**  * The configured {@link TypeConverter}.  * <p>By default this is {@link StandardTypeConverter}.  * @see Builder#withTypeConverter  * @see Builder#withConversionService  */ ;/**  * The configured {@link TypeConverter}.  * <p>By default this is {@link StandardTypeConverter}.  * @see Builder#withTypeConverter  * @see Builder#withConversionService  */ @Override public TypeConverter getTypeConverter() {     return this.typeConverter. }
true;public;0;4;/**  * Return an instance of {@link StandardTypeComparator}.  */ ;/**  * Return an instance of {@link StandardTypeComparator}.  */ @Override public TypeComparator getTypeComparator() {     return this.typeComparator. }
true;public;0;4;/**  * Return an instance of {@link StandardOperatorOverloader}.  */ ;/**  * Return an instance of {@link StandardOperatorOverloader}.  */ @Override public OperatorOverloader getOperatorOverloader() {     return this.operatorOverloader. }
false;public;2;4;;@Override public void setVariable(String name, @Nullable Object value) {     this.variables.put(name, value). }
false;public;1;5;;@Override @Nullable public Object lookupVariable(String name) {     return this.variables.get(name). }
true;public,static;1;9;/**  * Create a {@code SimpleEvaluationContext} for the specified {@link PropertyAccessor}  * delegates: typically a custom {@code PropertyAccessor} specific to a use case  * (e.g. attribute resolution in a custom data structure), potentially combined with  * a {@link DataBindingPropertyAccessor} if property dereferences are needed as well.  * @param accessors the accessor delegates to use  * @see DataBindingPropertyAccessor#forReadOnlyAccess()  * @see DataBindingPropertyAccessor#forReadWriteAccess()  */ ;/**  * Create a {@code SimpleEvaluationContext} for the specified {@link PropertyAccessor}  * delegates: typically a custom {@code PropertyAccessor} specific to a use case  * (e.g. attribute resolution in a custom data structure), potentially combined with  * a {@link DataBindingPropertyAccessor} if property dereferences are needed as well.  * @param accessors the accessor delegates to use  * @see DataBindingPropertyAccessor#forReadOnlyAccess()  * @see DataBindingPropertyAccessor#forReadWriteAccess()  */ public static Builder forPropertyAccessors(PropertyAccessor... accessors) {     for (PropertyAccessor accessor : accessors) {         if (accessor.getClass() == ReflectivePropertyAccessor.class) {             throw new IllegalArgumentException("SimpleEvaluationContext is not designed for use with a plain " + "ReflectivePropertyAccessor. Consider using DataBindingPropertyAccessor or a custom subclass.").         }     }     return new Builder(accessors). }
true;public,static;0;3;/**  * Create a {@code SimpleEvaluationContext} for read-only access to  * public properties via {@link DataBindingPropertyAccessor}.  * @see DataBindingPropertyAccessor#forReadOnlyAccess()  * @see #forPropertyAccessors  */ ;/**  * Create a {@code SimpleEvaluationContext} for read-only access to  * public properties via {@link DataBindingPropertyAccessor}.  * @see DataBindingPropertyAccessor#forReadOnlyAccess()  * @see #forPropertyAccessors  */ public static Builder forReadOnlyDataBinding() {     return new Builder(DataBindingPropertyAccessor.forReadOnlyAccess()). }
true;public,static;0;3;/**  * Create a {@code SimpleEvaluationContext} for read-write access to  * public properties via {@link DataBindingPropertyAccessor}.  * @see DataBindingPropertyAccessor#forReadWriteAccess()  * @see #forPropertyAccessors  */ ;/**  * Create a {@code SimpleEvaluationContext} for read-write access to  * public properties via {@link DataBindingPropertyAccessor}.  * @see DataBindingPropertyAccessor#forReadWriteAccess()  * @see #forPropertyAccessors  */ public static Builder forReadWriteDataBinding() {     return new Builder(DataBindingPropertyAccessor.forReadWriteAccess()). }
true;public;1;10;/**  * Register the specified {@link MethodResolver} delegates for  * a combination of property access and method resolution.  * @param resolvers the resolver delegates to use  * @see #withInstanceMethods()  * @see SimpleEvaluationContext#forPropertyAccessors  */ ;/**  * Register the specified {@link MethodResolver} delegates for  * a combination of property access and method resolution.  * @param resolvers the resolver delegates to use  * @see #withInstanceMethods()  * @see SimpleEvaluationContext#forPropertyAccessors  */ public Builder withMethodResolvers(MethodResolver... resolvers) {     for (MethodResolver resolver : resolvers) {         if (resolver.getClass() == ReflectiveMethodResolver.class) {             throw new IllegalArgumentException("SimpleEvaluationContext is not designed for use with a plain " + "ReflectiveMethodResolver. Consider using DataBindingMethodResolver or a custom subclass.").         }     }     this.resolvers = Arrays.asList(resolvers).     return this. }
true;public;0;4;/**  * Register a {@link DataBindingMethodResolver} for instance method invocation purposes  * (i.e. not supporting static methods) in addition to the specified property accessors,  * typically in combination with a {@link DataBindingPropertyAccessor}.  * @see #withMethodResolvers  * @see SimpleEvaluationContext#forReadOnlyDataBinding()  * @see SimpleEvaluationContext#forReadWriteDataBinding()  */ ;/**  * Register a {@link DataBindingMethodResolver} for instance method invocation purposes  * (i.e. not supporting static methods) in addition to the specified property accessors,  * typically in combination with a {@link DataBindingPropertyAccessor}.  * @see #withMethodResolvers  * @see SimpleEvaluationContext#forReadOnlyDataBinding()  * @see SimpleEvaluationContext#forReadWriteDataBinding()  */ public Builder withInstanceMethods() {     this.resolvers = Collections.singletonList(DataBindingMethodResolver.forInstanceMethodInvocation()).     return this. }
true;public;1;4;/**  * Register a custom {@link ConversionService}.  * <p>By default a {@link StandardTypeConverter} backed by a  * {@link org.springframework.core.convert.support.DefaultConversionService} is used.  * @see #withTypeConverter  * @see StandardTypeConverter#StandardTypeConverter(ConversionService)  */ ;/**  * Register a custom {@link ConversionService}.  * <p>By default a {@link StandardTypeConverter} backed by a  * {@link org.springframework.core.convert.support.DefaultConversionService} is used.  * @see #withTypeConverter  * @see StandardTypeConverter#StandardTypeConverter(ConversionService)  */ public Builder withConversionService(ConversionService conversionService) {     this.typeConverter = new StandardTypeConverter(conversionService).     return this. }
true;public;1;4;/**  * Register a custom {@link TypeConverter}.  * <p>By default a {@link StandardTypeConverter} backed by a  * {@link org.springframework.core.convert.support.DefaultConversionService} is used.  * @see #withConversionService  * @see StandardTypeConverter#StandardTypeConverter()  */ ;/**  * Register a custom {@link TypeConverter}.  * <p>By default a {@link StandardTypeConverter} backed by a  * {@link org.springframework.core.convert.support.DefaultConversionService} is used.  * @see #withConversionService  * @see StandardTypeConverter#StandardTypeConverter()  */ public Builder withTypeConverter(TypeConverter converter) {     this.typeConverter = converter.     return this. }
true;public;1;4;/**  * Specify a default root object to resolve against.  * <p>Default is none, expecting an object argument at evaluation time.  * @see org.springframework.expression.Expression#getValue(EvaluationContext)  * @see org.springframework.expression.Expression#getValue(EvaluationContext, Object)  */ ;/**  * Specify a default root object to resolve against.  * <p>Default is none, expecting an object argument at evaluation time.  * @see org.springframework.expression.Expression#getValue(EvaluationContext)  * @see org.springframework.expression.Expression#getValue(EvaluationContext, Object)  */ public Builder withRootObject(Object rootObject) {     this.rootObject = new TypedValue(rootObject).     return this. }
true;public;2;4;/**  * Specify a typed root object to resolve against.  * <p>Default is none, expecting an object argument at evaluation time.  * @see org.springframework.expression.Expression#getValue(EvaluationContext)  * @see org.springframework.expression.Expression#getValue(EvaluationContext, Object)  */ ;/**  * Specify a typed root object to resolve against.  * <p>Default is none, expecting an object argument at evaluation time.  * @see org.springframework.expression.Expression#getValue(EvaluationContext)  * @see org.springframework.expression.Expression#getValue(EvaluationContext, Object)  */ public Builder withTypedRootObject(Object rootObject, TypeDescriptor typeDescriptor) {     this.rootObject = new TypedValue(rootObject, typeDescriptor).     return this. }
false;public;0;3;;public SimpleEvaluationContext build() {     return new SimpleEvaluationContext(this.accessors, this.resolvers, this.typeConverter, this.rootObject). }
