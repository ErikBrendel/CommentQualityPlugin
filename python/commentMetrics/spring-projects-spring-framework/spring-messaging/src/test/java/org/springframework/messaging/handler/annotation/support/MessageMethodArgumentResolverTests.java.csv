commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Before public void setup() throws Exception {     this.method = MessageMethodArgumentResolverTests.class.getDeclaredMethod("handle", Message.class, Message.class, Message.class, Message.class, ErrorMessage.class, Message.class).     this.converter = mock(MessageConverter.class).     this.resolver = new MessageMethodArgumentResolver(this.converter). }
false;public;0;8;;@Test public void resolveWithPayloadTypeAsWildcard() throws Exception {     Message<String> message = MessageBuilder.withPayload("test").build().     MethodParameter parameter = new MethodParameter(this.method, 0).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;8;;@Test public void resolveWithMatchingPayloadType() throws Exception {     Message<Integer> message = MessageBuilder.withPayload(123).build().     MethodParameter parameter = new MethodParameter(this.method, 1).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;8;;@Test public void resolveWithPayloadTypeSubclass() throws Exception {     Message<Integer> message = MessageBuilder.withPayload(123).build().     MethodParameter parameter = new MethodParameter(this.method, 2).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;14;;@Test public void resolveWithConversion() throws Exception {     Message<String> message = MessageBuilder.withPayload("test").build().     MethodParameter parameter = new MethodParameter(this.method, 1).     when(this.converter.fromMessage(message, Integer.class)).thenReturn(4).     @SuppressWarnings("unchecked")     Message<Integer> actual = (Message<Integer>) this.resolver.resolveArgument(parameter, message).     assertNotNull(actual).     assertSame(message.getHeaders(), actual.getHeaders()).     assertEquals(new Integer(4), actual.getPayload()). }
false;public;0;11;;@Test public void resolveWithConversionNoMatchingConverter() throws Exception {     Message<String> message = MessageBuilder.withPayload("test").build().     MethodParameter parameter = new MethodParameter(this.method, 1).     assertTrue(this.resolver.supportsParameter(parameter)).     thrown.expect(MessageConversionException.class).     thrown.expectMessage(Integer.class.getName()).     thrown.expectMessage(String.class.getName()).     this.resolver.resolveArgument(parameter, message). }
false;public;0;12;;@Test public void resolveWithConversionEmptyPayload() throws Exception {     Message<String> message = MessageBuilder.withPayload("").build().     MethodParameter parameter = new MethodParameter(this.method, 1).     assertTrue(this.resolver.supportsParameter(parameter)).     thrown.expect(MessageConversionException.class).     thrown.expectMessage("payload is empty").     thrown.expectMessage(Integer.class.getName()).     thrown.expectMessage(String.class.getName()).     this.resolver.resolveArgument(parameter, message). }
false;public;0;8;;@Test public void resolveWithPayloadTypeUpperBound() throws Exception {     Message<Integer> message = MessageBuilder.withPayload(123).build().     MethodParameter parameter = new MethodParameter(this.method, 3).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;11;;@Test public void resolveWithPayloadTypeOutOfBound() throws Exception {     Message<Locale> message = MessageBuilder.withPayload(Locale.getDefault()).build().     MethodParameter parameter = new MethodParameter(this.method, 3).     assertTrue(this.resolver.supportsParameter(parameter)).     thrown.expect(MessageConversionException.class).     thrown.expectMessage(Number.class.getName()).     thrown.expectMessage(Locale.class.getName()).     this.resolver.resolveArgument(parameter, message). }
false;public;0;8;;@Test public void resolveMessageSubclassMatch() throws Exception {     ErrorMessage message = new ErrorMessage(new UnsupportedOperationException()).     MethodParameter parameter = new MethodParameter(this.method, 4).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;8;;@Test public void resolveWithMessageSubclassAndPayloadWildcard() throws Exception {     ErrorMessage message = new ErrorMessage(new UnsupportedOperationException()).     MethodParameter parameter = new MethodParameter(this.method, 0).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;12;;@Test public void resolveWithWrongMessageType() throws Exception {     UnsupportedOperationException ex = new UnsupportedOperationException().     Message<? extends Throwable> message = new GenericMessage<Throwable>(ex).     MethodParameter parameter = new MethodParameter(this.method, 4).     assertTrue(this.resolver.supportsParameter(parameter)).     thrown.expect(MethodArgumentTypeMismatchException.class).     thrown.expectMessage(ErrorMessage.class.getName()).     thrown.expectMessage(GenericMessage.class.getName()).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;10;;@Test public void resolveWithPayloadTypeAsWildcardAndNoConverter() throws Exception {     this.resolver = new MessageMethodArgumentResolver().     Message<String> message = MessageBuilder.withPayload("test").build().     MethodParameter parameter = new MethodParameter(this.method, 0).     assertTrue(this.resolver.supportsParameter(parameter)).     assertSame(message, this.resolver.resolveArgument(parameter, message)). }
false;public;0;13;;@Test public void resolveWithConversionNeededButNoConverter() throws Exception {     this.resolver = new MessageMethodArgumentResolver().     Message<String> message = MessageBuilder.withPayload("test").build().     MethodParameter parameter = new MethodParameter(this.method, 1).     assertTrue(this.resolver.supportsParameter(parameter)).     thrown.expect(MessageConversionException.class).     thrown.expectMessage(Integer.class.getName()).     thrown.expectMessage(String.class.getName()).     this.resolver.resolveArgument(parameter, message). }
false;public;0;14;;@Test public void resolveWithConversionEmptyPayloadButNoConverter() throws Exception {     this.resolver = new MessageMethodArgumentResolver().     Message<String> message = MessageBuilder.withPayload("").build().     MethodParameter parameter = new MethodParameter(this.method, 1).     assertTrue(this.resolver.supportsParameter(parameter)).     thrown.expect(MessageConversionException.class).     thrown.expectMessage("payload is empty").     thrown.expectMessage(Integer.class.getName()).     thrown.expectMessage(String.class.getName()).     this.resolver.resolveArgument(parameter, message). }
false;public;0;13;;// SPR-16486 @Test public void resolveWithJacksonConverter() throws Exception {     Message<String> inMessage = MessageBuilder.withPayload("{\"foo\":\"bar\"}").build().     MethodParameter parameter = new MethodParameter(this.method, 5).     this.resolver = new MessageMethodArgumentResolver(new MappingJackson2MessageConverter()).     Object actual = this.resolver.resolveArgument(parameter, inMessage).     assertTrue(actual instanceof Message).     Message<?> outMessage = (Message<?>) actual.     assertTrue(outMessage.getPayload() instanceof Foo).     assertEquals("bar", ((Foo) outMessage.getPayload()).getFoo()). }
false;private;6;9;;@SuppressWarnings("unused") private void handle(Message<?> wildcardPayload, Message<Integer> integerPayload, Message<Number> numberPayload, Message<? extends Number> anyNumberPayload, ErrorMessage subClass, Message<Foo> fooPayload) { }
false;public;0;3;;public String getFoo() {     return foo. }
false;public;1;3;;public void setFoo(String foo) {     this.foo = foo. }
