commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Before public void setup() {     List<String> destinationPrefixes = Arrays.asList("/test").     this.messageHandler = new TestMethodMessageHandler().     this.messageHandler.setApplicationContext(new StaticApplicationContext()).     this.messageHandler.setDestinationPrefixes(destinationPrefixes).     this.messageHandler.afterPropertiesSet().     this.testController = new TestController().     this.messageHandler.registerHandler(this.testController). }
false;public;0;4;;@Test(expected = IllegalStateException.class) public void duplicateMapping() {     this.messageHandler.registerHandler(new DuplicateMappingsController()). }
false;public;0;8;;@Test public void registeredMappings() {     Map<String, HandlerMethod> handlerMethods = this.messageHandler.getHandlerMethods().     assertNotNull(handlerMethods).     assertThat(handlerMethods.keySet(), Matchers.hasSize(3)). }
false;public;0;10;;@Test public void antPatchMatchWildcard() throws Exception {     Method method = this.testController.getClass().getMethod("handlerPathMatchWildcard").     this.messageHandler.registerHandlerMethod(this.testController, method, "/handlerPathMatch*").     this.messageHandler.handleMessage(toDestination("/test/handlerPathMatchFoo")).     assertEquals("pathMatchWildcard", this.testController.method). }
false;public;0;13;;@Test public void bestMatchWildcard() throws Exception {     Method method = this.testController.getClass().getMethod("bestMatch").     this.messageHandler.registerHandlerMethod(this.testController, method, "/bestmatch/{foo}/path").     method = this.testController.getClass().getMethod("secondBestMatch").     this.messageHandler.registerHandlerMethod(this.testController, method, "/bestmatch/*/*").     this.messageHandler.handleMessage(toDestination("/test/bestmatch/bar/path")).     assertEquals("bestMatch", this.testController.method). }
false;public;0;8;;@Test public void argumentResolution() {     this.messageHandler.handleMessage(toDestination("/test/handlerArgumentResolver")).     assertEquals("handlerArgumentResolver", this.testController.method).     assertNotNull(this.testController.arguments.get("message")). }
false;public;0;8;;@Test public void exceptionHandled() {     this.messageHandler.handleMessage(toDestination("/test/handlerThrowsExc")).     assertEquals("illegalStateException", this.testController.method).     assertNotNull(this.testController.arguments.get("exception")). }
false;private;1;3;;private Message<?> toDestination(String destination) {     return MessageBuilder.withPayload(new byte[0]).setHeader(DESTINATION_HEADER, destination).build(). }
false;public;0;3;;public void handlerPathMatchWildcard() {     this.method = "pathMatchWildcard". }
false;public;1;5;;@SuppressWarnings("rawtypes") public void handlerArgumentResolver(Message message) {     this.method = "handlerArgumentResolver".     this.arguments.put("message", message). }
false;public;0;3;;public void handlerThrowsExc() {     throw new IllegalStateException(). }
false;public;0;3;;public void bestMatch() {     this.method = "bestMatch". }
false;public;0;3;;public void secondBestMatch() {     this.method = "secondBestMatch". }
false;public;1;4;;public void illegalStateException(IllegalStateException exception) {     this.method = "illegalStateException".     this.arguments.put("exception", exception). }
false;public;0;1;;public void handlerFoo() { }
false;public;1;1;;public void handlerFoo(String arg) { }
false;public;1;3;;public void registerHandler(Object handler) {     super.detectHandlerMethods(handler). }
false;public;3;3;;public void registerHandlerMethod(Object handler, Method method, String mapping) {     super.registerHandlerMethod(handler, method, mapping). }
false;protected;0;7;;@Override protected List<? extends HandlerMethodArgumentResolver> initArgumentResolvers() {     List<HandlerMethodArgumentResolver> resolvers = new ArrayList<>().     resolvers.add(new MessageMethodArgumentResolver(new SimpleMessageConverter())).     resolvers.addAll(getCustomArgumentResolvers()).     return resolvers. }
false;protected;0;6;;@Override protected List<? extends HandlerMethodReturnValueHandler> initReturnValueHandlers() {     List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>().     handlers.addAll(getCustomReturnValueHandlers()).     return handlers. }
false;protected;1;4;;@Override protected boolean isHandler(Class<?> beanType) {     return beanType.getName().contains("Controller"). }
false;protected;2;8;;@Override protected String getMappingForMethod(Method method, Class<?> handlerType) {     String methodName = method.getName().     if (methodName.startsWith("handler")) {         return "/" + methodName.     }     return null. }
false;protected;1;8;;@Override protected Set<String> getDirectLookupDestinations(String mapping) {     Set<String> result = new LinkedHashSet<>().     if (!this.pathMatcher.isPattern(mapping)) {         result.add(mapping).     }     return result. }
false;protected;1;4;;@Override protected String getDestination(Message<?> message) {     return (String) message.getHeaders().get(DESTINATION_HEADER). }
false;protected;2;9;;@Override protected String getMatchingMapping(String mapping, Message<?> message) {     String destination = getLookupDestination(getDestination(message)).     if (mapping.equals(destination) || this.pathMatcher.match(mapping, destination)) {         return mapping.     }     return null. }
false;public;2;6;;@Override public int compare(String info1, String info2) {     DestinationPatternsMessageCondition cond1 = new DestinationPatternsMessageCondition(info1).     DestinationPatternsMessageCondition cond2 = new DestinationPatternsMessageCondition(info2).     return cond1.compareTo(cond2, message). }
false;protected;1;11;;@Override protected Comparator<String> getMappingComparator(final Message<?> message) {     return new Comparator<String>() {          @Override         public int compare(String info1, String info2) {             DestinationPatternsMessageCondition cond1 = new DestinationPatternsMessageCondition(info1).             DestinationPatternsMessageCondition cond2 = new DestinationPatternsMessageCondition(info2).             return cond1.compareTo(cond2, message).         }     }. }
false;protected;1;4;;@Override protected AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(Class<?> beanType) {     return new TestExceptionHandlerMethodResolver(beanType). }
false;private,static;1;9;;private static Map<Class<? extends Throwable>, Method> initExceptionMappings(Class<?> handlerType) {     Map<Class<? extends Throwable>, Method> result = new HashMap<>().     for (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHOD_FILTER)) {         for (Class<? extends Throwable> exception : getExceptionsFromMethodSignature(method)) {             result.put(exception, method).         }     }     return result. }
false;public;1;4;;@Override public boolean matches(Method method) {     return method.getName().contains("Exception"). }
