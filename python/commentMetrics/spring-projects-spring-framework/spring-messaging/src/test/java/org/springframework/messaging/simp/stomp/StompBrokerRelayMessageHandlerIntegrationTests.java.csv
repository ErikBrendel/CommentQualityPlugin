commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Before public void setup() throws Exception {     logger.debug("Setting up before '" + this.testName.getMethodName() + "'").     this.port = SocketUtils.findAvailableTcpPort(61613).     this.responseChannel = new ExecutorSubscribableChannel().     this.responseHandler = new TestMessageHandler().     this.responseChannel.subscribe(this.responseHandler).     this.eventPublisher = new TestEventPublisher().     startActiveMqBroker().     createAndStartRelay(). }
false;private;0;10;;private void startActiveMqBroker() throws Exception {     this.activeMQBroker = new BrokerService().     this.activeMQBroker.addConnector("stomp://localhost:" + this.port).     this.activeMQBroker.setStartAsync(false).     this.activeMQBroker.setPersistent(false).     this.activeMQBroker.setUseJmx(false).     this.activeMQBroker.getSystemUsage().getMemoryUsage().setLimit(1024 * 1024 * 5).     this.activeMQBroker.getSystemUsage().getTempUsage().setLimit(1024 * 1024 * 5).     this.activeMQBroker.start(). }
false;private;0;13;;private void createAndStartRelay() throws InterruptedException {     StubMessageChannel channel = new StubMessageChannel().     List<String> prefixes = Arrays.asList("/queue/", "/topic/").     this.relay = new StompBrokerRelayMessageHandler(channel, this.responseChannel, channel, prefixes).     this.relay.setRelayPort(this.port).     this.relay.setApplicationEventPublisher(this.eventPublisher).     this.relay.setSystemHeartbeatReceiveInterval(0).     this.relay.setSystemHeartbeatSendInterval(0).     this.relay.setPreservePublishOrder(true).     this.relay.start().     this.eventPublisher.expectBrokerAvailabilityEvent(true). }
false;public;0;10;;@After public void stop() throws Exception {     try {         logger.debug("STOMP broker relay stats: " + this.relay.getStatsInfo()).         this.relay.stop().     } finally {         stopActiveMqBrokerAndAwait().     } }
false;public;0;3;;public void run() {     latch.countDown(). }
false;private;0;16;;private void stopActiveMqBrokerAndAwait() throws Exception {     logger.debug("Stopping ActiveMQ broker and will await shutdown").     if (!this.activeMQBroker.isStarted()) {         logger.debug("Broker not running").         return.     }     final CountDownLatch latch = new CountDownLatch(1).     this.activeMQBroker.addShutdownHook(new Runnable() {          public void run() {             latch.countDown().         }     }).     this.activeMQBroker.stop().     assertTrue("Broker did not stop", latch.await(5, TimeUnit.SECONDS)).     logger.debug("Broker stopped"). }
false;public;0;23;;@Test public void publishSubscribe() throws Exception {     logger.debug("Starting test publishSubscribe()").     String sess1 = "sess1".     String sess2 = "sess2".     String subs1 = "subs1".     String destination = "/topic/test".     MessageExchange conn1 = MessageExchangeBuilder.connect(sess1).build().     MessageExchange conn2 = MessageExchangeBuilder.connect(sess2).build().     this.relay.handleMessage(conn1.message).     this.relay.handleMessage(conn2.message).     this.responseHandler.expectMessages(conn1, conn2).     MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build().     this.relay.handleMessage(subscribe.message).     this.responseHandler.expectMessages(subscribe).     MessageExchange send = MessageExchangeBuilder.send(destination, "foo").andExpectMessage(sess1, subs1).build().     this.relay.handleMessage(send.message).     this.responseHandler.expectMessages(send). }
false;public;0;10;;@Test(expected = MessageDeliveryException.class) public void messageDeliveryExceptionIfSystemSessionForwardFails() throws Exception {     logger.debug("Starting test messageDeliveryExceptionIfSystemSessionForwardFails()").     stopActiveMqBrokerAndAwait().     this.eventPublisher.expectBrokerAvailabilityEvent(false).     StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SEND).     this.relay.handleMessage(MessageBuilder.createMessage("test".getBytes(), headers.getMessageHeaders())). }
false;public;0;14;;@Test public void brokerBecomingUnavailableTriggersErrorFrame() throws Exception {     logger.debug("Starting test brokerBecomingUnavailableTriggersErrorFrame()").     String sess1 = "sess1".     MessageExchange connect = MessageExchangeBuilder.connect(sess1).build().     this.relay.handleMessage(connect.message).     this.responseHandler.expectMessages(connect).     MessageExchange error = MessageExchangeBuilder.error(sess1).build().     stopActiveMqBrokerAndAwait().     this.eventPublisher.expectBrokerAvailabilityEvent(false).     this.responseHandler.expectMessages(error). }
false;public;0;7;;@Test public void brokerAvailabilityEventWhenStopped() throws Exception {     logger.debug("Starting test brokerAvailabilityEventWhenStopped()").     stopActiveMqBrokerAndAwait().     this.eventPublisher.expectBrokerAvailabilityEvent(false). }
false;public;0;24;;@Test public void relayReconnectsIfBrokerComesBackUp() throws Exception {     logger.debug("Starting test relayReconnectsIfBrokerComesBackUp()").     String sess1 = "sess1".     MessageExchange conn1 = MessageExchangeBuilder.connect(sess1).build().     this.relay.handleMessage(conn1.message).     this.responseHandler.expectMessages(conn1).     String subs1 = "subs1".     String destination = "/topic/test".     MessageExchange subscribe = MessageExchangeBuilder.subscribeWithReceipt(sess1, subs1, destination, "r1").build().     this.relay.handleMessage(subscribe.message).     this.responseHandler.expectMessages(subscribe).     MessageExchange error = MessageExchangeBuilder.error(sess1).build().     stopActiveMqBrokerAndAwait().     this.responseHandler.expectMessages(error).     this.eventPublisher.expectBrokerAvailabilityEvent(false).     startActiveMqBroker().     this.eventPublisher.expectBrokerAvailabilityEvent(true). }
false;public;0;13;;@Test public void disconnectWithReceipt() throws Exception {     logger.debug("Starting test disconnectWithReceipt()").     MessageExchange connect = MessageExchangeBuilder.connect("sess1").build().     this.relay.handleMessage(connect.message).     this.responseHandler.expectMessages(connect).     MessageExchange disconnect = MessageExchangeBuilder.disconnectWithReceipt("sess1", "r123").build().     this.relay.handleMessage(disconnect.message).     this.responseHandler.expectMessages(disconnect). }
false;public;1;4;;@Override public void publishEvent(ApplicationEvent event) {     publishEvent((Object) event). }
false;public;1;7;;@Override public void publishEvent(Object event) {     logger.debug("Processing ApplicationEvent " + event).     if (event instanceof BrokerAvailabilityEvent) {         this.eventQueue.add((BrokerAvailabilityEvent) event).     } }
false;public;1;5;;public void expectBrokerAvailabilityEvent(boolean isBrokerAvailable) throws InterruptedException {     BrokerAvailabilityEvent event = this.eventQueue.poll(20000, TimeUnit.MILLISECONDS).     assertNotNull("Times out waiting for BrokerAvailabilityEvent[" + isBrokerAvailable + "]", event).     assertEquals(isBrokerAvailable, event.isBrokerAvailable()). }
false;public;1;7;;@Override public void handleMessage(Message<?> message) throws MessagingException {     if (SimpMessageType.HEARTBEAT == SimpMessageHeaderAccessor.getMessageType(message.getHeaders())) {         return.     }     this.queue.add(message). }
false;public;1;11;;public void expectMessages(MessageExchange... messageExchanges) throws InterruptedException {     List<MessageExchange> expectedMessages = new ArrayList<>(Arrays.<MessageExchange>asList(messageExchanges)).     while (expectedMessages.size() > 0) {         Message<?> message = this.queue.poll(10000, TimeUnit.MILLISECONDS).         assertNotNull("Timed out waiting for messages, expected [" + expectedMessages + "]", message).         MessageExchange match = findMatch(expectedMessages, message).         assertNotNull("Unexpected message=" + message + ", expected [" + expectedMessages + "]", match).         expectedMessages.remove(match).     } }
false;private;2;8;;private MessageExchange findMatch(List<MessageExchange> expectedMessages, Message<?> message) {     for (MessageExchange exchange : expectedMessages) {         if (exchange.matchMessage(message)) {             return exchange.         }     }     return null. }
false;public;1;9;;public boolean matchMessage(Message<?> message) {     for (int i = 0. i < this.expected.length. i++) {         if (this.expected[i].match(message)) {             this.actual[i] = message.             return true.         }     }     return false. }
false;public;0;6;;@Override public String toString() {     return "Forwarded message:\n" + this.message + "\n" + "Should receive back:\n" + Arrays.toString(this.expected) + "\n" + "Actually received:\n" + Arrays.toString(this.actual) + "\n". }
false;public,static;1;3;;public static MessageExchangeBuilder error(String sessionId) {     return new MessageExchangeBuilder(null).andExpectError(sessionId). }
false;public,static;1;11;;public static MessageExchangeBuilder connect(String sessionId) {     StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.CONNECT).     headers.setSessionId(sessionId).     headers.setAcceptVersion("1.1,1.2").     headers.setHeartbeat(0, 0).     Message<?> message = MessageBuilder.createMessage(new byte[0], headers.getMessageHeaders()).     MessageExchangeBuilder builder = new MessageExchangeBuilder(message).     builder.expected.add(new StompConnectedFrameMessageMatcher(sessionId)).     return builder. }
true;public,static;1;9;// TODO Determine why connectWithError() is unused. ;// TODO Determine why connectWithError() is unused. @SuppressWarnings("unused") public static MessageExchangeBuilder connectWithError(String sessionId) {     StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.CONNECT).     headers.setSessionId(sessionId).     headers.setAcceptVersion("1.1,1.2").     Message<?> message = MessageBuilder.createMessage(new byte[0], headers.getMessageHeaders()).     MessageExchangeBuilder builder = new MessageExchangeBuilder(message).     return builder.andExpectError(). }
false;public,static;4;14;;public static MessageExchangeBuilder subscribeWithReceipt(String sessionId, String subscriptionId, String destination, String receiptId) {     StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SUBSCRIBE).     headers.setSessionId(sessionId).     headers.setSubscriptionId(subscriptionId).     headers.setDestination(destination).     headers.setReceipt(receiptId).     Message<?> message = MessageBuilder.createMessage(new byte[0], headers.getMessageHeaders()).     MessageExchangeBuilder builder = new MessageExchangeBuilder(message).     builder.expected.add(new StompReceiptFrameMessageMatcher(sessionId, receiptId)).     return builder. }
false;public,static;2;7;;public static MessageExchangeBuilder send(String destination, String payload) {     SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE).     headers.setDestination(destination).     Message<?> message = MessageBuilder.createMessage(payload.getBytes(StandardCharsets.UTF_8), headers.getMessageHeaders()).     return new MessageExchangeBuilder(message). }
false;public,static;2;10;;public static MessageExchangeBuilder disconnectWithReceipt(String sessionId, String receiptId) {     StompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.DISCONNECT).     headers.setSessionId(sessionId).     headers.setReceipt(receiptId).     Message<?> message = MessageBuilder.createMessage(new byte[0], headers.getMessageHeaders()).     MessageExchangeBuilder builder = new MessageExchangeBuilder(message).     builder.expected.add(new StompReceiptFrameMessageMatcher(sessionId, receiptId)).     return builder. }
false;public;2;7;;public MessageExchangeBuilder andExpectMessage(String sessionId, String subscriptionId) {     Assert.state(SimpMessageType.MESSAGE.equals(this.headers.getMessageType()), "MESSAGE type expected").     String destination = this.headers.getDestination().     Object payload = this.message.getPayload().     this.expected.add(new StompMessageFrameMessageMatcher(sessionId, subscriptionId, destination, payload)).     return this. }
false;public;0;5;;public MessageExchangeBuilder andExpectError() {     String sessionId = this.headers.getSessionId().     Assert.state(sessionId != null, "No sessionId to match the ERROR frame to").     return andExpectError(sessionId). }
false;public;1;4;;public MessageExchangeBuilder andExpectError(String sessionId) {     this.expected.add(new StompFrameMessageMatcher(StompCommand.ERROR, sessionId)).     return this. }
false;public;0;3;;public MessageExchange build() {     return new MessageExchange(this.message, this.expected.toArray(new MessageMatcher[this.expected.size()])). }
false;;1;1;;boolean match(Message<?> message).
false;public,final;1;8;;@Override public final boolean match(Message<?> message) {     StompHeaderAccessor headers = StompHeaderAccessor.wrap(message).     if (!this.command.equals(headers.getCommand()) || (this.sessionId != headers.getSessionId())) {         return false.     }     return matchInternal(headers, message.getPayload()). }
false;protected;2;3;;protected boolean matchInternal(StompHeaderAccessor headers, Object payload) {     return true. }
false;public;0;4;;@Override public String toString() {     return "command=" + this.command + ", session=\"" + this.sessionId + "\"". }
false;protected;2;4;;@Override protected boolean matchInternal(StompHeaderAccessor headers, Object payload) {     return (this.receiptId.equals(headers.getReceiptId())). }
false;public;0;4;;@Override public String toString() {     return super.toString() + ", receiptId=\"" + this.receiptId + "\"". }
false;protected;2;14;;@Override protected boolean matchInternal(StompHeaderAccessor headers, Object payload) {     if (!this.subscriptionId.equals(headers.getSubscriptionId()) || !this.destination.equals(headers.getDestination())) {         return false.     }     if (payload instanceof byte[] && this.payload instanceof byte[]) {         return Arrays.equals((byte[]) payload, (byte[]) this.payload).     } else {         return this.payload.equals(payload).     } }
false;public;0;5;;@Override public String toString() {     return super.toString() + ", subscriptionId=\"" + this.subscriptionId + "\", destination=\"" + this.destination + "\", payload=\"" + getPayloadAsText() + "\"". }
false;protected;0;4;;protected String getPayloadAsText() {     return (this.payload instanceof byte[]) ? new String((byte[]) this.payload, StandardCharsets.UTF_8) : this.payload.toString(). }
