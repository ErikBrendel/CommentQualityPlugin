commented;modifiers;parameterAmount;loc;comment;code
false;public;0;23;;@Before public void setUp() throws Exception {     logger.debug("Setting up before '" + this.testName.getMethodName() + "'").     int port = SocketUtils.findAvailableTcpPort(61613).     this.activeMQBroker = new BrokerService().     this.activeMQBroker.addConnector("stomp://127.0.0.1:" + port).     this.activeMQBroker.setStartAsync(false).     this.activeMQBroker.setPersistent(false).     this.activeMQBroker.setUseJmx(false).     this.activeMQBroker.getSystemUsage().getMemoryUsage().setLimit(1024 * 1024 * 5).     this.activeMQBroker.getSystemUsage().getTempUsage().setLimit(1024 * 1024 * 5).     this.activeMQBroker.start().     ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler().     taskScheduler.afterPropertiesSet().     this.client = new ReactorNettyTcpStompClient("127.0.0.1", port).     this.client.setMessageConverter(new StringMessageConverter()).     this.client.setTaskScheduler(taskScheduler). }
false;public;0;16;;@After public void tearDown() throws Exception {     try {         this.client.shutdown().     } catch (Throwable ex) {         logger.error("Failed to shut client", ex).     }     final CountDownLatch latch = new CountDownLatch(1).     this.activeMQBroker.addShutdownHook(latch::countDown).     logger.debug("Stopping ActiveMQ broker and will await shutdown").     this.activeMQBroker.stop().     if (!latch.await(5, TimeUnit.SECONDS)) {         logger.debug("ActiveMQ broker did not shut in the expected time.").     } }
false;public;0;27;;@Test public void publishSubscribe() throws Exception {     String destination = "/topic/foo".     ConsumingHandler consumingHandler1 = new ConsumingHandler(destination).     ListenableFuture<StompSession> consumerFuture1 = this.client.connect(consumingHandler1).     ConsumingHandler consumingHandler2 = new ConsumingHandler(destination).     ListenableFuture<StompSession> consumerFuture2 = this.client.connect(consumingHandler2).     assertTrue(consumingHandler1.awaitForSubscriptions(5000)).     assertTrue(consumingHandler2.awaitForSubscriptions(5000)).     ProducingHandler producingHandler = new ProducingHandler().     producingHandler.addToSend(destination, "foo1").     producingHandler.addToSend(destination, "foo2").     ListenableFuture<StompSession> producerFuture = this.client.connect(producingHandler).     assertTrue(consumingHandler1.awaitForMessageCount(2, 5000)).     assertThat(consumingHandler1.getReceived(), containsInAnyOrder("foo1", "foo2")).     assertTrue(consumingHandler2.awaitForMessageCount(2, 5000)).     assertThat(consumingHandler2.getReceived(), containsInAnyOrder("foo1", "foo2")).     consumerFuture1.get().disconnect().     consumerFuture2.get().disconnect().     producerFuture.get().disconnect(). }
false;public;5;6;;@Override public void handleException(StompSession session, StompCommand command, StompHeaders headers, byte[] payload, Throwable ex) {     logger.error(command + " " + headers, ex). }
false;public;2;4;;@Override public void handleFrame(StompHeaders headers, @Nullable Object payload) {     logger.error("STOMP error frame " + headers + " payload=" + payload). }
false;public;2;4;;@Override public void handleTransportError(StompSession session, Throwable exception) {     logger.error(exception). }
false;public;0;3;;public List<String> getReceived() {     return this.received. }
false;public;1;4;;@Override public Type getPayloadType(StompHeaders headers) {     return String.class. }
false;public;2;4;;@Override public void handleFrame(StompHeaders headers, @Nullable Object payload) {     received.add((String) payload). }
false;public;2;17;;@Override public void afterConnected(StompSession session, StompHeaders connectedHeaders) {     for (String topic : this.topics) {         session.setAutoReceipt(true).         Subscription subscription = session.subscribe(topic, new StompFrameHandler() {              @Override             public Type getPayloadType(StompHeaders headers) {                 return String.class.             }              @Override             public void handleFrame(StompHeaders headers, @Nullable Object payload) {                 received.add((String) payload).             }         }).         subscription.addReceiptTask(subscriptionLatch::countDown).     } }
false;public;1;6;;public boolean awaitForSubscriptions(long millisToWait) throws InterruptedException {     if (logger.isDebugEnabled()) {         logger.debug("Awaiting for subscription receipts").     }     return this.subscriptionLatch.await(millisToWait, TimeUnit.MILLISECONDS). }
false;public;2;13;;public boolean awaitForMessageCount(int expected, long millisToWait) throws InterruptedException {     if (logger.isDebugEnabled()) {         logger.debug("Awaiting for message count: " + expected).     }     long startTime = System.currentTimeMillis().     while (this.received.size() < expected) {         Thread.sleep(500).         if ((System.currentTimeMillis() - startTime) > millisToWait) {             return false.         }     }     return true. }
false;public;2;5;;public ProducingHandler addToSend(String topic, Object payload) {     this.topics.add(topic).     this.payloads.add(payload).     return this. }
false;public;2;6;;@Override public void afterConnected(StompSession session, StompHeaders connectedHeaders) {     for (int i = 0. i < this.topics.size(). i++) {         session.send(this.topics.get(i), this.payloads.get(i)).     } }
