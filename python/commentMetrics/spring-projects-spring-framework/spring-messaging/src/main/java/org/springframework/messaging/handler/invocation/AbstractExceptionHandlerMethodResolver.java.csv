# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1386363047;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1405696918;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1413848647;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1467456997;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1467730834;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1495868221;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1498780456;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1504012043;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods);1518772998;Protected constructor accepting exception-to-method mappings.;protected AbstractExceptionHandlerMethodResolver(Map<Class<? extends Throwable>, Method> mappedMethods) {_		Assert.notNull(mappedMethods, "Mapped Methods must not be null")__		this.mappedMethods.putAll(mappedMethods)__	};protected,constructor,accepting,exception,to,method,mappings;protected,abstract,exception,handler,method,resolver,map,class,extends,throwable,method,mapped,methods,assert,not,null,mapped,methods,mapped,methods,must,not,be,null,this,mapped,methods,put,all,mapped,methods
AbstractExceptionHandlerMethodResolver -> @Nullable 	private Method getMappedMethod(Class<? extends Throwable> exceptionType);1495868221;Return the {@link Method} mapped to the given exception type, or {@code null} if none.;@Nullable_	private Method getMappedMethod(Class<? extends Throwable> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,link,method,mapped,to,the,given,exception,type,or,code,null,if,none;nullable,private,method,get,mapped,method,class,extends,throwable,exception,type,list,class,extends,throwable,matches,new,array,list,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> @Nullable 	private Method getMappedMethod(Class<? extends Throwable> exceptionType);1498780456;Return the {@link Method} mapped to the given exception type, or {@code null} if none.;@Nullable_	private Method getMappedMethod(Class<? extends Throwable> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,link,method,mapped,to,the,given,exception,type,or,code,null,if,none;nullable,private,method,get,mapped,method,class,extends,throwable,exception,type,list,class,extends,throwable,matches,new,array,list,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> @Nullable 	private Method getMappedMethod(Class<? extends Throwable> exceptionType);1504012043;Return the {@link Method} mapped to the given exception type, or {@code null} if none.;@Nullable_	private Method getMappedMethod(Class<? extends Throwable> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,link,method,mapped,to,the,given,exception,type,or,code,null,if,none;nullable,private,method,get,mapped,method,class,extends,throwable,exception,type,list,class,extends,throwable,matches,new,array,list,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> @Nullable 	private Method getMappedMethod(Class<? extends Throwable> exceptionType);1518772998;Return the {@link Method} mapped to the given exception type, or {@code null} if none.;@Nullable_	private Method getMappedMethod(Class<? extends Throwable> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			matches.sort(new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,link,method,mapped,to,the,given,exception,type,or,code,null,if,none;nullable,private,method,get,mapped,method,class,extends,throwable,exception,type,list,class,extends,throwable,matches,new,array,list,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,matches,sort,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1386363047;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1405696918;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1413848647;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1467456997;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1467730834;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1495868221;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1498780456;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return (this.mappedMethods.size() > 0)__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,size,0
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1504012043;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return !this.mappedMethods.isEmpty()__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,is,empty
AbstractExceptionHandlerMethodResolver -> public boolean hasExceptionMappings();1518772998;Whether the contained type has any exception mappings.;public boolean hasExceptionMappings() {_		return !this.mappedMethods.isEmpty()__	};whether,the,contained,type,has,any,exception,mappings;public,boolean,has,exception,mappings,return,this,mapped,methods,is,empty
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType);1495868221;Find a {@link Method} to handle the given exception type. This can be_useful if an {@link Exception} instance is not available (e.g. for tools)._@param exceptionType the exception type_@return a Method to handle the exception, or {@code null} if none found_@since 4.3.1;@Nullable_	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {_		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND)__		}_		return method != NO_METHOD_FOUND ? method : null__	};find,a,link,method,to,handle,the,given,exception,type,this,can,be,useful,if,an,link,exception,instance,is,not,available,e,g,for,tools,param,exception,type,the,exception,type,return,a,method,to,handle,the,exception,or,code,null,if,none,found,since,4,3,1;nullable,public,method,resolve,method,by,exception,type,class,extends,throwable,exception,type,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,null,method,return,method,method,null
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType);1498780456;Find a {@link Method} to handle the given exception type. This can be_useful if an {@link Exception} instance is not available (e.g. for tools)._@param exceptionType the exception type_@return a Method to handle the exception, or {@code null} if none found_@since 4.3.1;@Nullable_	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {_		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method)__		}_		return method__	};find,a,link,method,to,handle,the,given,exception,type,this,can,be,useful,if,an,link,exception,instance,is,not,available,e,g,for,tools,param,exception,type,the,exception,type,return,a,method,to,handle,the,exception,or,code,null,if,none,found,since,4,3,1;nullable,public,method,resolve,method,by,exception,type,class,extends,throwable,exception,type,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,return,method
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType);1504012043;Find a {@link Method} to handle the given exception type. This can be_useful if an {@link Exception} instance is not available (e.g. for tools)._@param exceptionType the exception type_@return a Method to handle the exception, or {@code null} if none found_@since 4.3.1;@Nullable_	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {_		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method)__		}_		return method__	};find,a,link,method,to,handle,the,given,exception,type,this,can,be,useful,if,an,link,exception,instance,is,not,available,e,g,for,tools,param,exception,type,the,exception,type,return,a,method,to,handle,the,exception,or,code,null,if,none,found,since,4,3,1;nullable,public,method,resolve,method,by,exception,type,class,extends,throwable,exception,type,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,return,method
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType);1518772998;Find a {@link Method} to handle the given exception type. This can be_useful if an {@link Exception} instance is not available (e.g. for tools)._@param exceptionType the exception type_@return a Method to handle the exception, or {@code null} if none found_@since 4.3.1;@Nullable_	public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {_		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method)__		}_		return method__	};find,a,link,method,to,handle,the,given,exception,type,this,can,be,useful,if,an,link,exception,instance,is,not,available,e,g,for,tools,param,exception,type,the,exception,type,return,a,method,to,handle,the,exception,or,code,null,if,none,found,since,4,3,1;nullable,public,method,resolve,method,by,exception,type,class,extends,throwable,exception,type,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,return,method
AbstractExceptionHandlerMethodResolver -> private Method getMappedMethod(Class<? extends Exception> exceptionType);1386363047;Return the method mapped to the given exception type or {@code null}.;private Method getMappedMethod(Class<? extends Exception> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<Class<? extends Throwable>>()__		for(Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,method,mapped,to,the,given,exception,type,or,code,null;private,method,get,mapped,method,class,extends,exception,exception,type,list,class,extends,throwable,matches,new,array,list,class,extends,throwable,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> private Method getMappedMethod(Class<? extends Exception> exceptionType);1405696918;Return the method mapped to the given exception type or {@code null}.;private Method getMappedMethod(Class<? extends Exception> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<Class<? extends Throwable>>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,method,mapped,to,the,given,exception,type,or,code,null;private,method,get,mapped,method,class,extends,exception,exception,type,list,class,extends,throwable,matches,new,array,list,class,extends,throwable,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> private Method getMappedMethod(Class<? extends Exception> exceptionType);1413848647;Return the method mapped to the given exception type or {@code null}.;private Method getMappedMethod(Class<? extends Exception> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<Class<? extends Throwable>>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,method,mapped,to,the,given,exception,type,or,code,null;private,method,get,mapped,method,class,extends,exception,exception,type,list,class,extends,throwable,matches,new,array,list,class,extends,throwable,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> private Method getMappedMethod(Class<? extends Throwable> exceptionType);1467456997;Return the {@link Method} mapped to the given exception type, or {@code null} if none.;private Method getMappedMethod(Class<? extends Throwable> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<Class<? extends Throwable>>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,link,method,mapped,to,the,given,exception,type,or,code,null,if,none;private,method,get,mapped,method,class,extends,throwable,exception,type,list,class,extends,throwable,matches,new,array,list,class,extends,throwable,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> private Method getMappedMethod(Class<? extends Throwable> exceptionType);1467730834;Return the {@link Method} mapped to the given exception type, or {@code null} if none.;private Method getMappedMethod(Class<? extends Throwable> exceptionType) {_		List<Class<? extends Throwable>> matches = new ArrayList<>()__		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {_			if (mappedException.isAssignableFrom(exceptionType)) {_				matches.add(mappedException)__			}_		}_		if (!matches.isEmpty()) {_			Collections.sort(matches, new ExceptionDepthComparator(exceptionType))__			return this.mappedMethods.get(matches.get(0))__		}_		else {_			return null__		}_	};return,the,link,method,mapped,to,the,given,exception,type,or,code,null,if,none;private,method,get,mapped,method,class,extends,throwable,exception,type,list,class,extends,throwable,matches,new,array,list,for,class,extends,throwable,mapped,exception,this,mapped,methods,key,set,if,mapped,exception,is,assignable,from,exception,type,matches,add,mapped,exception,if,matches,is,empty,collections,sort,matches,new,exception,depth,comparator,exception,type,return,this,mapped,methods,get,matches,get,0,else,return,null
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethod(Exception exception);1495868221;Find a {@link Method} to handle the given exception._Use {@link ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a Method to handle the exception, or {@code null} if none found;@Nullable_	public Method resolveMethod(Exception exception) {_		Method method = resolveMethodByExceptionType(exception.getClass())__		if (method == null) {_			Throwable cause = exception.getCause()__			if (cause != null) {_				method = resolveMethodByExceptionType(cause.getClass())__			}_		}_		return method__	};find,a,link,method,to,handle,the,given,exception,use,link,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null,if,none,found;nullable,public,method,resolve,method,exception,exception,method,method,resolve,method,by,exception,type,exception,get,class,if,method,null,throwable,cause,exception,get,cause,if,cause,null,method,resolve,method,by,exception,type,cause,get,class,return,method
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethod(Exception exception);1498780456;Find a {@link Method} to handle the given exception._Use {@link ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a Method to handle the exception, or {@code null} if none found;@Nullable_	public Method resolveMethod(Exception exception) {_		Method method = resolveMethodByExceptionType(exception.getClass())__		if (method == null) {_			Throwable cause = exception.getCause()__			if (cause != null) {_				method = resolveMethodByExceptionType(cause.getClass())__			}_		}_		return method__	};find,a,link,method,to,handle,the,given,exception,use,link,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null,if,none,found;nullable,public,method,resolve,method,exception,exception,method,method,resolve,method,by,exception,type,exception,get,class,if,method,null,throwable,cause,exception,get,cause,if,cause,null,method,resolve,method,by,exception,type,cause,get,class,return,method
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethod(Exception exception);1504012043;Find a {@link Method} to handle the given exception._Use {@link ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a Method to handle the exception, or {@code null} if none found;@Nullable_	public Method resolveMethod(Exception exception) {_		Method method = resolveMethodByExceptionType(exception.getClass())__		if (method == null) {_			Throwable cause = exception.getCause()__			if (cause != null) {_				method = resolveMethodByExceptionType(cause.getClass())__			}_		}_		return method__	};find,a,link,method,to,handle,the,given,exception,use,link,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null,if,none,found;nullable,public,method,resolve,method,exception,exception,method,method,resolve,method,by,exception,type,exception,get,class,if,method,null,throwable,cause,exception,get,cause,if,cause,null,method,resolve,method,by,exception,type,cause,get,class,return,method
AbstractExceptionHandlerMethodResolver -> @Nullable 	public Method resolveMethod(Exception exception);1518772998;Find a {@link Method} to handle the given exception._Use {@link ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a Method to handle the exception, or {@code null} if none found;@Nullable_	public Method resolveMethod(Exception exception) {_		Method method = resolveMethodByExceptionType(exception.getClass())__		if (method == null) {_			Throwable cause = exception.getCause()__			if (cause != null) {_				method = resolveMethodByExceptionType(cause.getClass())__			}_		}_		return method__	};find,a,link,method,to,handle,the,given,exception,use,link,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null,if,none,found;nullable,public,method,resolve,method,exception,exception,method,method,resolve,method,by,exception,type,exception,get,class,if,method,null,throwable,cause,exception,get,cause,if,cause,null,method,resolve,method,by,exception,type,cause,get,class,return,method
AbstractExceptionHandlerMethodResolver -> public Method resolveMethod(Exception exception);1386363047;Find a method to handle the given exception._Use {@link org.springframework.core.ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a method to handle the exception or {@code null};public Method resolveMethod(Exception exception) {_		Class<? extends Exception> exceptionType = exception.getClass()__		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND)__		}_		return method != NO_METHOD_FOUND ? method : null__	};find,a,method,to,handle,the,given,exception,use,link,org,springframework,core,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null;public,method,resolve,method,exception,exception,class,extends,exception,exception,type,exception,get,class,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,null,method,return,method,method,null
AbstractExceptionHandlerMethodResolver -> public Method resolveMethod(Exception exception);1405696918;Find a method to handle the given exception._Use {@link org.springframework.core.ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a method to handle the exception or {@code null};public Method resolveMethod(Exception exception) {_		Class<? extends Exception> exceptionType = exception.getClass()__		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND)__		}_		return method != NO_METHOD_FOUND ? method : null__	};find,a,method,to,handle,the,given,exception,use,link,org,springframework,core,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null;public,method,resolve,method,exception,exception,class,extends,exception,exception,type,exception,get,class,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,null,method,return,method,method,null
AbstractExceptionHandlerMethodResolver -> public Method resolveMethod(Exception exception);1413848647;Find a method to handle the given exception._Use {@link org.springframework.core.ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a method to handle the exception or {@code null};public Method resolveMethod(Exception exception) {_		Class<? extends Exception> exceptionType = exception.getClass()__		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND)__		}_		return method != NO_METHOD_FOUND ? method : null__	};find,a,method,to,handle,the,given,exception,use,link,org,springframework,core,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null;public,method,resolve,method,exception,exception,class,extends,exception,exception,type,exception,get,class,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,null,method,return,method,method,null
AbstractExceptionHandlerMethodResolver -> public Method resolveMethod(Exception exception);1467456997;Find a {@link Method} to handle the given exception._Use {@link ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a Method to handle the exception, or {@code null} if none found;public Method resolveMethod(Exception exception) {_		Method method = resolveMethodByExceptionType(exception.getClass())__		if (method == null) {_			Throwable cause = exception.getCause()__			if (cause != null) {_				method = resolveMethodByExceptionType(cause.getClass())__			}_		}_		return method__	};find,a,link,method,to,handle,the,given,exception,use,link,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null,if,none,found;public,method,resolve,method,exception,exception,method,method,resolve,method,by,exception,type,exception,get,class,if,method,null,throwable,cause,exception,get,cause,if,cause,null,method,resolve,method,by,exception,type,cause,get,class,return,method
AbstractExceptionHandlerMethodResolver -> public Method resolveMethod(Exception exception);1467730834;Find a {@link Method} to handle the given exception._Use {@link ExceptionDepthComparator} if more than one match is found._@param exception the exception_@return a Method to handle the exception, or {@code null} if none found;public Method resolveMethod(Exception exception) {_		Method method = resolveMethodByExceptionType(exception.getClass())__		if (method == null) {_			Throwable cause = exception.getCause()__			if (cause != null) {_				method = resolveMethodByExceptionType(cause.getClass())__			}_		}_		return method__	};find,a,link,method,to,handle,the,given,exception,use,link,exception,depth,comparator,if,more,than,one,match,is,found,param,exception,the,exception,return,a,method,to,handle,the,exception,or,code,null,if,none,found;public,method,resolve,method,exception,exception,method,method,resolve,method,by,exception,type,exception,get,class,if,method,null,throwable,cause,exception,get,cause,if,cause,null,method,resolve,method,by,exception,type,cause,get,class,return,method
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1386363047;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<Class<? extends Throwable>>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,class,extends,throwable,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1405696918;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<Class<? extends Throwable>>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,class,extends,throwable,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1413848647;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<Class<? extends Throwable>>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,class,extends,throwable,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1467456997;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<Class<? extends Throwable>>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,class,extends,throwable,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1467730834;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1495868221;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1498780456;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		Assert.notEmpty(result, "No exception types mapped to {" + method + "}")__		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,assert,not,empty,result,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1504012043;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		if (result.isEmpty()) {_			throw new IllegalStateException("No exception types mapped to " + method)__		}_		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,if,result,is,empty,throw,new,illegal,state,exception,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> @SuppressWarnings("unchecked") 	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method);1518772998;Extract the exceptions this method handles.This implementation looks for_sub-classes of Throwable in the method signature._The method is static to ensure safe use from sub-class constructors.;@SuppressWarnings("unchecked")_	protected static List<Class<? extends Throwable>> getExceptionsFromMethodSignature(Method method) {_		List<Class<? extends Throwable>> result = new ArrayList<>()__		for (Class<?> paramType : method.getParameterTypes()) {_			if (Throwable.class.isAssignableFrom(paramType)) {_				result.add((Class<? extends Throwable>) paramType)__			}_		}_		if (result.isEmpty()) {_			throw new IllegalStateException("No exception types mapped to " + method)__		}_		return result__	};extract,the,exceptions,this,method,handles,this,implementation,looks,for,sub,classes,of,throwable,in,the,method,signature,the,method,is,static,to,ensure,safe,use,from,sub,class,constructors;suppress,warnings,unchecked,protected,static,list,class,extends,throwable,get,exceptions,from,method,signature,method,method,list,class,extends,throwable,result,new,array,list,for,class,param,type,method,get,parameter,types,if,throwable,class,is,assignable,from,param,type,result,add,class,extends,throwable,param,type,if,result,is,empty,throw,new,illegal,state,exception,no,exception,types,mapped,to,method,return,result
AbstractExceptionHandlerMethodResolver -> public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType);1467456997;Find a {@link Method} to handle the given exception type. This can be_useful if an {@link Exception} instance is not available (e.g. for tools)._@param exceptionType the exception type_@return a Method to handle the exception, or {@code null} if none found_@since 4.3.1;public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {_		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND)__		}_		return method != NO_METHOD_FOUND ? method : null__	};find,a,link,method,to,handle,the,given,exception,type,this,can,be,useful,if,an,link,exception,instance,is,not,available,e,g,for,tools,param,exception,type,the,exception,type,return,a,method,to,handle,the,exception,or,code,null,if,none,found,since,4,3,1;public,method,resolve,method,by,exception,type,class,extends,throwable,exception,type,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,null,method,return,method,method,null
AbstractExceptionHandlerMethodResolver -> public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType);1467730834;Find a {@link Method} to handle the given exception type. This can be_useful if an {@link Exception} instance is not available (e.g. for tools)._@param exceptionType the exception type_@return a Method to handle the exception, or {@code null} if none found_@since 4.3.1;public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {_		Method method = this.exceptionLookupCache.get(exceptionType)__		if (method == null) {_			method = getMappedMethod(exceptionType)__			this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND)__		}_		return method != NO_METHOD_FOUND ? method : null__	};find,a,link,method,to,handle,the,given,exception,type,this,can,be,useful,if,an,link,exception,instance,is,not,available,e,g,for,tools,param,exception,type,the,exception,type,return,a,method,to,handle,the,exception,or,code,null,if,none,found,since,4,3,1;public,method,resolve,method,by,exception,type,class,extends,throwable,exception,type,method,method,this,exception,lookup,cache,get,exception,type,if,method,null,method,get,mapped,method,exception,type,this,exception,lookup,cache,put,exception,type,method,null,method,return,method,method,null
