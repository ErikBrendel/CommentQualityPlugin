commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean supportsParameter(MethodParameter parameter) {     return (parameter.hasParameterAnnotation(Payload.class) || this.useDefaultResolution). }
false;public;2;43;;@Override @Nullable public Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {     Payload ann = parameter.getParameterAnnotation(Payload.class).     if (ann != null && StringUtils.hasText(ann.expression())) {         throw new IllegalStateException("@Payload SpEL expressions not supported by this resolver").     }     Object payload = message.getPayload().     if (isEmptyPayload(payload)) {         if (ann == null || ann.required()) {             String paramName = getParameterName(parameter).             BindingResult bindingResult = new BeanPropertyBindingResult(payload, paramName).             bindingResult.addError(new ObjectError(paramName, "Payload value must not be empty")).             throw new MethodArgumentNotValidException(message, parameter, bindingResult).         } else {             return null.         }     }     Class<?> targetClass = parameter.getParameterType().     Class<?> payloadClass = payload.getClass().     if (ClassUtils.isAssignable(targetClass, payloadClass)) {         validate(message, parameter, payload).         return payload.     } else {         if (this.converter instanceof SmartMessageConverter) {             SmartMessageConverter smartConverter = (SmartMessageConverter) this.converter.             payload = smartConverter.fromMessage(message, targetClass, parameter).         } else {             payload = this.converter.fromMessage(message, targetClass).         }         if (payload == null) {             throw new MessageConversionException(message, "Cannot convert from [" + payloadClass.getName() + "] to [" + targetClass.getName() + "] for " + message).         }         validate(message, parameter, payload).         return payload.     } }
false;private;1;4;;private String getParameterName(MethodParameter param) {     String paramName = param.getParameterName().     return (paramName != null ? paramName : "Arg " + param.getParameterIndex()). }
true;protected;1;14;/**  * Specify if the given {@code payload} is empty.  * @param payload the payload to check (can be {@code null})  */ ;/**  * Specify if the given {@code payload} is empty.  * @param payload the payload to check (can be {@code null})  */ protected boolean isEmptyPayload(@Nullable Object payload) {     if (payload == null) {         return true.     } else if (payload instanceof byte[]) {         return ((byte[]) payload).length == 0.     } else if (payload instanceof String) {         return !StringUtils.hasText((String) payload).     } else {         return false.     } }
true;protected;3;24;/**  * Validate the payload if applicable.  * <p>The default implementation checks for {@code @javax.validation.Valid},  * Spring's {@link org.springframework.validation.annotation.Validated},  * and custom annotations whose name starts with "Valid".  * @param message the currently processed message  * @param parameter the method parameter  * @param target the target payload object  * @throws MethodArgumentNotValidException in case of binding errors  */ ;/**  * Validate the payload if applicable.  * <p>The default implementation checks for {@code @javax.validation.Valid},  * Spring's {@link org.springframework.validation.annotation.Validated},  * and custom annotations whose name starts with "Valid".  * @param message the currently processed message  * @param parameter the method parameter  * @param target the target payload object  * @throws MethodArgumentNotValidException in case of binding errors  */ protected void validate(Message<?> message, MethodParameter parameter, Object target) {     if (this.validator == null) {         return.     }     for (Annotation ann : parameter.getParameterAnnotations()) {         Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class).         if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {             Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)).             Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] { hints }).             BeanPropertyBindingResult bindingResult = new BeanPropertyBindingResult(target, getParameterName(parameter)).             if (!ObjectUtils.isEmpty(validationHints) && this.validator instanceof SmartValidator) {                 ((SmartValidator) this.validator).validate(target, bindingResult, validationHints).             } else {                 this.validator.validate(target, bindingResult).             }             if (bindingResult.hasErrors()) {                 throw new MethodArgumentNotValidException(message, parameter, bindingResult).             }             break.         }     } }
