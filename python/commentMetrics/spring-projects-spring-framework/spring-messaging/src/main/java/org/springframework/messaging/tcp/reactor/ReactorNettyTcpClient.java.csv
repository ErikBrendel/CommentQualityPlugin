commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set an alternative logger to use than the one based on the class name.  * @param logger the logger to use  * @since 5.1  */ ;/**  * Set an alternative logger to use than the one based on the class name.  * @param logger the logger to use  * @since 5.1  */ public void setLogger(Log logger) {     this.logger = logger. }
true;public;0;3;/**  * Return the currently configured Logger.  * @since 5.1  */ ;/**  * Return the currently configured Logger.  * @since 5.1  */ public Log getLogger() {     return logger. }
false;public;1;16;;@Override public ListenableFuture<Void> connect(final TcpConnectionHandler<P> handler) {     Assert.notNull(handler, "TcpConnectionHandler is required").     if (this.stopping) {         return handleShuttingDownConnectFailure(handler).     }     Mono<Void> connectMono = this.tcpClient.handle(new ReactorNettyHandler(handler)).connect().doOnError(handler::afterConnectFailure).then().     return new MonoToListenableFutureAdapter<>(connectMono). }
false;public;2;25;;@Override public ListenableFuture<Void> connect(TcpConnectionHandler<P> handler, ReconnectStrategy strategy) {     Assert.notNull(handler, "TcpConnectionHandler is required").     Assert.notNull(strategy, "ReconnectStrategy is required").     if (this.stopping) {         return handleShuttingDownConnectFailure(handler).     }     // Report first connect to the ListenableFuture     MonoProcessor<Void> connectMono = MonoProcessor.create().     this.tcpClient.handle(new ReactorNettyHandler(handler)).connect().doOnNext(updateConnectMono(connectMono)).doOnError(updateConnectMono(connectMono)).doOnError(// report all connect failures to the handler     handler::afterConnectFailure).flatMap(// post-connect issues     Connection::onDispose).retryWhen(reconnectFunction(strategy)).repeatWhen(reconnectFunction(strategy)).subscribe().     return new MonoToListenableFutureAdapter<>(connectMono). }
false;private;1;5;;private ListenableFuture<Void> handleShuttingDownConnectFailure(TcpConnectionHandler<P> handler) {     IllegalStateException ex = new IllegalStateException("Shutting down.").     handler.afterConnectFailure(ex).     return new MonoToListenableFutureAdapter<>(Mono.error(ex)). }
false;private;1;12;;private <T> Consumer<T> updateConnectMono(MonoProcessor<Void> connectMono) {     return o -> {         if (!connectMono.isTerminated()) {             if (o instanceof Throwable) {                 connectMono.onError((Throwable) o).             } else {                 connectMono.onComplete().             }         }     }. }
false;private;1;7;;private <T> Function<Flux<T>, Publisher<?>> reconnectFunction(ReconnectStrategy reconnectStrategy) {     return flux -> flux.scan(1, (count, element) -> count++).flatMap(attempt -> Optional.ofNullable(reconnectStrategy.getTimeToNextAttempt(attempt)).map(time -> Mono.delay(Duration.ofMillis(time), this.scheduler)).orElse(Mono.empty())). }
false;public;0;27;;@Override public ListenableFuture<Void> shutdown() {     if (this.stopping) {         SettableListenableFuture<Void> future = new SettableListenableFuture<>().         future.set(null).         return future.     }     this.stopping = true.     Mono<Void> result.     if (this.channelGroup != null) {         result = FutureMono.from(this.channelGroup.close()).         if (this.loopResources != null) {             result = result.onErrorResume(ex -> Mono.empty()).then(this.loopResources.disposeLater()).         }         if (this.poolResources != null) {             result = result.onErrorResume(ex -> Mono.empty()).then(this.poolResources.disposeLater()).         }         result = result.onErrorResume(ex -> Mono.empty()).then(stopScheduler()).     } else {         result = stopScheduler().     }     return new MonoToListenableFutureAdapter<>(result). }
false;private;0;16;;private Mono<Void> stopScheduler() {     return Mono.fromRunnable(() -> {         this.scheduler.dispose().         for (int i = 0. i < 20. i++) {             if (this.scheduler.isDisposed()) {                 break.             }             try {                 Thread.sleep(100).             } catch (Throwable ex) {                 break.             }         }     }). }
false;public;0;4;;@Override public String toString() {     return "ReactorNettyTcpClient[" + this.tcpClient + "]". }
false;public;2;24;;@Override @SuppressWarnings("unchecked") public Publisher<Void> apply(NettyInbound inbound, NettyOutbound outbound) {     inbound.withConnection(conn -> {         if (logger.isDebugEnabled()) {             logger.debug("Connected to " + conn.address()).         }     }).     DirectProcessor<Void> completion = DirectProcessor.create().     TcpConnection<P> connection = new ReactorNettyTcpConnection<>(inbound, outbound, codec, completion).     scheduler.schedule(() -> this.connectionHandler.afterConnected(connection)).     inbound.withConnection(conn -> conn.addHandler(new StompMessageDecoder<>(codec))).     inbound.receiveObject().cast(Message.class).publishOn(scheduler, PUBLISH_ON_BUFFER_SIZE).subscribe(this.connectionHandler::handleMessage, this.connectionHandler::handleFailure, this.connectionHandler::afterConnectionClosed).     return completion. }
false;protected;3;5;;@Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {     Collection<Message<P>> messages = this.codec.decode(in).     out.addAll(messages). }
