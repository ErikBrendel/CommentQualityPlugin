commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * {@inheritDoc}  * <p>Destination prefixes are expected to be slash-separated Strings and  * therefore a slash is automatically appended where missing to ensure a  * proper prefix-based match (i.e. matching complete segments).  * <p>Note however that the remaining portion of a destination after the  * prefix may use a different separator (e.g. commonly "." in messaging)  * depending on the configured {@code PathMatcher}.  */ ;/**  * {@inheritDoc}  * <p>Destination prefixes are expected to be slash-separated Strings and  * therefore a slash is automatically appended where missing to ensure a  * proper prefix-based match (i.e. matching complete segments).  * <p>Note however that the remaining portion of a destination after the  * prefix may use a different separator (e.g. commonly "." in messaging)  * depending on the configured {@code PathMatcher}.  */ @Override public void setDestinationPrefixes(@Nullable Collection<String> prefixes) {     super.setDestinationPrefixes(appendSlashes(prefixes)). }
false;private,static;1;14;;@Nullable private static Collection<String> appendSlashes(@Nullable Collection<String> prefixes) {     if (CollectionUtils.isEmpty(prefixes)) {         return prefixes.     }     Collection<String> result = new ArrayList<>(prefixes.size()).     for (String prefix : prefixes) {         if (!prefix.endsWith("/")) {             prefix = prefix + "/".         }         result.add(prefix).     }     return result. }
true;public;1;4;/**  * Configure a {@link MessageConverter} to use to convert the payload of a message from  * its serialized form with a specific MIME type to an Object matching the target method  * parameter. The converter is also used when sending a message to the message broker.  * @see CompositeMessageConverter  */ ;/**  * Configure a {@link MessageConverter} to use to convert the payload of a message from  * its serialized form with a specific MIME type to an Object matching the target method  * parameter. The converter is also used when sending a message to the message broker.  * @see CompositeMessageConverter  */ public void setMessageConverter(MessageConverter converter) {     this.messageConverter = converter.     ((AbstractMessageSendingTemplate<?>) this.clientMessagingTemplate).setMessageConverter(converter). }
true;public;0;3;/**  * Return the configured {@link MessageConverter}.  */ ;/**  * Return the configured {@link MessageConverter}.  */ public MessageConverter getMessageConverter() {     return this.messageConverter. }
true;public;1;3;/**  * Configure a {@link ConversionService} to use when resolving method arguments,  * for example message header values.  * <p>By default, {@link DefaultFormattingConversionService} is used.  */ ;/**  * Configure a {@link ConversionService} to use when resolving method arguments,  * for example message header values.  * <p>By default, {@link DefaultFormattingConversionService} is used.  */ public void setConversionService(ConversionService conversionService) {     this.conversionService = conversionService. }
true;public;0;3;/**  * Return the configured {@link ConversionService}.  */ ;/**  * Return the configured {@link ConversionService}.  */ public ConversionService getConversionService() {     return this.conversionService. }
true;public;1;5;/**  * Set the PathMatcher implementation to use for matching destinations  * against configured destination patterns.  * <p>By default, {@link AntPathMatcher} is used.  */ ;/**  * Set the PathMatcher implementation to use for matching destinations  * against configured destination patterns.  * <p>By default, {@link AntPathMatcher} is used.  */ public void setPathMatcher(PathMatcher pathMatcher) {     Assert.notNull(pathMatcher, "PathMatcher must not be null").     this.pathMatcher = pathMatcher.     this.slashPathSeparator = this.pathMatcher.combine("a", "a").equals("a/a"). }
true;public;0;3;/**  * Return the PathMatcher implementation to use for matching destinations.  */ ;/**  * Return the PathMatcher implementation to use for matching destinations.  */ public PathMatcher getPathMatcher() {     return this.pathMatcher. }
true;public;0;4;/**  * Return the configured Validator instance.  */ ;/**  * Return the configured Validator instance.  */ @Nullable public Validator getValidator() {     return this.validator. }
true;public;1;3;/**  * Set the Validator instance used for validating {@code @Payload} arguments.  * @see org.springframework.validation.annotation.Validated  * @see PayloadArgumentResolver  */ ;/**  * Set the Validator instance used for validating {@code @Payload} arguments.  * @see org.springframework.validation.annotation.Validated  * @see PayloadArgumentResolver  */ public void setValidator(@Nullable Validator validator) {     this.validator = validator. }
false;public;1;4;;@Override public void setEmbeddedValueResolver(StringValueResolver resolver) {     this.valueResolver = resolver. }
true;public;1;3;/**  * Configure a {@link MessageHeaderInitializer} to pass on to  * {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}  * that send messages from controller return values.  * <p>By default, this property is not set.  */ ;/**  * Configure a {@link MessageHeaderInitializer} to pass on to  * {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}  * that send messages from controller return values.  * <p>By default, this property is not set.  */ public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {     this.headerInitializer = headerInitializer. }
true;public;0;4;/**  * Return the configured header initializer.  */ ;/**  * Return the configured header initializer.  */ @Nullable public MessageHeaderInitializer getHeaderInitializer() {     return this.headerInitializer. }
false;public,final;0;7;;@Override public final void start() {     synchronized (this.lifecycleMonitor) {         this.clientInboundChannel.subscribe(this).         this.running = true.     } }
false;public,final;0;7;;@Override public final void stop() {     synchronized (this.lifecycleMonitor) {         this.running = false.         this.clientInboundChannel.unsubscribe(this).     } }
false;public,final;1;7;;@Override public final void stop(Runnable callback) {     synchronized (this.lifecycleMonitor) {         stop().         callback.run().     } }
false;public,final;0;4;;@Override public final boolean isRunning() {     return this.running. }
false;protected;0;21;;protected List<HandlerMethodArgumentResolver> initArgumentResolvers() {     ApplicationContext context = getApplicationContext().     ConfigurableBeanFactory beanFactory = (context instanceof ConfigurableApplicationContext ? ((ConfigurableApplicationContext) context).getBeanFactory() : null).     List<HandlerMethodArgumentResolver> resolvers = new ArrayList<>().     // Annotation-based argument resolution     resolvers.add(new HeaderMethodArgumentResolver(this.conversionService, beanFactory)).     resolvers.add(new HeadersMethodArgumentResolver()).     resolvers.add(new DestinationVariableMethodArgumentResolver(this.conversionService)).     // Type-based argument resolution     resolvers.add(new PrincipalMethodArgumentResolver()).     resolvers.add(new MessageMethodArgumentResolver(this.messageConverter)).     resolvers.addAll(getCustomArgumentResolvers()).     resolvers.add(new PayloadArgumentResolver(this.messageConverter, this.validator)).     return resolvers. }
false;protected;0;34;;@Override protected List<? extends HandlerMethodReturnValueHandler> initReturnValueHandlers() {     List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>().     // Single-purpose return value types     handlers.add(new ListenableFutureReturnValueHandler()).     handlers.add(new CompletableFutureReturnValueHandler()).     handlers.add(new ReactiveReturnValueHandler()).     // Annotation-based return value types     SendToMethodReturnValueHandler sendToHandler = new SendToMethodReturnValueHandler(this.brokerTemplate, true).     sendToHandler.setHeaderInitializer(this.headerInitializer).     handlers.add(sendToHandler).     SubscriptionMethodReturnValueHandler subscriptionHandler = new SubscriptionMethodReturnValueHandler(this.clientMessagingTemplate).     subscriptionHandler.setHeaderInitializer(this.headerInitializer).     handlers.add(subscriptionHandler).     // Custom return value types     handlers.addAll(getCustomReturnValueHandlers()).     // Catch-all     sendToHandler = new SendToMethodReturnValueHandler(this.brokerTemplate, false).     sendToHandler.setHeaderInitializer(this.headerInitializer).     handlers.add(sendToHandler).     return handlers. }
false;protected;0;4;;@Override protected Log getReturnValueHandlerLogger() {     return SimpLogging.forLog(HandlerMethodReturnValueHandlerComposite.defaultLogger). }
false;protected;0;4;;@Override protected Log getHandlerMethodLogger() {     return SimpLogging.forLog(HandlerMethod.defaultLogger). }
false;protected;1;4;;@Override protected boolean isHandler(Class<?> beanType) {     return AnnotatedElementUtils.hasAnnotation(beanType, Controller.class). }
false;protected;2;33;;@Override @Nullable protected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {     MessageMapping messageAnn = AnnotatedElementUtils.findMergedAnnotation(method, MessageMapping.class).     if (messageAnn != null) {         MessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class).         // otherwise @MessageMapping is just being used as a (meta-annotation) marker.         if (messageAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {             SimpMessageMappingInfo result = createMessageMappingCondition(messageAnn.value()).             if (typeAnn != null) {                 result = createMessageMappingCondition(typeAnn.value()).combine(result).             }             return result.         }     }     SubscribeMapping subscribeAnn = AnnotatedElementUtils.findMergedAnnotation(method, SubscribeMapping.class).     if (subscribeAnn != null) {         MessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class).         // otherwise @SubscribeMapping is just being used as a (meta-annotation) marker.         if (subscribeAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {             SimpMessageMappingInfo result = createSubscribeMappingCondition(subscribeAnn.value()).             if (typeAnn != null) {                 result = createMessageMappingCondition(typeAnn.value()).combine(result).             }             return result.         }     }     return null. }
false;private;1;5;;private SimpMessageMappingInfo createMessageMappingCondition(String[] destinations) {     String[] resolvedDestinations = resolveEmbeddedValuesInDestinations(destinations).     return new SimpMessageMappingInfo(SimpMessageTypeMessageCondition.MESSAGE, new DestinationPatternsMessageCondition(resolvedDestinations, this.pathMatcher)). }
false;private;1;5;;private SimpMessageMappingInfo createSubscribeMappingCondition(String[] destinations) {     String[] resolvedDestinations = resolveEmbeddedValuesInDestinations(destinations).     return new SimpMessageMappingInfo(SimpMessageTypeMessageCondition.SUBSCRIBE, new DestinationPatternsMessageCondition(resolvedDestinations, this.pathMatcher)). }
true;protected;1;10;/**  * Resolve placeholder values in the given array of destinations.  * @return a new array with updated destinations  * @since 4.2  */ ;/**  * Resolve placeholder values in the given array of destinations.  * @return a new array with updated destinations  * @since 4.2  */ protected String[] resolveEmbeddedValuesInDestinations(String[] destinations) {     if (this.valueResolver == null) {         return destinations.     }     String[] result = new String[destinations.length].     for (int i = 0. i < destinations.length. i++) {         result[i] = this.valueResolver.resolveStringValue(destinations[i]).     }     return result. }
false;protected;1;10;;@Override protected Set<String> getDirectLookupDestinations(SimpMessageMappingInfo mapping) {     Set<String> result = new LinkedHashSet<>().     for (String pattern : mapping.getDestinationConditions().getPatterns()) {         if (!this.pathMatcher.isPattern(pattern)) {             result.add(pattern).         }     }     return result. }
false;protected;1;5;;@Override @Nullable protected String getDestination(Message<?> message) {     return SimpMessageHeaderAccessor.getDestination(message.getHeaders()). }
false;protected;1;20;;@Override protected String getLookupDestination(@Nullable String destination) {     if (destination == null) {         return null.     }     if (CollectionUtils.isEmpty(getDestinationPrefixes())) {         return destination.     }     for (String prefix : getDestinationPrefixes()) {         if (destination.startsWith(prefix)) {             if (this.slashPathSeparator) {                 return destination.substring(prefix.length() - 1).             } else {                 return destination.substring(prefix.length()).             }         }     }     return null. }
false;protected;2;6;;@Override @Nullable protected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message) {     return mapping.getMatchingCondition(message). }
false;protected;1;4;;@Override protected Comparator<SimpMessageMappingInfo> getMappingComparator(final Message<?> message) {     return (info1, info2) -> info1.compareTo(info2, message). }
false;protected;4;23;;@Override protected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {     Set<String> patterns = mapping.getDestinationConditions().getPatterns().     if (!CollectionUtils.isEmpty(patterns)) {         String pattern = patterns.iterator().next().         Map<String, String> vars = getPathMatcher().extractUriTemplateVariables(pattern, lookupDestination).         if (!CollectionUtils.isEmpty(vars)) {             MessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class).             Assert.state(mha != null && mha.isMutable(), "Mutable MessageHeaderAccessor required").             mha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars).         }     }     try {         SimpAttributesContextHolder.setAttributesFromMessage(message).         super.handleMatch(mapping, handlerMethod, lookupDestination, message).     } finally {         SimpAttributesContextHolder.resetAttributes().     } }
false;protected;1;4;;@Override protected AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(Class<?> beanType) {     return new AnnotationExceptionHandlerMethodResolver(beanType). }
