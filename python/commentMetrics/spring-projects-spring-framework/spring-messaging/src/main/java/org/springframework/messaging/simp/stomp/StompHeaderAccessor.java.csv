commented;modifiers;parameterAmount;loc;comment;code
false;;0;29;;void updateSimpMessageHeadersFromStompHeaders() {     if (getNativeHeaders() == null) {         return.     }     String value = getFirstNativeHeader(STOMP_DESTINATION_HEADER).     if (value != null) {         super.setDestination(value).     }     value = getFirstNativeHeader(STOMP_CONTENT_TYPE_HEADER).     if (value != null) {         super.setContentType(MimeTypeUtils.parseMimeType(value)).     }     StompCommand command = getCommand().     if (StompCommand.MESSAGE.equals(command)) {         value = getFirstNativeHeader(STOMP_SUBSCRIPTION_HEADER).         if (value != null) {             super.setSubscriptionId(value).         }     } else if (StompCommand.SUBSCRIBE.equals(command) || StompCommand.UNSUBSCRIBE.equals(command)) {         value = getFirstNativeHeader(STOMP_ID_HEADER).         if (value != null) {             super.setSubscriptionId(value).         }     } else if (StompCommand.CONNECT.equals(command)) {         protectPasscode().     } }
false;;0;11;;void updateStompHeadersFromSimpMessageHeaders() {     String destination = getDestination().     if (destination != null) {         setNativeHeader(STOMP_DESTINATION_HEADER, destination).     }     MimeType contentType = getContentType().     if (contentType != null) {         setNativeHeader(STOMP_CONTENT_TYPE_HEADER, contentType.toString()).     }     trySetStompHeaderForSubscriptionId(). }
false;protected;1;4;;@Override protected MessageHeaderAccessor createAccessor(Message<?> message) {     return wrap(message). }
true;protected;0;5;// Redeclared for visibility within simp.stomp ;// Redeclared for visibility within simp.stomp @Override @Nullable protected Map<String, List<String>> getNativeHeaders() {     return super.getNativeHeaders(). }
false;public;0;15;;public StompCommand updateStompCommandAsClientMessage() {     SimpMessageType messageType = getMessageType().     if (messageType != SimpMessageType.MESSAGE) {         throw new IllegalStateException("Unexpected message type " + messageType).     }     StompCommand command = getCommand().     if (command == null) {         command = StompCommand.SEND.         setHeader(COMMAND_HEADER, command).     } else if (!command.equals(StompCommand.SEND)) {         throw new IllegalStateException("Unexpected STOMP command " + command).     }     return command. }
false;public;0;18;;public void updateStompCommandAsServerMessage() {     SimpMessageType messageType = getMessageType().     if (messageType != SimpMessageType.MESSAGE) {         throw new IllegalStateException("Unexpected message type " + messageType).     }     StompCommand command = getCommand().     if ((command == null) || StompCommand.SEND.equals(command)) {         setHeader(COMMAND_HEADER, StompCommand.MESSAGE).     } else if (!StompCommand.MESSAGE.equals(command)) {         throw new IllegalStateException("Unexpected STOMP command " + command).     }     trySetStompHeaderForSubscriptionId().     if (getMessageId() == null) {         String messageId = getSessionId() + '-' + messageIdCounter.getAndIncrement().         setNativeHeader(STOMP_MESSAGE_ID_HEADER, messageId).     } }
true;public;0;4;/**  * Return the STOMP command, or {@code null} if not yet set.  */ ;/**  * Return the STOMP command, or {@code null} if not yet set.  */ @Nullable public StompCommand getCommand() {     return (StompCommand) getHeader(COMMAND_HEADER). }
false;public;0;3;;public boolean isHeartbeat() {     return (SimpMessageType.HEARTBEAT == getMessageType()). }
false;public;0;8;;public long[] getHeartbeat() {     String rawValue = getFirstNativeHeader(STOMP_HEARTBEAT_HEADER).     String[] rawValues = StringUtils.split(rawValue, ",").     if (rawValues == null) {         return Arrays.copyOf(DEFAULT_HEARTBEAT, 2).     }     return new long[] { Long.valueOf(rawValues[0]), Long.valueOf(rawValues[1]) }. }
false;public;1;3;;public void setAcceptVersion(String acceptVersion) {     setNativeHeader(STOMP_ACCEPT_VERSION_HEADER, acceptVersion). }
false;public;0;4;;public Set<String> getAcceptVersion() {     String rawValue = getFirstNativeHeader(STOMP_ACCEPT_VERSION_HEADER).     return (rawValue != null ? StringUtils.commaDelimitedListToSet(rawValue) : Collections.emptySet()). }
false;public;1;3;;public void setHost(@Nullable String host) {     setNativeHeader(STOMP_HOST_HEADER, host). }
false;public;0;4;;@Nullable public String getHost() {     return getFirstNativeHeader(STOMP_HOST_HEADER). }
false;public;1;5;;@Override public void setDestination(@Nullable String destination) {     super.setDestination(destination).     setNativeHeader(STOMP_DESTINATION_HEADER, destination). }
false;public;1;5;;@Override public void setContentType(MimeType contentType) {     super.setContentType(contentType).     setNativeHeader(STOMP_CONTENT_TYPE_HEADER, contentType.toString()). }
false;public;1;5;;@Override public void setSubscriptionId(@Nullable String subscriptionId) {     super.setSubscriptionId(subscriptionId).     trySetStompHeaderForSubscriptionId(). }
false;private;0;15;;private void trySetStompHeaderForSubscriptionId() {     String subscriptionId = getSubscriptionId().     if (subscriptionId != null) {         StompCommand command = getCommand().         if (command != null && StompCommand.MESSAGE.equals(command)) {             setNativeHeader(STOMP_SUBSCRIPTION_HEADER, subscriptionId).         } else {             SimpMessageType messageType = getMessageType().             if (SimpMessageType.SUBSCRIBE.equals(messageType) || SimpMessageType.UNSUBSCRIBE.equals(messageType)) {                 setNativeHeader(STOMP_ID_HEADER, subscriptionId).             }         }     } }
false;public;0;5;;@Nullable public Integer getContentLength() {     String header = getFirstNativeHeader(STOMP_CONTENT_LENGTH_HEADER).     return (header != null ? Integer.valueOf(header) : null). }
false;public;1;3;;public void setContentLength(int contentLength) {     setNativeHeader(STOMP_CONTENT_LENGTH_HEADER, String.valueOf(contentLength)). }
false;public;2;3;;public void setHeartbeat(long cx, long cy) {     setNativeHeader(STOMP_HEARTBEAT_HEADER, cx + "," + cy). }
false;public;1;3;;public void setAck(@Nullable String ack) {     setNativeHeader(STOMP_ACK_HEADER, ack). }
false;public;0;4;;@Nullable public String getAck() {     return getFirstNativeHeader(STOMP_ACK_HEADER). }
false;public;1;3;;public void setNack(@Nullable String nack) {     setNativeHeader(STOMP_NACK_HEADER, nack). }
false;public;0;4;;@Nullable public String getNack() {     return getFirstNativeHeader(STOMP_NACK_HEADER). }
false;public;1;3;;public void setLogin(@Nullable String login) {     setNativeHeader(STOMP_LOGIN_HEADER, login). }
false;public;0;4;;@Nullable public String getLogin() {     return getFirstNativeHeader(STOMP_LOGIN_HEADER). }
false;public;1;4;;public void setPasscode(@Nullable String passcode) {     setNativeHeader(STOMP_PASSCODE_HEADER, passcode).     protectPasscode(). }
false;private;0;7;;private void protectPasscode() {     String value = getFirstNativeHeader(STOMP_PASSCODE_HEADER).     if (value != null && !"PROTECTED".equals(value)) {         setHeader(CREDENTIALS_HEADER, new StompPasscode(value)).         setNativeHeader(STOMP_PASSCODE_HEADER, "PROTECTED").     } }
true;public;0;5;/**  * Return the passcode header value, or {@code null} if not set.  */ ;/**  * Return the passcode header value, or {@code null} if not set.  */ @Nullable public String getPasscode() {     StompPasscode credentials = (StompPasscode) getHeader(CREDENTIALS_HEADER).     return (credentials != null ? credentials.passcode : null). }
false;public;1;3;;public void setReceiptId(@Nullable String receiptId) {     setNativeHeader(STOMP_RECEIPT_ID_HEADER, receiptId). }
false;public;0;4;;@Nullable public String getReceiptId() {     return getFirstNativeHeader(STOMP_RECEIPT_ID_HEADER). }
false;public;1;3;;public void setReceipt(@Nullable String receiptId) {     setNativeHeader(STOMP_RECEIPT_HEADER, receiptId). }
false;public;0;4;;@Nullable public String getReceipt() {     return getFirstNativeHeader(STOMP_RECEIPT_HEADER). }
false;public;0;4;;@Nullable public String getMessage() {     return getFirstNativeHeader(STOMP_MESSAGE_HEADER). }
false;public;1;3;;public void setMessage(@Nullable String content) {     setNativeHeader(STOMP_MESSAGE_HEADER, content). }
false;public;0;4;;@Nullable public String getMessageId() {     return getFirstNativeHeader(STOMP_MESSAGE_ID_HEADER). }
false;public;1;3;;public void setMessageId(@Nullable String id) {     setNativeHeader(STOMP_MESSAGE_ID_HEADER, id). }
false;public;0;4;;@Nullable public String getVersion() {     return getFirstNativeHeader(STOMP_VERSION_HEADER). }
false;public;1;3;;public void setVersion(@Nullable String version) {     setNativeHeader(STOMP_VERSION_HEADER, version). }
false;public;1;27;;// Logging related @Override public String getShortLogMessage(Object payload) {     StompCommand command = getCommand().     if (StompCommand.SUBSCRIBE.equals(command)) {         return "SUBSCRIBE " + getDestination() + " id=" + getSubscriptionId() + appendSession().     } else if (StompCommand.UNSUBSCRIBE.equals(command)) {         return "UNSUBSCRIBE id=" + getSubscriptionId() + appendSession().     } else if (StompCommand.SEND.equals(command)) {         return "SEND " + getDestination() + appendSession() + appendPayload(payload).     } else if (StompCommand.CONNECT.equals(command)) {         Principal user = getUser().         return "CONNECT" + (user != null ? " user=" + user.getName() : "") + appendSession().     } else if (StompCommand.CONNECTED.equals(command)) {         return "CONNECTED heart-beat=" + Arrays.toString(getHeartbeat()) + appendSession().     } else if (StompCommand.DISCONNECT.equals(command)) {         String receipt = getReceipt().         return "DISCONNECT" + (receipt != null ? " receipt=" + receipt : "") + appendSession().     } else {         return getDetailedLogMessage(payload).     } }
false;public;1;25;;@Override public String getDetailedLogMessage(@Nullable Object payload) {     if (isHeartbeat()) {         String sessionId = getSessionId().         return "heart-beat" + (sessionId != null ? " in session " + sessionId : "").     }     StompCommand command = getCommand().     if (command == null) {         return super.getDetailedLogMessage(payload).     }     StringBuilder sb = new StringBuilder().     sb.append(command.name()).append(" ").     Map<String, List<String>> nativeHeaders = getNativeHeaders().     if (nativeHeaders != null) {         sb.append(nativeHeaders).     }     sb.append(appendSession()).     if (getUser() != null) {         sb.append(", user=").append(getUser().getName()).     }     if (payload != null && command.isBodyAllowed()) {         sb.append(appendPayload(payload)).     }     return sb.toString(). }
false;private;0;3;;private String appendSession() {     return " session=" + getSessionId(). }
false;private;1;17;;private String appendPayload(Object payload) {     if (payload.getClass() != byte[].class) {         throw new IllegalStateException("Expected byte array payload but got: " + ClassUtils.getQualifiedName(payload.getClass())).     }     byte[] bytes = (byte[]) payload.     MimeType mimeType = getContentType().     String contentType = (mimeType != null ? " " + mimeType.toString() : "").     if (bytes.length == 0 || mimeType == null || !isReadableContentType()) {         return contentType.     }     Charset charset = mimeType.getCharset().     charset = (charset != null ? charset : StandardCharsets.UTF_8).     return (bytes.length < 80) ? contentType + " payload=" + new String(bytes, charset) : contentType + " payload=" + new String(Arrays.copyOf(bytes, 80), charset) + "...(truncated)". }
true;public,static;1;3;/**  * Create an instance for the given STOMP command.  */ ;// Static factory methods and accessors /**  * Create an instance for the given STOMP command.  */ public static StompHeaderAccessor create(StompCommand command) {     return new StompHeaderAccessor(command, null). }
true;public,static;2;3;/**  * Create an instance for the given STOMP command and headers.  */ ;/**  * Create an instance for the given STOMP command and headers.  */ public static StompHeaderAccessor create(StompCommand command, Map<String, List<String>> headers) {     return new StompHeaderAccessor(command, headers). }
true;public,static;0;3;/**  * Create headers for a heartbeat. While a STOMP heartbeat frame does not  * have headers, a session id is needed for processing purposes at a minimum.  */ ;/**  * Create headers for a heartbeat. While a STOMP heartbeat frame does not  * have headers, a session id is needed for processing purposes at a minimum.  */ public static StompHeaderAccessor createForHeartbeat() {     return new StompHeaderAccessor(). }
true;public,static;1;3;/**  * Create an instance from the payload and headers of the given Message.  */ ;/**  * Create an instance from the payload and headers of the given Message.  */ public static StompHeaderAccessor wrap(Message<?> message) {     return new StompHeaderAccessor(message). }
true;public,static;1;4;/**  * Return the STOMP command from the given headers, or {@code null} if not set.  */ ;/**  * Return the STOMP command from the given headers, or {@code null} if not set.  */ @Nullable public static StompCommand getCommand(Map<String, Object> headers) {     return (StompCommand) headers.get(COMMAND_HEADER). }
true;public,static;1;5;/**  * Return the passcode header value, or {@code null} if not set.  */ ;/**  * Return the passcode header value, or {@code null} if not set.  */ @Nullable public static String getPasscode(Map<String, Object> headers) {     StompPasscode credentials = (StompPasscode) headers.get(CREDENTIALS_HEADER).     return (credentials != null ? credentials.passcode : null). }
false;public,static;1;5;;@Nullable public static Integer getContentLength(Map<String, List<String>> nativeHeaders) {     List<String> values = nativeHeaders.get(STOMP_CONTENT_LENGTH_HEADER).     return (!CollectionUtils.isEmpty(values) ? Integer.valueOf(values.get(0)) : null). }
false;public;0;4;;@Override public String toString() {     return "[PROTECTED]". }
