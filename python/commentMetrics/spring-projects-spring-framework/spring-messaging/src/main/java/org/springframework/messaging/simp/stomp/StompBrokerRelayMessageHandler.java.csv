commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the STOMP message broker host.  */ ;/**  * Set the STOMP message broker host.  */ public void setRelayHost(String relayHost) {     Assert.hasText(relayHost, "relayHost must not be empty").     this.relayHost = relayHost. }
true;public;0;3;/**  * Return the STOMP message broker host.  */ ;/**  * Return the STOMP message broker host.  */ public String getRelayHost() {     return this.relayHost. }
true;public;1;3;/**  * Set the STOMP message broker port.  */ ;/**  * Set the STOMP message broker port.  */ public void setRelayPort(int relayPort) {     this.relayPort = relayPort. }
true;public;0;3;/**  * Return the STOMP message broker port.  */ ;/**  * Return the STOMP message broker port.  */ public int getRelayPort() {     return this.relayPort. }
true;public;1;4;/**  * Set the login to use when creating connections to the STOMP broker on  * behalf of connected clients.  * <p>By default this is set to "guest".  * @see #setSystemLogin(String)  */ ;/**  * Set the login to use when creating connections to the STOMP broker on  * behalf of connected clients.  * <p>By default this is set to "guest".  * @see #setSystemLogin(String)  */ public void setClientLogin(String clientLogin) {     Assert.hasText(clientLogin, "clientLogin must not be empty").     this.clientLogin = clientLogin. }
true;public;0;3;/**  * Return the configured login to use for connections to the STOMP broker  * on behalf of connected clients.  * @see #getSystemLogin()  */ ;/**  * Return the configured login to use for connections to the STOMP broker  * on behalf of connected clients.  * @see #getSystemLogin()  */ public String getClientLogin() {     return this.clientLogin. }
true;public;1;4;/**  * Set the client passcode to use to create connections to the STOMP broker on  * behalf of connected clients.  * <p>By default this is set to "guest".  * @see #setSystemPasscode  */ ;/**  * Set the client passcode to use to create connections to the STOMP broker on  * behalf of connected clients.  * <p>By default this is set to "guest".  * @see #setSystemPasscode  */ public void setClientPasscode(String clientPasscode) {     Assert.hasText(clientPasscode, "clientPasscode must not be empty").     this.clientPasscode = clientPasscode. }
true;public;0;3;/**  * Return the configured passcode to use for connections to the STOMP broker on  * behalf of connected clients.  * @see #getSystemPasscode()  */ ;/**  * Return the configured passcode to use for connections to the STOMP broker on  * behalf of connected clients.  * @see #getSystemPasscode()  */ public String getClientPasscode() {     return this.clientPasscode. }
true;public;1;4;/**  * Set the login for the shared "system" connection used to send messages to  * the STOMP broker from within the application, i.e. messages not associated  * with a specific client session (e.g. REST/HTTP request handling method).  * <p>By default this is set to "guest".  */ ;/**  * Set the login for the shared "system" connection used to send messages to  * the STOMP broker from within the application, i.e. messages not associated  * with a specific client session (e.g. REST/HTTP request handling method).  * <p>By default this is set to "guest".  */ public void setSystemLogin(String systemLogin) {     Assert.hasText(systemLogin, "systemLogin must not be empty").     this.systemLogin = systemLogin. }
true;public;0;3;/**  * Return the login used for the shared "system" connection to the STOMP broker.  */ ;/**  * Return the login used for the shared "system" connection to the STOMP broker.  */ public String getSystemLogin() {     return this.systemLogin. }
true;public;1;3;/**  * Set the passcode for the shared "system" connection used to send messages to  * the STOMP broker from within the application, i.e. messages not associated  * with a specific client session (e.g. REST/HTTP request handling method).  * <p>By default this is set to "guest".  */ ;/**  * Set the passcode for the shared "system" connection used to send messages to  * the STOMP broker from within the application, i.e. messages not associated  * with a specific client session (e.g. REST/HTTP request handling method).  * <p>By default this is set to "guest".  */ public void setSystemPasscode(String systemPasscode) {     this.systemPasscode = systemPasscode. }
true;public;0;3;/**  * Return the passcode used for the shared "system" connection to the STOMP broker.  */ ;/**  * Return the passcode used for the shared "system" connection to the STOMP broker.  */ public String getSystemPasscode() {     return this.systemPasscode. }
true;public;1;3;/**  * Set the interval, in milliseconds, at which the "system" connection will, in the  * absence of any other data being sent, send a heartbeat to the STOMP broker. A value  * of zero will prevent heartbeats from being sent to the broker.  * <p>The default value is 10000.  * <p>See class-level documentation for more information on the "system" connection.  */ ;/**  * Set the interval, in milliseconds, at which the "system" connection will, in the  * absence of any other data being sent, send a heartbeat to the STOMP broker. A value  * of zero will prevent heartbeats from being sent to the broker.  * <p>The default value is 10000.  * <p>See class-level documentation for more information on the "system" connection.  */ public void setSystemHeartbeatSendInterval(long systemHeartbeatSendInterval) {     this.systemHeartbeatSendInterval = systemHeartbeatSendInterval. }
true;public;0;3;/**  * Return the interval, in milliseconds, at which the "system" connection will  * send heartbeats to the STOMP broker.  */ ;/**  * Return the interval, in milliseconds, at which the "system" connection will  * send heartbeats to the STOMP broker.  */ public long getSystemHeartbeatSendInterval() {     return this.systemHeartbeatSendInterval. }
true;public;1;3;/**  * Set the maximum interval, in milliseconds, at which the "system" connection  * expects, in the absence of any other data, to receive a heartbeat from the STOMP  * broker. A value of zero will configure the connection to expect not to receive  * heartbeats from the broker.  * <p>The default value is 10000.  * <p>See class-level documentation for more information on the "system" connection.  */ ;/**  * Set the maximum interval, in milliseconds, at which the "system" connection  * expects, in the absence of any other data, to receive a heartbeat from the STOMP  * broker. A value of zero will configure the connection to expect not to receive  * heartbeats from the broker.  * <p>The default value is 10000.  * <p>See class-level documentation for more information on the "system" connection.  */ public void setSystemHeartbeatReceiveInterval(long heartbeatReceiveInterval) {     this.systemHeartbeatReceiveInterval = heartbeatReceiveInterval. }
true;public;0;3;/**  * Return the interval, in milliseconds, at which the "system" connection expects  * to receive heartbeats from the STOMP broker.  */ ;/**  * Return the interval, in milliseconds, at which the "system" connection expects  * to receive heartbeats from the STOMP broker.  */ public long getSystemHeartbeatReceiveInterval() {     return this.systemHeartbeatReceiveInterval. }
true;public;1;6;/**  * Configure one more destinations to subscribe to on the shared "system"  * connection along with MessageHandler's to handle received messages.  * <p>This is for internal use in a multi-application server scenario where  * servers forward messages to each other (e.g. unresolved user destinations).  * @param subscriptions the destinations to subscribe to.  */ ;/**  * Configure one more destinations to subscribe to on the shared "system"  * connection along with MessageHandler's to handle received messages.  * <p>This is for internal use in a multi-application server scenario where  * servers forward messages to each other (e.g. unresolved user destinations).  * @param subscriptions the destinations to subscribe to.  */ public void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {     this.systemSubscriptions.clear().     if (subscriptions != null) {         this.systemSubscriptions.putAll(subscriptions).     } }
true;public;0;3;/**  * Return the configured map with subscriptions on the "system" connection.  */ ;/**  * Return the configured map with subscriptions on the "system" connection.  */ public Map<String, MessageHandler> getSystemSubscriptions() {     return this.systemSubscriptions. }
true;public;1;3;/**  * Set the value of the "host" header to use in STOMP CONNECT frames. When this  * property is configured, a "host" header will be added to every STOMP frame sent to  * the STOMP broker. This may be useful for example in a cloud environment where the  * actual host to which the TCP connection is established is different from the host  * providing the cloud-based STOMP service.  * <p>By default this property is not set.  */ ;/**  * Set the value of the "host" header to use in STOMP CONNECT frames. When this  * property is configured, a "host" header will be added to every STOMP frame sent to  * the STOMP broker. This may be useful for example in a cloud environment where the  * actual host to which the TCP connection is established is different from the host  * providing the cloud-based STOMP service.  * <p>By default this property is not set.  */ public void setVirtualHost(@Nullable String virtualHost) {     this.virtualHost = virtualHost. }
true;public;0;4;/**  * Return the configured virtual host value.  */ ;/**  * Return the configured virtual host value.  */ @Nullable public String getVirtualHost() {     return this.virtualHost. }
true;public;1;3;/**  * Configure a TCP client for managing TCP connections to the STOMP broker.  * <p>By default {@link ReactorNettyTcpClient} is used.  * <p><strong>Note:</strong> when this property is used, any  * {@link #setRelayHost(String) host} or {@link #setRelayPort(int) port}  * specified are effectively ignored.  */ ;/**  * Configure a TCP client for managing TCP connections to the STOMP broker.  * <p>By default {@link ReactorNettyTcpClient} is used.  * <p><strong>Note:</strong> when this property is used, any  * {@link #setRelayHost(String) host} or {@link #setRelayPort(int) port}  * specified are effectively ignored.  */ public void setTcpClient(@Nullable TcpOperations<byte[]> tcpClient) {     this.tcpClient = tcpClient. }
true;public;0;4;/**  * Get the configured TCP client (never {@code null} unless not configured  * invoked and this method is invoked before the handler is started and  * hence a default implementation initialized).  */ ;/**  * Get the configured TCP client (never {@code null} unless not configured  * invoked and this method is invoked before the handler is started and  * hence a default implementation initialized).  */ @Nullable public TcpOperations<byte[]> getTcpClient() {     return this.tcpClient. }
true;public;1;3;/**  * Configure a {@link MessageHeaderInitializer} to apply to the headers of all  * messages created through the {@code StompBrokerRelayMessageHandler} that  * are sent to the client outbound message channel.  * <p>By default this property is not set.  */ ;/**  * Configure a {@link MessageHeaderInitializer} to apply to the headers of all  * messages created through the {@code StompBrokerRelayMessageHandler} that  * are sent to the client outbound message channel.  * <p>By default this property is not set.  */ public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {     this.headerInitializer = headerInitializer. }
true;public;0;4;/**  * Return the configured header initializer.  */ ;/**  * Return the configured header initializer.  */ @Nullable public MessageHeaderInitializer getHeaderInitializer() {     return this.headerInitializer. }
true;public;0;3;/**  * Return a String describing internal state and counters.  */ ;/**  * Return a String describing internal state and counters.  */ public String getStatsInfo() {     return this.stats.toString(). }
true;public;0;3;/**  * Return the current count of TCP connection to the broker.  */ ;/**  * Return the current count of TCP connection to the broker.  */ public int getConnectionCount() {     return this.connectionHandlers.size(). }
false;protected;0;30;;@Override protected void startInternal() {     if (this.tcpClient == null) {         this.tcpClient = initTcpClient().     }     if (logger.isInfoEnabled()) {         logger.info("Starting \"system\" session, " + toString()).     }     StompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.CONNECT).     accessor.setAcceptVersion("1.1,1.2").     accessor.setLogin(this.systemLogin).     accessor.setPasscode(this.systemPasscode).     accessor.setHeartbeat(this.systemHeartbeatSendInterval, this.systemHeartbeatReceiveInterval).     String virtualHost = getVirtualHost().     if (virtualHost != null) {         accessor.setHost(virtualHost).     }     accessor.setSessionId(SYSTEM_SESSION_ID).     if (logger.isDebugEnabled()) {         logger.debug("Forwarding " + accessor.getShortLogMessage(EMPTY_PAYLOAD)).     }     SystemStompConnectionHandler handler = new SystemStompConnectionHandler(accessor).     this.connectionHandlers.put(handler.getSessionId(), handler).     this.stats.incrementConnectCount().     this.tcpClient.connect(handler, new FixedIntervalReconnectStrategy(5000)). }
false;private;0;10;;private ReactorNettyTcpClient<byte[]> initTcpClient() {     StompDecoder decoder = new StompDecoder().     if (this.headerInitializer != null) {         decoder.setHeaderInitializer(this.headerInitializer).     }     ReactorNettyCodec<byte[]> codec = new StompReactorNettyCodec(decoder).     ReactorNettyTcpClient<byte[]> client = new ReactorNettyTcpClient<>(this.relayHost, this.relayPort, codec).     client.setLogger(SimpLogging.forLog(client.getLogger())).     return client. }
false;protected;0;12;;@Override protected void stopInternal() {     publishBrokerUnavailableEvent().     if (this.tcpClient != null) {         try {             this.tcpClient.shutdown().get(5000, TimeUnit.MILLISECONDS).         } catch (Throwable ex) {             logger.error("Error in shutdown of TCP client", ex).         }     } }
false;protected;1;109;;@Override protected void handleMessageInternal(Message<?> message) {     String sessionId = SimpMessageHeaderAccessor.getSessionId(message.getHeaders()).     if (!isBrokerAvailable()) {         if (sessionId == null || SYSTEM_SESSION_ID.equals(sessionId)) {             throw new MessageDeliveryException("Message broker not active. Consider subscribing to " + "receive BrokerAvailabilityEvent's from an ApplicationListener Spring bean.").         }         StompConnectionHandler handler = this.connectionHandlers.get(sessionId).         if (handler != null) {             handler.sendStompErrorFrameToClient("Broker not available.").             handler.clearConnection().         } else {             StompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.ERROR).             if (getHeaderInitializer() != null) {                 getHeaderInitializer().initHeaders(accessor).             }             accessor.setSessionId(sessionId).             Principal user = SimpMessageHeaderAccessor.getUser(message.getHeaders()).             if (user != null) {                 accessor.setUser(user).             }             accessor.setMessage("Broker not available.").             MessageHeaders headers = accessor.getMessageHeaders().             getClientOutboundChannel().send(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers)).         }         return.     }     StompHeaderAccessor stompAccessor.     StompCommand command.     MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class).     if (accessor == null) {         throw new IllegalStateException("No header accessor (not using the SimpMessagingTemplate?): " + message).     } else if (accessor instanceof StompHeaderAccessor) {         stompAccessor = (StompHeaderAccessor) accessor.         command = stompAccessor.getCommand().     } else if (accessor instanceof SimpMessageHeaderAccessor) {         stompAccessor = StompHeaderAccessor.wrap(message).         command = stompAccessor.getCommand().         if (command == null) {             command = stompAccessor.updateStompCommandAsClientMessage().         }     } else {         throw new IllegalStateException("Unexpected header accessor type " + accessor.getClass() + " in " + message).     }     if (sessionId == null) {         if (!SimpMessageType.MESSAGE.equals(stompAccessor.getMessageType())) {             if (logger.isErrorEnabled()) {                 logger.error("Only STOMP SEND supported from within the server side. Ignoring " + message).             }             return.         }         sessionId = SYSTEM_SESSION_ID.         stompAccessor.setSessionId(sessionId).     }     String destination = stompAccessor.getDestination().     if (command != null && command.requiresDestination() && !checkDestinationPrefix(destination)) {         return.     }     if (StompCommand.CONNECT.equals(command)) {         if (logger.isDebugEnabled()) {             logger.debug(stompAccessor.getShortLogMessage(EMPTY_PAYLOAD)).         }         stompAccessor = (stompAccessor.isMutable() ? stompAccessor : StompHeaderAccessor.wrap(message)).         stompAccessor.setLogin(this.clientLogin).         stompAccessor.setPasscode(this.clientPasscode).         if (getVirtualHost() != null) {             stompAccessor.setHost(getVirtualHost()).         }         StompConnectionHandler handler = new StompConnectionHandler(sessionId, stompAccessor).         this.connectionHandlers.put(sessionId, handler).         this.stats.incrementConnectCount().         Assert.state(this.tcpClient != null, "No TCP client available").         this.tcpClient.connect(handler).     } else if (StompCommand.DISCONNECT.equals(command)) {         StompConnectionHandler handler = this.connectionHandlers.get(sessionId).         if (handler == null) {             if (logger.isDebugEnabled()) {                 logger.debug("Ignoring DISCONNECT in session " + sessionId + ". Connection already cleaned up.").             }             return.         }         this.stats.incrementDisconnectCount().         handler.forward(message, stompAccessor).     } else {         StompConnectionHandler handler = this.connectionHandlers.get(sessionId).         if (handler == null) {             if (logger.isDebugEnabled()) {                 logger.debug("No TCP connection for session " + sessionId + " in " + message).             }             return.         }         handler.forward(message, stompAccessor).     } }
false;public;0;4;;@Override public String toString() {     return "StompBrokerRelay[" + getTcpClientInfo() + "]". }
false;private;0;3;;private String getTcpClientInfo() {     return this.tcpClient != null ? this.tcpClient.toString() : this.relayHost + ":" + this.relayPort. }
false;public;0;3;;public String getSessionId() {     return this.sessionId. }
false;protected;0;4;;@Nullable protected TcpConnection<byte[]> getTcpConnection() {     return this.tcpConnection. }
false;public;1;14;;@Override public void afterConnected(TcpConnection<byte[]> connection) {     if (logger.isDebugEnabled()) {         logger.debug("TCP connection opened in session=" + getSessionId()).     }     this.tcpConnection = connection.     connection.onReadInactivity(() -> {         if (this.tcpConnection != null && !this.isStompConnected) {             handleTcpConnectionFailure("No CONNECTED frame received in " + MAX_TIME_TO_CONNECTED_FRAME + " ms.", null).         }     }, MAX_TIME_TO_CONNECTED_FRAME).     connection.send(MessageBuilder.createMessage(EMPTY_PAYLOAD, this.connectHeaders.getMessageHeaders())). }
false;public;1;4;;@Override public void afterConnectFailure(Throwable ex) {     handleTcpConnectionFailure("Failed to connect: " + ex.getMessage(), ex). }
true;protected;2;18;/**  * Invoked when any TCP connectivity issue is detected, i.e. failure to establish  * the TCP connection, failure to send a message, missed heartbeat, etc.  */ ;/**  * Invoked when any TCP connectivity issue is detected, i.e. failure to establish  * the TCP connection, failure to send a message, missed heartbeat, etc.  */ protected void handleTcpConnectionFailure(String error, @Nullable Throwable ex) {     if (logger.isInfoEnabled()) {         logger.info("TCP connection failure in session " + this.sessionId + ": " + error, ex).     }     try {         sendStompErrorFrameToClient(error).     } finally {         try {             clearConnection().         } catch (Throwable ex2) {             if (logger.isDebugEnabled()) {                 logger.debug("Failure while clearing TCP connection state in session " + this.sessionId, ex2).             }         }     } }
false;private;1;17;;private void sendStompErrorFrameToClient(String errorText) {     if (this.isRemoteClientSession) {         StompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.ERROR).         if (getHeaderInitializer() != null) {             getHeaderInitializer().initHeaders(accessor).         }         accessor.setSessionId(this.sessionId).         Principal user = this.connectHeaders.getUser().         if (user != null) {             accessor.setUser(user).         }         accessor.setMessage(errorText).         accessor.setLeaveMutable(true).         Message<?> errorMessage = MessageBuilder.createMessage(EMPTY_PAYLOAD, accessor.getMessageHeaders()).         handleInboundMessage(errorMessage).     } }
false;protected;1;5;;protected void handleInboundMessage(Message<?> message) {     if (this.isRemoteClientSession) {         this.outboundChannel.send(message).     } }
false;public;1;26;;@Override public void handleMessage(Message<byte[]> message) {     StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class).     Assert.state(accessor != null, "No StompHeaderAccessor").     accessor.setSessionId(this.sessionId).     Principal user = this.connectHeaders.getUser().     if (user != null) {         accessor.setUser(user).     }     StompCommand command = accessor.getCommand().     if (StompCommand.CONNECTED.equals(command)) {         if (logger.isDebugEnabled()) {             logger.debug("Received " + accessor.getShortLogMessage(EMPTY_PAYLOAD)).         }         afterStompConnected(accessor).     } else if (logger.isErrorEnabled() && StompCommand.ERROR.equals(command)) {         logger.error("Received " + accessor.getShortLogMessage(message.getPayload())).     } else if (logger.isTraceEnabled()) {         logger.trace("Received " + accessor.getDetailedLogMessage(message.getPayload())).     }     handleInboundMessage(message). }
true;protected;1;5;/**  * Invoked after the STOMP CONNECTED frame is received. At this point the  * connection is ready for sending STOMP messages to the broker.  */ ;/**  * Invoked after the STOMP CONNECTED frame is received. At this point the  * connection is ready for sending STOMP messages to the broker.  */ protected void afterStompConnected(StompHeaderAccessor connectedHeaders) {     this.isStompConnected = true.     stats.incrementConnectedCount().     initHeartbeats(connectedHeaders). }
false;private;1;27;;private void initHeartbeats(StompHeaderAccessor connectedHeaders) {     if (this.isRemoteClientSession) {         return.     }     TcpConnection<byte[]> con = this.tcpConnection.     Assert.state(con != null, "No TcpConnection available").     long clientSendInterval = this.connectHeaders.getHeartbeat()[0].     long clientReceiveInterval = this.connectHeaders.getHeartbeat()[1].     long serverSendInterval = connectedHeaders.getHeartbeat()[0].     long serverReceiveInterval = connectedHeaders.getHeartbeat()[1].     if (clientSendInterval > 0 && serverReceiveInterval > 0) {         long interval = Math.max(clientSendInterval, serverReceiveInterval).         con.onWriteInactivity(() -> con.send(HEARTBEAT_MESSAGE).addCallback(result -> {         }, ex -> handleTcpConnectionFailure("Failed to forward heartbeat: " + ex.getMessage(), ex)), interval).     }     if (clientReceiveInterval > 0 && serverSendInterval > 0) {         final long interval = Math.max(clientReceiveInterval, serverSendInterval) * HEARTBEAT_MULTIPLIER.         con.onReadInactivity(() -> handleTcpConnectionFailure("No messages received in " + interval + " ms.", null), interval).     } }
false;public;1;9;;@Override public void handleFailure(Throwable ex) {     if (this.tcpConnection != null) {         handleTcpConnectionFailure("Transport failure: " + ex.getMessage(), ex).     } else if (logger.isErrorEnabled()) {         logger.error("Transport failure: " + ex).     } }
false;public;0;22;;@Override public void afterConnectionClosed() {     if (this.tcpConnection == null) {         return.     }     try {         if (logger.isDebugEnabled()) {             logger.debug("TCP connection to broker closed in session " + this.sessionId).         }         sendStompErrorFrameToClient("Connection to broker closed.").     } finally {         try {             // Prevent clearConnection() from trying to close             this.tcpConnection = null.             clearConnection().         } catch (Throwable ex) {         // Shouldn't happen with connection reset beforehand         }     } }
false;public;1;6;;@Override public void onSuccess(@Nullable Void result) {     if (accessor.getCommand() == StompCommand.DISCONNECT) {         afterDisconnectSent(accessor).     } }
false;public;1;10;;@Override public void onFailure(Throwable ex) {     if (tcpConnection != null) {         handleTcpConnectionFailure("failed to forward " + accessor.getShortLogMessage(message.getPayload()), ex).     } else if (logger.isErrorEnabled()) {         logger.error("Failed to forward " + accessor.getShortLogMessage(message.getPayload())).     } }
true;public;2;54;/**  * Forward the given message to the STOMP broker.  * <p>The method checks whether we have an active TCP connection and have  * received the STOMP CONNECTED frame. For client messages this should be  * false only if we lose the TCP connection around the same time when a  * client message is being forwarded, so we simply log the ignored message  * at debug level. For messages from within the application being sent on  * the "system" connection an exception is raised so that components sending  * the message have a chance to handle it -- by default the broker message  * channel is synchronous.  * <p>Note that if messages arrive concurrently around the same time a TCP  * connection is lost, there is a brief period of time before the connection  * is reset when one or more messages may sneak through and an attempt made  * to forward them. Rather than synchronizing to guard against that, this  * method simply lets them try and fail. For client sessions that may  * result in an additional STOMP ERROR frame(s) being sent downstream but  * code handling that downstream should be idempotent in such cases.  * @param message the message to send (never {@code null})  * @return a future to wait for the result  */ ;/**  * Forward the given message to the STOMP broker.  * <p>The method checks whether we have an active TCP connection and have  * received the STOMP CONNECTED frame. For client messages this should be  * false only if we lose the TCP connection around the same time when a  * client message is being forwarded, so we simply log the ignored message  * at debug level. For messages from within the application being sent on  * the "system" connection an exception is raised so that components sending  * the message have a chance to handle it -- by default the broker message  * channel is synchronous.  * <p>Note that if messages arrive concurrently around the same time a TCP  * connection is lost, there is a brief period of time before the connection  * is reset when one or more messages may sneak through and an attempt made  * to forward them. Rather than synchronizing to guard against that, this  * method simply lets them try and fail. For client sessions that may  * result in an additional STOMP ERROR frame(s) being sent downstream but  * code handling that downstream should be idempotent in such cases.  * @param message the message to send (never {@code null})  * @return a future to wait for the result  */ @SuppressWarnings("unchecked") public ListenableFuture<Void> forward(final Message<?> message, final StompHeaderAccessor accessor) {     TcpConnection<byte[]> conn = this.tcpConnection.     if (!this.isStompConnected || conn == null) {         if (this.isRemoteClientSession) {             if (logger.isDebugEnabled()) {                 logger.debug("TCP connection closed already, ignoring " + accessor.getShortLogMessage(message.getPayload())).             }             return EMPTY_TASK.         } else {             throw new IllegalStateException("Cannot forward messages " + (conn != null ? "before STOMP CONNECTED. " : "while inactive. ") + "Consider subscribing to receive BrokerAvailabilityEvent's from " + "an ApplicationListener Spring bean. Dropped " + accessor.getShortLogMessage(message.getPayload())).         }     }     final Message<?> messageToSend = (accessor.isMutable() && accessor.isModified()) ? MessageBuilder.createMessage(message.getPayload(), accessor.getMessageHeaders()) : message.     StompCommand command = accessor.getCommand().     if (logger.isDebugEnabled() && (StompCommand.SEND.equals(command) || StompCommand.SUBSCRIBE.equals(command) || StompCommand.UNSUBSCRIBE.equals(command) || StompCommand.DISCONNECT.equals(command))) {         logger.debug("Forwarding " + accessor.getShortLogMessage(message.getPayload())).     } else if (logger.isTraceEnabled()) {         logger.trace("Forwarding " + accessor.getDetailedLogMessage(message.getPayload())).     }     ListenableFuture<Void> future = conn.send((Message<byte[]>) messageToSend).     future.addCallback(new ListenableFutureCallback<Void>() {          @Override         public void onSuccess(@Nullable Void result) {             if (accessor.getCommand() == StompCommand.DISCONNECT) {                 afterDisconnectSent(accessor).             }         }          @Override         public void onFailure(Throwable ex) {             if (tcpConnection != null) {                 handleTcpConnectionFailure("failed to forward " + accessor.getShortLogMessage(message.getPayload()), ex).             } else if (logger.isErrorEnabled()) {                 logger.error("Failed to forward " + accessor.getShortLogMessage(message.getPayload())).             }         }     }).     return future. }
true;private;1;12;/**  * After a DISCONNECT there should be no more client frames so we can  * close the connection pro-actively. However, if the DISCONNECT has a  * receipt header we leave the connection open and expect the server will  * respond with a RECEIPT and then close the connection.  * @see <a href="http://stomp.github.io/stomp-specification-1.2.html#DISCONNECT">  *     STOMP Specification 1.2 DISCONNECT</a>  */ ;/**  * After a DISCONNECT there should be no more client frames so we can  * close the connection pro-actively. However, if the DISCONNECT has a  * receipt header we leave the connection open and expect the server will  * respond with a RECEIPT and then close the connection.  * @see <a href="http://stomp.github.io/stomp-specification-1.2.html#DISCONNECT">  *     STOMP Specification 1.2 DISCONNECT</a>  */ private void afterDisconnectSent(StompHeaderAccessor accessor) {     if (accessor.getReceipt() == null) {         try {             clearConnection().         } catch (Throwable ex) {             if (logger.isDebugEnabled()) {                 logger.debug("Failure while clearing TCP connection state in session " + this.sessionId, ex).             }         }     } }
true;public;0;20;/**  * Clean up state associated with the connection and close it.  * Any exception arising from closing the connection are propagated.  */ ;/**  * Clean up state associated with the connection and close it.  * Any exception arising from closing the connection are propagated.  */ public void clearConnection() {     if (logger.isDebugEnabled()) {         logger.debug("Cleaning up connection state for session " + this.sessionId).     }     if (this.isRemoteClientSession) {         StompBrokerRelayMessageHandler.this.connectionHandlers.remove(this.sessionId).     }     this.isStompConnected = false.     TcpConnection<byte[]> conn = this.tcpConnection.     this.tcpConnection = null.     if (conn != null) {         if (logger.isDebugEnabled()) {             logger.debug("Closing TCP connection in session " + this.sessionId).         }         conn.close().     } }
false;public;0;4;;@Override public String toString() {     return "StompConnectionHandler[sessionId=" + this.sessionId + "]". }
false;protected;1;9;;@Override protected void afterStompConnected(StompHeaderAccessor connectedHeaders) {     if (logger.isInfoEnabled()) {         logger.info("\"System\" session connected.").     }     super.afterStompConnected(connectedHeaders).     publishBrokerAvailableEvent().     sendSystemSubscriptions(). }
false;private;0;21;;private void sendSystemSubscriptions() {     int i = 0.     for (String destination : getSystemSubscriptions().keySet()) {         StompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.SUBSCRIBE).         accessor.setSubscriptionId(String.valueOf(i++)).         accessor.setDestination(destination).         if (logger.isDebugEnabled()) {             logger.debug("Subscribing to " + destination + " on \"system\" connection.").         }         TcpConnection<byte[]> conn = getTcpConnection().         if (conn != null) {             MessageHeaders headers = accessor.getMessageHeaders().             conn.send(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers)).addCallback(result -> {             }, ex -> {                 String error = "Failed to subscribe in \"system\" session.".                 handleTcpConnectionFailure(error, ex).             }).         }     } }
false;protected;1;30;;@Override protected void handleInboundMessage(Message<?> message) {     StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class).     if (accessor != null && StompCommand.MESSAGE.equals(accessor.getCommand())) {         String destination = accessor.getDestination().         if (destination == null) {             if (logger.isDebugEnabled()) {                 logger.debug("Got message on \"system\" connection, with no destination: " + accessor.getDetailedLogMessage(message.getPayload())).             }             return.         }         if (!getSystemSubscriptions().containsKey(destination)) {             if (logger.isDebugEnabled()) {                 logger.debug("Got message on \"system\" connection with no handler: " + accessor.getDetailedLogMessage(message.getPayload())).             }             return.         }         try {             MessageHandler handler = getSystemSubscriptions().get(destination).             handler.handleMessage(message).         } catch (Throwable ex) {             if (logger.isDebugEnabled()) {                 logger.debug("Error while handling message on \"system\" connection.", ex).             }         }     } }
false;protected;2;5;;@Override protected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex) {     super.handleTcpConnectionFailure(errorMessage, ex).     publishBrokerUnavailableEvent(). }
false;public;0;5;;@Override public void afterConnectionClosed() {     super.afterConnectionClosed().     publishBrokerUnavailableEvent(). }
false;public;2;13;;@Override public ListenableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor) {     try {         ListenableFuture<Void> future = super.forward(message, accessor).         if (message.getHeaders().get(SimpMessageHeaderAccessor.IGNORE_ERROR) == null) {             future.get().         }         return future.     } catch (Throwable ex) {         throw new MessageDeliveryException(message, ex).     } }
false;public;0;4;;@Override public Void call() {     return null. }
false;public;0;3;;public void incrementConnectCount() {     this.connect.incrementAndGet(). }
false;public;0;3;;public void incrementConnectedCount() {     this.connected.incrementAndGet(). }
false;public;0;3;;public void incrementDisconnectCount() {     this.disconnect.incrementAndGet(). }
false;public;0;6;;public String toString() {     return (connectionHandlers.size() + " sessions, " + getTcpClientInfo() + (isBrokerAvailable() ? " (available)" : " (not available)") + ", processed CONNECT(" + this.connect.get() + ")-CONNECTED(" + this.connected.get() + ")-DISCONNECT(" + this.disconnect.get() + ")"). }
