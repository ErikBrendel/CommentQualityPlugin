commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;11;;private static Set<String> prependLeadingSlash(Collection<String> patterns, PathMatcher pathMatcher) {     boolean slashSeparator = pathMatcher.combine("a", "a").equals("a/a").     Set<String> result = new LinkedHashSet<>(patterns.size()).     for (String pattern : patterns) {         if (slashSeparator && StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {             pattern = "/" + pattern.         }         result.add(pattern).     }     return result. }
false;public;0;3;;public Set<String> getPatterns() {     return this.patterns. }
false;protected;0;4;;@Override protected Collection<String> getContent() {     return this.patterns. }
false;protected;0;4;;@Override protected String getToStringInfix() {     return " || ". }
true;public;1;21;/**  * Returns a new instance with URL patterns from the current instance ("this") and  * the "other" instance as follows:  * <ul>  * <li>If there are patterns in both instances, combine the patterns in "this" with  * the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}.  * <li>If only one instance has patterns, use them.  * <li>If neither instance has patterns, use an empty String (i.e. "").  * </ul>  */ ;/**  * Returns a new instance with URL patterns from the current instance ("this") and  * the "other" instance as follows:  * <ul>  * <li>If there are patterns in both instances, combine the patterns in "this" with  * the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}.  * <li>If only one instance has patterns, use them.  * <li>If neither instance has patterns, use an empty String (i.e. "").  * </ul>  */ @Override public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {     Set<String> result = new LinkedHashSet<>().     if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {         for (String pattern1 : this.patterns) {             for (String pattern2 : other.patterns) {                 result.add(this.pathMatcher.combine(pattern1, pattern2)).             }         }     } else if (!this.patterns.isEmpty()) {         result.addAll(this.patterns).     } else if (!other.patterns.isEmpty()) {         result.addAll(other.patterns).     } else {         result.add("").     }     return new DestinationPatternsMessageCondition(result, this.pathMatcher). }
true;public;1;24;/**  * Check if any of the patterns match the given Message destination and return an instance  * that is guaranteed to contain matching patterns, sorted via  * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.  * @param message the message to match to  * @return the same instance if the condition contains no patterns.  * or a new condition with sorted matching patterns.  * or {@code null} either if a destination can not be extracted or there is no match  */ ;/**  * Check if any of the patterns match the given Message destination and return an instance  * that is guaranteed to contain matching patterns, sorted via  * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.  * @param message the message to match to  * @return the same instance if the condition contains no patterns.  * or a new condition with sorted matching patterns.  * or {@code null} either if a destination can not be extracted or there is no match  */ @Override @Nullable public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {     String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER).     if (destination == null) {         return null.     }     if (this.patterns.isEmpty()) {         return this.     }     List<String> matches = new ArrayList<>().     for (String pattern : this.patterns) {         if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {             matches.add(pattern).         }     }     if (matches.isEmpty()) {         return null.     }     matches.sort(this.pathMatcher.getPatternComparator(destination)).     return new DestinationPatternsMessageCondition(matches, this.pathMatcher). }
true;public;2;27;/**  * Compare the two conditions based on the destination patterns they contain.  * Patterns are compared one at a time, from top to bottom via  * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.  * If all compared patterns match equally, but one instance has more patterns,  * it is considered a closer match.  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(Message)} to ensure they contain only patterns  * that match the request and are sorted with the best matches on top.  */ ;/**  * Compare the two conditions based on the destination patterns they contain.  * Patterns are compared one at a time, from top to bottom via  * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.  * If all compared patterns match equally, but one instance has more patterns,  * it is considered a closer match.  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(Message)} to ensure they contain only patterns  * that match the request and are sorted with the best matches on top.  */ @Override public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {     String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER).     if (destination == null) {         return 0.     }     Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination).     Iterator<String> iterator = this.patterns.iterator().     Iterator<String> iteratorOther = other.patterns.iterator().     while (iterator.hasNext() && iteratorOther.hasNext()) {         int result = patternComparator.compare(iterator.next(), iteratorOther.next()).         if (result != 0) {             return result.         }     }     if (iterator.hasNext()) {         return -1.     } else if (iteratorOther.hasNext()) {         return 1.     } else {         return 0.     } }
