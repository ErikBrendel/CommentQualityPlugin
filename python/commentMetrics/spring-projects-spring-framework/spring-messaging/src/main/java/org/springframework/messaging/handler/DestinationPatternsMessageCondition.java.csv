# id;timestamp;commentText;codeText;commentWords;codeWords
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1386350678;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1405378164;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher, false)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher,false
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1405378165;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1407154420;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1414619099;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1414847132;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1449703897;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1467730834;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1474905889;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1496837955;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1502974979;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1508532146;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1518772998;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1520529117;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other);1530174524;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link org.springframework.util.PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new DestinationPatternsMessageCondition(result, this.pathMatcher)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,org,springframework,util,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,destination,patterns,message,condition,combine,destination,patterns,message,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,destination,patterns,message,condition,result,this,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1386350678;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1405378164;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null, true)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null,true
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1405378165;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1407154420;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1414619099;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1414847132;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1449703897;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1467730834;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1474905889;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1496837955;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1502974979;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1508532146;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1518772998;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1520529117;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String... patterns);1530174524;Creates a new instance with the given destination patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public DestinationPatternsMessageCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,destination,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,destination,patterns,message,condition,string,patterns,this,patterns,null
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1386350678;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1405378164;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1405378165;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1407154420;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1414619099;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1414847132;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1449703897;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1467730834;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1474905889;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1496837955;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return 0__		}_		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,0,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1502974979;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return 0__		}_		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,0,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1508532146;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return 0__		}_		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,0,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1518772998;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return 0__		}_		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)___		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,0,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1520529117;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they contain only patterns_that match the request and are sorted with the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return 0__		}__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}__		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,0,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message);1530174524;Compare the two conditions based on the destination patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._If all compared patterns match equally, but one instance has more patterns,_it is considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(Message)} to ensure they contain only patterns_that match the request and are sorted with the best matches on top.;@Override_	public int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return 0__		}__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(destination)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}__		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,destination,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,message,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,destination,patterns,message,condition,other,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,0,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,destination,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
DestinationPatternsMessageCondition -> @Override 	@Nullable 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1502974979;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	@Nullable_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,nullable,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	@Nullable 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1508532146;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	@Nullable_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,nullable,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	@Nullable 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1518772998;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	@Nullable_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		matches.sort(this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,nullable,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,matches,sort,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	@Nullable 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1520529117;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	@Nullable_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}_		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}_		if (matches.isEmpty()) {_			return null__		}__		matches.sort(this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,nullable,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,matches,sort,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	@Nullable 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1530174524;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	@Nullable_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}_		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}_		if (matches.isEmpty()) {_			return null__		}__		matches.sort(this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,nullable,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,matches,sort,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1405378164;Additional constructor with a customized path matcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the customized path matcher to use with patterns;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher, true)__	};additional,constructor,with,a,customized,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,customized,path,matcher,to,use,with,patterns;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher,true
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1405378165;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use.;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1407154420;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use.;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1414619099;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use.;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1414847132;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1449703897;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1467730834;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher);1474905889;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, PathMatcher pathMatcher) {_		this(asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,path,matcher,path,matcher,this,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1386350678;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1405378164;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher, false)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher,false
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1405378165;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1407154420;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1414619099;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1414847132;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1449703897;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1467730834;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1474905889;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> @Override 	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message);1496837955;Check if any of the patterns match the given Message destination and return an instance_that is guaranteed to contain matching patterns, sorted via_{@link org.springframework.util.PathMatcher#getPatternComparator(String)}._@param message the message to match to_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} either if a destination can not be extracted or there is no match;@Override_	public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {_		String destination = (String) message.getHeaders().get(LOOKUP_DESTINATION_HEADER)__		if (destination == null) {_			return null__		}__		if (this.patterns.isEmpty()) {_			return this__		}__		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			if (pattern.equals(destination) || this.pathMatcher.match(pattern, destination)) {_				matches.add(pattern)__			}_		}__		if (matches.isEmpty()) {_			return null__		}__		Collections.sort(matches, this.pathMatcher.getPatternComparator(destination))__		return new DestinationPatternsMessageCondition(matches, this.pathMatcher)__	};check,if,any,of,the,patterns,match,the,given,message,destination,and,return,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,org,springframework,util,path,matcher,get,pattern,comparator,string,param,message,the,message,to,match,to,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,either,if,a,destination,can,not,be,extracted,or,there,is,no,match;override,public,destination,patterns,message,condition,get,matching,condition,message,message,string,destination,string,message,get,headers,get,if,destination,null,return,null,if,this,patterns,is,empty,return,this,list,string,matches,new,array,list,for,string,pattern,this,patterns,if,pattern,equals,destination,this,path,matcher,match,pattern,destination,matches,add,pattern,if,matches,is,empty,return,null,collections,sort,matches,this,path,matcher,get,pattern,comparator,destination,return,new,destination,patterns,message,condition,matches,this,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher);1496837955;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher) {_		this(Arrays.asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,nullable,path,matcher,path,matcher,this,arrays,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher);1502974979;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher) {_		this(Arrays.asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,nullable,path,matcher,path,matcher,this,arrays,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher);1508532146;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher) {_		this(Arrays.asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,nullable,path,matcher,path,matcher,this,arrays,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher);1518772998;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher) {_		this(Arrays.asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,nullable,path,matcher,path,matcher,this,arrays,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher);1520529117;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher) {_		this(Arrays.asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,nullable,path,matcher,path,matcher,this,arrays,as,list,patterns,path,matcher
DestinationPatternsMessageCondition -> public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher);1530174524;Alternative constructor accepting a custom PathMatcher._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher the PathMatcher to use;public DestinationPatternsMessageCondition(String[] patterns, @Nullable PathMatcher pathMatcher) {_		this(Arrays.asList(patterns), pathMatcher)__	};alternative,constructor,accepting,a,custom,path,matcher,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,the,path,matcher,to,use;public,destination,patterns,message,condition,string,patterns,nullable,path,matcher,path,matcher,this,arrays,as,list,patterns,path,matcher
