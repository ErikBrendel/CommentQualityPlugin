commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the supported MIME types.  */ ;/**  * Return the supported MIME types.  */ public List<MimeType> getSupportedMimeTypes() {     return Collections.unmodifiableList(this.supportedMimeTypes). }
true;public;1;3;/**  * Configure the {@link ContentTypeResolver} to use to resolve the content  * type of an input message.  * <p>Note that if no resolver is configured, then  * {@link #setStrictContentTypeMatch(boolean) strictContentTypeMatch} should  * be left as {@code false} (the default) or otherwise this converter will  * ignore all messages.  * <p>By default, a {@code DefaultContentTypeResolver} instance is used.  */ ;/**  * Configure the {@link ContentTypeResolver} to use to resolve the content  * type of an input message.  * <p>Note that if no resolver is configured, then  * {@link #setStrictContentTypeMatch(boolean) strictContentTypeMatch} should  * be left as {@code false} (the default) or otherwise this converter will  * ignore all messages.  * <p>By default, a {@code DefaultContentTypeResolver} instance is used.  */ public void setContentTypeResolver(@Nullable ContentTypeResolver resolver) {     this.contentTypeResolver = resolver. }
true;public;0;4;/**  * Return the configured {@link ContentTypeResolver}.  */ ;/**  * Return the configured {@link ContentTypeResolver}.  */ @Nullable public ContentTypeResolver getContentTypeResolver() {     return this.contentTypeResolver. }
true;public;1;7;/**  * Whether this converter should convert messages for which no content type  * could be resolved through the configured  * {@link org.springframework.messaging.converter.ContentTypeResolver}.  * <p>A converter can configured to be strict only when a  * {@link #setContentTypeResolver contentTypeResolver} is configured and the  * list of {@link #getSupportedMimeTypes() supportedMimeTypes} is not be empty.  * <p>When this flag is set to {@code true}, {@link #supportsMimeType(MessageHeaders)}  * will return {@code false} if the {@link #setContentTypeResolver contentTypeResolver}  * is not defined or if no content-type header is present.  */ ;/**  * Whether this converter should convert messages for which no content type  * could be resolved through the configured  * {@link org.springframework.messaging.converter.ContentTypeResolver}.  * <p>A converter can configured to be strict only when a  * {@link #setContentTypeResolver contentTypeResolver} is configured and the  * list of {@link #getSupportedMimeTypes() supportedMimeTypes} is not be empty.  * <p>When this flag is set to {@code true}, {@link #supportsMimeType(MessageHeaders)}  * will return {@code false} if the {@link #setContentTypeResolver contentTypeResolver}  * is not defined or if no content-type header is present.  */ public void setStrictContentTypeMatch(boolean strictContentTypeMatch) {     if (strictContentTypeMatch) {         Assert.notEmpty(getSupportedMimeTypes(), "Strict match requires non-empty list of supported mime types").         Assert.notNull(getContentTypeResolver(), "Strict match requires ContentTypeResolver").     }     this.strictContentTypeMatch = strictContentTypeMatch. }
true;public;0;3;/**  * Whether content type resolution must produce a value that matches one of  * the supported MIME types.  */ ;/**  * Whether content type resolution must produce a value that matches one of  * the supported MIME types.  */ public boolean isStrictContentTypeMatch() {     return this.strictContentTypeMatch. }
true;public;1;5;/**  * Configure the preferred serialization class to use (byte[] or String) when  * converting an Object payload to a {@link Message}.  * <p>The default value is byte[].  * @param payloadClass either byte[] or String  */ ;/**  * Configure the preferred serialization class to use (byte[] or String) when  * converting an Object payload to a {@link Message}.  * <p>The default value is byte[].  * @param payloadClass either byte[] or String  */ public void setSerializedPayloadClass(Class<?> payloadClass) {     Assert.isTrue(byte[].class == payloadClass || String.class == payloadClass, () -> "Payload class must be byte[] or String: " + payloadClass).     this.serializedPayloadClass = payloadClass. }
true;public;0;3;/**  * Return the configured preferred serialization payload class.  */ ;/**  * Return the configured preferred serialization payload class.  */ public Class<?> getSerializedPayloadClass() {     return this.serializedPayloadClass. }
true;protected;1;5;/**  * Returns the default content type for the payload. Called when  * {@link #toMessage(Object, MessageHeaders)} is invoked without message headers or  * without a content type header.  * <p>By default, this returns the first element of the {@link #getSupportedMimeTypes()  * supportedMimeTypes}, if any. Can be overridden in sub-classes.  * @param payload the payload being converted to message  * @return the content type, or {@code null} if not known  */ ;/**  * Returns the default content type for the payload. Called when  * {@link #toMessage(Object, MessageHeaders)} is invoked without message headers or  * without a content type header.  * <p>By default, this returns the first element of the {@link #getSupportedMimeTypes()  * supportedMimeTypes}, if any. Can be overridden in sub-classes.  * @param payload the payload being converted to message  * @return the content type, or {@code null} if not known  */ @Nullable protected MimeType getDefaultContentType(Object payload) {     List<MimeType> mimeTypes = getSupportedMimeTypes().     return (!mimeTypes.isEmpty() ? mimeTypes.get(0) : null). }
false;public,final;2;5;;@Override @Nullable public final Object fromMessage(Message<?> message, Class<?> targetClass) {     return fromMessage(message, targetClass, null). }
false;public,final;3;8;;@Override @Nullable public final Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {     if (!canConvertFrom(message, targetClass)) {         return null.     }     return convertFromInternal(message, targetClass, conversionHint). }
false;protected;2;3;;protected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {     return (supports(targetClass) && supportsMimeType(message.getHeaders())). }
false;public,final;2;5;;@Override @Nullable public final Message<?> toMessage(Object payload, @Nullable MessageHeaders headers) {     return toMessage(payload, headers, null). }
false;public,final;3;32;;@Override @Nullable public final Message<?> toMessage(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {     if (!canConvertTo(payload, headers)) {         return null.     }     Object payloadToUse = convertToInternal(payload, headers, conversionHint).     if (payloadToUse == null) {         return null.     }     MimeType mimeType = getDefaultContentType(payloadToUse).     if (headers != null) {         MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(headers, MessageHeaderAccessor.class).         if (accessor != null && accessor.isMutable()) {             if (mimeType != null) {                 accessor.setHeaderIfAbsent(MessageHeaders.CONTENT_TYPE, mimeType).             }             return MessageBuilder.createMessage(payloadToUse, accessor.getMessageHeaders()).         }     }     MessageBuilder<?> builder = MessageBuilder.withPayload(payloadToUse).     if (headers != null) {         builder.copyHeaders(headers).     }     if (mimeType != null) {         builder.setHeaderIfAbsent(MessageHeaders.CONTENT_TYPE, mimeType).     }     return builder.build(). }
false;protected;2;3;;protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {     return (supports(payload.getClass()) && supportsMimeType(headers)). }
false;protected;1;15;;protected boolean supportsMimeType(@Nullable MessageHeaders headers) {     if (getSupportedMimeTypes().isEmpty()) {         return true.     }     MimeType mimeType = getMimeType(headers).     if (mimeType == null) {         return !isStrictContentTypeMatch().     }     for (MimeType current : getSupportedMimeTypes()) {         if (current.getType().equals(mimeType.getType()) && current.getSubtype().equals(mimeType.getSubtype())) {             return true.         }     }     return false. }
false;protected;1;4;;@Nullable protected MimeType getMimeType(@Nullable MessageHeaders headers) {     return (headers != null && this.contentTypeResolver != null ? this.contentTypeResolver.resolve(headers) : null). }
true;protected,abstract;1;1;/**  * Whether the given class is supported by this converter.  * @param clazz the class to test for support  * @return {@code true} if supported. {@code false} otherwise  */ ;/**  * Whether the given class is supported by this converter.  * @param clazz the class to test for support  * @return {@code true} if supported. {@code false} otherwise  */ protected abstract boolean supports(Class<?> clazz).
true;protected;3;6;/**  * Convert the message payload from serialized form to an Object.  * @param message the input message  * @param targetClass the target class for the conversion  * @param conversionHint an extra object passed to the {@link MessageConverter},  * e.g. the associated {@code MethodParameter} (may be {@code null}}  * @return the result of the conversion, or {@code null} if the converter cannot  * perform the conversion  * @since 4.2  */ ;/**  * Convert the message payload from serialized form to an Object.  * @param message the input message  * @param targetClass the target class for the conversion  * @param conversionHint an extra object passed to the {@link MessageConverter},  * e.g. the associated {@code MethodParameter} (may be {@code null}}  * @return the result of the conversion, or {@code null} if the converter cannot  * perform the conversion  * @since 4.2  */ @Nullable protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {     return null. }
true;protected;3;6;/**  * Convert the payload object to serialized form.  * @param payload the Object to convert  * @param headers optional headers for the message (may be {@code null})  * @param conversionHint an extra object passed to the {@link MessageConverter},  * e.g. the associated {@code MethodParameter} (may be {@code null}}  * @return the resulting payload for the message, or {@code null} if the converter  * cannot perform the conversion  * @since 4.2  */ ;/**  * Convert the payload object to serialized form.  * @param payload the Object to convert  * @param headers optional headers for the message (may be {@code null})  * @param conversionHint an extra object passed to the {@link MessageConverter},  * e.g. the associated {@code MethodParameter} (may be {@code null}}  * @return the resulting payload for the message, or {@code null} if the converter  * cannot perform the conversion  * @since 4.2  */ @Nullable protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {     return null. }
