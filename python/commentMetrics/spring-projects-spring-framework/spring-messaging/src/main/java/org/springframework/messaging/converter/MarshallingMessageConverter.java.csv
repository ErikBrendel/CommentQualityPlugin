commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the {@link Marshaller} to be used by this message converter.  */ ;/**  * Set the {@link Marshaller} to be used by this message converter.  */ public void setMarshaller(@Nullable Marshaller marshaller) {     this.marshaller = marshaller. }
true;public;0;4;/**  * Return the configured Marshaller.  */ ;/**  * Return the configured Marshaller.  */ @Nullable public Marshaller getMarshaller() {     return this.marshaller. }
true;public;1;3;/**  * Set the {@link Unmarshaller} to be used by this message converter.  */ ;/**  * Set the {@link Unmarshaller} to be used by this message converter.  */ public void setUnmarshaller(@Nullable Unmarshaller unmarshaller) {     this.unmarshaller = unmarshaller. }
true;public;0;4;/**  * Return the configured unmarshaller.  */ ;/**  * Return the configured unmarshaller.  */ @Nullable public Unmarshaller getUnmarshaller() {     return this.unmarshaller. }
false;protected;2;5;;@Override protected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {     return (supportsMimeType(message.getHeaders()) && this.unmarshaller != null && this.unmarshaller.supports(targetClass)). }
false;protected;2;5;;@Override protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {     return (supportsMimeType(headers) && this.marshaller != null && this.marshaller.supports(payload.getClass())). }
false;protected;1;5;;@Override protected boolean supports(Class<?> clazz) {     // should not be called, since we override canConvertFrom/canConvertTo instead     throw new UnsupportedOperationException(). }
false;protected;3;16;;@Override @Nullable protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {     Assert.notNull(this.unmarshaller, "Property 'unmarshaller' is required").     try {         Source source = getSource(message.getPayload()).         Object result = this.unmarshaller.unmarshal(source).         if (!targetClass.isInstance(result)) {             throw new TypeMismatchException(result, targetClass).         }         return result.     } catch (Exception ex) {         throw new MessageConversionException(message, "Could not unmarshal XML: " + ex.getMessage(), ex).     } }
false;private;1;8;;private Source getSource(Object payload) {     if (payload instanceof byte[]) {         return new StreamSource(new ByteArrayInputStream((byte[]) payload)).     } else {         return new StreamSource(new StringReader((String) payload)).     } }
false;protected;3;25;;@Override @Nullable protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {     Assert.notNull(this.marshaller, "Property 'marshaller' is required").     try {         if (byte[].class == getSerializedPayloadClass()) {             ByteArrayOutputStream out = new ByteArrayOutputStream().             Result result = new StreamResult(out).             this.marshaller.marshal(payload, result).             payload = out.toByteArray().         } else {             Writer writer = new StringWriter().             Result result = new StreamResult(writer).             this.marshaller.marshal(payload, result).             payload = writer.toString().         }     } catch (Throwable ex) {         throw new MessageConversionException("Could not marshal XML: " + ex.getMessage(), ex).     }     return payload. }
