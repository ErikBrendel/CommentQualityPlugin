commented;modifiers;parameterAmount;loc;comment;code
true;public;1;10;/**  * Set the content-type header.  * Applies to the SEND, MESSAGE, and ERROR frames.  */ ;/**  * Set the content-type header.  * Applies to the SEND, MESSAGE, and ERROR frames.  */ public void setContentType(@Nullable MimeType mimeType) {     if (mimeType != null) {         Assert.isTrue(!mimeType.isWildcardType(), "'Content-Type' cannot contain wildcard type '*'").         Assert.isTrue(!mimeType.isWildcardSubtype(), "'Content-Type' cannot contain wildcard subtype '*'").         set(CONTENT_TYPE, mimeType.toString()).     } else {         set(CONTENT_TYPE, null).     } }
true;public;0;5;/**  * Return the content-type header value.  */ ;/**  * Return the content-type header value.  */ @Nullable public MimeType getContentType() {     String value = getFirst(CONTENT_TYPE).     return (StringUtils.hasLength(value) ? MimeTypeUtils.parseMimeType(value) : null). }
true;public;1;3;/**  * Set the content-length header.  * Applies to the SEND, MESSAGE, and ERROR frames.  */ ;/**  * Set the content-length header.  * Applies to the SEND, MESSAGE, and ERROR frames.  */ public void setContentLength(long contentLength) {     set(CONTENT_LENGTH, Long.toString(contentLength)). }
true;public;0;4;/**  * Return the content-length header or -1 if unknown.  */ ;/**  * Return the content-length header or -1 if unknown.  */ public long getContentLength() {     String value = getFirst(CONTENT_LENGTH).     return (value != null ? Long.parseLong(value) : -1). }
true;public;1;3;/**  * Set the receipt header.  * Applies to any client frame other than CONNECT.  */ ;/**  * Set the receipt header.  * Applies to any client frame other than CONNECT.  */ public void setReceipt(@Nullable String receipt) {     set(RECEIPT, receipt). }
true;public;0;4;/**  * Get the receipt header.  */ ;/**  * Get the receipt header.  */ @Nullable public String getReceipt() {     return getFirst(RECEIPT). }
true;public;1;3;/**  * Set the host header.  * Applies to the CONNECT frame.  */ ;/**  * Set the host header.  * Applies to the CONNECT frame.  */ public void setHost(@Nullable String host) {     set(HOST, host). }
true;public;0;4;/**  * Get the host header.  */ ;/**  * Get the host header.  */ @Nullable public String getHost() {     return getFirst(HOST). }
true;public;1;10;/**  * Set the accept-version header. Must be one of "1.1", "1.2", or both.  * Applies to the CONNECT frame.  * @since 5.0.7  */ ;/**  * Set the accept-version header. Must be one of "1.1", "1.2", or both.  * Applies to the CONNECT frame.  * @since 5.0.7  */ public void setAcceptVersion(@Nullable String... acceptVersions) {     if (ObjectUtils.isEmpty(acceptVersions)) {         set(ACCEPT_VERSION, null).         return.     }     Arrays.stream(acceptVersions).forEach(version -> Assert.isTrue(version != null && (version.equals("1.1") || version.equals("1.2")), "Invalid version: " + version)).     set(ACCEPT_VERSION, StringUtils.arrayToCommaDelimitedString(acceptVersions)). }
true;public;0;5;/**  * Get the accept-version header.  * @since 5.0.7  */ ;/**  * Get the accept-version header.  * @since 5.0.7  */ @Nullable public String[] getAcceptVersion() {     String value = getFirst(ACCEPT_VERSION).     return value != null ? StringUtils.commaDelimitedListToStringArray(value) : null. }
true;public;1;3;/**  * Set the login header.  * Applies to the CONNECT frame.  */ ;/**  * Set the login header.  * Applies to the CONNECT frame.  */ public void setLogin(@Nullable String login) {     set(LOGIN, login). }
true;public;0;4;/**  * Get the login header.  */ ;/**  * Get the login header.  */ @Nullable public String getLogin() {     return getFirst(LOGIN). }
true;public;1;3;/**  * Set the passcode header.  * Applies to the CONNECT frame.  */ ;/**  * Set the passcode header.  * Applies to the CONNECT frame.  */ public void setPasscode(@Nullable String passcode) {     set(PASSCODE, passcode). }
true;public;0;4;/**  * Get the passcode header.  */ ;/**  * Get the passcode header.  */ @Nullable public String getPasscode() {     return getFirst(PASSCODE). }
true;public;1;11;/**  * Set the heartbeat header.  * Applies to the CONNECT and CONNECTED frames.  */ ;/**  * Set the heartbeat header.  * Applies to the CONNECT and CONNECTED frames.  */ public void setHeartbeat(@Nullable long[] heartbeat) {     if (heartbeat == null || heartbeat.length != 2) {         throw new IllegalArgumentException("Heart-beat array must be of length 2, not " + (heartbeat != null ? heartbeat.length : "null")).     }     String value = heartbeat[0] + "," + heartbeat[1].     if (heartbeat[0] < 0 || heartbeat[1] < 0) {         throw new IllegalArgumentException("Heart-beat values cannot be negative: " + value).     }     set(HEARTBEAT, value). }
true;public;0;9;/**  * Get the heartbeat header.  */ ;/**  * Get the heartbeat header.  */ @Nullable public long[] getHeartbeat() {     String rawValue = getFirst(HEARTBEAT).     String[] rawValues = StringUtils.split(rawValue, ",").     if (rawValues == null) {         return null.     }     return new long[] { Long.valueOf(rawValues[0]), Long.valueOf(rawValues[1]) }. }
true;public;0;4;/**  * Whether heartbeats are enabled. Returns {@code false} if  * {@link #setHeartbeat} is set to "0,0", and {@code true} otherwise.  */ ;/**  * Whether heartbeats are enabled. Returns {@code false} if  * {@link #setHeartbeat} is set to "0,0", and {@code true} otherwise.  */ public boolean isHeartbeatEnabled() {     long[] heartbeat = getHeartbeat().     return (heartbeat != null && heartbeat[0] != 0 && heartbeat[1] != 0). }
true;public;1;3;/**  * Set the session header.  * Applies to the CONNECTED frame.  */ ;/**  * Set the session header.  * Applies to the CONNECTED frame.  */ public void setSession(@Nullable String session) {     set(SESSION, session). }
true;public;0;4;/**  * Get the session header.  */ ;/**  * Get the session header.  */ @Nullable public String getSession() {     return getFirst(SESSION). }
true;public;1;3;/**  * Set the server header.  * Applies to the CONNECTED frame.  */ ;/**  * Set the server header.  * Applies to the CONNECTED frame.  */ public void setServer(@Nullable String server) {     set(SERVER, server). }
true;public;0;4;/**  * Get the server header.  * Applies to the CONNECTED frame.  */ ;/**  * Get the server header.  * Applies to the CONNECTED frame.  */ @Nullable public String getServer() {     return getFirst(SERVER). }
true;public;1;3;/**  * Set the destination header.  */ ;/**  * Set the destination header.  */ public void setDestination(@Nullable String destination) {     set(DESTINATION, destination). }
true;public;0;4;/**  * Get the destination header.  * Applies to the SEND, SUBSCRIBE, and MESSAGE frames.  */ ;/**  * Get the destination header.  * Applies to the SEND, SUBSCRIBE, and MESSAGE frames.  */ @Nullable public String getDestination() {     return getFirst(DESTINATION). }
true;public;1;3;/**  * Set the id header.  * Applies to the SUBSCR0BE, UNSUBSCRIBE, and ACK or NACK frames.  */ ;/**  * Set the id header.  * Applies to the SUBSCR0BE, UNSUBSCRIBE, and ACK or NACK frames.  */ public void setId(@Nullable String id) {     set(ID, id). }
true;public;0;4;/**  * Get the id header.  */ ;/**  * Get the id header.  */ @Nullable public String getId() {     return getFirst(ID). }
true;public;1;3;/**  * Set the ack header to one of "auto", "client", or "client-individual".  * Applies to the SUBSCRIBE and MESSAGE frames.  */ ;/**  * Set the ack header to one of "auto", "client", or "client-individual".  * Applies to the SUBSCRIBE and MESSAGE frames.  */ public void setAck(@Nullable String ack) {     set(ACK, ack). }
true;public;0;4;/**  * Get the ack header.  */ ;/**  * Get the ack header.  */ @Nullable public String getAck() {     return getFirst(ACK). }
true;public;1;3;/**  * Set the login header.  * Applies to the MESSAGE frame.  */ ;/**  * Set the login header.  * Applies to the MESSAGE frame.  */ public void setSubscription(@Nullable String subscription) {     set(SUBSCRIPTION, subscription). }
true;public;0;4;/**  * Get the subscription header.  */ ;/**  * Get the subscription header.  */ @Nullable public String getSubscription() {     return getFirst(SUBSCRIPTION). }
true;public;1;3;/**  * Set the message-id header.  * Applies to the MESSAGE frame.  */ ;/**  * Set the message-id header.  * Applies to the MESSAGE frame.  */ public void setMessageId(@Nullable String messageId) {     set(MESSAGE_ID, messageId). }
true;public;0;4;/**  * Get the message-id header.  */ ;/**  * Get the message-id header.  */ @Nullable public String getMessageId() {     return getFirst(MESSAGE_ID). }
true;public;1;3;/**  * Set the receipt-id header.  * Applies to the RECEIPT frame.  */ ;/**  * Set the receipt-id header.  * Applies to the RECEIPT frame.  */ public void setReceiptId(@Nullable String receiptId) {     set(RECEIPT_ID, receiptId). }
true;public;0;4;/**  * Get the receipt header.  */ ;/**  * Get the receipt header.  */ @Nullable public String getReceiptId() {     return getFirst(RECEIPT_ID). }
true;public;1;6;/**  * Return the first header value for the given header name, if any.  * @param headerName the header name  * @return the first header value, or {@code null} if none  */ ;/**  * Return the first header value for the given header name, if any.  * @param headerName the header name  * @return the first header value, or {@code null} if none  */ @Override @Nullable public String getFirst(String headerName) {     List<String> headerValues = this.headers.get(headerName).     return headerValues != null ? headerValues.get(0) : null. }
true;public;2;5;/**  * Add the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #set(String, String)  */ ;/**  * Add the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #set(String, String)  */ @Override public void add(String headerName, @Nullable String headerValue) {     List<String> headerValues = this.headers.computeIfAbsent(headerName, k -> new LinkedList<>()).     headerValues.add(headerValue). }
false;public;2;5;;@Override public void addAll(String headerName, List<? extends String> headerValues) {     List<String> currentValues = this.headers.computeIfAbsent(headerName, k -> new LinkedList<>()).     currentValues.addAll(headerValues). }
false;public;1;4;;@Override public void addAll(MultiValueMap<String, String> values) {     values.forEach(this::addAll). }
true;public;2;6;/**  * Set the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #add(String, String)  */ ;/**  * Set the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #add(String, String)  */ @Override public void set(String headerName, @Nullable String headerValue) {     List<String> headerValues = new LinkedList<>().     headerValues.add(headerValue).     this.headers.put(headerName, headerValues). }
false;public;1;4;;@Override public void setAll(Map<String, String> values) {     values.forEach(this::set). }
false;public;0;6;;@Override public Map<String, String> toSingleValueMap() {     LinkedHashMap<String, String> singleValueMap = new LinkedHashMap<>(this.headers.size()).     this.headers.forEach((key, value) -> singleValueMap.put(key, value.get(0))).     return singleValueMap. }
false;public;0;4;;// Map implementation @Override public int size() {     return this.headers.size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return this.headers.isEmpty(). }
false;public;1;4;;@Override public boolean containsKey(Object key) {     return this.headers.containsKey(key). }
false;public;1;4;;@Override public boolean containsValue(Object value) {     return this.headers.containsValue(value). }
false;public;1;4;;@Override public List<String> get(Object key) {     return this.headers.get(key). }
false;public;2;4;;@Override public List<String> put(String key, List<String> value) {     return this.headers.put(key, value). }
false;public;1;4;;@Override public List<String> remove(Object key) {     return this.headers.remove(key). }
false;public;1;4;;@Override public void putAll(Map<? extends String, ? extends List<String>> map) {     this.headers.putAll(map). }
false;public;0;4;;@Override public void clear() {     this.headers.clear(). }
false;public;0;4;;@Override public Set<String> keySet() {     return this.headers.keySet(). }
false;public;0;4;;@Override public Collection<List<String>> values() {     return this.headers.values(). }
false;public;0;4;;@Override public Set<Entry<String, List<String>>> entrySet() {     return this.headers.entrySet(). }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof StompHeaders && this.headers.equals(((StompHeaders) other).headers))). }
false;public;0;4;;@Override public int hashCode() {     return this.headers.hashCode(). }
false;public;0;4;;@Override public String toString() {     return this.headers.toString(). }
true;public,static;1;3;/**  * Return a {@code StompHeaders} object that can only be read, not written to.  */ ;/**  * Return a {@code StompHeaders} object that can only be read, not written to.  */ public static StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers) {     return new StompHeaders((headers != null ? headers : Collections.emptyMap()), true). }
