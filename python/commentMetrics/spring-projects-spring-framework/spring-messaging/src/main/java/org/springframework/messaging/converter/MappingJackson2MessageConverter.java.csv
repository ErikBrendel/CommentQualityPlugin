commented;modifiers;parameterAmount;loc;comment;code
false;private;0;6;;private ObjectMapper initObjectMapper() {     ObjectMapper objectMapper = new ObjectMapper().     objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false).     objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).     return objectMapper. }
true;public;1;5;/**  * Set the {@code ObjectMapper} for this converter.  * If not set, a default {@link ObjectMapper#ObjectMapper() ObjectMapper} is used.  * <p>Setting a custom-configured {@code ObjectMapper} is one way to take further  * control of the JSON serialization process. For example, an extended  * {@link com.fasterxml.jackson.databind.ser.SerializerFactory} can be  * configured that provides custom serializers for specific types. The other  * option for refining the serialization process is to use Jackson's provided  * annotations on the types to be serialized, in which case a custom-configured  * ObjectMapper is unnecessary.  */ ;/**  * Set the {@code ObjectMapper} for this converter.  * If not set, a default {@link ObjectMapper#ObjectMapper() ObjectMapper} is used.  * <p>Setting a custom-configured {@code ObjectMapper} is one way to take further  * control of the JSON serialization process. For example, an extended  * {@link com.fasterxml.jackson.databind.ser.SerializerFactory} can be  * configured that provides custom serializers for specific types. The other  * option for refining the serialization process is to use Jackson's provided  * annotations on the types to be serialized, in which case a custom-configured  * ObjectMapper is unnecessary.  */ public void setObjectMapper(ObjectMapper objectMapper) {     Assert.notNull(objectMapper, "ObjectMapper must not be null").     this.objectMapper = objectMapper.     configurePrettyPrint(). }
true;public;0;3;/**  * Return the underlying {@code ObjectMapper} for this converter.  */ ;/**  * Return the underlying {@code ObjectMapper} for this converter.  */ public ObjectMapper getObjectMapper() {     return this.objectMapper. }
true;public;1;4;/**  * Whether to use the {@link DefaultPrettyPrinter} when writing JSON.  * This is a shortcut for setting up an {@code ObjectMapper} as follows:  * <pre class="code">  * ObjectMapper mapper = new ObjectMapper().  * mapper.configure(SerializationFeature.INDENT_OUTPUT, true).  * converter.setObjectMapper(mapper).  * </pre>  */ ;/**  * Whether to use the {@link DefaultPrettyPrinter} when writing JSON.  * This is a shortcut for setting up an {@code ObjectMapper} as follows:  * <pre class="code">  * ObjectMapper mapper = new ObjectMapper().  * mapper.configure(SerializationFeature.INDENT_OUTPUT, true).  * converter.setObjectMapper(mapper).  * </pre>  */ public void setPrettyPrint(boolean prettyPrint) {     this.prettyPrint = prettyPrint.     configurePrettyPrint(). }
false;private;0;5;;private void configurePrettyPrint() {     if (this.prettyPrint != null) {         this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, this.prettyPrint).     } }
false;protected;2;13;;@Override protected boolean canConvertFrom(Message<?> message, @Nullable Class<?> targetClass) {     if (targetClass == null || !supportsMimeType(message.getHeaders())) {         return false.     }     JavaType javaType = this.objectMapper.constructType(targetClass).     AtomicReference<Throwable> causeRef = new AtomicReference<>().     if (this.objectMapper.canDeserialize(javaType, causeRef)) {         return true.     }     logWarningIfNecessary(javaType, causeRef.get()).     return false. }
false;protected;2;12;;@Override protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {     if (!supportsMimeType(headers)) {         return false.     }     AtomicReference<Throwable> causeRef = new AtomicReference<>().     if (this.objectMapper.canSerialize(payload.getClass(), causeRef)) {         return true.     }     logWarningIfNecessary(payload.getClass(), causeRef.get()).     return false. }
true;protected;2;22;/**  * Determine whether to log the given exception coming from a  * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.  * @param type the class that Jackson tested for (de-)serializability  * @param cause the Jackson-thrown exception to evaluate  * (typically a {@link JsonMappingException})  * @since 4.3  */ ;/**  * Determine whether to log the given exception coming from a  * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.  * @param type the class that Jackson tested for (de-)serializability  * @param cause the Jackson-thrown exception to evaluate  * (typically a {@link JsonMappingException})  * @since 4.3  */ protected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {     if (cause == null) {         return.     }     // Do not log warning for serializer not found (note: different message wording on Jackson 2.9)     boolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage().startsWith("Cannot find")).     if (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {         String msg = "Failed to evaluate Jackson " + (type instanceof JavaType ? "de" : "") + "serialization for type [" + type + "]".         if (debugLevel) {             logger.debug(msg, cause).         } else if (logger.isDebugEnabled()) {             logger.warn(msg, cause).         } else {             logger.warn(msg + ": " + cause).         }     } }
false;protected;1;5;;@Override protected boolean supports(Class<?> clazz) {     // should not be called, since we override canConvertFrom/canConvertTo instead     throw new UnsupportedOperationException(). }
false;protected;3;29;;@Override @Nullable protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {     JavaType javaType = getJavaType(targetClass, conversionHint).     Object payload = message.getPayload().     Class<?> view = getSerializationView(conversionHint).     // Note: in the view case, calling withType instead of forType for compatibility with Jackson <2.5     try {         if (payload instanceof byte[]) {             if (view != null) {                 return this.objectMapper.readerWithView(view).forType(javaType).readValue((byte[]) payload).             } else {                 return this.objectMapper.readValue((byte[]) payload, javaType).             }         } else {             if (view != null) {                 return this.objectMapper.readerWithView(view).forType(javaType).readValue(payload.toString()).             } else {                 return this.objectMapper.readValue(payload.toString(), javaType).             }         }     } catch (IOException ex) {         throw new MessageConversionException(message, "Could not read JSON: " + ex.getMessage(), ex).     } }
false;private;2;14;;private JavaType getJavaType(Class<?> targetClass, @Nullable Object conversionHint) {     if (conversionHint instanceof MethodParameter) {         MethodParameter param = (MethodParameter) conversionHint.         param = param.nestedIfOptional().         if (Message.class.isAssignableFrom(param.getParameterType())) {             param = param.nested().         }         Type genericParameterType = param.getNestedGenericParameterType().         Class<?> contextClass = param.getContainingClass().         Type type = GenericTypeResolver.resolveType(genericParameterType, contextClass).         return this.objectMapper.getTypeFactory().constructType(type).     }     return this.objectMapper.constructType(targetClass). }
false;protected;3;35;;@Override @Nullable protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {     try {         Class<?> view = getSerializationView(conversionHint).         if (byte[].class == getSerializedPayloadClass()) {             ByteArrayOutputStream out = new ByteArrayOutputStream(1024).             JsonEncoding encoding = getJsonEncoding(getMimeType(headers)).             JsonGenerator generator = this.objectMapper.getFactory().createGenerator(out, encoding).             if (view != null) {                 this.objectMapper.writerWithView(view).writeValue(generator, payload).             } else {                 this.objectMapper.writeValue(generator, payload).             }             payload = out.toByteArray().         } else {             Writer writer = new StringWriter().             if (view != null) {                 this.objectMapper.writerWithView(view).writeValue(writer, payload).             } else {                 this.objectMapper.writeValue(writer, payload).             }             payload = writer.toString().         }     } catch (IOException ex) {         throw new MessageConversionException("Could not write JSON: " + ex.getMessage(), ex).     }     return payload. }
true;protected;1;20;/**  * Determine a Jackson serialization view based on the given conversion hint.  * @param conversionHint the conversion hint Object as passed into the  * converter for the current conversion attempt  * @return the serialization view class, or {@code null} if none  * @since 4.2  */ ;/**  * Determine a Jackson serialization view based on the given conversion hint.  * @param conversionHint the conversion hint Object as passed into the  * converter for the current conversion attempt  * @return the serialization view class, or {@code null} if none  * @since 4.2  */ @Nullable protected Class<?> getSerializationView(@Nullable Object conversionHint) {     if (conversionHint instanceof MethodParameter) {         MethodParameter param = (MethodParameter) conversionHint.         JsonView annotation = (param.getParameterIndex() >= 0 ? param.getParameterAnnotation(JsonView.class) : param.getMethodAnnotation(JsonView.class)).         if (annotation != null) {             return extractViewClass(annotation, conversionHint).         }     } else if (conversionHint instanceof JsonView) {         return extractViewClass((JsonView) conversionHint, conversionHint).     } else if (conversionHint instanceof Class) {         return (Class<?>) conversionHint.     }     // No JSON view specified...     return null. }
false;private;2;8;;private Class<?> extractViewClass(JsonView annotation, Object conversionHint) {     Class<?>[] classes = annotation.value().     if (classes.length != 1) {         throw new IllegalArgumentException("@JsonView only supported for handler methods with exactly 1 class argument: " + conversionHint).     }     return classes[0]. }
true;protected;1;11;/**  * Determine the JSON encoding to use for the given content type.  * @param contentType the MIME type from the MessageHeaders, if any  * @return the JSON encoding to use (never {@code null})  */ ;/**  * Determine the JSON encoding to use for the given content type.  * @param contentType the MIME type from the MessageHeaders, if any  * @return the JSON encoding to use (never {@code null})  */ protected JsonEncoding getJsonEncoding(@Nullable MimeType contentType) {     if (contentType != null && (contentType.getCharset() != null)) {         Charset charset = contentType.getCharset().         for (JsonEncoding encoding : JsonEncoding.values()) {             if (charset.name().equals(encoding.getJavaName())) {                 return encoding.             }         }     }     return JsonEncoding.UTF8. }
