commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public SubscribableChannel getClientInboundChannel() {     return this.clientInboundChannel. }
false;public;0;3;;public MessageChannel getClientOutboundChannel() {     return this.clientOutboundChannel. }
false;public;0;3;;public SubscribableChannel getBrokerChannel() {     return this.brokerChannel. }
false;public;0;3;;public Collection<String> getDestinationPrefixes() {     return this.destinationPrefixes. }
true;public;1;4;/**  * Whether the client must receive messages in the order of publication.  * <p>By default messages sent to the {@code "clientOutboundChannel"} may  * not be processed in the same order because the channel is backed by a  * ThreadPoolExecutor that in turn does not guarantee processing in order.  * <p>When this flag is set to {@code true} messages within the same session  * will be sent to the {@code "clientOutboundChannel"} one at a time in  * order to preserve the order of publication. Enable this only if needed  * since there is some performance overhead to keep messages in order.  * @param preservePublishOrder whether to publish in order  * @since 5.1  */ ;/**  * Whether the client must receive messages in the order of publication.  * <p>By default messages sent to the {@code "clientOutboundChannel"} may  * not be processed in the same order because the channel is backed by a  * ThreadPoolExecutor that in turn does not guarantee processing in order.  * <p>When this flag is set to {@code true} messages within the same session  * will be sent to the {@code "clientOutboundChannel"} one at a time in  * order to preserve the order of publication. Enable this only if needed  * since there is some performance overhead to keep messages in order.  * @param preservePublishOrder whether to publish in order  * @since 5.1  */ public void setPreservePublishOrder(boolean preservePublishOrder) {     OrderedMessageSender.configureOutboundChannel(this.clientOutboundChannel, preservePublishOrder).     this.preservePublishOrder = preservePublishOrder. }
true;public;0;3;/**  * Whether to ensure messages are received in the order of publication.  * @since 5.1  */ ;/**  * Whether to ensure messages are received in the order of publication.  * @since 5.1  */ public boolean isPreservePublishOrder() {     return this.preservePublishOrder. }
false;public;1;4;;@Override public void setApplicationEventPublisher(@Nullable ApplicationEventPublisher publisher) {     this.eventPublisher = publisher. }
false;public;0;4;;@Nullable public ApplicationEventPublisher getApplicationEventPublisher() {     return this.eventPublisher. }
false;public;1;3;;public void setAutoStartup(boolean autoStartup) {     this.autoStartup = autoStartup. }
false;public;0;4;;@Override public boolean isAutoStartup() {     return this.autoStartup. }
false;public;0;14;;@Override public void start() {     synchronized (this.lifecycleMonitor) {         logger.info("Starting...").         this.clientInboundChannel.subscribe(this).         this.brokerChannel.subscribe(this).         if (this.clientInboundChannel instanceof InterceptableChannel) {             ((InterceptableChannel) this.clientInboundChannel).addInterceptor(0, this.unsentDisconnectInterceptor).         }         startInternal().         this.running = true.         logger.info("Started.").     } }
false;protected;0;2;;protected void startInternal() { }
false;public;0;14;;@Override public void stop() {     synchronized (this.lifecycleMonitor) {         logger.info("Stopping...").         stopInternal().         this.clientInboundChannel.unsubscribe(this).         this.brokerChannel.unsubscribe(this).         if (this.clientInboundChannel instanceof InterceptableChannel) {             ((InterceptableChannel) this.clientInboundChannel).removeInterceptor(this.unsentDisconnectInterceptor).         }         this.running = false.         logger.info("Stopped.").     } }
false;protected;0;2;;protected void stopInternal() { }
false;public,final;1;7;;@Override public final void stop(Runnable callback) {     synchronized (this.lifecycleMonitor) {         stop().         callback.run().     } }
true;public,final;0;4;/**  * Check whether this message handler is currently running.  * <p>Note that even when this message handler is running the  * {@link #isBrokerAvailable()} flag may still independently alternate between  * being on and off depending on the concrete sub-class implementation.  */ ;/**  * Check whether this message handler is currently running.  * <p>Note that even when this message handler is running the  * {@link #isBrokerAvailable()} flag may still independently alternate between  * being on and off depending on the concrete sub-class implementation.  */ @Override public final boolean isRunning() {     return this.running. }
true;public;0;3;/**  * Whether the message broker is currently available and able to process messages.  * <p>Note that this is in addition to the {@link #isRunning()} flag, which  * indicates whether this message handler is running. In other words the message  * handler must first be running and then the {@code #isBrokerAvailable()} flag  * may still independently alternate between being on and off depending on the  * concrete sub-class implementation.  * <p>Application components may implement  * {@code org.springframework.context.ApplicationListener&lt.BrokerAvailabilityEvent&gt.}  * to receive notifications when broker becomes available and unavailable.  */ ;/**  * Whether the message broker is currently available and able to process messages.  * <p>Note that this is in addition to the {@link #isRunning()} flag, which  * indicates whether this message handler is running. In other words the message  * handler must first be running and then the {@code #isBrokerAvailable()} flag  * may still independently alternate between being on and off depending on the  * concrete sub-class implementation.  * <p>Application components may implement  * {@code org.springframework.context.ApplicationListener&lt.BrokerAvailabilityEvent&gt.}  * to receive notifications when broker becomes available and unavailable.  */ public boolean isBrokerAvailable() {     return this.brokerAvailable.get(). }
false;public;1;10;;@Override public void handleMessage(Message<?> message) {     if (!this.running) {         if (logger.isTraceEnabled()) {             logger.trace(this + " not running yet. Ignoring " + message).         }         return.     }     handleMessageInternal(message). }
false;protected,abstract;1;1;;protected abstract void handleMessageInternal(Message<?> message).
false;protected;1;11;;protected boolean checkDestinationPrefix(@Nullable String destination) {     if (destination == null || CollectionUtils.isEmpty(this.destinationPrefixes)) {         return true.     }     for (String prefix : this.destinationPrefixes) {         if (destination.startsWith(prefix)) {             return true.         }     }     return false. }
false;protected;0;9;;protected void publishBrokerAvailableEvent() {     boolean shouldPublish = this.brokerAvailable.compareAndSet(false, true).     if (this.eventPublisher != null && shouldPublish) {         if (logger.isInfoEnabled()) {             logger.info(this.availableEvent).         }         this.eventPublisher.publishEvent(this.availableEvent).     } }
false;protected;0;9;;protected void publishBrokerUnavailableEvent() {     boolean shouldPublish = this.brokerAvailable.compareAndSet(true, false).     if (this.eventPublisher != null && shouldPublish) {         if (logger.isInfoEnabled()) {             logger.info(this.notAvailableEvent).         }         this.eventPublisher.publishEvent(this.notAvailableEvent).     } }
true;protected;1;4;/**  * Get the MessageChannel to use for sending messages to clients, possibly  * a per-session wrapper when {@code preservePublishOrder=true}.  * @since 5.1  */ ;/**  * Get the MessageChannel to use for sending messages to clients, possibly  * a per-session wrapper when {@code preservePublishOrder=true}.  * @since 5.1  */ protected MessageChannel getClientOutboundChannelForSession(String sessionId) {     return this.preservePublishOrder ? new OrderedMessageSender(getClientOutboundChannel(), logger) : getClientOutboundChannel(). }
false;public;4;12;;@Override public void afterSendCompletion(Message<?> message, MessageChannel channel, boolean sent, @Nullable Exception ex) {     if (!sent) {         SimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders()).         if (SimpMessageType.DISCONNECT.equals(messageType)) {             logger.debug("Detected unsent DISCONNECT message. Processing anyway.").             handleMessage(message).         }     } }
