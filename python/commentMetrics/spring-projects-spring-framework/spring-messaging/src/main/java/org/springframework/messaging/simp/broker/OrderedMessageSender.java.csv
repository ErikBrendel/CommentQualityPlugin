commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public boolean send(Message<?> message) {     return send(message, -1). }
false;public;2;6;;@Override public boolean send(Message<?> message, long timeout) {     this.messages.add(message).     trySend().     return true. }
false;private;0;10;;private void trySend() {     // Take sendInProgress flag only if queue is not empty     if (this.messages.isEmpty()) {         return.     }     if (this.sendInProgress.compareAndSet(false, true)) {         sendNextMessage().     } }
false;private;0;24;;private void sendNextMessage() {     for (. . ) {         Message<?> message = this.messages.poll().         if (message != null) {             try {                 addCompletionCallback(message).                 if (this.channel.send(message)) {                     return.                 }             } catch (Throwable ex) {                 if (logger.isErrorEnabled()) {                     logger.error("Failed to send " + message, ex).                 }             }         } else {             // We ran out of messages..             this.sendInProgress.set(false).             trySend().             break.         }     } }
false;private;1;5;;private void addCompletionCallback(Message<?> msg) {     SimpMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(msg, SimpMessageHeaderAccessor.class).     Assert.isTrue(accessor != null && accessor.isMutable(), "Expected mutable SimpMessageHeaderAccessor").     accessor.setHeader(COMPLETION_TASK_HEADER, (Runnable) this::sendNextMessage). }
true;static;2;17;/**  * Install or remove an {@link ExecutorChannelInterceptor} that invokes a  * completion task once the message is handled.  * @param channel the channel to configure  * @param preservePublishOrder whether preserve order is on or off based on  * which an interceptor is either added or removed.  */ ;/**  * Install or remove an {@link ExecutorChannelInterceptor} that invokes a  * completion task once the message is handled.  * @param channel the channel to configure  * @param preservePublishOrder whether preserve order is on or off based on  * which an interceptor is either added or removed.  */ static void configureOutboundChannel(MessageChannel channel, boolean preservePublishOrder) {     if (preservePublishOrder) {         Assert.isInstanceOf(ExecutorSubscribableChannel.class, channel, "An ExecutorSubscribableChannel is required for `preservePublishOrder`").         ExecutorSubscribableChannel execChannel = (ExecutorSubscribableChannel) channel.         if (execChannel.getInterceptors().stream().noneMatch(i -> i instanceof CallbackInterceptor)) {             execChannel.addInterceptor(0, new CallbackInterceptor()).         }     } else if (channel instanceof ExecutorSubscribableChannel) {         ExecutorSubscribableChannel execChannel = (ExecutorSubscribableChannel) channel.         execChannel.getInterceptors().stream().filter(i -> i instanceof CallbackInterceptor).findFirst().map(execChannel::removeInterceptor).     } }
false;public;4;9;;@Override public void afterMessageHandled(Message<?> msg, MessageChannel ch, MessageHandler handler, @Nullable Exception ex) {     Runnable task = (Runnable) msg.getHeaders().get(OrderedMessageSender.COMPLETION_TASK_HEADER).     if (task != null) {         task.run().     } }
