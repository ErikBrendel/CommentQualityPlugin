commented;modifiers;parameterAmount;loc;comment;code
false;private;0;10;;private MethodParameter[] initMethodParameters() {     int count = this.bridgedMethod.getParameterCount().     MethodParameter[] result = new MethodParameter[count].     for (int i = 0. i < count. i++) {         HandlerMethodParameter parameter = new HandlerMethodParameter(i).         GenericTypeResolver.resolveParameterType(parameter, this.beanType).         result[i] = parameter.     }     return result. }
true;public;1;3;/**  * Set an alternative logger to use than the one based on the class name.  * @param logger the logger to use  * @since 5.1  */ ;/**  * Set an alternative logger to use than the one based on the class name.  * @param logger the logger to use  * @since 5.1  */ public void setLogger(Log logger) {     this.logger = logger. }
true;public;0;3;/**  * Return the currently configured Logger.  * @since 5.1  */ ;/**  * Return the currently configured Logger.  * @since 5.1  */ public Log getLogger() {     return logger. }
true;public;0;3;/**  * Return the bean for this handler method.  */ ;/**  * Return the bean for this handler method.  */ public Object getBean() {     return this.bean. }
true;public;0;3;/**  * Return the method for this handler method.  */ ;/**  * Return the method for this handler method.  */ public Method getMethod() {     return this.method. }
true;public;0;3;/**  * This method returns the type of the handler for this handler method.  * <p>Note that if the bean type is a CGLIB-generated class, the original  * user-defined class is returned.  */ ;/**  * This method returns the type of the handler for this handler method.  * <p>Note that if the bean type is a CGLIB-generated class, the original  * user-defined class is returned.  */ public Class<?> getBeanType() {     return this.beanType. }
true;protected;0;3;/**  * If the bean method is a bridge method, this method returns the bridged  * (user-defined) method. Otherwise it returns the same method as {@link #getMethod()}.  */ ;/**  * If the bean method is a bridge method, this method returns the bridged  * (user-defined) method. Otherwise it returns the same method as {@link #getMethod()}.  */ protected Method getBridgedMethod() {     return this.bridgedMethod. }
true;public;0;3;/**  * Return the method parameters for this handler method.  */ ;/**  * Return the method parameters for this handler method.  */ public MethodParameter[] getMethodParameters() {     return this.parameters. }
true;public;0;3;/**  * Return the HandlerMethod return type.  */ ;/**  * Return the HandlerMethod return type.  */ public MethodParameter getReturnType() {     return new HandlerMethodParameter(-1). }
true;public;1;3;/**  * Return the actual return value type.  */ ;/**  * Return the actual return value type.  */ public MethodParameter getReturnValueType(@Nullable Object returnValue) {     return new ReturnValueMethodParameter(returnValue). }
true;public;0;3;/**  * Return {@code true} if the method return type is void, {@code false} otherwise.  */ ;/**  * Return {@code true} if the method return type is void, {@code false} otherwise.  */ public boolean isVoid() {     return Void.TYPE.equals(getReturnType().getParameterType()). }
true;public;1;4;/**  * Return a single annotation on the underlying method traversing its super methods  * if no annotation can be found on the given method itself.  * <p>Also supports <em>merged</em> composed annotations with attribute  * overrides as of Spring Framework 4.3.  * @param annotationType the type of annotation to introspect the method for  * @return the annotation, or {@code null} if none found  * @see AnnotatedElementUtils#findMergedAnnotation  */ ;/**  * Return a single annotation on the underlying method traversing its super methods  * if no annotation can be found on the given method itself.  * <p>Also supports <em>merged</em> composed annotations with attribute  * overrides as of Spring Framework 4.3.  * @param annotationType the type of annotation to introspect the method for  * @return the annotation, or {@code null} if none found  * @see AnnotatedElementUtils#findMergedAnnotation  */ @Nullable public <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {     return AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType). }
true;public;1;3;/**  * Return whether the parameter is declared with the given annotation type.  * @param annotationType the annotation type to look for  * @since 4.3  * @see AnnotatedElementUtils#hasAnnotation  */ ;/**  * Return whether the parameter is declared with the given annotation type.  * @param annotationType the annotation type to look for  * @since 4.3  * @see AnnotatedElementUtils#hasAnnotation  */ public <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {     return AnnotatedElementUtils.hasAnnotation(this.method, annotationType). }
true;public;0;4;/**  * Return the HandlerMethod from which this HandlerMethod instance was  * resolved via {@link #createWithResolvedBean()}.  * @since 4.3  */ ;/**  * Return the HandlerMethod from which this HandlerMethod instance was  * resolved via {@link #createWithResolvedBean()}.  * @since 4.3  */ @Nullable public HandlerMethod getResolvedFromHandlerMethod() {     return this.resolvedFromHandlerMethod. }
true;public;0;9;/**  * If the provided instance contains a bean name rather than an object instance,  * the bean name is resolved before a {@link HandlerMethod} is created and returned.  */ ;/**  * If the provided instance contains a bean name rather than an object instance,  * the bean name is resolved before a {@link HandlerMethod} is created and returned.  */ public HandlerMethod createWithResolvedBean() {     Object handler = this.bean.     if (this.bean instanceof String) {         Assert.state(this.beanFactory != null, "Cannot resolve bean name without BeanFactory").         String beanName = (String) this.bean.         handler = this.beanFactory.getBean(beanName).     }     return new HandlerMethod(this, handler). }
true;public;0;4;/**  * Return a short representation of this handler method for log message purposes.  */ ;/**  * Return a short representation of this handler method for log message purposes.  */ public String getShortLogMessage() {     int args = this.method.getParameterCount().     return getBeanType().getName() + "#" + this.method.getName() + "[" + args + " args]". }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof HandlerMethod)) {         return false.     }     HandlerMethod otherMethod = (HandlerMethod) other.     return (this.bean.equals(otherMethod.bean) && this.method.equals(otherMethod.method)). }
false;public;0;4;;@Override public int hashCode() {     return (this.bean.hashCode() * 31 + this.method.hashCode()). }
false;public;0;4;;@Override public String toString() {     return this.method.toGenericString(). }
false;protected,static;2;11;;// Support methods for use in "InvocableHandlerMethod" sub-class variants.. @Nullable protected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {     if (!ObjectUtils.isEmpty(providedArgs)) {         for (Object providedArg : providedArgs) {             if (parameter.getParameterType().isInstance(providedArg)) {                 return providedArg.             }         }     }     return null. }
false;protected,static;2;4;;protected static String formatArgumentError(MethodParameter param, String message) {     return "Could not resolve parameter [" + param.getParameterIndex() + "] in " + param.getExecutable().toGenericString() + (StringUtils.hasText(message) ? ": " + message : ""). }
true;protected;3;11;/**  * Assert that the target bean class is an instance of the class where the given  * method is declared. In some cases the actual endpoint instance at request-  * processing time may be a JDK dynamic proxy (lazy initialization, prototype  * beans, and others). Endpoint classes that require proxying should prefer  * class-based proxy mechanisms.  */ ;/**  * Assert that the target bean class is an instance of the class where the given  * method is declared. In some cases the actual endpoint instance at request-  * processing time may be a JDK dynamic proxy (lazy initialization, prototype  * beans, and others). Endpoint classes that require proxying should prefer  * class-based proxy mechanisms.  */ protected void assertTargetBean(Method method, Object targetBean, Object[] args) {     Class<?> methodDeclaringClass = method.getDeclaringClass().     Class<?> targetBeanClass = targetBean.getClass().     if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {         String text = "The mapped handler method class '" + methodDeclaringClass.getName() + "' is not an instance of the actual endpoint bean class '" + targetBeanClass.getName() + "'. If the endpoint requires proxying " + "(e.g. due to @Transactional), please use class-based proxying.".         throw new IllegalStateException(formatInvokeError(text, args)).     } }
false;protected;2;13;;protected String formatInvokeError(String text, Object[] args) {     String formattedArgs = IntStream.range(0, args.length).mapToObj(i -> (args[i] != null ? "[" + i + "] [type=" + args[i].getClass().getName() + "] [value=" + args[i] + "]" : "[" + i + "] [null]")).collect(Collectors.joining(",\n", " ", " ")).     return text + "\n" + "Endpoint [" + getBeanType().getName() + "]\n" + "Method [" + getBridgedMethod().toGenericString() + "] " + "with argument values:\n" + formattedArgs. }
false;public;0;4;;@Override public Class<?> getContainingClass() {     return HandlerMethod.this.getBeanType(). }
false;public;1;4;;@Override public <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {     return HandlerMethod.this.getMethodAnnotation(annotationType). }
false;public;1;4;;@Override public <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {     return HandlerMethod.this.hasMethodAnnotation(annotationType). }
false;public;0;4;;@Override public HandlerMethodParameter clone() {     return new HandlerMethodParameter(this). }
false;public;0;4;;@Override public Class<?> getParameterType() {     return (this.returnValue != null ? this.returnValue.getClass() : super.getParameterType()). }
false;public;0;4;;@Override public ReturnValueMethodParameter clone() {     return new ReturnValueMethodParameter(this). }
