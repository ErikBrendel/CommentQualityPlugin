commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the wrapped {@link StompDecoder}.  */ ;/**  * Return the wrapped {@link StompDecoder}.  */ public final StompDecoder getStompDecoder() {     return this.stompDecoder. }
true;public,final;0;3;/**  * Return the configured buffer size limit.  */ ;/**  * Return the configured buffer size limit.  */ public final int getBufferSizeLimit() {     return this.bufferSizeLimit. }
true;public;1;20;/**  * Decodes one or more STOMP frames from the given {@code ByteBuffer} into a  * list of {@link Message Messages}.  * <p>If there was enough data to parse a "content-length" header, then the  * value is used to determine how much more data is needed before a new  * attempt to decode is made.  * <p>If there was not enough data to parse the "content-length", or if there  * is "content-length" header, every subsequent call to decode attempts to  * parse again with all available data. Therefore the presence of a "content-length"  * header helps to optimize the decoding of large messages.  * @param newBuffer a buffer containing new data to decode  * @return decoded messages or an empty list  * @throws StompConversionException raised in case of decoding issues  */ ;/**  * Decodes one or more STOMP frames from the given {@code ByteBuffer} into a  * list of {@link Message Messages}.  * <p>If there was enough data to parse a "content-length" header, then the  * value is used to determine how much more data is needed before a new  * attempt to decode is made.  * <p>If there was not enough data to parse the "content-length", or if there  * is "content-length" header, every subsequent call to decode attempts to  * parse again with all available data. Therefore the presence of a "content-length"  * header helps to optimize the decoding of large messages.  * @param newBuffer a buffer containing new data to decode  * @return decoded messages or an empty list  * @throws StompConversionException raised in case of decoding issues  */ public List<Message<byte[]>> decode(ByteBuffer newBuffer) {     this.chunks.add(newBuffer).     checkBufferLimits().     Integer contentLength = this.expectedContentLength.     if (contentLength != null && getBufferSize() < contentLength) {         return Collections.emptyList().     }     ByteBuffer bufferToDecode = assembleChunksAndReset().     MultiValueMap<String, String> headers = new LinkedMultiValueMap<>().     List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers).     if (bufferToDecode.hasRemaining()) {         this.chunks.add(bufferToDecode).         this.expectedContentLength = StompHeaderAccessor.getContentLength(headers).     }     return messages. }
false;private;0;16;;private ByteBuffer assembleChunksAndReset() {     ByteBuffer result.     if (this.chunks.size() == 1) {         result = this.chunks.remove().     } else {         result = ByteBuffer.allocate(getBufferSize()).         for (ByteBuffer partial : this.chunks) {             result.put(partial).         }         result.flip().     }     this.chunks.clear().     this.expectedContentLength = null.     return result. }
false;private;0;12;;private void checkBufferLimits() {     Integer contentLength = this.expectedContentLength.     if (contentLength != null && contentLength > this.bufferSizeLimit) {         throw new StompConversionException("STOMP 'content-length' header value " + this.expectedContentLength + "  exceeds configured buffer size limit " + this.bufferSizeLimit).     }     if (getBufferSize() > this.bufferSizeLimit) {         throw new StompConversionException("The configured STOMP buffer size limit of " + this.bufferSizeLimit + " bytes has been exceeded").     } }
true;public;0;7;/**  * Calculate the current buffer size.  */ ;/**  * Calculate the current buffer size.  */ public int getBufferSize() {     int size = 0.     for (ByteBuffer buffer : this.chunks) {         size = size + buffer.remaining().     }     return size. }
true;public;0;4;/**  * Get the expected content length of the currently buffered, incomplete STOMP frame.  */ ;/**  * Get the expected content length of the currently buffered, incomplete STOMP frame.  */ @Nullable public Integer getExpectedContentLength() {     return this.expectedContentLength. }
