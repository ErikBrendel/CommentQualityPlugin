# id;timestamp;commentText;codeText;commentWords;codeWords
BufferingStompDecoder -> public Integer getExpectedContentLength();1395703237;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public Integer getExpectedContentLength();1397429525;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public Integer getExpectedContentLength();1397439322;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public Integer getExpectedContentLength();1413848647;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public Integer getExpectedContentLength();1467730834;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public Integer getExpectedContentLength();1474903230;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public Integer getExpectedContentLength();1497251962;Get the expected content length of the currently buffered, incomplete STOMP frame.;public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1397439322;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s.__<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made.__<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages.__@param newBuffer a buffer containing new data to decode__@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {__		this.chunks.add(newBuffer)___		checkBufferLimits()___		if (getExpectedContentLength() != null && getBufferSize() < this.expectedContentLength) {_			return Collections.<Message<byte[]>>emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()___		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,get,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,message,byte,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,string,string,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1413848647;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s.__<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made.__<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages.__@param newBuffer a buffer containing new data to decode__@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {__		this.chunks.add(newBuffer)___		checkBufferLimits()___		if (getExpectedContentLength() != null && getBufferSize() < this.expectedContentLength) {_			return Collections.<Message<byte[]>>emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()___		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,get,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,message,byte,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,string,string,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1467730834;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s.__<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made.__<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages.__@param newBuffer a buffer containing new data to decode__@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {__		this.chunks.add(newBuffer)___		checkBufferLimits()___		if (getExpectedContentLength() != null && getBufferSize() < this.expectedContentLength) {_			return Collections.<Message<byte[]>>emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()___		MultiValueMap<String, String> headers = new LinkedMultiValueMap<>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,get,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,message,byte,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1474903230;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s._<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made._<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages._@param newBuffer a buffer containing new data to decode_@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {_		this.chunks.add(newBuffer)__		checkBufferLimits()___		if (this.expectedContentLength != null && getBufferSize() < this.expectedContentLength) {_			return Collections.emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()__		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,this,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,string,string,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1497251962;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s._<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made._<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages._@param newBuffer a buffer containing new data to decode_@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {_		this.chunks.add(newBuffer)__		checkBufferLimits()___		if (this.expectedContentLength != null && getBufferSize() < this.expectedContentLength) {_			return Collections.emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()__		MultiValueMap<String, String> headers = new LinkedMultiValueMap<>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,this,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1498780456;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s._<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made._<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages._@param newBuffer a buffer containing new data to decode_@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {_		this.chunks.add(newBuffer)__		checkBufferLimits()___		Integer contentLength = this.expectedContentLength__		if (contentLength != null && getBufferSize() < contentLength) {_			return Collections.emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()__		MultiValueMap<String, String> headers = new LinkedMultiValueMap<>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,integer,content,length,this,expected,content,length,if,content,length,null,get,buffer,size,content,length,return,collections,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1520529117;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s._<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made._<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages._@param newBuffer a buffer containing new data to decode_@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {_		this.chunks.add(newBuffer)__		checkBufferLimits()___		Integer contentLength = this.expectedContentLength__		if (contentLength != null && getBufferSize() < contentLength) {_			return Collections.emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()__		MultiValueMap<String, String> headers = new LinkedMultiValueMap<>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,integer,content,length,this,expected,content,length,if,content,length,null,get,buffer,size,content,length,return,collections,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public List<Message<byte[]>> decode(ByteBuffer newBuffer);1530174524;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message Messages}._<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made._<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages._@param newBuffer a buffer containing new data to decode_@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;public List<Message<byte[]>> decode(ByteBuffer newBuffer) {_		this.chunks.add(newBuffer)__		checkBufferLimits()___		Integer contentLength = this.expectedContentLength__		if (contentLength != null && getBufferSize() < contentLength) {_			return Collections.emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()__		MultiValueMap<String, String> headers = new LinkedMultiValueMap<>()__		List<Message<byte[]>> messages = this.stompDecoder.decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,messages,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,integer,content,length,this,expected,content,length,if,content,length,null,get,buffer,size,content,length,return,collections,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,list,message,byte,messages,this,stomp,decoder,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public final StompDecoder getStompDecoder();1474903230;Return the wrapped {@link StompDecoder}.;public final StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,stomp,decoder;public,final,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public final StompDecoder getStompDecoder();1497251962;Return the wrapped {@link StompDecoder}.;public final StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,stomp,decoder;public,final,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public final StompDecoder getStompDecoder();1498780456;Return the wrapped {@link StompDecoder}.;public final StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,stomp,decoder;public,final,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public final StompDecoder getStompDecoder();1520529117;Return the wrapped {@link StompDecoder}.;public final StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,stomp,decoder;public,final,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public final StompDecoder getStompDecoder();1530174524;Return the wrapped {@link StompDecoder}.;public final StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,stomp,decoder;public,final,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public StompDecoder getStompDecoder();1397439322;Return the wrapped_{@link org.springframework.messaging.simp.stomp.StompDecoder}.;public StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,org,springframework,messaging,simp,stomp,stomp,decoder;public,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public StompDecoder getStompDecoder();1413848647;Return the wrapped_{@link org.springframework.messaging.simp.stomp.StompDecoder}.;public StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,org,springframework,messaging,simp,stomp,stomp,decoder;public,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public StompDecoder getStompDecoder();1467730834;Return the wrapped_{@link org.springframework.messaging.simp.stomp.StompDecoder}.;public StompDecoder getStompDecoder() {_		return this.stompDecoder__	};return,the,wrapped,link,org,springframework,messaging,simp,stomp,stomp,decoder;public,stomp,decoder,get,stomp,decoder,return,this,stomp,decoder
BufferingStompDecoder -> public int getBufferSizeLimit();1395703237;Return the configured buffer size limit.;public int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public int getBufferSizeLimit();1397429525;Return the configured buffer size limit.;public int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public int getBufferSizeLimit();1397439322;Return the configured buffer size limit.;public int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public int getBufferSizeLimit();1413848647;Return the configured buffer size limit.;public int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public int getBufferSizeLimit();1467730834;Return the configured buffer size limit.;public int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> @Nullable 	public Integer getExpectedContentLength();1498780456;Get the expected content length of the currently buffered, incomplete STOMP frame.;@Nullable_	public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;nullable,public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> @Nullable 	public Integer getExpectedContentLength();1520529117;Get the expected content length of the currently buffered, incomplete STOMP frame.;@Nullable_	public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;nullable,public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> @Nullable 	public Integer getExpectedContentLength();1530174524;Get the expected content length of the currently buffered, incomplete STOMP frame.;@Nullable_	public Integer getExpectedContentLength() {_		return this.expectedContentLength__	};get,the,expected,content,length,of,the,currently,buffered,incomplete,stomp,frame;nullable,public,integer,get,expected,content,length,return,this,expected,content,length
BufferingStompDecoder -> public int getBufferSize();1395703237;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1397429525;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1397439322;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1413848647;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1467730834;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1474903230;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1497251962;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1498780456;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1520529117;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> public int getBufferSize();1530174524;Calculate the current buffer size.;public int getBufferSize() {_		int size = 0__		for (ByteBuffer buffer : this.chunks) {_			size = size + buffer.remaining()__		}_		return size__	};calculate,the,current,buffer,size;public,int,get,buffer,size,int,size,0,for,byte,buffer,buffer,this,chunks,size,size,buffer,remaining,return,size
BufferingStompDecoder -> @Override 	public List<Message<byte[]>> decode(ByteBuffer newBuffer);1395703237;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s.__<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made.__<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages.__@param newBuffer a buffer containing new data to decode__@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;@Override_	public List<Message<byte[]>> decode(ByteBuffer newBuffer) {__		this.chunks.add(newBuffer)___		checkBufferLimits()___		if (getExpectedContentLength() != null && getBufferSize() < this.expectedContentLength) {_			return Collections.<Message<byte[]>>emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()___		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>()__		List<Message<byte[]>> messages = decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;override,public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,get,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,message,byte,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,string,string,list,message,byte,messages,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,get,content,length,headers,return,messages
BufferingStompDecoder -> @Override 	public List<Message<byte[]>> decode(ByteBuffer newBuffer);1397429525;Decodes one or more STOMP frames from the given {@code ByteBuffer} into a_list of {@link Message}s.__<p>If there was enough data to parse a "content-length" header, then the_value is used to determine how much more data is needed before a new_attempt to decode is made.__<p>If there was not enough data to parse the "content-length", or if there_is "content-length" header, every subsequent call to decode attempts to_parse again with all available data. Therefore the presence of a "content-length"_header helps to optimize the decoding of large messages.__@param newBuffer a buffer containing new data to decode__@return decoded messages or an empty list_@throws StompConversionException raised in case of decoding issues;@Override_	public List<Message<byte[]>> decode(ByteBuffer newBuffer) {__		this.chunks.add(newBuffer)___		checkBufferLimits()___		if (getExpectedContentLength() != null && getBufferSize() < this.expectedContentLength) {_			return Collections.<Message<byte[]>>emptyList()__		}__		ByteBuffer bufferToDecode = assembleChunksAndReset()___		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>()__		List<Message<byte[]>> messages = decode(bufferToDecode, headers)___		if (bufferToDecode.hasRemaining()) {_			this.chunks.add(bufferToDecode)__			this.expectedContentLength = StompHeaderAccessor.getContentLength(headers)__		}__		return messages__	};decodes,one,or,more,stomp,frames,from,the,given,code,byte,buffer,into,a,list,of,link,message,s,p,if,there,was,enough,data,to,parse,a,content,length,header,then,the,value,is,used,to,determine,how,much,more,data,is,needed,before,a,new,attempt,to,decode,is,made,p,if,there,was,not,enough,data,to,parse,the,content,length,or,if,there,is,content,length,header,every,subsequent,call,to,decode,attempts,to,parse,again,with,all,available,data,therefore,the,presence,of,a,content,length,header,helps,to,optimize,the,decoding,of,large,messages,param,new,buffer,a,buffer,containing,new,data,to,decode,return,decoded,messages,or,an,empty,list,throws,stomp,conversion,exception,raised,in,case,of,decoding,issues;override,public,list,message,byte,decode,byte,buffer,new,buffer,this,chunks,add,new,buffer,check,buffer,limits,if,get,expected,content,length,null,get,buffer,size,this,expected,content,length,return,collections,message,byte,empty,list,byte,buffer,buffer,to,decode,assemble,chunks,and,reset,multi,value,map,string,string,headers,new,linked,multi,value,map,string,string,list,message,byte,messages,decode,buffer,to,decode,headers,if,buffer,to,decode,has,remaining,this,chunks,add,buffer,to,decode,this,expected,content,length,stomp,header,accessor,get,content,length,headers,return,messages
BufferingStompDecoder -> public final int getBufferSizeLimit();1474903230;Return the configured buffer size limit.;public final int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,final,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public final int getBufferSizeLimit();1497251962;Return the configured buffer size limit.;public final int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,final,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public final int getBufferSizeLimit();1498780456;Return the configured buffer size limit.;public final int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,final,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public final int getBufferSizeLimit();1520529117;Return the configured buffer size limit.;public final int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,final,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public final int getBufferSizeLimit();1530174524;Return the configured buffer size limit.;public final int getBufferSizeLimit() {_		return this.bufferSizeLimit__	};return,the,configured,buffer,size,limit;public,final,int,get,buffer,size,limit,return,this,buffer,size,limit
BufferingStompDecoder -> public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit);1474903230;Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}._@param stompDecoder the target decoder to wrap_@param bufferSizeLimit the buffer size limit;public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit) {_		Assert.notNull(stompDecoder, "StompDecoder is required")__		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0")__		this.stompDecoder = stompDecoder__		this.bufferSizeLimit = bufferSizeLimit__	};create,a,new,code,buffering,stomp,decoder,wrapping,the,given,code,stomp,decoder,param,stomp,decoder,the,target,decoder,to,wrap,param,buffer,size,limit,the,buffer,size,limit;public,buffering,stomp,decoder,stomp,decoder,stomp,decoder,int,buffer,size,limit,assert,not,null,stomp,decoder,stomp,decoder,is,required,assert,is,true,buffer,size,limit,0,buffer,size,limit,must,be,greater,than,0,this,stomp,decoder,stomp,decoder,this,buffer,size,limit,buffer,size,limit
BufferingStompDecoder -> public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit);1497251962;Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}._@param stompDecoder the target decoder to wrap_@param bufferSizeLimit the buffer size limit;public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit) {_		Assert.notNull(stompDecoder, "StompDecoder is required")__		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0")__		this.stompDecoder = stompDecoder__		this.bufferSizeLimit = bufferSizeLimit__	};create,a,new,code,buffering,stomp,decoder,wrapping,the,given,code,stomp,decoder,param,stomp,decoder,the,target,decoder,to,wrap,param,buffer,size,limit,the,buffer,size,limit;public,buffering,stomp,decoder,stomp,decoder,stomp,decoder,int,buffer,size,limit,assert,not,null,stomp,decoder,stomp,decoder,is,required,assert,is,true,buffer,size,limit,0,buffer,size,limit,must,be,greater,than,0,this,stomp,decoder,stomp,decoder,this,buffer,size,limit,buffer,size,limit
BufferingStompDecoder -> public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit);1498780456;Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}._@param stompDecoder the target decoder to wrap_@param bufferSizeLimit the buffer size limit;public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit) {_		Assert.notNull(stompDecoder, "StompDecoder is required")__		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0")__		this.stompDecoder = stompDecoder__		this.bufferSizeLimit = bufferSizeLimit__	};create,a,new,code,buffering,stomp,decoder,wrapping,the,given,code,stomp,decoder,param,stomp,decoder,the,target,decoder,to,wrap,param,buffer,size,limit,the,buffer,size,limit;public,buffering,stomp,decoder,stomp,decoder,stomp,decoder,int,buffer,size,limit,assert,not,null,stomp,decoder,stomp,decoder,is,required,assert,is,true,buffer,size,limit,0,buffer,size,limit,must,be,greater,than,0,this,stomp,decoder,stomp,decoder,this,buffer,size,limit,buffer,size,limit
BufferingStompDecoder -> public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit);1520529117;Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}._@param stompDecoder the target decoder to wrap_@param bufferSizeLimit the buffer size limit;public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit) {_		Assert.notNull(stompDecoder, "StompDecoder is required")__		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0")__		this.stompDecoder = stompDecoder__		this.bufferSizeLimit = bufferSizeLimit__	};create,a,new,code,buffering,stomp,decoder,wrapping,the,given,code,stomp,decoder,param,stomp,decoder,the,target,decoder,to,wrap,param,buffer,size,limit,the,buffer,size,limit;public,buffering,stomp,decoder,stomp,decoder,stomp,decoder,int,buffer,size,limit,assert,not,null,stomp,decoder,stomp,decoder,is,required,assert,is,true,buffer,size,limit,0,buffer,size,limit,must,be,greater,than,0,this,stomp,decoder,stomp,decoder,this,buffer,size,limit,buffer,size,limit
BufferingStompDecoder -> public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit);1530174524;Create a new {@code BufferingStompDecoder} wrapping the given {@code StompDecoder}._@param stompDecoder the target decoder to wrap_@param bufferSizeLimit the buffer size limit;public BufferingStompDecoder(StompDecoder stompDecoder, int bufferSizeLimit) {_		Assert.notNull(stompDecoder, "StompDecoder is required")__		Assert.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0")__		this.stompDecoder = stompDecoder__		this.bufferSizeLimit = bufferSizeLimit__	};create,a,new,code,buffering,stomp,decoder,wrapping,the,given,code,stomp,decoder,param,stomp,decoder,the,target,decoder,to,wrap,param,buffer,size,limit,the,buffer,size,limit;public,buffering,stomp,decoder,stomp,decoder,stomp,decoder,int,buffer,size,limit,assert,not,null,stomp,decoder,stomp,decoder,is,required,assert,is,true,buffer,size,limit,0,buffer,size,limit,must,be,greater,than,0,this,stomp,decoder,stomp,decoder,this,buffer,size,limit,buffer,size,limit
