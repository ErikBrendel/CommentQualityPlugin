commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the {@link PathMatcher} to use.  */ ;/**  * Specify the {@link PathMatcher} to use.  */ public void setPathMatcher(PathMatcher pathMatcher) {     this.pathMatcher = pathMatcher. }
true;public;0;3;/**  * Return the configured {@link PathMatcher}.  */ ;/**  * Return the configured {@link PathMatcher}.  */ public PathMatcher getPathMatcher() {     return this.pathMatcher. }
true;public;1;3;/**  * Specify the maximum number of entries for the resolved destination cache.  * Default is 1024.  */ ;/**  * Specify the maximum number of entries for the resolved destination cache.  * Default is 1024.  */ public void setCacheLimit(int cacheLimit) {     this.cacheLimit = cacheLimit. }
true;public;0;3;/**  * Return the maximum number of entries for the resolved destination cache.  */ ;/**  * Return the maximum number of entries for the resolved destination cache.  */ public int getCacheLimit() {     return this.cacheLimit. }
true;public;1;3;/**  * Configure the name of a header that a subscription message can have for  * the purpose of filtering messages matched to the subscription. The header  * value is expected to be a Spring EL boolean expression to be applied to  * the headers of messages matched to the subscription.  * <p>For example:  * <pre>  * headers.foo == 'bar'  * </pre>  * <p>By default this is set to "selector". You can set it to a different  * name, or to {@code null} to turn off support for a selector header.  * @param selectorHeaderName the name to use for a selector header  * @since 4.2  */ ;/**  * Configure the name of a header that a subscription message can have for  * the purpose of filtering messages matched to the subscription. The header  * value is expected to be a Spring EL boolean expression to be applied to  * the headers of messages matched to the subscription.  * <p>For example:  * <pre>  * headers.foo == 'bar'  * </pre>  * <p>By default this is set to "selector". You can set it to a different  * name, or to {@code null} to turn off support for a selector header.  * @param selectorHeaderName the name to use for a selector header  * @since 4.2  */ public void setSelectorHeaderName(@Nullable String selectorHeaderName) {     this.selectorHeaderName = (StringUtils.hasText(selectorHeaderName) ? selectorHeaderName : null). }
true;public;0;4;/**  * Return the name for the selector header name.  * @since 4.2  */ ;/**  * Return the name for the selector header name.  * @since 4.2  */ @Nullable public String getSelectorHeaderName() {     return this.selectorHeaderName. }
false;protected;4;8;;@Override protected void addSubscriptionInternal(String sessionId, String subsId, String destination, Message<?> message) {     Expression expression = getSelectorExpression(message.getHeaders()).     this.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression).     this.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId). }
false;private;1;22;;@Nullable private Expression getSelectorExpression(MessageHeaders headers) {     Expression expression = null.     if (getSelectorHeaderName() != null) {         String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers).         if (selector != null) {             try {                 expression = this.expressionParser.parseExpression(selector).                 this.selectorHeaderInUse = true.                 if (logger.isTraceEnabled()) {                     logger.trace("Subscription selector: [" + selector + "]").                 }             } catch (Throwable ex) {                 if (logger.isDebugEnabled()) {                     logger.debug("Failed to parse selector: " + selector, ex).                 }             }         }     }     return expression. }
false;protected;3;10;;@Override protected void removeSubscriptionInternal(String sessionId, String subsId, Message<?> message) {     SessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId).     if (info != null) {         String destination = info.removeSubscription(subsId).         if (destination != null) {             this.destinationCache.updateAfterRemovedSubscription(sessionId, subsId).         }     } }
false;public;1;7;;@Override public void unregisterAllSubscriptions(String sessionId) {     SessionSubscriptionInfo info = this.subscriptionRegistry.removeSubscriptions(sessionId).     if (info != null) {         this.destinationCache.updateAfterRemovedSession(info).     } }
false;protected;2;5;;@Override protected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {     MultiValueMap<String, String> result = this.destinationCache.getSubscriptions(destination, message).     return filterSubscriptions(result, message). }
false;private;2;39;;private MultiValueMap<String, String> filterSubscriptions(MultiValueMap<String, String> allMatches, Message<?> message) {     if (!this.selectorHeaderInUse) {         return allMatches.     }     MultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size()).     allMatches.forEach((sessionId, subIds) -> {         for (String subId : subIds) {             SessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId).             if (info == null) {                 continue.             }             Subscription sub = info.getSubscription(subId).             if (sub == null) {                 continue.             }             Expression expression = sub.getSelectorExpression().             if (expression == null) {                 result.add(sessionId, subId).                 continue.             }             try {                 if (Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {                     result.add(sessionId, subId).                 }             } catch (SpelEvaluationException ex) {                 if (logger.isDebugEnabled()) {                     logger.debug("Failed to evaluate selector: " + ex.getMessage()).                 }             } catch (Throwable ex) {                 logger.debug("Failed to evaluate selector", ex).             }         }     }).     return result. }
false;public;0;4;;@Override public String toString() {     return "DefaultSubscriptionRegistry[" + this.destinationCache + ", " + this.subscriptionRegistry + "]". }
false;protected;1;10;;@Override protected boolean removeEldestEntry(Map.Entry<String, LinkedMultiValueMap<String, String>> eldest) {     if (size() > getCacheLimit()) {         accessCache.remove(eldest.getKey()).         return true.     } else {         return false.     } }
false;public;2;22;;public LinkedMultiValueMap<String, String> getSubscriptions(String destination, Message<?> message) {     LinkedMultiValueMap<String, String> result = this.accessCache.get(destination).     if (result == null) {         synchronized (this.updateCache) {             result = new LinkedMultiValueMap<>().             for (SessionSubscriptionInfo info : subscriptionRegistry.getAllSubscriptions()) {                 for (String destinationPattern : info.getDestinations()) {                     if (getPathMatcher().match(destinationPattern, destination)) {                         for (Subscription sub : info.getSubscriptions(destinationPattern)) {                             result.add(info.sessionId, sub.getId()).                         }                     }                 }             }             if (!result.isEmpty()) {                 this.updateCache.put(destination, result.deepCopy()).                 this.accessCache.put(destination, result).             }         }     }     return result. }
false;public;3;14;;public void updateAfterNewSubscription(String destination, String sessionId, String subsId) {     synchronized (this.updateCache) {         this.updateCache.forEach((cachedDestination, subscriptions) -> {             if (getPathMatcher().match(destination, cachedDestination)) {                 // Subscription id's may also be populated via getSubscriptions()                 List<String> subsForSession = subscriptions.get(sessionId).                 if (subsForSession == null || !subsForSession.contains(subsId)) {                     subscriptions.add(sessionId, subsId).                     this.accessCache.put(cachedDestination, subscriptions.deepCopy()).                 }             }         }).     } }
false;public;2;24;;public void updateAfterRemovedSubscription(String sessionId, String subsId) {     synchronized (this.updateCache) {         Set<String> destinationsToRemove = new HashSet<>().         this.updateCache.forEach((destination, sessionMap) -> {             List<String> subscriptions = sessionMap.get(sessionId).             if (subscriptions != null) {                 subscriptions.remove(subsId).                 if (subscriptions.isEmpty()) {                     sessionMap.remove(sessionId).                 }                 if (sessionMap.isEmpty()) {                     destinationsToRemove.add(destination).                 } else {                     this.accessCache.put(destination, sessionMap.deepCopy()).                 }             }         }).         for (String destination : destinationsToRemove) {             this.updateCache.remove(destination).             this.accessCache.remove(destination).         }     } }
false;public;1;19;;public void updateAfterRemovedSession(SessionSubscriptionInfo info) {     synchronized (this.updateCache) {         Set<String> destinationsToRemove = new HashSet<>().         this.updateCache.forEach((destination, sessionMap) -> {             if (sessionMap.remove(info.getSessionId()) != null) {                 if (sessionMap.isEmpty()) {                     destinationsToRemove.add(destination).                 } else {                     this.accessCache.put(destination, sessionMap.deepCopy()).                 }             }         }).         for (String destination : destinationsToRemove) {             this.updateCache.remove(destination).             this.accessCache.remove(destination).         }     } }
false;public;0;4;;@Override public String toString() {     return "cache[" + this.accessCache.size() + " destination(s)]". }
false;public;1;4;;@Nullable public SessionSubscriptionInfo getSubscriptions(String sessionId) {     return this.sessions.get(sessionId). }
false;public;0;3;;public Collection<SessionSubscriptionInfo> getAllSubscriptions() {     return this.sessions.values(). }
false;public;4;14;;public SessionSubscriptionInfo addSubscription(String sessionId, String subscriptionId, String destination, @Nullable Expression selectorExpression) {     SessionSubscriptionInfo info = this.sessions.get(sessionId).     if (info == null) {         info = new SessionSubscriptionInfo(sessionId).         SessionSubscriptionInfo value = this.sessions.putIfAbsent(sessionId, info).         if (value != null) {             info = value.         }     }     info.addSubscription(destination, subscriptionId, selectorExpression).     return info. }
false;public;1;4;;@Nullable public SessionSubscriptionInfo removeSubscriptions(String sessionId) {     return this.sessions.remove(sessionId). }
false;public;0;4;;@Override public String toString() {     return "registry[" + this.sessions.size() + " sessions]". }
false;public;0;3;;public String getSessionId() {     return this.sessionId. }
false;public;0;3;;public Set<String> getDestinations() {     return this.destinationLookup.keySet(). }
false;public;1;3;;public Set<Subscription> getSubscriptions(String destination) {     return this.destinationLookup.get(destination). }
false;public;1;12;;@Nullable public Subscription getSubscription(String subscriptionId) {     for (Map.Entry<String, Set<DefaultSubscriptionRegistry.Subscription>> destinationEntry : this.destinationLookup.entrySet()) {         for (Subscription sub : destinationEntry.getValue()) {             if (sub.getId().equalsIgnoreCase(subscriptionId)) {                 return sub.             }         }     }     return null. }
false;public;3;13;;public void addSubscription(String destination, String subscriptionId, @Nullable Expression selectorExpression) {     Set<Subscription> subs = this.destinationLookup.get(destination).     if (subs == null) {         synchronized (this.destinationLookup) {             subs = this.destinationLookup.get(destination).             if (subs == null) {                 subs = new CopyOnWriteArraySet<>().                 this.destinationLookup.put(destination, subs).             }         }     }     subs.add(new Subscription(subscriptionId, selectorExpression)). }
false;public;1;20;;@Nullable public String removeSubscription(String subscriptionId) {     for (Map.Entry<String, Set<DefaultSubscriptionRegistry.Subscription>> destinationEntry : this.destinationLookup.entrySet()) {         Set<Subscription> subs = destinationEntry.getValue().         if (subs != null) {             for (Subscription sub : subs) {                 if (sub.getId().equals(subscriptionId) && subs.remove(sub)) {                     synchronized (this.destinationLookup) {                         if (subs.isEmpty()) {                             this.destinationLookup.remove(destinationEntry.getKey()).                         }                     }                     return destinationEntry.getKey().                 }             }         }     }     return null. }
false;public;0;4;;@Override public String toString() {     return "[sessionId=" + this.sessionId + ", subscriptions=" + this.destinationLookup + "]". }
false;public;0;3;;public String getId() {     return this.id. }
false;public;0;4;;@Nullable public Expression getSelectorExpression() {     return this.selectorExpression. }
false;public;1;4;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof Subscription && this.id.equals(((Subscription) other).id))). }
false;public;0;4;;@Override public int hashCode() {     return this.id.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "subscription(id=" + this.id + ")". }
false;public;0;4;;@Override public Class<?>[] getSpecificTargetClasses() {     return new Class<?>[] { Message.class, MessageHeaders.class }. }
false;public;3;4;;@Override public boolean canRead(EvaluationContext context, @Nullable Object target, String name) {     return true. }
false;public;3;27;;@Override public TypedValue read(EvaluationContext context, @Nullable Object target, String name) {     Object value.     if (target instanceof Message) {         value = name.equals("headers") ? ((Message) target).getHeaders() : null.     } else if (target instanceof MessageHeaders) {         MessageHeaders headers = (MessageHeaders) target.         SimpMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(headers, SimpMessageHeaderAccessor.class).         Assert.state(accessor != null, "No SimpMessageHeaderAccessor").         if ("destination".equalsIgnoreCase(name)) {             value = accessor.getDestination().         } else {             value = accessor.getFirstNativeHeader(name).             if (value == null) {                 value = headers.get(name).             }         }     } else {         // Should never happen...         throw new IllegalStateException("Expected Message or MessageHeaders.").     }     return new TypedValue(value). }
false;public;3;4;;@Override public boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {     return false. }
false;public;4;3;;@Override public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value) { }
