commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set an alternative logger to use than the one based on the class name.  * @param logger the logger to use  * @since 5.1  */ ;/**  * Set an alternative logger to use than the one based on the class name.  * @param logger the logger to use  * @since 5.1  */ public void setLogger(Log logger) {     this.logger = logger. }
true;public;0;3;/**  * Return the currently configured Logger.  * @since 5.1  */ ;/**  * Return the currently configured Logger.  * @since 5.1  */ public Log getLogger() {     return logger. }
true;public;0;3;/**  * Return a read-only list with the configured handlers.  */ ;/**  * Return a read-only list with the configured handlers.  */ public List<HandlerMethodReturnValueHandler> getReturnValueHandlers() {     return Collections.unmodifiableList(this.returnValueHandlers). }
true;public;0;3;/**  * Clear the list of configured handlers.  */ ;/**  * Clear the list of configured handlers.  */ public void clear() {     this.returnValueHandlers.clear(). }
true;public;1;4;/**  * Add the given {@link HandlerMethodReturnValueHandler}.  */ ;/**  * Add the given {@link HandlerMethodReturnValueHandler}.  */ public HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler returnValueHandler) {     this.returnValueHandlers.add(returnValueHandler).     return this. }
true;public;1;8;/**  * Add the given {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.  */ ;/**  * Add the given {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.  */ public HandlerMethodReturnValueHandlerComposite addHandlers(@Nullable List<? extends HandlerMethodReturnValueHandler> handlers) {     if (handlers != null) {         this.returnValueHandlers.addAll(handlers).     }     return this. }
false;public;1;4;;@Override public boolean supportsReturnType(MethodParameter returnType) {     return getReturnValueHandler(returnType) != null. }
false;private;1;11;;@SuppressWarnings("ForLoopReplaceableByForEach") @Nullable private HandlerMethodReturnValueHandler getReturnValueHandler(MethodParameter returnType) {     for (int i = 0. i < this.returnValueHandlers.size(). i++) {         HandlerMethodReturnValueHandler handler = this.returnValueHandlers.get(i).         if (handler.supportsReturnType(returnType)) {             return handler.         }     }     return null. }
false;public;3;13;;@Override public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message) throws Exception {     HandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType).     if (handler == null) {         throw new IllegalStateException("No handler for return value type: " + returnType.getParameterType()).     }     if (logger.isTraceEnabled()) {         logger.trace("Processing return value with " + handler).     }     handler.handleReturnValue(returnValue, returnType, message). }
false;public;2;6;;@Override public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {     HandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType).     return (handler instanceof AsyncHandlerMethodReturnValueHandler && ((AsyncHandlerMethodReturnValueHandler) handler).isAsyncReturnValue(returnValue, returnType)). }
false;public;2;8;;@Override @Nullable public ListenableFuture<?> toListenableFuture(Object returnValue, MethodParameter returnType) {     HandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType).     Assert.state(handler instanceof AsyncHandlerMethodReturnValueHandler, "AsyncHandlerMethodReturnValueHandler required").     return ((AsyncHandlerMethodReturnValueHandler) handler).toListenableFuture(returnValue, returnType). }
