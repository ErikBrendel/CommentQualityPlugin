commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Configure the default destination to use in send methods that don't have  * a destination argument. If a default destination is not configured, send methods  * without a destination argument will raise an exception if invoked.  */ ;/**  * Configure the default destination to use in send methods that don't have  * a destination argument. If a default destination is not configured, send methods  * without a destination argument will raise an exception if invoked.  */ public void setDefaultDestination(@Nullable D defaultDestination) {     this.defaultDestination = defaultDestination. }
true;public;0;4;/**  * Return the configured default destination.  */ ;/**  * Return the configured default destination.  */ @Nullable public D getDefaultDestination() {     return this.defaultDestination. }
true;public;1;4;/**  * Set the {@link MessageConverter} to use in {@code convertAndSend} methods.  * <p>By default, {@link SimpleMessageConverter} is used.  * @param messageConverter the message converter to use  */ ;/**  * Set the {@link MessageConverter} to use in {@code convertAndSend} methods.  * <p>By default, {@link SimpleMessageConverter} is used.  * @param messageConverter the message converter to use  */ public void setMessageConverter(MessageConverter messageConverter) {     Assert.notNull(messageConverter, "MessageConverter must not be null").     this.converter = messageConverter. }
true;public;0;3;/**  * Return the configured {@link MessageConverter}.  */ ;/**  * Return the configured {@link MessageConverter}.  */ public MessageConverter getMessageConverter() {     return this.converter. }
false;public;1;4;;@Override public void send(Message<?> message) {     send(getRequiredDefaultDestination(), message). }
false;protected,final;0;4;;protected final D getRequiredDefaultDestination() {     Assert.state(this.defaultDestination != null, "No 'defaultDestination' configured").     return this.defaultDestination. }
false;public;2;4;;@Override public void send(D destination, Message<?> message) {     doSend(destination, message). }
false;protected,abstract;2;1;;protected abstract void doSend(D destination, Message<?> message).
false;public;1;4;;@Override public void convertAndSend(Object payload) throws MessagingException {     convertAndSend(payload, null). }
false;public;2;4;;@Override public void convertAndSend(D destination, Object payload) throws MessagingException {     convertAndSend(destination, payload, (Map<String, Object>) null). }
false;public;3;6;;@Override public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers) throws MessagingException {     convertAndSend(destination, payload, headers, null). }
false;public;2;6;;@Override public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor) throws MessagingException {     convertAndSend(getRequiredDefaultDestination(), payload, postProcessor). }
false;public;3;6;;@Override public void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor) throws MessagingException {     convertAndSend(destination, payload, null, postProcessor). }
false;public;4;7;;@Override public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor) throws MessagingException {     Message<?> message = doConvert(payload, headers, postProcessor).     send(destination, message). }
true;protected;3;31;/**  * Convert the given Object to serialized form, possibly using a  * {@link MessageConverter}, wrap it as a message with the given  * headers and apply the given post processor.  * @param payload the Object to use as payload  * @param headers headers for the message to send  * @param postProcessor the post processor to apply to the message  * @return the converted message  */ ;/**  * Convert the given Object to serialized form, possibly using a  * {@link MessageConverter}, wrap it as a message with the given  * headers and apply the given post processor.  * @param payload the Object to use as payload  * @param headers headers for the message to send  * @param postProcessor the post processor to apply to the message  * @return the converted message  */ protected Message<?> doConvert(Object payload, @Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor) {     MessageHeaders messageHeaders = null.     Object conversionHint = (headers != null ? headers.get(CONVERSION_HINT_HEADER) : null).     Map<String, Object> headersToUse = processHeadersToSend(headers).     if (headersToUse != null) {         if (headersToUse instanceof MessageHeaders) {             messageHeaders = (MessageHeaders) headersToUse.         } else {             messageHeaders = new MessageHeaders(headersToUse).         }     }     MessageConverter converter = getMessageConverter().     Message<?> message = (converter instanceof SmartMessageConverter ? ((SmartMessageConverter) converter).toMessage(payload, messageHeaders, conversionHint) : converter.toMessage(payload, messageHeaders)).     if (message == null) {         String payloadType = payload.getClass().getName().         Object contentType = (messageHeaders != null ? messageHeaders.get(MessageHeaders.CONTENT_TYPE) : null).         throw new MessageConversionException("Unable to convert payload with type='" + payloadType + "', contentType='" + contentType + "', converter=[" + getMessageConverter() + "]").     }     if (postProcessor != null) {         message = postProcessor.postProcessMessage(message).     }     return message. }
true;protected;1;4;/**  * Provides access to the map of input headers before a send operation.  * Subclasses can modify the headers and then return the same or a different map.  * <p>This default implementation in this class returns the input map.  * @param headers the headers to send (or {@code null} if none)  * @return the actual headers to send (or {@code null} if none)  */ ;/**  * Provides access to the map of input headers before a send operation.  * Subclasses can modify the headers and then return the same or a different map.  * <p>This default implementation in this class returns the input map.  * @param headers the headers to send (or {@code null} if none)  * @return the actual headers to send (or {@code null} if none)  */ @Nullable protected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {     return headers. }
