commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Nullable public Executor getExecutor() {     return this.executor. }
false;public;1;6;;@Override public void setInterceptors(List<ChannelInterceptor> interceptors) {     super.setInterceptors(interceptors).     this.executorInterceptors.clear().     interceptors.forEach(this::updateExecutorInterceptorsFor). }
false;public;1;5;;@Override public void addInterceptor(ChannelInterceptor interceptor) {     super.addInterceptor(interceptor).     updateExecutorInterceptorsFor(interceptor). }
false;public;2;5;;@Override public void addInterceptor(int index, ChannelInterceptor interceptor) {     super.addInterceptor(index, interceptor).     updateExecutorInterceptorsFor(interceptor). }
false;private;1;5;;private void updateExecutorInterceptorsFor(ChannelInterceptor interceptor) {     if (interceptor instanceof ExecutorChannelInterceptor) {         this.executorInterceptors.add((ExecutorChannelInterceptor) interceptor).     } }
false;public;2;13;;@Override public boolean sendInternal(Message<?> message, long timeout) {     for (MessageHandler handler : getSubscribers()) {         SendTask sendTask = new SendTask(message, handler).         if (this.executor == null) {             sendTask.run().         } else {             this.executor.execute(sendTask).         }     }     return true. }
false;public;0;4;;@Override public Message<?> getMessage() {     return this.inputMessage. }
false;public;0;4;;@Override public MessageHandler getMessageHandler() {     return this.messageHandler. }
false;public;0;26;;@Override public void run() {     Message<?> message = this.inputMessage.     try {         message = applyBeforeHandle(message).         if (message == null) {             return.         }         this.messageHandler.handleMessage(message).         triggerAfterMessageHandled(message, null).     } catch (Exception ex) {         triggerAfterMessageHandled(message, ex).         if (ex instanceof MessagingException) {             throw (MessagingException) ex.         }         String description = "Failed to handle " + message + " to " + this + " in " + this.messageHandler.         throw new MessageDeliveryException(message, description, ex).     } catch (Throwable err) {         String description = "Failed to handle " + message + " to " + this + " in " + this.messageHandler.         MessageDeliveryException ex2 = new MessageDeliveryException(message, description, err).         triggerAfterMessageHandled(message, ex2).         throw ex2.     } }
false;private;1;17;;@Nullable private Message<?> applyBeforeHandle(Message<?> message) {     Message<?> messageToUse = message.     for (ExecutorChannelInterceptor interceptor : executorInterceptors) {         messageToUse = interceptor.beforeHandle(messageToUse, ExecutorSubscribableChannel.this, this.messageHandler).         if (messageToUse == null) {             String name = interceptor.getClass().getSimpleName().             if (logger.isDebugEnabled()) {                 logger.debug(name + " returned null from beforeHandle, i.e. precluding the send.").             }             triggerAfterMessageHandled(message, null).             return null.         }         this.interceptorIndex++.     }     return messageToUse. }
false;private;2;11;;private void triggerAfterMessageHandled(Message<?> message, @Nullable Exception ex) {     for (int i = this.interceptorIndex. i >= 0. i--) {         ExecutorChannelInterceptor interceptor = executorInterceptors.get(i).         try {             interceptor.afterMessageHandled(message, ExecutorSubscribableChannel.this, this.messageHandler, ex).         } catch (Throwable ex2) {             logger.error("Exception from afterMessageHandled in " + interceptor, ex2).         }     } }
