commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setApplicationContext(@Nullable ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
false;public;0;4;;@Nullable public ApplicationContext getApplicationContext() {     return this.applicationContext. }
false;public;0;10;;@Bean public AbstractSubscribableChannel clientInboundChannel() {     ExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(clientInboundChannelExecutor()).     channel.setLogger(SimpLogging.forLog(channel.getLogger())).     ChannelRegistration reg = getClientInboundChannelRegistration().     if (reg.hasInterceptors()) {         channel.setInterceptors(reg.getInterceptors()).     }     return channel. }
false;public;0;7;;@Bean public ThreadPoolTaskExecutor clientInboundChannelExecutor() {     TaskExecutorRegistration reg = getClientInboundChannelRegistration().taskExecutor().     ThreadPoolTaskExecutor executor = reg.getTaskExecutor().     executor.setThreadNamePrefix("clientInboundChannel-").     return executor. }
false;protected,final;0;9;;protected final ChannelRegistration getClientInboundChannelRegistration() {     if (this.clientInboundChannelRegistration == null) {         ChannelRegistration registration = new ChannelRegistration().         configureClientInboundChannel(registration).         registration.interceptors(new ImmutableMessageChannelInterceptor()).         this.clientInboundChannelRegistration = registration.     }     return this.clientInboundChannelRegistration. }
true;protected;1;2;/**  * A hook for subclasses to customize the message channel for inbound messages  * from WebSocket clients.  */ ;/**  * A hook for subclasses to customize the message channel for inbound messages  * from WebSocket clients.  */ protected void configureClientInboundChannel(ChannelRegistration registration) { }
false;public;0;10;;@Bean public AbstractSubscribableChannel clientOutboundChannel() {     ExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(clientOutboundChannelExecutor()).     channel.setLogger(SimpLogging.forLog(channel.getLogger())).     ChannelRegistration reg = getClientOutboundChannelRegistration().     if (reg.hasInterceptors()) {         channel.setInterceptors(reg.getInterceptors()).     }     return channel. }
false;public;0;7;;@Bean public ThreadPoolTaskExecutor clientOutboundChannelExecutor() {     TaskExecutorRegistration reg = getClientOutboundChannelRegistration().taskExecutor().     ThreadPoolTaskExecutor executor = reg.getTaskExecutor().     executor.setThreadNamePrefix("clientOutboundChannel-").     return executor. }
false;protected,final;0;9;;protected final ChannelRegistration getClientOutboundChannelRegistration() {     if (this.clientOutboundChannelRegistration == null) {         ChannelRegistration registration = new ChannelRegistration().         configureClientOutboundChannel(registration).         registration.interceptors(new ImmutableMessageChannelInterceptor()).         this.clientOutboundChannelRegistration = registration.     }     return this.clientOutboundChannelRegistration. }
true;protected;1;2;/**  * A hook for subclasses to customize the message channel for messages from  * the application or message broker to WebSocket clients.  */ ;/**  * A hook for subclasses to customize the message channel for messages from  * the application or message broker to WebSocket clients.  */ protected void configureClientOutboundChannel(ChannelRegistration registration) { }
false;public;0;10;;@Bean public AbstractSubscribableChannel brokerChannel() {     ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration().     ExecutorSubscribableChannel channel = (reg.hasTaskExecutor() ? new ExecutorSubscribableChannel(brokerChannelExecutor()) : new ExecutorSubscribableChannel()).     reg.interceptors(new ImmutableMessageChannelInterceptor()).     channel.setLogger(SimpLogging.forLog(channel.getLogger())).     channel.setInterceptors(reg.getInterceptors()).     return channel. }
false;public;0;17;;@Bean public ThreadPoolTaskExecutor brokerChannelExecutor() {     ChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration().     ThreadPoolTaskExecutor executor.     if (reg.hasTaskExecutor()) {         executor = reg.taskExecutor().getTaskExecutor().     } else {         // Should never be used         executor = new ThreadPoolTaskExecutor().         executor.setCorePoolSize(0).         executor.setMaxPoolSize(1).         executor.setQueueCapacity(0).     }     executor.setThreadNamePrefix("brokerChannel-").     return executor. }
true;protected,final;0;8;/**  * An accessor for the {@link MessageBrokerRegistry} that ensures its one-time creation  * and initialization through {@link #configureMessageBroker(MessageBrokerRegistry)}.  */ ;/**  * An accessor for the {@link MessageBrokerRegistry} that ensures its one-time creation  * and initialization through {@link #configureMessageBroker(MessageBrokerRegistry)}.  */ protected final MessageBrokerRegistry getBrokerRegistry() {     if (this.brokerRegistry == null) {         MessageBrokerRegistry registry = new MessageBrokerRegistry(clientInboundChannel(), clientOutboundChannel()).         configureMessageBroker(registry).         this.brokerRegistry = registry.     }     return this.brokerRegistry. }
true;protected;1;2;/**  * A hook for subclasses to customize message broker configuration through the  * provided {@link MessageBrokerRegistry} instance.  */ ;/**  * A hook for subclasses to customize message broker configuration through the  * provided {@link MessageBrokerRegistry} instance.  */ protected void configureMessageBroker(MessageBrokerRegistry registry) { }
true;public,final;0;4;/**  * Provide access to the configured PatchMatcher for access from other  * configuration classes.  */ ;/**  * Provide access to the configured PatchMatcher for access from other  * configuration classes.  */ @Nullable public final PathMatcher getPathMatcher() {     return getBrokerRegistry().getPathMatcher(). }
false;public;0;21;;@Bean public SimpAnnotationMethodMessageHandler simpAnnotationMethodMessageHandler() {     SimpAnnotationMethodMessageHandler handler = createAnnotationMethodMessageHandler().     handler.setDestinationPrefixes(getBrokerRegistry().getApplicationDestinationPrefixes()).     handler.setMessageConverter(brokerMessageConverter()).     handler.setValidator(simpValidator()).     List<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<>().     addArgumentResolvers(argumentResolvers).     handler.setCustomArgumentResolvers(argumentResolvers).     List<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>().     addReturnValueHandlers(returnValueHandlers).     handler.setCustomReturnValueHandlers(returnValueHandlers).     PathMatcher pathMatcher = getBrokerRegistry().getPathMatcher().     if (pathMatcher != null) {         handler.setPathMatcher(pathMatcher).     }     return handler. }
true;protected;0;4;/**  * Protected method for plugging in a custom subclass of  * {@link org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler  * SimpAnnotationMethodMessageHandler}.  * @since 4.2  */ ;/**  * Protected method for plugging in a custom subclass of  * {@link org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler  * SimpAnnotationMethodMessageHandler}.  * @since 4.2  */ protected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler() {     return new SimpAnnotationMethodMessageHandler(clientInboundChannel(), clientOutboundChannel(), brokerMessagingTemplate()). }
false;protected;1;2;;protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) { }
false;protected;1;2;;protected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) { }
false;public;0;10;;@Bean @Nullable public AbstractBrokerMessageHandler simpleBrokerMessageHandler() {     SimpleBrokerMessageHandler handler = getBrokerRegistry().getSimpleBroker(brokerChannel()).     if (handler == null) {         return null.     }     updateUserDestinationResolver(handler).     return handler. }
false;private;1;6;;private void updateUserDestinationResolver(AbstractBrokerMessageHandler handler) {     Collection<String> prefixes = handler.getDestinationPrefixes().     if (!prefixes.isEmpty() && !prefixes.iterator().next().startsWith("/")) {         ((DefaultUserDestinationResolver) userDestinationResolver()).setRemoveLeadingSlash(true).     } }
false;public;0;20;;@Bean @Nullable public AbstractBrokerMessageHandler stompBrokerRelayMessageHandler() {     StompBrokerRelayMessageHandler handler = getBrokerRegistry().getStompBrokerRelay(brokerChannel()).     if (handler == null) {         return null.     }     Map<String, MessageHandler> subscriptions = new HashMap<>(4).     String destination = getBrokerRegistry().getUserDestinationBroadcast().     if (destination != null) {         subscriptions.put(destination, userDestinationMessageHandler()).     }     destination = getBrokerRegistry().getUserRegistryBroadcast().     if (destination != null) {         subscriptions.put(destination, userRegistryMessageHandler()).     }     handler.setSystemSubscriptions(subscriptions).     updateUserDestinationResolver(handler).     return handler. }
false;public;0;10;;@Bean public UserDestinationMessageHandler userDestinationMessageHandler() {     UserDestinationMessageHandler handler = new UserDestinationMessageHandler(clientInboundChannel(), brokerChannel(), userDestinationResolver()).     String destination = getBrokerRegistry().getUserDestinationBroadcast().     if (destination != null) {         handler.setBroadcastDestination(destination).     }     return handler. }
false;public;0;12;;@Bean @Nullable public MessageHandler userRegistryMessageHandler() {     if (getBrokerRegistry().getUserRegistryBroadcast() == null) {         return null.     }     SimpUserRegistry userRegistry = userRegistry().     Assert.isInstanceOf(MultiServerUserRegistry.class, userRegistry, "MultiServerUserRegistry required").     return new UserRegistryMessageHandler((MultiServerUserRegistry) userRegistry, brokerMessagingTemplate(), getBrokerRegistry().getUserRegistryBroadcast(), messageBrokerTaskScheduler()). }
true;public;0;8;// Expose alias for 4.1 compatibility ;// Expose alias for 4.1 compatibility @Bean(name = { "messageBrokerTaskScheduler", "messageBrokerSockJsTaskScheduler" }) public ThreadPoolTaskScheduler messageBrokerTaskScheduler() {     ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler().     scheduler.setThreadNamePrefix("MessageBroker-").     scheduler.setPoolSize(Runtime.getRuntime().availableProcessors()).     scheduler.setRemoveOnCancelPolicy(true).     return scheduler. }
false;public;0;10;;@Bean public SimpMessagingTemplate brokerMessagingTemplate() {     SimpMessagingTemplate template = new SimpMessagingTemplate(brokerChannel()).     String prefix = getBrokerRegistry().getUserDestinationPrefix().     if (prefix != null) {         template.setUserDestinationPrefix(prefix).     }     template.setMessageConverter(brokerMessageConverter()).     return template. }
false;public;0;13;;@Bean public CompositeMessageConverter brokerMessageConverter() {     List<MessageConverter> converters = new ArrayList<>().     boolean registerDefaults = configureMessageConverters(converters).     if (registerDefaults) {         converters.add(new StringMessageConverter()).         converters.add(new ByteArrayMessageConverter()).         if (jackson2Present) {             converters.add(createJacksonConverter()).         }     }     return new CompositeMessageConverter(converters). }
false;protected;0;7;;protected MappingJackson2MessageConverter createJacksonConverter() {     DefaultContentTypeResolver resolver = new DefaultContentTypeResolver().     resolver.setDefaultMimeType(MimeTypeUtils.APPLICATION_JSON).     MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter().     converter.setContentTypeResolver(resolver).     return converter. }
true;protected;1;3;/**  * Override this method to add custom message converters.  * @param messageConverters the list to add converters to, initially empty  * @return {@code true} if default message converters should be added to list,  * {@code false} if no more converters should be added.  */ ;/**  * Override this method to add custom message converters.  * @param messageConverters the list to add converters to, initially empty  * @return {@code true} if default message converters should be added to list,  * {@code false} if no more converters should be added.  */ protected boolean configureMessageConverters(List<MessageConverter> messageConverters) {     return true. }
false;public;0;9;;@Bean public UserDestinationResolver userDestinationResolver() {     DefaultUserDestinationResolver resolver = new DefaultUserDestinationResolver(userRegistry()).     String prefix = getBrokerRegistry().getUserDestinationPrefix().     if (prefix != null) {         resolver.setUserDestinationPrefix(prefix).     }     return resolver. }
false;public;0;10;;@Bean @SuppressWarnings("deprecation") public SimpUserRegistry userRegistry() {     SimpUserRegistry registry = createLocalUserRegistry().     if (registry == null) {         registry = createLocalUserRegistry(getBrokerRegistry().getUserRegistryOrder()).     }     boolean broadcast = getBrokerRegistry().getUserRegistryBroadcast() != null.     return (broadcast ? new MultiServerUserRegistry(registry) : registry). }
true;protected;0;5;/**  * Create the user registry that provides access to local users.  * @deprecated as of 5.1 in favor of {@link #createLocalUserRegistry(Integer)}  */ ;/**  * Create the user registry that provides access to local users.  * @deprecated as of 5.1 in favor of {@link #createLocalUserRegistry(Integer)}  */ @Deprecated @Nullable protected SimpUserRegistry createLocalUserRegistry() {     return null. }
true;protected,abstract;1;1;/**  * Create the user registry that provides access to local users.  * @param order the order to use as a {@link SmartApplicationListener}.  * @since 5.1  */ ;/**  * Create the user registry that provides access to local users.  * @param order the order to use as a {@link SmartApplicationListener}.  * @since 5.1  */ protected abstract SimpUserRegistry createLocalUserRegistry(@Nullable Integer order).
false;public;1;4;;@Override public boolean supports(Class<?> clazz) {     return false. }
false;public;2;3;;@Override public void validate(@Nullable Object target, Errors errors) { }
true;protected;0;31;/**  * Return a {@link org.springframework.validation.Validator  * org.springframework.validation.Validators} instance for validating  * {@code @Payload} method arguments.  * <p>In order, this method tries to get a Validator instance:  * <ul>  * <li>delegating to getValidator() first</li>  * <li>if none returned, getting an existing instance with its well-known name "mvcValidator",  * created by an MVC configuration</li>  * <li>if none returned, checking the classpath for the presence of a JSR-303 implementation  * before creating a {@code OptionalValidatorFactoryBean}</li>  * <li>returning a no-op Validator instance</li>  * </ul>  */ ;/**  * Return a {@link org.springframework.validation.Validator  * org.springframework.validation.Validators} instance for validating  * {@code @Payload} method arguments.  * <p>In order, this method tries to get a Validator instance:  * <ul>  * <li>delegating to getValidator() first</li>  * <li>if none returned, getting an existing instance with its well-known name "mvcValidator",  * created by an MVC configuration</li>  * <li>if none returned, checking the classpath for the presence of a JSR-303 implementation  * before creating a {@code OptionalValidatorFactoryBean}</li>  * <li>returning a no-op Validator instance</li>  * </ul>  */ protected Validator simpValidator() {     Validator validator = getValidator().     if (validator == null) {         if (this.applicationContext != null && this.applicationContext.containsBean(MVC_VALIDATOR_NAME)) {             validator = this.applicationContext.getBean(MVC_VALIDATOR_NAME, Validator.class).         } else if (ClassUtils.isPresent("javax.validation.Validator", getClass().getClassLoader())) {             Class<?> clazz.             try {                 String className = "org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean".                 clazz = ClassUtils.forName(className, AbstractMessageBrokerConfiguration.class.getClassLoader()).             } catch (Throwable ex) {                 throw new BeanInitializationException("Could not find default validator class", ex).             }             validator = (Validator) BeanUtils.instantiateClass(clazz).         } else {             validator = new Validator() {                  @Override                 public boolean supports(Class<?> clazz) {                     return false.                 }                  @Override                 public void validate(@Nullable Object target, Errors errors) {                 }             }.         }     }     return validator. }
true;public;0;4;/**  * Override this method to provide a custom {@link Validator}.  * @since 4.0.1  */ ;/**  * Override this method to provide a custom {@link Validator}.  * @since 4.0.1  */ @Nullable public Validator getValidator() {     return null. }
