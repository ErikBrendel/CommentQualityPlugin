commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getSessionId() {     return this.sessionId. }
true;public;0;3;/**  * Return the configured session handler.  */ ;/**  * Return the configured session handler.  */ public StompSessionHandler getSessionHandler() {     return this.sessionHandler. }
false;public;0;4;;@Override public ListenableFuture<StompSession> getSessionFuture() {     return this.sessionFuture. }
true;public;1;4;/**  * Set the {@link MessageConverter} to use to convert the payload of incoming  * and outgoing messages to and from {@code byte[]} based on object type, or  * expected object type, and the "content-type" header.  * <p>By default, {@link SimpleMessageConverter} is configured.  * @param messageConverter the message converter to use  */ ;/**  * Set the {@link MessageConverter} to use to convert the payload of incoming  * and outgoing messages to and from {@code byte[]} based on object type, or  * expected object type, and the "content-type" header.  * <p>By default, {@link SimpleMessageConverter} is configured.  * @param messageConverter the message converter to use  */ public void setMessageConverter(MessageConverter messageConverter) {     Assert.notNull(messageConverter, "MessageConverter must not be null").     this.converter = messageConverter. }
true;public;0;3;/**  * Return the configured {@link MessageConverter}.  */ ;/**  * Return the configured {@link MessageConverter}.  */ public MessageConverter getMessageConverter() {     return this.converter. }
true;public;1;3;/**  * Configure the TaskScheduler to use for receipt tracking.  */ ;/**  * Configure the TaskScheduler to use for receipt tracking.  */ public void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {     this.taskScheduler = taskScheduler. }
true;public;0;4;/**  * Return the configured TaskScheduler to use for receipt tracking.  */ ;/**  * Return the configured TaskScheduler to use for receipt tracking.  */ @Nullable public TaskScheduler getTaskScheduler() {     return this.taskScheduler. }
true;public;1;4;/**  * Configure the time in milliseconds before a receipt expires.  * <p>By default set to 15,000 (15 seconds).  */ ;/**  * Configure the time in milliseconds before a receipt expires.  * <p>By default set to 15,000 (15 seconds).  */ public void setReceiptTimeLimit(long receiptTimeLimit) {     Assert.isTrue(receiptTimeLimit > 0, "Receipt time limit must be larger than zero").     this.receiptTimeLimit = receiptTimeLimit. }
true;public;0;3;/**  * Return the configured time limit before a receipt expires.  */ ;/**  * Return the configured time limit before a receipt expires.  */ public long getReceiptTimeLimit() {     return this.receiptTimeLimit. }
false;public;1;4;;@Override public void setAutoReceipt(boolean autoReceiptEnabled) {     this.autoReceiptEnabled = autoReceiptEnabled. }
true;public;0;3;/**  * Whether receipt headers should be automatically added.  */ ;/**  * Whether receipt headers should be automatically added.  */ public boolean isAutoReceiptEnabled() {     return this.autoReceiptEnabled. }
false;public;0;4;;@Override public boolean isConnected() {     return (this.connection != null). }
false;public;2;6;;@Override public Receiptable send(String destination, Object payload) {     StompHeaders headers = new StompHeaders().     headers.setDestination(destination).     return send(headers, payload). }
false;public;2;14;;@Override public Receiptable send(StompHeaders headers, Object payload) {     Assert.hasText(headers.getDestination(), "Destination header is required").     String receiptId = checkOrAddReceipt(headers).     Receiptable receiptable = new ReceiptHandler(receiptId).     StompHeaderAccessor accessor = createHeaderAccessor(StompCommand.SEND).     accessor.addNativeHeaders(headers).     Message<byte[]> message = createMessage(accessor, payload).     execute(message).     return receiptable. }
false;private;1;9;;@Nullable private String checkOrAddReceipt(StompHeaders headers) {     String receiptId = headers.getReceipt().     if (isAutoReceiptEnabled() && receiptId == null) {         receiptId = String.valueOf(DefaultStompSession.this.receiptIndex.getAndIncrement()).         headers.setReceipt(receiptId).     }     return receiptId. }
false;private;1;6;;private StompHeaderAccessor createHeaderAccessor(StompCommand command) {     StompHeaderAccessor accessor = StompHeaderAccessor.create(command).     accessor.setSessionId(this.sessionId).     accessor.setLeaveMutable(true).     return accessor. }
false;private;2;21;;@SuppressWarnings("unchecked") private Message<byte[]> createMessage(StompHeaderAccessor accessor, @Nullable Object payload) {     accessor.updateSimpMessageHeadersFromStompHeaders().     Message<byte[]> message.     if (payload == null) {         message = MessageBuilder.createMessage(EMPTY_PAYLOAD, accessor.getMessageHeaders()).     } else if (payload instanceof byte[]) {         message = MessageBuilder.createMessage((byte[]) payload, accessor.getMessageHeaders()).     } else {         message = (Message<byte[]>) getMessageConverter().toMessage(payload, accessor.getMessageHeaders()).         accessor.updateStompHeadersFromSimpMessageHeaders().         if (message == null) {             throw new MessageConversionException("Unable to convert payload with type='" + payload.getClass().getName() + "', contentType='" + accessor.getContentType() + "', converter=[" + getMessageConverter() + "]").         }     }     return message. }
false;private;1;19;;private void execute(Message<byte[]> message) {     if (logger.isTraceEnabled()) {         StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class).         if (accessor != null) {             logger.trace("Sending " + accessor.getDetailedLogMessage(message.getPayload())).         }     }     TcpConnection<byte[]> conn = this.connection.     Assert.state(conn != null, "Connection closed").     try {         conn.send(message).get().     } catch (ExecutionException ex) {         throw new MessageDeliveryException(message, ex.getCause()).     } catch (Throwable ex) {         throw new MessageDeliveryException(message, ex).     } }
false;public;2;6;;@Override public Subscription subscribe(String destination, StompFrameHandler handler) {     StompHeaders headers = new StompHeaders().     headers.setDestination(destination).     return subscribe(headers, handler). }
false;public;2;20;;@Override public Subscription subscribe(StompHeaders headers, StompFrameHandler handler) {     Assert.hasText(headers.getDestination(), "Destination header is required").     Assert.notNull(handler, "StompFrameHandler must not be null").     String subscriptionId = headers.getId().     if (!StringUtils.hasText(subscriptionId)) {         subscriptionId = String.valueOf(DefaultStompSession.this.subscriptionIndex.getAndIncrement()).         headers.setId(subscriptionId).     }     checkOrAddReceipt(headers).     Subscription subscription = new DefaultSubscription(headers, handler).     StompHeaderAccessor accessor = createHeaderAccessor(StompCommand.SUBSCRIBE).     accessor.addNativeHeaders(headers).     Message<byte[]> message = createMessage(accessor, EMPTY_PAYLOAD).     execute(message).     return subscription. }
false;public;2;11;;@Override public Receiptable acknowledge(String messageId, boolean consumed) {     StompHeaders headers = new StompHeaders().     if ("1.1".equals(this.version)) {         headers.setMessageId(messageId).     } else {         headers.setId(messageId).     }     return acknowledge(headers, consumed). }
false;public;2;13;;@Override public Receiptable acknowledge(StompHeaders headers, boolean consumed) {     String receiptId = checkOrAddReceipt(headers).     Receiptable receiptable = new ReceiptHandler(receiptId).     StompCommand command = (consumed ? StompCommand.ACK : StompCommand.NACK).     StompHeaderAccessor accessor = createHeaderAccessor(command).     accessor.addNativeHeaders(headers).     Message<byte[]> message = createMessage(accessor, null).     execute(message).     return receiptable. }
false;private;2;9;;private void unsubscribe(String id, @Nullable StompHeaders headers) {     StompHeaderAccessor accessor = createHeaderAccessor(StompCommand.UNSUBSCRIBE).     if (headers != null) {         accessor.addNativeHeaders(headers).     }     accessor.setSubscriptionId(id).     Message<byte[]> message = createMessage(accessor, EMPTY_PAYLOAD).     execute(message). }
false;public;0;12;;@Override public void disconnect() {     this.closing = true.     try {         StompHeaderAccessor accessor = createHeaderAccessor(StompCommand.DISCONNECT).         Message<byte[]> message = createMessage(accessor, EMPTY_PAYLOAD).         execute(message).     } finally {         resetConnection().     } }
false;public;1;14;;// TcpConnectionHandler @Override public void afterConnected(TcpConnection<byte[]> connection) {     this.connection = connection.     if (logger.isDebugEnabled()) {         logger.debug("Connection established in session id=" + this.sessionId).     }     StompHeaderAccessor accessor = createHeaderAccessor(StompCommand.CONNECT).     accessor.addNativeHeaders(this.connectHeaders).     if (this.connectHeaders.getAcceptVersion() == null) {         accessor.setAcceptVersion("1.1,1.2").     }     Message<byte[]> message = createMessage(accessor, EMPTY_PAYLOAD).     execute(message). }
false;public;1;8;;@Override public void afterConnectFailure(Throwable ex) {     if (logger.isDebugEnabled()) {         logger.debug("Failed to connect session id=" + this.sessionId, ex).     }     this.sessionFuture.setException(ex).     this.sessionHandler.handleTransportError(this, ex). }
false;public;1;54;;@Override public void handleMessage(Message<byte[]> message) {     StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class).     Assert.state(accessor != null, "No StompHeaderAccessor").     accessor.setSessionId(this.sessionId).     StompCommand command = accessor.getCommand().     Map<String, List<String>> nativeHeaders = accessor.getNativeHeaders().     StompHeaders headers = StompHeaders.readOnlyStompHeaders(nativeHeaders).     boolean isHeartbeat = accessor.isHeartbeat().     if (logger.isTraceEnabled()) {         logger.trace("Received " + accessor.getDetailedLogMessage(message.getPayload())).     }     try {         if (StompCommand.MESSAGE.equals(command)) {             DefaultSubscription subscription = this.subscriptions.get(headers.getSubscription()).             if (subscription != null) {                 invokeHandler(subscription.getHandler(), message, headers).             } else if (logger.isDebugEnabled()) {                 logger.debug("No handler for: " + accessor.getDetailedLogMessage(message.getPayload()) + ". Perhaps just unsubscribed?").             }         } else {             if (StompCommand.RECEIPT.equals(command)) {                 String receiptId = headers.getReceiptId().                 ReceiptHandler handler = this.receiptHandlers.get(receiptId).                 if (handler != null) {                     handler.handleReceiptReceived().                 } else if (logger.isDebugEnabled()) {                     logger.debug("No matching receipt: " + accessor.getDetailedLogMessage(message.getPayload())).                 }             } else if (StompCommand.CONNECTED.equals(command)) {                 initHeartbeatTasks(headers).                 this.version = headers.getFirst("version").                 this.sessionFuture.set(this).                 this.sessionHandler.afterConnected(this, headers).             } else if (StompCommand.ERROR.equals(command)) {                 invokeHandler(this.sessionHandler, message, headers).             } else if (!isHeartbeat && logger.isTraceEnabled()) {                 logger.trace("Message not handled.").             }         }     } catch (Throwable ex) {         this.sessionHandler.handleException(this, command, headers, message.getPayload(), ex).     } }
false;private;3;18;;private void invokeHandler(StompFrameHandler handler, Message<byte[]> message, StompHeaders headers) {     if (message.getPayload().length == 0) {         handler.handleFrame(headers, null).         return.     }     Type payloadType = handler.getPayloadType(headers).     Class<?> resolvedType = ResolvableType.forType(payloadType).resolve().     if (resolvedType == null) {         throw new MessageConversionException("Unresolvable payload type [" + payloadType + "] from handler type [" + handler.getClass() + "]").     }     Object object = getMessageConverter().fromMessage(message, resolvedType).     if (object == null) {         throw new MessageConversionException("No suitable converter for payload type [" + payloadType + "] from handler type [" + handler.getClass() + "]").     }     handler.handleFrame(headers, object). }
false;private;1;17;;private void initHeartbeatTasks(StompHeaders connectedHeaders) {     long[] connect = this.connectHeaders.getHeartbeat().     long[] connected = connectedHeaders.getHeartbeat().     if (connect == null || connected == null) {         return.     }     TcpConnection<byte[]> con = this.connection.     Assert.state(con != null, "No TcpConnection available").     if (connect[0] > 0 && connected[1] > 0) {         long interval = Math.max(connect[0], connected[1]).         con.onWriteInactivity(new WriteInactivityTask(), interval).     }     if (connect[1] > 0 && connected[0] > 0) {         long interval = Math.max(connect[1], connected[0]) * HEARTBEAT_MULTIPLIER.         con.onReadInactivity(new ReadInactivityTask(), interval).     } }
false;public;1;12;;@Override public void handleFailure(Throwable ex) {     try {         // no-op if already set         this.sessionFuture.setException(ex).         this.sessionHandler.handleTransportError(this, ex).     } catch (Throwable ex2) {         if (logger.isDebugEnabled()) {             logger.debug("Uncaught failure while handling transport failure", ex2).         }     } }
false;public;0;10;;@Override public void afterConnectionClosed() {     if (logger.isDebugEnabled()) {         logger.debug("Connection closed in session id=" + this.sessionId).     }     if (!this.closing) {         resetConnection().         handleFailure(new ConnectionLostException("Connection closed")).     } }
false;private;0;12;;private void resetConnection() {     TcpConnection<?> conn = this.connection.     this.connection = null.     if (conn != null) {         try {             conn.close().         } catch (Throwable ex) {         // ignore         }     } }
false;private;0;6;;private void initReceiptHandling() {     Assert.notNull(getTaskScheduler(), "To track receipts, a TaskScheduler must be configured").     DefaultStompSession.this.receiptHandlers.put(this.receiptId, this).     Date startTime = new Date(System.currentTimeMillis() + getReceiptTimeLimit()).     this.future = getTaskScheduler().schedule(this::handleReceiptNotReceived, startTime). }
false;public;0;5;;@Override @Nullable public String getReceiptId() {     return this.receiptId. }
false;public;1;4;;@Override public void addReceiptTask(Runnable task) {     addTask(task, true). }
false;public;1;4;;@Override public void addReceiptLostTask(Runnable task) {     addTask(task, false). }
false;private;2;17;;private void addTask(Runnable task, boolean successTask) {     Assert.notNull(this.receiptId, "To track receipts, set autoReceiptEnabled=true or add 'receiptId' header").     synchronized (this) {         if (this.result != null && this.result == successTask) {             invoke(Collections.singletonList(task)).         } else {             if (successTask) {                 this.receiptCallbacks.add(task).             } else {                 this.receiptLostCallbacks.add(task).             }         }     } }
false;private;1;10;;private void invoke(List<Runnable> callbacks) {     for (Runnable runnable : callbacks) {         try {             runnable.run().         } catch (Throwable ex) {         // ignore         }     } }
false;public;0;3;;public void handleReceiptReceived() {     handleInternal(true). }
false;public;0;3;;public void handleReceiptNotReceived() {     handleInternal(false). }
false;private;1;13;;private void handleInternal(boolean result) {     synchronized (this) {         if (this.result != null) {             return.         }         this.result = result.         invoke(result ? this.receiptCallbacks : this.receiptLostCallbacks).         DefaultStompSession.this.receiptHandlers.remove(this.receiptId).         if (this.future != null) {             this.future.cancel(true).         }     } }
false;public;0;5;;@Override @Nullable public String getSubscriptionId() {     return this.headers.getId(). }
false;public;0;4;;@Override public StompHeaders getSubscriptionHeaders() {     return this.headers. }
false;public;0;3;;public StompFrameHandler getHandler() {     return this.handler. }
false;public;0;4;;@Override public void unsubscribe() {     unsubscribe(null). }
false;public;1;8;;@Override public void unsubscribe(@Nullable StompHeaders headers) {     String id = this.headers.getId().     if (id != null) {         DefaultStompSession.this.subscriptions.remove(id).         DefaultStompSession.this.unsubscribe(id, headers).     } }
false;public;0;6;;@Override public String toString() {     return "Subscription [id=" + getSubscriptionId() + ", destination='" + this.headers.getDestination() + "', receiptId='" + getReceiptId() + "', handler=" + getHandler() + "]". }
false;public;1;2;;public void onSuccess(@Nullable Void result) { }
false;public;1;3;;public void onFailure(Throwable ex) {     handleFailure(ex). }
false;public;0;14;;@Override public void run() {     TcpConnection<byte[]> conn = connection.     if (conn != null) {         conn.send(HEARTBEAT).addCallback(new ListenableFutureCallback<Void>() {              public void onSuccess(@Nullable Void result) {             }              public void onFailure(Throwable ex) {                 handleFailure(ex).             }         }).     } }
false;public;0;10;;@Override public void run() {     closing = true.     String error = "Server has gone quiet. Closing connection in session id=" + sessionId + ".".     if (logger.isDebugEnabled()) {         logger.debug(error).     }     resetConnection().     handleFailure(new IllegalStateException(error)). }
