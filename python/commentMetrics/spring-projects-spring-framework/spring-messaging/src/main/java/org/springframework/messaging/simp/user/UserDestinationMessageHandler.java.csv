commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@link UserDestinationResolver}.  */ ;/**  * Return the configured {@link UserDestinationResolver}.  */ public UserDestinationResolver getUserDestinationResolver() {     return this.destinationResolver. }
true;public;1;4;/**  * Set a destination to broadcast messages to that remain unresolved because  * the user is not connected. In a multi-application server scenario this  * gives other application servers a chance to try.  * <p>By default this is not set.  * @param destination the target destination.  */ ;/**  * Set a destination to broadcast messages to that remain unresolved because  * the user is not connected. In a multi-application server scenario this  * gives other application servers a chance to try.  * <p>By default this is not set.  * @param destination the target destination.  */ public void setBroadcastDestination(@Nullable String destination) {     this.broadcastHandler = (StringUtils.hasText(destination) ? new BroadcastHandler(this.messagingTemplate, destination) : null). }
true;public;0;4;/**  * Return the configured destination for unresolved messages.  */ ;/**  * Return the configured destination for unresolved messages.  */ @Nullable public String getBroadcastDestination() {     return (this.broadcastHandler != null ? this.broadcastHandler.getBroadcastDestination() : null). }
true;public;0;3;/**  * Return the messaging template used to send resolved messages to the  * broker channel.  */ ;/**  * Return the messaging template used to send resolved messages to the  * broker channel.  */ public MessageSendingOperations<String> getBrokerMessagingTemplate() {     return this.messagingTemplate. }
true;public;1;3;/**  * Configure a custom {@link MessageHeaderInitializer} to initialize the  * headers of resolved target messages.  * <p>By default this is not set.  */ ;/**  * Configure a custom {@link MessageHeaderInitializer} to initialize the  * headers of resolved target messages.  * <p>By default this is not set.  */ public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {     this.headerInitializer = headerInitializer. }
true;public;0;4;/**  * Return the configured header initializer.  */ ;/**  * Return the configured header initializer.  */ @Nullable public MessageHeaderInitializer getHeaderInitializer() {     return this.headerInitializer. }
false;public,final;0;8;;@Override public final void start() {     synchronized (this.lifecycleMonitor) {         this.clientInboundChannel.subscribe(this).         this.brokerChannel.subscribe(this).         this.running = true.     } }
false;public,final;0;8;;@Override public final void stop() {     synchronized (this.lifecycleMonitor) {         this.running = false.         this.clientInboundChannel.unsubscribe(this).         this.brokerChannel.unsubscribe(this).     } }
false;public,final;1;7;;@Override public final void stop(Runnable callback) {     synchronized (this.lifecycleMonitor) {         stop().         callback.run().     } }
false;public,final;0;4;;@Override public final boolean isRunning() {     return this.running. }
false;public;1;38;;@Override public void handleMessage(Message<?> message) throws MessagingException {     Message<?> messageToUse = message.     if (this.broadcastHandler != null) {         messageToUse = this.broadcastHandler.preHandle(message).         if (messageToUse == null) {             return.         }     }     UserDestinationResult result = this.destinationResolver.resolveDestination(messageToUse).     if (result == null) {         return.     }     if (result.getTargetDestinations().isEmpty()) {         if (logger.isTraceEnabled()) {             logger.trace("No active sessions for user destination: " + result.getSourceDestination()).         }         if (this.broadcastHandler != null) {             this.broadcastHandler.handleUnresolved(messageToUse).         }         return.     }     SimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.wrap(messageToUse).     initHeaders(accessor).     accessor.setNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION, result.getSubscribeDestination()).     accessor.setLeaveMutable(true).     messageToUse = MessageBuilder.createMessage(messageToUse.getPayload(), accessor.getMessageHeaders()).     if (logger.isTraceEnabled()) {         logger.trace("Translated " + result.getSourceDestination() + " -> " + result.getTargetDestinations()).     }     for (String target : result.getTargetDestinations()) {         this.messagingTemplate.send(target, messageToUse).     } }
false;private;1;5;;private void initHeaders(SimpMessageHeaderAccessor headerAccessor) {     if (getHeaderInitializer() != null) {         getHeaderInitializer().initHeaders(headerAccessor).     } }
false;public;0;4;;@Override public String toString() {     return "UserDestinationMessageHandler[" + this.destinationResolver + "]". }
false;public;0;3;;public String getBroadcastDestination() {     return this.broadcastDestination. }
false;public;1;30;;@Nullable public Message<?> preHandle(Message<?> message) throws MessagingException {     String destination = SimpMessageHeaderAccessor.getDestination(message.getHeaders()).     if (!getBroadcastDestination().equals(destination)) {         return message.     }     SimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class).     Assert.state(accessor != null, "No SimpMessageHeaderAccessor").     if (accessor.getSessionId() == null) {         // Our own broadcast         return null.     }     destination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION).     if (logger.isTraceEnabled()) {         logger.trace("Checking unresolved user destination: " + destination).     }     SimpMessageHeaderAccessor newAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE).     for (String name : accessor.toNativeHeaderMap().keySet()) {         if (NO_COPY_LIST.contains(name)) {             continue.         }         newAccessor.setNativeHeader(name, accessor.getFirstNativeHeader(name)).     }     if (destination != null) {         newAccessor.setDestination(destination).     }     // ensure send doesn't block     newAccessor.setHeader(SimpMessageHeaderAccessor.IGNORE_ERROR, true).     return MessageBuilder.createMessage(message.getPayload(), newAccessor.getMessageHeaders()). }
false;public;1;17;;public void handleUnresolved(Message<?> message) {     MessageHeaders headers = message.getHeaders().     if (SimpMessageHeaderAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION, headers) != null) {         // Re-broadcast         return.     }     SimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.wrap(message).     String destination = accessor.getDestination().     accessor.setNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION, destination).     accessor.setLeaveMutable(true).     message = MessageBuilder.createMessage(message.getPayload(), accessor.getMessageHeaders()).     if (logger.isTraceEnabled()) {         logger.trace("Translated " + destination + " -> " + getBroadcastDestination()).     }     this.messagingTemplate.send(getBroadcastDestination(), message). }
