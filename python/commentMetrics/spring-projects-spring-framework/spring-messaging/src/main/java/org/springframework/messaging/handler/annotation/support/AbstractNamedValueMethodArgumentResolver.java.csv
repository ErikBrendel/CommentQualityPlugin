commented;modifiers;parameterAmount;loc;comment;code
false;public;2;34;;@Override @Nullable public Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {     NamedValueInfo namedValueInfo = getNamedValueInfo(parameter).     MethodParameter nestedParameter = parameter.nestedIfOptional().     Object resolvedName = resolveStringValue(namedValueInfo.name).     if (resolvedName == null) {         throw new IllegalArgumentException("Specified name must not resolve to null: [" + namedValueInfo.name + "]").     }     Object arg = resolveArgumentInternal(nestedParameter, message, resolvedName.toString()).     if (arg == null) {         if (namedValueInfo.defaultValue != null) {             arg = resolveStringValue(namedValueInfo.defaultValue).         } else if (namedValueInfo.required && !nestedParameter.isOptional()) {             handleMissingValue(namedValueInfo.name, nestedParameter, message).         }         arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType()).     } else if ("".equals(arg) && namedValueInfo.defaultValue != null) {         arg = resolveStringValue(namedValueInfo.defaultValue).     }     if (parameter != nestedParameter || !ClassUtils.isAssignableValue(parameter.getParameterType(), arg)) {         arg = this.conversionService.convert(arg, TypeDescriptor.forObject(arg), new TypeDescriptor(parameter)).     }     handleResolvedValue(arg, namedValueInfo.name, parameter, message).     return arg. }
true;private;1;9;/**  * Obtain the named value for the given method parameter.  */ ;/**  * Obtain the named value for the given method parameter.  */ private NamedValueInfo getNamedValueInfo(MethodParameter parameter) {     NamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter).     if (namedValueInfo == null) {         namedValueInfo = createNamedValueInfo(parameter).         namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo).         this.namedValueInfoCache.put(parameter, namedValueInfo).     }     return namedValueInfo. }
true;protected,abstract;1;1;/**  * Create the {@link NamedValueInfo} object for the given method parameter. Implementations typically  * retrieve the method annotation by means of {@link MethodParameter#getParameterAnnotation(Class)}.  * @param parameter the method parameter  * @return the named value information  */ ;/**  * Create the {@link NamedValueInfo} object for the given method parameter. Implementations typically  * retrieve the method annotation by means of {@link MethodParameter#getParameterAnnotation(Class)}.  * @param parameter the method parameter  * @return the named value information  */ protected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter).
true;private;2;12;/**  * Create a new NamedValueInfo based on the given NamedValueInfo with sanitized values.  */ ;/**  * Create a new NamedValueInfo based on the given NamedValueInfo with sanitized values.  */ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {     String name = info.name.     if (info.name.isEmpty()) {         name = parameter.getParameterName().         if (name == null) {             throw new IllegalArgumentException("Name for argument type [" + parameter.getParameterType().getName() + "] not available, and parameter name information not found in class file either.").         }     }     String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue).     return new NamedValueInfo(name, info.required, defaultValue). }
true;private;1;11;/**  * Resolve the given annotation-specified value,  * potentially containing placeholders and expressions.  */ ;/**  * Resolve the given annotation-specified value,  * potentially containing placeholders and expressions.  */ private Object resolveStringValue(String value) {     if (this.configurableBeanFactory == null) {         return value.     }     String placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value).     BeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver().     if (exprResolver == null) {         return value.     }     return exprResolver.evaluate(placeholdersResolved, this.expressionContext). }
true;protected,abstract;3;3;/**  * Resolves the given parameter type and value name into an argument value.  * @param parameter the method parameter to resolve to an argument value  * @param message the current request  * @param name the name of the value being resolved  * @return the resolved argument. May be {@code null}  * @throws Exception in case of errors  */ ;/**  * Resolves the given parameter type and value name into an argument value.  * @param parameter the method parameter to resolve to an argument value  * @param message the current request  * @param name the name of the value being resolved  * @return the resolved argument. May be {@code null}  * @throws Exception in case of errors  */ @Nullable protected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name) throws Exception.
true;protected,abstract;3;1;/**  * Invoked when a named value is required, but  * {@link #resolveArgumentInternal(MethodParameter, Message, String)} returned {@code null} and  * there is no default value. Subclasses typically throw an exception in this case.  * @param name the name for the value  * @param parameter the method parameter  * @param message the message being processed  */ ;/**  * Invoked when a named value is required, but  * {@link #resolveArgumentInternal(MethodParameter, Message, String)} returned {@code null} and  * there is no default value. Subclasses typically throw an exception in this case.  * @param name the name for the value  * @param parameter the method parameter  * @param message the message being processed  */ protected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message).
true;private;3;14;/**  * A {@code null} results in a {@code false} value for {@code boolean}s or an  * exception for other primitives.  */ ;/**  * A {@code null} results in a {@code false} value for {@code boolean}s or an  * exception for other primitives.  */ private Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {     if (value == null) {         if (Boolean.TYPE.equals(paramType)) {             return Boolean.FALSE.         } else if (paramType.isPrimitive()) {             throw new IllegalStateException("Optional " + paramType + " parameter '" + name + "' is present but cannot be translated into a null value due to being " + "declared as a primitive type. Consider declaring it as object wrapper " + "for the corresponding primitive type.").         }     }     return value. }
true;protected;4;2;/**  * Invoked after a value is resolved.  * @param arg the resolved argument value  * @param name the argument name  * @param parameter the argument parameter type  * @param message the message  */ ;/**  * Invoked after a value is resolved.  * @param arg the resolved argument value  * @param name the argument name  * @param parameter the argument parameter type  * @param message the message  */ protected void handleResolvedValue(Object arg, String name, MethodParameter parameter, Message<?> message) { }
