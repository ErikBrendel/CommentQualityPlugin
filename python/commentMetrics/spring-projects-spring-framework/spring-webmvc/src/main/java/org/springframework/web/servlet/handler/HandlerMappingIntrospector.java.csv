commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured HandlerMapping's.  */ ;/**  * Return the configured HandlerMapping's.  */ public List<HandlerMapping> getHandlerMappings() {     return (this.handlerMappings != null ? this.handlerMappings : Collections.emptyList()). }
false;public;1;4;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
false;public;0;7;;@Override public void afterPropertiesSet() {     if (this.handlerMappings == null) {         Assert.notNull(this.applicationContext, "No ApplicationContext").         this.handlerMappings = initHandlerMappings(this.applicationContext).     } }
true;public;1;16;/**  * Find the {@link HandlerMapping} that would handle the given request and  * return it as a {@link MatchableHandlerMapping} that can be used to test  * request-matching criteria.  * <p>If the matching HandlerMapping is not an instance of  * {@link MatchableHandlerMapping}, an IllegalStateException is raised.  * @param request the current request  * @return the resolved matcher, or {@code null}  * @throws Exception if any of the HandlerMapping's raise an exception  */ ;/**  * Find the {@link HandlerMapping} that would handle the given request and  * return it as a {@link MatchableHandlerMapping} that can be used to test  * request-matching criteria.  * <p>If the matching HandlerMapping is not an instance of  * {@link MatchableHandlerMapping}, an IllegalStateException is raised.  * @param request the current request  * @return the resolved matcher, or {@code null}  * @throws Exception if any of the HandlerMapping's raise an exception  */ @Nullable public MatchableHandlerMapping getMatchableHandlerMapping(HttpServletRequest request) throws Exception {     Assert.notNull(this.handlerMappings, "Handler mappings not initialized").     HttpServletRequest wrapper = new RequestAttributeChangeIgnoringWrapper(request).     for (HandlerMapping handlerMapping : this.handlerMappings) {         Object handler = handlerMapping.getHandler(wrapper).         if (handler == null) {             continue.         }         if (handlerMapping instanceof MatchableHandlerMapping) {             return ((MatchableHandlerMapping) handlerMapping).         }         throw new IllegalStateException("HandlerMapping is not a MatchableHandlerMapping").     }     return null. }
false;public;1;29;;@Override @Nullable public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {     Assert.notNull(this.handlerMappings, "Handler mappings not initialized").     HttpServletRequest wrapper = new RequestAttributeChangeIgnoringWrapper(request).     for (HandlerMapping handlerMapping : this.handlerMappings) {         HandlerExecutionChain handler = null.         try {             handler = handlerMapping.getHandler(wrapper).         } catch (Exception ex) {         // Ignore         }         if (handler == null) {             continue.         }         if (handler.getInterceptors() != null) {             for (HandlerInterceptor interceptor : handler.getInterceptors()) {                 if (interceptor instanceof CorsConfigurationSource) {                     return ((CorsConfigurationSource) interceptor).getCorsConfiguration(wrapper).                 }             }         }         if (handler.getHandler() instanceof CorsConfigurationSource) {             return ((CorsConfigurationSource) handler.getHandler()).getCorsConfiguration(wrapper).         }     }     return null. }
false;private,static;1;10;;private static List<HandlerMapping> initHandlerMappings(ApplicationContext applicationContext) {     Map<String, HandlerMapping> beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, HandlerMapping.class, true, false).     if (!beans.isEmpty()) {         List<HandlerMapping> mappings = new ArrayList<>(beans.values()).         AnnotationAwareOrderComparator.sort(mappings).         return Collections.unmodifiableList(mappings).     }     return Collections.unmodifiableList(initFallback(applicationContext)). }
false;private,static;1;26;;private static List<HandlerMapping> initFallback(ApplicationContext applicationContext) {     Properties props.     String path = "DispatcherServlet.properties".     try {         Resource resource = new ClassPathResource(path, DispatcherServlet.class).         props = PropertiesLoaderUtils.loadProperties(resource).     } catch (IOException ex) {         throw new IllegalStateException("Could not load '" + path + "': " + ex.getMessage()).     }     String value = props.getProperty(HandlerMapping.class.getName()).     String[] names = StringUtils.commaDelimitedListToStringArray(value).     List<HandlerMapping> result = new ArrayList<>(names.length).     for (String name : names) {         try {             Class<?> clazz = ClassUtils.forName(name, DispatcherServlet.class.getClassLoader()).             Object mapping = applicationContext.getAutowireCapableBeanFactory().createBean(clazz).             result.add((HandlerMapping) mapping).         } catch (ClassNotFoundException ex) {             throw new IllegalStateException("Could not find default HandlerMapping [" + name + "]").         }     }     return result. }
false;public;2;4;;@Override public void setAttribute(String name, Object value) { // Ignore attribute change... }
