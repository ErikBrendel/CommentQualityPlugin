commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Whether the type can be adapted to a Reactive Streams {@link Publisher}.  */ ;/**  * Whether the type can be adapted to a Reactive Streams {@link Publisher}.  */ public boolean isReactiveType(Class<?> type) {     return (this.reactiveRegistry.hasAdapters() && this.reactiveRegistry.getAdapter(type) != null). }
true;public;4;43;/**  * Process the given reactive return value and decide whether to adapt it  * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.  * @return an emitter for streaming, or {@code null} if handled internally  * with a {@link DeferredResult}  */ ;/**  * Process the given reactive return value and decide whether to adapt it  * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.  * @return an emitter for streaming, or {@code null} if handled internally  * with a {@link DeferredResult}  */ @Nullable public ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mav, NativeWebRequest request) throws Exception {     Assert.notNull(returnValue, "Expected return value").     ReactiveAdapter adapter = this.reactiveRegistry.getAdapter(returnValue.getClass()).     Assert.state(adapter != null, () -> "Unexpected return value: " + returnValue).     ResolvableType elementType = ResolvableType.forMethodParameter(returnType).getGeneric().     Class<?> elementClass = elementType.toClass().     Collection<MediaType> mediaTypes = getMediaTypes(request).     Optional<MediaType> mediaType = mediaTypes.stream().filter(MimeType::isConcrete).findFirst().     if (adapter.isMultiValue()) {         if (mediaTypes.stream().anyMatch(MediaType.TEXT_EVENT_STREAM::includes) || ServerSentEvent.class.isAssignableFrom(elementClass)) {             logExecutorWarning(returnType).             SseEmitter emitter = new SseEmitter(STREAMING_TIMEOUT_VALUE).             new SseEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue).             return emitter.         }         if (CharSequence.class.isAssignableFrom(elementClass)) {             logExecutorWarning(returnType).             ResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN)).             new TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue).             return emitter.         }         if (mediaTypes.stream().anyMatch(MediaType.APPLICATION_STREAM_JSON::includes)) {             logExecutorWarning(returnType).             ResponseBodyEmitter emitter = getEmitter(MediaType.APPLICATION_STREAM_JSON).             new JsonEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue).             return emitter.         }     }     // Not streaming...     DeferredResult<Object> result = new DeferredResult<>().     new DeferredResultSubscriber(result, adapter, elementType).connect(adapter, returnValue).     WebAsyncUtils.getAsyncManager(request).startDeferredResultProcessing(result, mav).     return null. }
false;private;1;10;;@SuppressWarnings("unchecked") private Collection<MediaType> getMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {     Collection<MediaType> mediaTypes = (Collection<MediaType>) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST).     return CollectionUtils.isEmpty(mediaTypes) ? this.contentNegotiationManager.resolveMediaTypes(request) : mediaTypes. }
false;protected;1;4;;@Override protected void extendResponse(ServerHttpResponse outputMessage) {     outputMessage.getHeaders().setContentType(mediaType). }
false;private;1;8;;private ResponseBodyEmitter getEmitter(MediaType mediaType) {     return new ResponseBodyEmitter(STREAMING_TIMEOUT_VALUE) {          @Override         protected void extendResponse(ServerHttpResponse outputMessage) {             outputMessage.getHeaders().setContentType(mediaType).         }     }. }
false;private;1;20;;@SuppressWarnings("ConstantConditions") private void logExecutorWarning(MethodParameter returnType) {     if (this.taskExecutorWarning && logger.isWarnEnabled()) {         synchronized (this) {             if (this.taskExecutorWarning) {                 String executorTypeName = this.taskExecutor.getClass().getSimpleName().                 logger.warn("\n!!!\n" + "Streaming through a reactive type requires an Executor to write to the response.\n" + "Please, configure a TaskExecutor in the MVC config under \"async support\".\n" + "The " + executorTypeName + " currently in use is not suitable under load.\n" + "-------------------------------\n" + "Controller:\t" + returnType.getContainingClass().getName() + "\n" + "Method:\t\t" + returnType.getMethod().getName() + "\n" + "Returning:\t" + ResolvableType.forMethodParameter(returnType).toString() + "\n" + "!!!").                 this.taskExecutorWarning = false.             }         }     } }
false;public;2;4;;public void connect(ReactiveAdapter adapter, Object returnValue) {     Publisher<Object> publisher = adapter.toPublisher(returnValue).     publisher.subscribe(this). }
false;protected;0;3;;protected ResponseBodyEmitter getEmitter() {     return this.emitter. }
false;public,final;1;13;;@Override public final void onSubscribe(Subscription subscription) {     this.subscription = subscription.     this.emitter.onTimeout(() -> {         if (logger.isTraceEnabled()) {             logger.trace("Connection timeout for " + this.emitter).         }         terminate().         this.emitter.complete().     }).     this.emitter.onError(this.emitter::completeWithError).     subscription.request(1). }
false;public,final;1;5;;@Override public final void onNext(Object element) {     this.elementRef.lazySet(element).     trySchedule(). }
false;public,final;1;6;;@Override public final void onError(Throwable ex) {     this.error = ex.     this.terminated = true.     trySchedule(). }
false;public,final;0;5;;@Override public final void onComplete() {     this.terminated = true.     trySchedule(). }
false;private;0;5;;private void trySchedule() {     if (this.executing.getAndIncrement() == 0) {         schedule().     } }
false;private;0;14;;private void schedule() {     try {         this.taskExecutor.execute(this).     } catch (Throwable ex) {         try {             terminate().         } finally {             this.executing.decrementAndGet().             this.elementRef.lazySet(null).         }     } }
false;public;0;50;;@Override public void run() {     if (this.done) {         this.elementRef.lazySet(null).         return.     }     // Check terminal signal before processing element..     boolean isTerminated = this.terminated.     Object element = this.elementRef.get().     if (element != null) {         this.elementRef.lazySet(null).         Assert.state(this.subscription != null, "No subscription").         try {             send(element).             this.subscription.request(1).         } catch (final Throwable ex) {             if (logger.isTraceEnabled()) {                 logger.trace("Send for " + this.emitter + " failed: " + ex).             }             terminate().             return.         }     }     if (isTerminated) {         this.done = true.         Throwable ex = this.error.         this.error = null.         if (ex != null) {             if (logger.isTraceEnabled()) {                 logger.trace("Publisher for " + this.emitter + " failed: " + ex).             }             this.emitter.completeWithError(ex).         } else {             if (logger.isTraceEnabled()) {                 logger.trace("Publisher for " + this.emitter + " completed").             }             this.emitter.complete().         }         return.     }     if (this.executing.decrementAndGet() != 0) {         schedule().     } }
false;protected,abstract;1;1;;protected abstract void send(Object element) throws IOException.
false;private;0;6;;private void terminate() {     this.done = true.     if (this.subscription != null) {         this.subscription.cancel().     } }
false;protected;1;10;;@Override protected void send(Object element) throws IOException {     if (element instanceof ServerSentEvent) {         ServerSentEvent<?> event = (ServerSentEvent<?>) element.         ((SseEmitter) getEmitter()).send(adapt(event)).     } else {         getEmitter().send(element, MediaType.APPLICATION_JSON).     } }
false;private;1;24;;private SseEmitter.SseEventBuilder adapt(ServerSentEvent<?> sse) {     SseEmitter.SseEventBuilder builder = SseEmitter.event().     String id = sse.id().     String event = sse.event().     Duration retry = sse.retry().     String comment = sse.comment().     Object data = sse.data().     if (id != null) {         builder.id(id).     }     if (event != null) {         builder.name(event).     }     if (data != null) {         builder.data(data).     }     if (retry != null) {         builder.reconnectTime(retry.toMillis()).     }     if (comment != null) {         builder.comment(comment).     }     return builder. }
false;protected;1;5;;@Override protected void send(Object element) throws IOException {     getEmitter().send(element, MediaType.APPLICATION_JSON).     getEmitter().send("\n", MediaType.TEXT_PLAIN). }
false;protected;1;4;;@Override protected void send(Object element) throws IOException {     getEmitter().send(element, MediaType.TEXT_PLAIN). }
false;public;2;4;;public void connect(ReactiveAdapter adapter, Object returnValue) {     Publisher<Object> publisher = adapter.toPublisher(returnValue).     publisher.subscribe(this). }
false;public;1;5;;@Override public void onSubscribe(Subscription subscription) {     this.result.onTimeout(subscription::cancel).     subscription.request(Long.MAX_VALUE). }
false;public;1;4;;@Override public void onNext(Object element) {     this.values.add(element). }
false;public;1;4;;@Override public void onError(Throwable ex) {     this.result.setErrorResult(ex). }
false;public;0;12;;@Override public void onComplete() {     if (this.values.size() > 1 || this.multiValueSource) {         this.result.setResult(this.values).     } else if (this.values.size() == 1) {         this.result.setResult(this.values.get(0)).     } else {         this.result.setResult(null).     } }
false;public;0;3;;public ResolvableType getReturnType() {     return ResolvableType.forClassWithGenerics(List.class, this.elementType). }
