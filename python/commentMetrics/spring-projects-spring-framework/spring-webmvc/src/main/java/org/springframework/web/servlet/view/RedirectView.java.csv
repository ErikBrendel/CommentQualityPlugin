commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether to interpret a given URL that starts with a slash ("/")  * as relative to the current ServletContext, i.e. as relative to the  * web application root.  * <p>Default is "false": A URL that starts with a slash will be interpreted  * as absolute, i.e. taken as-is. If "true", the context path will be  * prepended to the URL in such a case.  * @see javax.servlet.http.HttpServletRequest#getContextPath  */ ;/**  * Set whether to interpret a given URL that starts with a slash ("/")  * as relative to the current ServletContext, i.e. as relative to the  * web application root.  * <p>Default is "false": A URL that starts with a slash will be interpreted  * as absolute, i.e. taken as-is. If "true", the context path will be  * prepended to the URL in such a case.  * @see javax.servlet.http.HttpServletRequest#getContextPath  */ public void setContextRelative(boolean contextRelative) {     this.contextRelative = contextRelative. }
true;public;1;3;/**  * Set whether to stay compatible with HTTP 1.0 clients.  * <p>In the default implementation, this will enforce HTTP status code 302  * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.  * Turning this off will send HTTP status code 303, which is the correct  * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.  * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any  * difference. However, some clients depend on 303 when redirecting  * after a POST request. turn this flag off in such a scenario.  * @see javax.servlet.http.HttpServletResponse#sendRedirect  */ ;/**  * Set whether to stay compatible with HTTP 1.0 clients.  * <p>In the default implementation, this will enforce HTTP status code 302  * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.  * Turning this off will send HTTP status code 303, which is the correct  * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.  * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any  * difference. However, some clients depend on 303 when redirecting  * after a POST request. turn this flag off in such a scenario.  * @see javax.servlet.http.HttpServletResponse#sendRedirect  */ public void setHttp10Compatible(boolean http10Compatible) {     this.http10Compatible = http10Compatible. }
true;public;1;3;/**  * Set the {@code exposeModelAttributes} flag which denotes whether  * or not model attributes should be exposed as HTTP query parameters.  * <p>Defaults to {@code true}.  */ ;/**  * Set the {@code exposeModelAttributes} flag which denotes whether  * or not model attributes should be exposed as HTTP query parameters.  * <p>Defaults to {@code true}.  */ public void setExposeModelAttributes(final boolean exposeModelAttributes) {     this.exposeModelAttributes = exposeModelAttributes. }
true;public;1;3;/**  * Set the encoding scheme for this view.  * <p>Default is the request's encoding scheme  * (which is ISO-8859-1 if not specified otherwise).  */ ;/**  * Set the encoding scheme for this view.  * <p>Default is the request's encoding scheme  * (which is ISO-8859-1 if not specified otherwise).  */ public void setEncodingScheme(String encodingScheme) {     this.encodingScheme = encodingScheme. }
true;public;1;3;/**  * Set the status code for this view.  * <p>Default is to send 302/303, depending on the value of the  * {@link #setHttp10Compatible(boolean) http10Compatible} flag.  */ ;/**  * Set the status code for this view.  * <p>Default is to send 302/303, depending on the value of the  * {@link #setHttp10Compatible(boolean) http10Compatible} flag.  */ public void setStatusCode(HttpStatus statusCode) {     this.statusCode = statusCode. }
true;public;1;3;/**  * Whether to treat the redirect URL as a URI template.  * Set this flag to {@code false} if the redirect URL contains open  * and close curly braces "{", "}" and you don't want them interpreted  * as URI variables.  * <p>Defaults to {@code true}.  */ ;/**  * Whether to treat the redirect URL as a URI template.  * Set this flag to {@code false} if the redirect URL contains open  * and close curly braces "{", "}" and you don't want them interpreted  * as URI variables.  * <p>Defaults to {@code true}.  */ public void setExpandUriTemplateVariables(boolean expandUriTemplateVariables) {     this.expandUriTemplateVariables = expandUriTemplateVariables. }
true;public;1;3;/**  * When set to {@code true} the query string of the current URL is appended  * and thus propagated through to the redirected URL.  * <p>Defaults to {@code false}.  * @since 4.1  */ ;/**  * When set to {@code true} the query string of the current URL is appended  * and thus propagated through to the redirected URL.  * <p>Defaults to {@code false}.  * @since 4.1  */ public void setPropagateQueryParams(boolean propagateQueryParams) {     this.propagateQueryParams = propagateQueryParams. }
true;public;0;3;/**  * Whether to propagate the query params of the current URL.  * @since 4.1  */ ;/**  * Whether to propagate the query params of the current URL.  * @since 4.1  */ public boolean isPropagateQueryProperties() {     return this.propagateQueryParams. }
true;public;1;3;/**  * Configure one or more hosts associated with the application.  * All other hosts will be considered external hosts.  * <p>In effect, this property provides a way turn off encoding via  * {@link HttpServletResponse#encodeRedirectURL} for URLs that have a  * host and that host is not listed as a known host.  * <p>If not set (the default) all URLs are encoded through the response.  * @param hosts one or more application hosts  * @since 4.3  */ ;/**  * Configure one or more hosts associated with the application.  * All other hosts will be considered external hosts.  * <p>In effect, this property provides a way turn off encoding via  * {@link HttpServletResponse#encodeRedirectURL} for URLs that have a  * host and that host is not listed as a known host.  * <p>If not set (the default) all URLs are encoded through the response.  * @param hosts one or more application hosts  * @since 4.3  */ public void setHosts(@Nullable String... hosts) {     this.hosts = hosts. }
true;public;0;4;/**  * Return the configured application hosts.  * @since 4.3  */ ;/**  * Return the configured application hosts.  * @since 4.3  */ @Nullable public String[] getHosts() {     return this.hosts. }
true;public;0;4;/**  * Returns "true" indicating this view performs a redirect.  */ ;/**  * Returns "true" indicating this view performs a redirect.  */ @Override public boolean isRedirectView() {     return true. }
true;protected;0;4;/**  * An ApplicationContext is not strictly required for RedirectView.  */ ;/**  * An ApplicationContext is not strictly required for RedirectView.  */ @Override protected boolean isContextRequired() {     return false. }
true;protected;3;13;/**  * Convert model to request parameters and redirect to the given URL.  * @see #appendQueryProperties  * @see #sendRedirect  */ ;/**  * Convert model to request parameters and redirect to the given URL.  * @see #appendQueryProperties  * @see #sendRedirect  */ @Override protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws IOException {     String targetUrl = createTargetUrl(model, request).     targetUrl = updateTargetUrl(targetUrl, model, request, response).     // Save flash attributes     RequestContextUtils.saveOutputFlashMap(targetUrl, request, response).     // Redirect     sendRedirect(request, response, targetUrl, this.http10Compatible). }
true;protected,final;2;35;/**  * Create the target URL by checking if the redirect string is a URI template first,  * expanding it with the given model, and then optionally appending simple type model  * attributes as query String parameters.  */ ;/**  * Create the target URL by checking if the redirect string is a URI template first,  * expanding it with the given model, and then optionally appending simple type model  * attributes as query String parameters.  */ protected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request) throws UnsupportedEncodingException {     // Prepare target URL.     StringBuilder targetUrl = new StringBuilder().     String url = getUrl().     Assert.state(url != null, "'url' not set").     if (this.contextRelative && getUrl().startsWith("/")) {         // Do not apply context path to relative URLs.         targetUrl.append(getContextPath(request)).     }     targetUrl.append(getUrl()).     String enc = this.encodingScheme.     if (enc == null) {         enc = request.getCharacterEncoding().     }     if (enc == null) {         enc = WebUtils.DEFAULT_CHARACTER_ENCODING.     }     if (this.expandUriTemplateVariables && StringUtils.hasText(targetUrl)) {         Map<String, String> variables = getCurrentRequestUriVariables(request).         targetUrl = replaceUriTemplateVariables(targetUrl.toString(), model, variables, enc).     }     if (isPropagateQueryProperties()) {         appendCurrentQueryParams(targetUrl, request).     }     if (this.exposeModelAttributes) {         appendQueryProperties(targetUrl, model, enc).     }     return targetUrl.toString(). }
false;private;1;7;;private String getContextPath(HttpServletRequest request) {     String contextPath = request.getContextPath().     while (contextPath.startsWith("//")) {         contextPath = contextPath.substring(1).     }     return contextPath. }
true;protected;4;20;/**  * Replace URI template variables in the target URL with encoded model  * attributes or URI variables from the current request. Model attributes  * referenced in the URL are removed from the model.  * @param targetUrl the redirect URL  * @param model a Map that contains model attributes  * @param currentUriVariables current request URI variables to use  * @param encodingScheme the encoding scheme to use  * @throws UnsupportedEncodingException if string encoding failed  */ ;/**  * Replace URI template variables in the target URL with encoded model  * attributes or URI variables from the current request. Model attributes  * referenced in the URL are removed from the model.  * @param targetUrl the redirect URL  * @param model a Map that contains model attributes  * @param currentUriVariables current request URI variables to use  * @param encodingScheme the encoding scheme to use  * @throws UnsupportedEncodingException if string encoding failed  */ protected StringBuilder replaceUriTemplateVariables(String targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme) throws UnsupportedEncodingException {     StringBuilder result = new StringBuilder().     Matcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl).     int endLastMatch = 0.     while (matcher.find()) {         String name = matcher.group(1).         Object value = (model.containsKey(name) ? model.remove(name) : currentUriVariables.get(name)).         if (value == null) {             throw new IllegalArgumentException("Model has no value for key '" + name + "'").         }         result.append(targetUrl.substring(endLastMatch, matcher.start())).         result.append(UriUtils.encodePathSegment(value.toString(), encodingScheme)).         endLastMatch = matcher.end().     }     result.append(targetUrl.substring(endLastMatch, targetUrl.length())).     return result. }
false;private;1;6;;@SuppressWarnings("unchecked") private Map<String, String> getCurrentRequestUriVariables(HttpServletRequest request) {     String name = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE.     Map<String, String> uriVars = (Map<String, String>) request.getAttribute(name).     return (uriVars != null) ? uriVars : Collections.<String, String>emptyMap(). }
true;protected;2;23;/**  * Append the query string of the current request to the target redirect URL.  * @param targetUrl the StringBuilder to append the properties to  * @param request the current request  * @since 4.1  */ ;/**  * Append the query string of the current request to the target redirect URL.  * @param targetUrl the StringBuilder to append the properties to  * @param request the current request  * @since 4.1  */ protected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request) {     String query = request.getQueryString().     if (StringUtils.hasText(query)) {         // Extract anchor fragment, if any.         String fragment = null.         int anchorIndex = targetUrl.indexOf("#").         if (anchorIndex > -1) {             fragment = targetUrl.substring(anchorIndex).             targetUrl.delete(anchorIndex, targetUrl.length()).         }         if (targetUrl.toString().indexOf('?') < 0) {             targetUrl.append('?').append(query).         } else {             targetUrl.append('&').append(query).         }         // Append anchor fragment, if any, to end of URL.         if (fragment != null) {             targetUrl.append(fragment).         }     } }
true;protected;3;46;/**  * Append query properties to the redirect URL.  * Stringifies, URL-encodes and formats model attributes as query properties.  * @param targetUrl the StringBuilder to append the properties to  * @param model a Map that contains model attributes  * @param encodingScheme the encoding scheme to use  * @throws UnsupportedEncodingException if string encoding failed  * @see #queryProperties  */ ;/**  * Append query properties to the redirect URL.  * Stringifies, URL-encodes and formats model attributes as query properties.  * @param targetUrl the StringBuilder to append the properties to  * @param model a Map that contains model attributes  * @param encodingScheme the encoding scheme to use  * @throws UnsupportedEncodingException if string encoding failed  * @see #queryProperties  */ @SuppressWarnings("unchecked") protected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme) throws UnsupportedEncodingException {     // Extract anchor fragment, if any.     String fragment = null.     int anchorIndex = targetUrl.indexOf("#").     if (anchorIndex > -1) {         fragment = targetUrl.substring(anchorIndex).         targetUrl.delete(anchorIndex, targetUrl.length()).     }     // If there aren't already some parameters, we need a "?".     boolean first = (targetUrl.toString().indexOf('?') < 0).     for (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {         Object rawValue = entry.getValue().         Iterator<Object> valueIter.         if (rawValue != null && rawValue.getClass().isArray()) {             valueIter = Arrays.asList(ObjectUtils.toObjectArray(rawValue)).iterator().         } else if (rawValue instanceof Collection) {             valueIter = ((Collection<Object>) rawValue).iterator().         } else {             valueIter = Collections.singleton(rawValue).iterator().         }         while (valueIter.hasNext()) {             Object value = valueIter.next().             if (first) {                 targetUrl.append('?').                 first = false.             } else {                 targetUrl.append('&').             }             String encodedKey = urlEncode(entry.getKey(), encodingScheme).             String encodedValue = (value != null ? urlEncode(value.toString(), encodingScheme) : "").             targetUrl.append(encodedKey).append('=').append(encodedValue).         }     }     // Append anchor fragment, if any, to end of URL.     if (fragment != null) {         targetUrl.append(fragment).     } }
true;protected;1;9;/**  * Determine name-value pairs for query strings, which will be stringified,  * URL-encoded and formatted by {@link #appendQueryProperties}.  * <p>This implementation filters the model through checking  * {@link #isEligibleProperty(String, Object)} for each element,  * by default accepting Strings, primitives and primitive wrappers only.  * @param model the original model Map  * @return the filtered Map of eligible query properties  * @see #isEligibleProperty(String, Object)  */ ;/**  * Determine name-value pairs for query strings, which will be stringified,  * URL-encoded and formatted by {@link #appendQueryProperties}.  * <p>This implementation filters the model through checking  * {@link #isEligibleProperty(String, Object)} for each element,  * by default accepting Strings, primitives and primitive wrappers only.  * @param model the original model Map  * @return the filtered Map of eligible query properties  * @see #isEligibleProperty(String, Object)  */ protected Map<String, Object> queryProperties(Map<String, Object> model) {     Map<String, Object> result = new LinkedHashMap<>().     model.forEach((name, value) -> {         if (isEligibleProperty(name, value)) {             result.put(name, value).         }     }).     return result. }
true;protected;2;34;/**  * Determine whether the given model element should be exposed  * as a query property.  * <p>The default implementation considers Strings and primitives  * as eligible, and also arrays and Collections/Iterables with  * corresponding elements. This can be overridden in subclasses.  * @param key the key of the model element  * @param value the value of the model element  * @return whether the element is eligible as query property  */ ;/**  * Determine whether the given model element should be exposed  * as a query property.  * <p>The default implementation considers Strings and primitives  * as eligible, and also arrays and Collections/Iterables with  * corresponding elements. This can be overridden in subclasses.  * @param key the key of the model element  * @param value the value of the model element  * @return whether the element is eligible as query property  */ protected boolean isEligibleProperty(String key, @Nullable Object value) {     if (value == null) {         return false.     }     if (isEligibleValue(value)) {         return true.     }     if (value.getClass().isArray()) {         int length = Array.getLength(value).         if (length == 0) {             return false.         }         for (int i = 0. i < length. i++) {             Object element = Array.get(value, i).             if (!isEligibleValue(element)) {                 return false.             }         }         return true.     }     if (value instanceof Collection) {         Collection<?> coll = (Collection<?>) value.         if (coll.isEmpty()) {             return false.         }         for (Object element : coll) {             if (!isEligibleValue(element)) {                 return false.             }         }         return true.     }     return false. }
true;protected;1;3;/**  * Determine whether the given model element value is eligible for exposure.  * <p>The default implementation considers primitives, Strings, Numbers, Dates,  * URIs, URLs and Locale objects as eligible. This can be overridden in subclasses.  * @param value the model element value  * @return whether the element value is eligible  * @see BeanUtils#isSimpleValueType  */ ;/**  * Determine whether the given model element value is eligible for exposure.  * <p>The default implementation considers primitives, Strings, Numbers, Dates,  * URIs, URLs and Locale objects as eligible. This can be overridden in subclasses.  * @param value the model element value  * @return whether the element value is eligible  * @see BeanUtils#isSimpleValueType  */ protected boolean isEligibleValue(@Nullable Object value) {     return (value != null && BeanUtils.isSimpleValueType(value.getClass())). }
true;protected;2;3;/**  * URL-encode the given input String with the given encoding scheme.  * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.  * @param input the unencoded input String  * @param encodingScheme the encoding scheme  * @return the encoded output String  * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder  * @see java.net.URLEncoder#encode(String, String)  * @see java.net.URLEncoder#encode(String)  */ ;/**  * URL-encode the given input String with the given encoding scheme.  * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.  * @param input the unencoded input String  * @param encodingScheme the encoding scheme  * @return the encoded output String  * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder  * @see java.net.URLEncoder#encode(String, String)  * @see java.net.URLEncoder#encode(String)  */ protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {     return URLEncoder.encode(input, encodingScheme). }
true;protected;4;16;/**  * Find the registered {@link RequestDataValueProcessor}, if any, and allow  * it to update the redirect target URL.  * @param targetUrl the given redirect URL  * @return the updated URL or the same as URL as the one passed in  */ ;/**  * Find the registered {@link RequestDataValueProcessor}, if any, and allow  * it to update the redirect target URL.  * @param targetUrl the given redirect URL  * @return the updated URL or the same as URL as the one passed in  */ protected String updateTargetUrl(String targetUrl, Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) {     WebApplicationContext wac = getWebApplicationContext().     if (wac == null) {         wac = RequestContextUtils.findWebApplicationContext(request, getServletContext()).     }     if (wac != null && wac.containsBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {         RequestDataValueProcessor processor = wac.getBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class).         return processor.processUrl(request, targetUrl).     }     return targetUrl. }
true;protected;4;25;/**  * Send a redirect back to the HTTP client.  * @param request current HTTP request (allows for reacting to request method)  * @param response current HTTP response (for sending response headers)  * @param targetUrl the target URL to redirect to  * @param http10Compatible whether to stay compatible with HTTP 1.0 clients  * @throws IOException if thrown by response methods  */ ;/**  * Send a redirect back to the HTTP client.  * @param request current HTTP request (allows for reacting to request method)  * @param response current HTTP response (for sending response headers)  * @param targetUrl the target URL to redirect to  * @param http10Compatible whether to stay compatible with HTTP 1.0 clients  * @throws IOException if thrown by response methods  */ protected void sendRedirect(HttpServletRequest request, HttpServletResponse response, String targetUrl, boolean http10Compatible) throws IOException {     String encodedURL = (isRemoteHost(targetUrl) ? targetUrl : response.encodeRedirectURL(targetUrl)).     if (http10Compatible) {         HttpStatus attributeStatusCode = (HttpStatus) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE).         if (this.statusCode != null) {             response.setStatus(this.statusCode.value()).             response.setHeader("Location", encodedURL).         } else if (attributeStatusCode != null) {             response.setStatus(attributeStatusCode.value()).             response.setHeader("Location", encodedURL).         } else {             // Send status code 302 by default.             response.sendRedirect(encodedURL).         }     } else {         HttpStatus statusCode = getHttp11StatusCode(request, response, targetUrl).         response.setStatus(statusCode.value()).         response.setHeader("Location", encodedURL).     } }
true;protected;1;15;/**  * Whether the given targetUrl has a host that is a "foreign" system in which  * case {@link HttpServletResponse#encodeRedirectURL} will not be applied.  * This method returns {@code true} if the {@link #setHosts(String[])}  * property is configured and the target URL has a host that does not match.  * @param targetUrl the target redirect URL  * @return {@code true} the target URL has a remote host, {@code false} if it  * the URL does not have a host or the "host" property is not configured.  * @since 4.3  */ ;/**  * Whether the given targetUrl has a host that is a "foreign" system in which  * case {@link HttpServletResponse#encodeRedirectURL} will not be applied.  * This method returns {@code true} if the {@link #setHosts(String[])}  * property is configured and the target URL has a host that does not match.  * @param targetUrl the target redirect URL  * @return {@code true} the target URL has a remote host, {@code false} if it  * the URL does not have a host or the "host" property is not configured.  * @since 4.3  */ protected boolean isRemoteHost(String targetUrl) {     if (ObjectUtils.isEmpty(getHosts())) {         return false.     }     String targetHost = UriComponentsBuilder.fromUriString(targetUrl).build().getHost().     if (StringUtils.isEmpty(targetHost)) {         return false.     }     for (String host : getHosts()) {         if (targetHost.equals(host)) {             return false.         }     }     return true. }
true;protected;3;12;/**  * Determines the status code to use for HTTP 1.1 compatible requests.  * <p>The default implementation returns the {@link #setStatusCode(HttpStatus) statusCode}  * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.  * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).  * @param request the request to inspect  * @param response the servlet response  * @param targetUrl the target URL  * @return the response status  */ ;/**  * Determines the status code to use for HTTP 1.1 compatible requests.  * <p>The default implementation returns the {@link #setStatusCode(HttpStatus) statusCode}  * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.  * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).  * @param request the request to inspect  * @param response the servlet response  * @param targetUrl the target URL  * @return the response status  */ protected HttpStatus getHttp11StatusCode(HttpServletRequest request, HttpServletResponse response, String targetUrl) {     if (this.statusCode != null) {         return this.statusCode.     }     HttpStatus attributeStatusCode = (HttpStatus) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE).     if (attributeStatusCode != null) {         return attributeStatusCode.     }     return HttpStatus.SEE_OTHER. }
