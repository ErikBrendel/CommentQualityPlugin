commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify whether this resolver's cookies should be compliant with BCP 47  * language tags instead of Java's legacy locale specification format.  * <p>The default is {@code true}, as of 5.1. Switch this to {@code false}  * for rendering Java's legacy locale specification format. For parsing,  * this resolver leniently accepts the legacy {@link Locale#toString}  * format as well as BCP 47 language tags in any case.  * @since 4.3  * @see #parseLocaleValue(String)  * @see #toLocaleValue(Locale)  * @see Locale#forLanguageTag(String)  * @see Locale#toLanguageTag()  */ ;/**  * Specify whether this resolver's cookies should be compliant with BCP 47  * language tags instead of Java's legacy locale specification format.  * <p>The default is {@code true}, as of 5.1. Switch this to {@code false}  * for rendering Java's legacy locale specification format. For parsing,  * this resolver leniently accepts the legacy {@link Locale#toString}  * format as well as BCP 47 language tags in any case.  * @since 4.3  * @see #parseLocaleValue(String)  * @see #toLocaleValue(Locale)  * @see Locale#forLanguageTag(String)  * @see Locale#toLanguageTag()  */ public void setLanguageTagCompliant(boolean languageTagCompliant) {     this.languageTagCompliant = languageTagCompliant. }
true;public;0;3;/**  * Return whether this resolver's cookies should be compliant with BCP 47  * language tags instead of Java's legacy locale specification format.  * @since 4.3  */ ;/**  * Return whether this resolver's cookies should be compliant with BCP 47  * language tags instead of Java's legacy locale specification format.  * @since 4.3  */ public boolean isLanguageTagCompliant() {     return this.languageTagCompliant. }
true;public;1;3;/**  * Set a fixed Locale that this resolver will return if no cookie found.  */ ;/**  * Set a fixed Locale that this resolver will return if no cookie found.  */ public void setDefaultLocale(@Nullable Locale defaultLocale) {     this.defaultLocale = defaultLocale. }
true;protected;0;4;/**  * Return the fixed Locale that this resolver will return if no cookie found,  * if any.  */ ;/**  * Return the fixed Locale that this resolver will return if no cookie found,  * if any.  */ @Nullable protected Locale getDefaultLocale() {     return this.defaultLocale. }
true;public;1;3;/**  * Set a fixed TimeZone that this resolver will return if no cookie found.  * @since 4.0  */ ;/**  * Set a fixed TimeZone that this resolver will return if no cookie found.  * @since 4.0  */ public void setDefaultTimeZone(@Nullable TimeZone defaultTimeZone) {     this.defaultTimeZone = defaultTimeZone. }
true;protected;0;4;/**  * Return the fixed TimeZone that this resolver will return if no cookie found,  * if any.  * @since 4.0  */ ;/**  * Return the fixed TimeZone that this resolver will return if no cookie found,  * if any.  * @since 4.0  */ @Nullable protected TimeZone getDefaultTimeZone() {     return this.defaultTimeZone. }
false;public;1;5;;@Override public Locale resolveLocale(HttpServletRequest request) {     parseLocaleCookieIfNecessary(request).     return (Locale) request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME). }
false;public;0;5;;@Override @Nullable public Locale getLocale() {     return (Locale) request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME). }
false;public;0;5;;@Override @Nullable public TimeZone getTimeZone() {     return (TimeZone) request.getAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME). }
false;public;1;16;;@Override public LocaleContext resolveLocaleContext(final HttpServletRequest request) {     parseLocaleCookieIfNecessary(request).     return new TimeZoneAwareLocaleContext() {          @Override         @Nullable         public Locale getLocale() {             return (Locale) request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME).         }          @Override         @Nullable         public TimeZone getTimeZone() {             return (TimeZone) request.getAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME).         }     }. }
false;private;1;54;;private void parseLocaleCookieIfNecessary(HttpServletRequest request) {     if (request.getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME) == null) {         Locale locale = null.         TimeZone timeZone = null.         // Retrieve and parse cookie value.         String cookieName = getCookieName().         if (cookieName != null) {             Cookie cookie = WebUtils.getCookie(request, cookieName).             if (cookie != null) {                 String value = cookie.getValue().                 String localePart = value.                 String timeZonePart = null.                 int separatorIndex = localePart.indexOf('/').                 if (separatorIndex == -1) {                     // Leniently accept older cookies separated by a space...                     separatorIndex = localePart.indexOf(' ').                 }                 if (separatorIndex >= 0) {                     localePart = value.substring(0, separatorIndex).                     timeZonePart = value.substring(separatorIndex + 1).                 }                 try {                     locale = (!"-".equals(localePart) ? parseLocaleValue(localePart) : null).                     if (timeZonePart != null) {                         timeZone = StringUtils.parseTimeZoneString(timeZonePart).                     }                 } catch (IllegalArgumentException ex) {                     String cookieDescription = "invalid locale cookie '" + cookieName + "': [" + value + "] due to: " + ex.getMessage().                     if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {                         // Error dispatch: ignore locale/timezone parse exceptions                         if (logger.isDebugEnabled()) {                             logger.debug("Ignoring " + cookieDescription).                         }                     } else {                         throw new IllegalStateException("Encountered " + cookieDescription).                     }                 }                 if (logger.isTraceEnabled()) {                     logger.trace("Parsed cookie value [" + cookie.getValue() + "] into locale '" + locale + "'" + (timeZone != null ? " and time zone '" + timeZone.getID() + "'" : "")).                 }             }         }         request.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME, (locale != null ? locale : determineDefaultLocale(request))).         request.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME, (timeZone != null ? timeZone : determineDefaultTimeZone(request))).     } }
false;public;3;4;;@Override public void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale) {     setLocaleContext(request, response, (locale != null ? new SimpleLocaleContext(locale) : null)). }
false;public;3;24;;@Override public void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable LocaleContext localeContext) {     Assert.notNull(response, "HttpServletResponse is required for CookieLocaleResolver").     Locale locale = null.     TimeZone timeZone = null.     if (localeContext != null) {         locale = localeContext.getLocale().         if (localeContext instanceof TimeZoneAwareLocaleContext) {             timeZone = ((TimeZoneAwareLocaleContext) localeContext).getTimeZone().         }         addCookie(response, (locale != null ? toLocaleValue(locale) : "-") + (timeZone != null ? '/' + timeZone.getID() : "")).     } else {         removeCookie(response).     }     request.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME, (locale != null ? locale : determineDefaultLocale(request))).     request.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME, (timeZone != null ? timeZone : determineDefaultTimeZone(request))). }
true;protected;1;4;/**  * Parse the given locale value coming from an incoming cookie.  * <p>The default implementation calls {@link StringUtils#parseLocale(String)},  * accepting the {@link Locale#toString} format as well as BCP 47 language tags.  * @param localeValue the locale value to parse  * @return the corresponding {@code Locale} instance  * @since 4.3  * @see StringUtils#parseLocale(String)  */ ;/**  * Parse the given locale value coming from an incoming cookie.  * <p>The default implementation calls {@link StringUtils#parseLocale(String)},  * accepting the {@link Locale#toString} format as well as BCP 47 language tags.  * @param localeValue the locale value to parse  * @return the corresponding {@code Locale} instance  * @since 4.3  * @see StringUtils#parseLocale(String)  */ @Nullable protected Locale parseLocaleValue(String localeValue) {     return StringUtils.parseLocale(localeValue). }
true;protected;1;3;/**  * Render the given locale as a text value for inclusion in a cookie.  * <p>The default implementation calls {@link Locale#toString()}  * or JDK 7's {@link Locale#toLanguageTag()}, depending on the  * {@link #setLanguageTagCompliant "languageTagCompliant"} configuration property.  * @param locale the locale to stringify  * @return a String representation for the given locale  * @since 4.3  * @see #isLanguageTagCompliant()  */ ;/**  * Render the given locale as a text value for inclusion in a cookie.  * <p>The default implementation calls {@link Locale#toString()}  * or JDK 7's {@link Locale#toLanguageTag()}, depending on the  * {@link #setLanguageTagCompliant "languageTagCompliant"} configuration property.  * @param locale the locale to stringify  * @return a String representation for the given locale  * @since 4.3  * @see #isLanguageTagCompliant()  */ protected String toLocaleValue(Locale locale) {     return (isLanguageTagCompliant() ? locale.toLanguageTag() : locale.toString()). }
true;protected;1;8;/**  * Determine the default locale for the given request,  * Called if no locale cookie has been found.  * <p>The default implementation returns the specified default locale,  * if any, else falls back to the request's accept-header locale.  * @param request the request to resolve the locale for  * @return the default locale (never {@code null})  * @see #setDefaultLocale  * @see javax.servlet.http.HttpServletRequest#getLocale()  */ ;/**  * Determine the default locale for the given request,  * Called if no locale cookie has been found.  * <p>The default implementation returns the specified default locale,  * if any, else falls back to the request's accept-header locale.  * @param request the request to resolve the locale for  * @return the default locale (never {@code null})  * @see #setDefaultLocale  * @see javax.servlet.http.HttpServletRequest#getLocale()  */ @Nullable protected Locale determineDefaultLocale(HttpServletRequest request) {     Locale defaultLocale = getDefaultLocale().     if (defaultLocale == null) {         defaultLocale = request.getLocale().     }     return defaultLocale. }
true;protected;1;4;/**  * Determine the default time zone for the given request,  * Called if no TimeZone cookie has been found.  * <p>The default implementation returns the specified default time zone,  * if any, or {@code null} otherwise.  * @param request the request to resolve the time zone for  * @return the default time zone (or {@code null} if none defined)  * @see #setDefaultTimeZone  */ ;/**  * Determine the default time zone for the given request,  * Called if no TimeZone cookie has been found.  * <p>The default implementation returns the specified default time zone,  * if any, or {@code null} otherwise.  * @param request the request to resolve the time zone for  * @return the default time zone (or {@code null} if none defined)  * @see #setDefaultTimeZone  */ @Nullable protected TimeZone determineDefaultTimeZone(HttpServletRequest request) {     return getDefaultTimeZone(). }
