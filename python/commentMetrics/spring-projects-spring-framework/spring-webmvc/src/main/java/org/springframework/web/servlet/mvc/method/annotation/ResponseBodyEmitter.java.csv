commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the configured timeout value, if any.  */ ;/**  * Return the configured timeout value, if any.  */ @Nullable public Long getTimeout() {     return this.timeout. }
false;synchronized;1;22;;synchronized void initialize(Handler handler) throws IOException {     this.handler = handler.     for (DataWithMediaType sendAttempt : this.earlySendAttempts) {         sendInternal(sendAttempt.getData(), sendAttempt.getMediaType()).     }     this.earlySendAttempts.clear().     if (this.complete) {         if (this.failure != null) {             this.handler.completeWithError(this.failure).         } else {             this.handler.complete().         }     } else {         this.handler.onTimeout(this.timeoutCallback).         this.handler.onError(this.errorCallback).         this.handler.onCompletion(this.completionCallback).     } }
true;protected;1;2;/**  * Invoked after the response is updated with the status code and headers,  * if the ResponseBodyEmitter is wrapped in a ResponseEntity, but before the  * response is committed, i.e. before the response body has been written to.  * <p>The default implementation is empty.  */ ;/**  * Invoked after the response is updated with the status code and headers,  * if the ResponseBodyEmitter is wrapped in a ResponseEntity, but before the  * response is committed, i.e. before the response body has been written to.  * <p>The default implementation is empty.  */ protected void extendResponse(ServerHttpResponse outputMessage) { }
true;public;1;3;/**  * Write the given object to the response.  * <p>If any exception occurs a dispatch is made back to the app server where  * Spring MVC will pass the exception through its exception handling mechanism.  * <p><strong>Note:</strong> if the send fails with an IOException, you do  * not need to call {@link #completeWithError(Throwable)} in order to clean  * up. Instead the Servlet container creates a notification that results in a  * dispatch where Spring MVC invokes exception resolvers and completes  * processing.  * @param object the object to write  * @throws IOException raised when an I/O error occurs  * @throws java.lang.IllegalStateException wraps any other errors  */ ;/**  * Write the given object to the response.  * <p>If any exception occurs a dispatch is made back to the app server where  * Spring MVC will pass the exception through its exception handling mechanism.  * <p><strong>Note:</strong> if the send fails with an IOException, you do  * not need to call {@link #completeWithError(Throwable)} in order to clean  * up. Instead the Servlet container creates a notification that results in a  * dispatch where Spring MVC invokes exception resolvers and completes  * processing.  * @param object the object to write  * @throws IOException raised when an I/O error occurs  * @throws java.lang.IllegalStateException wraps any other errors  */ public void send(Object object) throws IOException {     send(object, null). }
true;public,synchronized;2;4;/**  * Overloaded variant of {@link #send(Object)} that also accepts a MediaType  * hint for how to serialize the given Object.  * @param object the object to write  * @param mediaType a MediaType hint for selecting an HttpMessageConverter  * @throws IOException raised when an I/O error occurs  * @throws java.lang.IllegalStateException wraps any other errors  */ ;/**  * Overloaded variant of {@link #send(Object)} that also accepts a MediaType  * hint for how to serialize the given Object.  * @param object the object to write  * @param mediaType a MediaType hint for selecting an HttpMessageConverter  * @throws IOException raised when an I/O error occurs  * @throws java.lang.IllegalStateException wraps any other errors  */ public synchronized void send(Object object, @Nullable MediaType mediaType) throws IOException {     Assert.state(!this.complete, "ResponseBodyEmitter is already set complete").     sendInternal(object, mediaType). }
false;private;2;18;;private void sendInternal(Object object, @Nullable MediaType mediaType) throws IOException {     if (this.handler != null) {         try {             this.handler.send(object, mediaType).         } catch (IOException ex) {             this.sendFailed = true.             throw ex.         } catch (Throwable ex) {             this.sendFailed = true.             throw new IllegalStateException("Failed to send " + object, ex).         }     } else {         this.earlySendAttempts.add(new DataWithMediaType(object, mediaType)).     } }
true;public,synchronized;0;10;/**  * Complete request processing by performing a dispatch into the servlet  * container, where Spring MVC is invoked once more, and completes the  * request processing lifecycle.  * <p><strong>Note:</strong> this method should be called by the application  * to complete request processing. It should not be used after container  * related events such as an error while {@link #send(Object) sending}.  */ ;/**  * Complete request processing by performing a dispatch into the servlet  * container, where Spring MVC is invoked once more, and completes the  * request processing lifecycle.  * <p><strong>Note:</strong> this method should be called by the application  * to complete request processing. It should not be used after container  * related events such as an error while {@link #send(Object) sending}.  */ public synchronized void complete() {     // Ignore, after send failure     if (this.sendFailed) {         return.     }     this.complete = true.     if (this.handler != null) {         this.handler.complete().     } }
true;public,synchronized;1;11;/**  * Complete request processing with an error.  * <p>A dispatch is made into the app server where Spring MVC will pass the  * exception through its exception handling mechanism. Note however that  * at this stage of request processing, the response is committed and the  * response status can no longer be changed.  * <p><strong>Note:</strong> this method should be called by the application  * to complete request processing with an error. It should not be used after  * container related events such as an error while  * {@link #send(Object) sending}.  */ ;/**  * Complete request processing with an error.  * <p>A dispatch is made into the app server where Spring MVC will pass the  * exception through its exception handling mechanism. Note however that  * at this stage of request processing, the response is committed and the  * response status can no longer be changed.  * <p><strong>Note:</strong> this method should be called by the application  * to complete request processing with an error. It should not be used after  * container related events such as an error while  * {@link #send(Object) sending}.  */ public synchronized void completeWithError(Throwable ex) {     // Ignore, after send failure     if (this.sendFailed) {         return.     }     this.complete = true.     this.failure = ex.     if (this.handler != null) {         this.handler.completeWithError(ex).     } }
true;public,synchronized;1;3;/**  * Register code to invoke when the async request times out. This method is  * called from a container thread when an async request times out.  */ ;/**  * Register code to invoke when the async request times out. This method is  * called from a container thread when an async request times out.  */ public synchronized void onTimeout(Runnable callback) {     this.timeoutCallback.setDelegate(callback). }
true;public,synchronized;1;3;/**  * Register code to invoke for an error during async request processing.  * This method is called from a container thread when an error occurred  * while processing an async request.  * @since 5.0  */ ;/**  * Register code to invoke for an error during async request processing.  * This method is called from a container thread when an error occurred  * while processing an async request.  * @since 5.0  */ public synchronized void onError(Consumer<Throwable> callback) {     this.errorCallback.setDelegate(callback). }
true;public,synchronized;1;3;/**  * Register code to invoke when the async request completes. This method is  * called from a container thread when an async request completed for any  * reason including timeout and network error. This method is useful for  * detecting that a {@code ResponseBodyEmitter} instance is no longer usable.  */ ;/**  * Register code to invoke when the async request completes. This method is  * called from a container thread when an async request completed for any  * reason including timeout and network error. This method is useful for  * detecting that a {@code ResponseBodyEmitter} instance is no longer usable.  */ public synchronized void onCompletion(Runnable callback) {     this.completionCallback.setDelegate(callback). }
false;public;0;4;;@Override public String toString() {     return "ResponseBodyEmitter@" + ObjectUtils.getIdentityHexString(this). }
false;;2;1;;void send(Object data, @Nullable MediaType mediaType) throws IOException.
false;;0;1;;void complete().
false;;1;1;;void completeWithError(Throwable failure).
false;;1;1;;void onTimeout(Runnable callback).
false;;1;1;;void onError(Consumer<Throwable> callback).
false;;1;1;;void onCompletion(Runnable callback).
false;public;0;3;;public Object getData() {     return this.data. }
false;public;0;4;;@Nullable public MediaType getMediaType() {     return this.mediaType. }
false;public;1;3;;public void setDelegate(Runnable delegate) {     this.delegate = delegate. }
false;public;0;7;;@Override public void run() {     ResponseBodyEmitter.this.complete = true.     if (this.delegate != null) {         this.delegate.run().     } }
false;public;1;3;;public void setDelegate(Consumer<Throwable> callback) {     this.delegate = callback. }
false;public;1;7;;@Override public void accept(Throwable t) {     ResponseBodyEmitter.this.complete = true.     if (this.delegate != null) {         this.delegate.accept(t).     } }
