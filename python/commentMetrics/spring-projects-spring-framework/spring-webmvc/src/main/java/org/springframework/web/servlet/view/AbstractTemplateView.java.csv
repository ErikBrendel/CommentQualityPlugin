commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether all request attributes should be added to the  * model prior to merging with the template. Default is "false".  */ ;/**  * Set whether all request attributes should be added to the  * model prior to merging with the template. Default is "false".  */ public void setExposeRequestAttributes(boolean exposeRequestAttributes) {     this.exposeRequestAttributes = exposeRequestAttributes. }
true;public;1;3;/**  * Set whether HttpServletRequest attributes are allowed to override (hide)  * controller generated model attributes of the same name. Default is "false",  * which causes an exception to be thrown if request attributes of the same  * name as model attributes are found.  */ ;/**  * Set whether HttpServletRequest attributes are allowed to override (hide)  * controller generated model attributes of the same name. Default is "false",  * which causes an exception to be thrown if request attributes of the same  * name as model attributes are found.  */ public void setAllowRequestOverride(boolean allowRequestOverride) {     this.allowRequestOverride = allowRequestOverride. }
true;public;1;3;/**  * Set whether all HttpSession attributes should be added to the  * model prior to merging with the template. Default is "false".  */ ;/**  * Set whether all HttpSession attributes should be added to the  * model prior to merging with the template. Default is "false".  */ public void setExposeSessionAttributes(boolean exposeSessionAttributes) {     this.exposeSessionAttributes = exposeSessionAttributes. }
true;public;1;3;/**  * Set whether HttpSession attributes are allowed to override (hide)  * controller generated model attributes of the same name. Default is "false",  * which causes an exception to be thrown if session attributes of the same  * name as model attributes are found.  */ ;/**  * Set whether HttpSession attributes are allowed to override (hide)  * controller generated model attributes of the same name. Default is "false",  * which causes an exception to be thrown if session attributes of the same  * name as model attributes are found.  */ public void setAllowSessionOverride(boolean allowSessionOverride) {     this.allowSessionOverride = allowSessionOverride. }
true;public;1;3;/**  * Set whether to expose a RequestContext for use by Spring's macro library,  * under the name "springMacroRequestContext". Default is "true".  * <p>Currently needed for Spring's FreeMarker default macros.  * Note that this is <i>not</i> required for templates that use HTML forms  * <i>unless</i> you wish to take advantage of the Spring helper macros.  * @see #SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE  */ ;/**  * Set whether to expose a RequestContext for use by Spring's macro library,  * under the name "springMacroRequestContext". Default is "true".  * <p>Currently needed for Spring's FreeMarker default macros.  * Note that this is <i>not</i> required for templates that use HTML forms  * <i>unless</i> you wish to take advantage of the Spring helper macros.  * @see #SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE  */ public void setExposeSpringMacroHelpers(boolean exposeSpringMacroHelpers) {     this.exposeSpringMacroHelpers = exposeSpringMacroHelpers. }
false;protected,final;3;66;;@Override protected final void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {     if (this.exposeRequestAttributes) {         Map<String, Object> exposed = null.         for (Enumeration<String> en = request.getAttributeNames(). en.hasMoreElements(). ) {             String attribute = en.nextElement().             if (model.containsKey(attribute) && !this.allowRequestOverride) {                 throw new ServletException("Cannot expose request attribute '" + attribute + "' because of an existing model object of the same name").             }             Object attributeValue = request.getAttribute(attribute).             if (logger.isDebugEnabled()) {                 exposed = exposed != null ? exposed : new LinkedHashMap<>().                 exposed.put(attribute, attributeValue).             }             model.put(attribute, attributeValue).         }         if (logger.isTraceEnabled() && exposed != null) {             logger.trace("Exposed request attributes to model: " + exposed).         }     }     if (this.exposeSessionAttributes) {         HttpSession session = request.getSession(false).         if (session != null) {             Map<String, Object> exposed = null.             for (Enumeration<String> en = session.getAttributeNames(). en.hasMoreElements(). ) {                 String attribute = en.nextElement().                 if (model.containsKey(attribute) && !this.allowSessionOverride) {                     throw new ServletException("Cannot expose session attribute '" + attribute + "' because of an existing model object of the same name").                 }                 Object attributeValue = session.getAttribute(attribute).                 if (logger.isDebugEnabled()) {                     exposed = exposed != null ? exposed : new LinkedHashMap<>().                     exposed.put(attribute, attributeValue).                 }                 model.put(attribute, attributeValue).             }             if (logger.isTraceEnabled() && exposed != null) {                 logger.trace("Exposed session attributes to model: " + exposed).             }         }     }     if (this.exposeSpringMacroHelpers) {         if (model.containsKey(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE)) {             throw new ServletException("Cannot expose bind macro helper '" + SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE + "' because of an existing model object of the same name").         }         // Expose RequestContext instance for Spring macros.         model.put(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE, new RequestContext(request, response, getServletContext(), model)).     }     applyContentType(response).     if (logger.isDebugEnabled()) {         logger.debug("Rendering [" + getUrl() + "]").     }     renderMergedTemplateModel(model, request, response). }
true;protected;1;5;/**  * Apply this view's content type as specified in the "contentType"  * bean property to the given response.  * <p>Only applies the view's contentType if no content type has been  * set on the response before. This allows handlers to override the  * default content type beforehand.  * @param response current HTTP response  * @see #setContentType  */ ;/**  * Apply this view's content type as specified in the "contentType"  * bean property to the given response.  * <p>Only applies the view's contentType if no content type has been  * set on the response before. This allows handlers to override the  * default content type beforehand.  * @param response current HTTP response  * @see #setContentType  */ protected void applyContentType(HttpServletResponse response) {     if (response.getContentType() == null) {         response.setContentType(getContentType()).     } }
true;protected,abstract;3;2;/**  * Subclasses must implement this method to actually render the view.  * @param model combined output Map, with request attributes and  * session attributes merged into it if required  * @param request current HTTP request  * @param response current HTTP response  * @throws Exception if rendering failed  */ ;/**  * Subclasses must implement this method to actually render the view.  * @param model combined output Map, with request attributes and  * session attributes merged into it if required  * @param request current HTTP request  * @param response current HTTP response  * @throws Exception if rendering failed  */ protected abstract void renderMergedTemplateModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception.
