commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Configure Tiles using a custom TilesInitializer, typically specified as an inner bean.  * <p>Default is a variant of {@link org.apache.tiles.startup.DefaultTilesInitializer},  * respecting the "definitions", "preparerFactoryClass" etc properties on this configurer.  * <p><b>NOTE: Specifying a custom TilesInitializer effectively disables all other bean  * properties on this configurer.</b> The entire initialization procedure is then left  * to the TilesInitializer as specified.  */ ;/**  * Configure Tiles using a custom TilesInitializer, typically specified as an inner bean.  * <p>Default is a variant of {@link org.apache.tiles.startup.DefaultTilesInitializer},  * respecting the "definitions", "preparerFactoryClass" etc properties on this configurer.  * <p><b>NOTE: Specifying a custom TilesInitializer effectively disables all other bean  * properties on this configurer.</b> The entire initialization procedure is then left  * to the TilesInitializer as specified.  */ public void setTilesInitializer(TilesInitializer tilesInitializer) {     this.tilesInitializer = tilesInitializer. }
true;public;1;13;/**  * Specify whether to apply Tiles 3.0's "complete-autoload" configuration.  * <p>See {@link org.apache.tiles.extras.complete.CompleteAutoloadTilesContainerFactory}  * for details on the complete-autoload mode.  * <p><b>NOTE: Specifying the complete-autoload mode effectively disables all other bean  * properties on this configurer.</b> The entire initialization procedure is then left  * to {@link org.apache.tiles.extras.complete.CompleteAutoloadTilesInitializer}.  * @see org.apache.tiles.extras.complete.CompleteAutoloadTilesContainerFactory  * @see org.apache.tiles.extras.complete.CompleteAutoloadTilesInitializer  */ ;/**  * Specify whether to apply Tiles 3.0's "complete-autoload" configuration.  * <p>See {@link org.apache.tiles.extras.complete.CompleteAutoloadTilesContainerFactory}  * for details on the complete-autoload mode.  * <p><b>NOTE: Specifying the complete-autoload mode effectively disables all other bean  * properties on this configurer.</b> The entire initialization procedure is then left  * to {@link org.apache.tiles.extras.complete.CompleteAutoloadTilesInitializer}.  * @see org.apache.tiles.extras.complete.CompleteAutoloadTilesContainerFactory  * @see org.apache.tiles.extras.complete.CompleteAutoloadTilesInitializer  */ public void setCompleteAutoload(boolean completeAutoload) {     if (completeAutoload) {         try {             this.tilesInitializer = new SpringCompleteAutoloadTilesInitializer().         } catch (Throwable ex) {             throw new IllegalStateException("Tiles-Extras 3.0 not available", ex).         }     } else {         this.tilesInitializer = null.     } }
true;public;1;3;/**  * Set the Tiles definitions, i.e. the list of files containing the definitions.  * Default is "/WEB-INF/tiles.xml".  */ ;/**  * Set the Tiles definitions, i.e. the list of files containing the definitions.  * Default is "/WEB-INF/tiles.xml".  */ public void setDefinitions(String... definitions) {     this.definitions = definitions. }
true;public;1;3;/**  * Set whether to check Tiles definition files for a refresh at runtime.  * Default is "false".  */ ;/**  * Set whether to check Tiles definition files for a refresh at runtime.  * Default is "false".  */ public void setCheckRefresh(boolean checkRefresh) {     this.checkRefresh = checkRefresh. }
true;public;1;3;/**  * Set whether to validate the Tiles XML definitions. Default is "true".  */ ;/**  * Set whether to validate the Tiles XML definitions. Default is "true".  */ public void setValidateDefinitions(boolean validateDefinitions) {     this.validateDefinitions = validateDefinitions. }
true;public;1;3;/**  * Set the {@link org.apache.tiles.definition.DefinitionsFactory} implementation to use.  * Default is {@link org.apache.tiles.definition.UnresolvingLocaleDefinitionsFactory},  * operating on definition resource URLs.  * <p>Specify a custom DefinitionsFactory, e.g. a UrlDefinitionsFactory subclass,  * to customize the creation of Tiles Definition objects. Note that such a  * DefinitionsFactory has to be able to handle {@link java.net.URL} source objects,  * unless you configure a different TilesContainerFactory.  */ ;/**  * Set the {@link org.apache.tiles.definition.DefinitionsFactory} implementation to use.  * Default is {@link org.apache.tiles.definition.UnresolvingLocaleDefinitionsFactory},  * operating on definition resource URLs.  * <p>Specify a custom DefinitionsFactory, e.g. a UrlDefinitionsFactory subclass,  * to customize the creation of Tiles Definition objects. Note that such a  * DefinitionsFactory has to be able to handle {@link java.net.URL} source objects,  * unless you configure a different TilesContainerFactory.  */ public void setDefinitionsFactoryClass(Class<? extends DefinitionsFactory> definitionsFactoryClass) {     this.definitionsFactoryClass = definitionsFactoryClass. }
true;public;1;3;/**  * Set the {@link org.apache.tiles.preparer.factory.PreparerFactory} implementation to use.  * Default is {@link org.apache.tiles.preparer.factory.BasicPreparerFactory}, creating  * shared instances for specified preparer classes.  * <p>Specify {@link SimpleSpringPreparerFactory} to autowire  * {@link org.apache.tiles.preparer.ViewPreparer} instances based on specified  * preparer classes, applying Spring's container callbacks as well as applying  * configured Spring BeanPostProcessors. If Spring's context-wide annotation-config  * has been activated, annotations in ViewPreparer classes will be automatically  * detected and applied.  * <p>Specify {@link SpringBeanPreparerFactory} to operate on specified preparer  * <i>names</i> instead of classes, obtaining the corresponding Spring bean from  * the DispatcherServlet's application context. The full bean creation process  * will be in the control of the Spring application context in this case,  * allowing for the use of scoped beans etc. Note that you need to define one  * Spring bean definition per preparer name (as used in your Tiles definitions).  * @see SimpleSpringPreparerFactory  * @see SpringBeanPreparerFactory  */ ;/**  * Set the {@link org.apache.tiles.preparer.factory.PreparerFactory} implementation to use.  * Default is {@link org.apache.tiles.preparer.factory.BasicPreparerFactory}, creating  * shared instances for specified preparer classes.  * <p>Specify {@link SimpleSpringPreparerFactory} to autowire  * {@link org.apache.tiles.preparer.ViewPreparer} instances based on specified  * preparer classes, applying Spring's container callbacks as well as applying  * configured Spring BeanPostProcessors. If Spring's context-wide annotation-config  * has been activated, annotations in ViewPreparer classes will be automatically  * detected and applied.  * <p>Specify {@link SpringBeanPreparerFactory} to operate on specified preparer  * <i>names</i> instead of classes, obtaining the corresponding Spring bean from  * the DispatcherServlet's application context. The full bean creation process  * will be in the control of the Spring application context in this case,  * allowing for the use of scoped beans etc. Note that you need to define one  * Spring bean definition per preparer name (as used in your Tiles definitions).  * @see SimpleSpringPreparerFactory  * @see SpringBeanPreparerFactory  */ public void setPreparerFactoryClass(Class<? extends PreparerFactory> preparerFactoryClass) {     this.preparerFactoryClass = preparerFactoryClass. }
true;public;1;3;/**  * Set whether to use a MutableTilesContainer (typically the CachingTilesContainer  * implementation) for this application. Default is "false".  * @see org.apache.tiles.mgmt.MutableTilesContainer  * @see org.apache.tiles.impl.mgmt.CachingTilesContainer  */ ;/**  * Set whether to use a MutableTilesContainer (typically the CachingTilesContainer  * implementation) for this application. Default is "false".  * @see org.apache.tiles.mgmt.MutableTilesContainer  * @see org.apache.tiles.impl.mgmt.CachingTilesContainer  */ public void setUseMutableTilesContainer(boolean useMutableTilesContainer) {     this.useMutableTilesContainer = useMutableTilesContainer. }
false;public;1;4;;@Override public void setServletContext(ServletContext servletContext) {     this.servletContext = servletContext. }
true;public;0;9;/**  * Creates and exposes a TilesContainer for this web application,  * delegating to the TilesInitializer.  * @throws TilesException in case of setup failure  */ ;/**  * Creates and exposes a TilesContainer for this web application,  * delegating to the TilesInitializer.  * @throws TilesException in case of setup failure  */ @Override public void afterPropertiesSet() throws TilesException {     Assert.state(this.servletContext != null, "No ServletContext available").     ApplicationContext preliminaryContext = new SpringWildcardServletTilesApplicationContext(this.servletContext).     if (this.tilesInitializer == null) {         this.tilesInitializer = new SpringTilesInitializer().     }     this.tilesInitializer.initialize(preliminaryContext). }
true;public;0;6;/**  * Removes the TilesContainer from this web application.  * @throws TilesException in case of cleanup failure  */ ;/**  * Removes the TilesContainer from this web application.  * @throws TilesException in case of cleanup failure  */ @Override public void destroy() throws TilesException {     if (this.tilesInitializer != null) {         this.tilesInitializer.destroy().     } }
false;protected;1;4;;@Override protected AbstractTilesContainerFactory createContainerFactory(ApplicationContext context) {     return new SpringTilesContainerFactory(). }
false;protected;2;4;;@Override protected TilesContainer createDecoratedContainer(TilesContainer originalContainer, ApplicationContext context) {     return (useMutableTilesContainer ? new CachingTilesContainer(originalContainer) : originalContainer). }
false;protected;1;16;;@Override protected List<ApplicationResource> getSources(ApplicationContext applicationContext) {     if (definitions != null) {         List<ApplicationResource> result = new LinkedList<>().         for (String definition : definitions) {             Collection<ApplicationResource> resources = applicationContext.getResources(definition).             if (resources != null) {                 result.addAll(resources).             }         }         return result.     } else {         return super.getSources(applicationContext).     } }
false;protected;2;9;;@Override protected BaseLocaleUrlDefinitionDAO instantiateLocaleDefinitionDao(ApplicationContext applicationContext, LocaleResolver resolver) {     BaseLocaleUrlDefinitionDAO dao = super.instantiateLocaleDefinitionDao(applicationContext, resolver).     if (checkRefresh && dao instanceof CachingLocaleUrlDefinitionDAO) {         ((CachingLocaleUrlDefinitionDAO) dao).setCheckRefresh(true).     }     return dao. }
false;protected;1;6;;@Override protected DefinitionsReader createDefinitionsReader(ApplicationContext context) {     DigesterDefinitionsReader reader = (DigesterDefinitionsReader) super.createDefinitionsReader(context).     reader.setValidating(validateDefinitions).     return reader. }
false;protected;2;22;;@Override protected DefinitionsFactory createDefinitionsFactory(ApplicationContext applicationContext, LocaleResolver resolver) {     if (definitionsFactoryClass != null) {         DefinitionsFactory factory = BeanUtils.instantiateClass(definitionsFactoryClass).         if (factory instanceof ApplicationContextAware) {             ((ApplicationContextAware) factory).setApplicationContext(applicationContext).         }         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(factory).         if (bw.isWritableProperty("localeResolver")) {             bw.setPropertyValue("localeResolver", resolver).         }         if (bw.isWritableProperty("definitionDAO")) {             bw.setPropertyValue("definitionDAO", createLocaleDefinitionDao(applicationContext, resolver)).         }         return factory.     } else {         return super.createDefinitionsFactory(applicationContext, resolver).     } }
false;protected;1;9;;@Override protected PreparerFactory createPreparerFactory(ApplicationContext context) {     if (preparerFactoryClass != null) {         return BeanUtils.instantiateClass(preparerFactoryClass).     } else {         return super.createPreparerFactory(context).     } }
false;protected;1;4;;@Override protected LocaleResolver createLocaleResolver(ApplicationContext context) {     return new SpringLocaleResolver(). }
false;protected;2;12;;@Override protected AttributeEvaluatorFactory createAttributeEvaluatorFactory(ApplicationContext context, LocaleResolver resolver) {     AttributeEvaluator evaluator.     if (tilesElPresent && JspFactory.getDefaultFactory() != null) {         evaluator = new TilesElActivator().createEvaluator().     } else {         evaluator = new DirectAttributeEvaluator().     }     return new BasicAttributeEvaluatorFactory(evaluator). }
false;protected;1;4;;@Override protected AbstractTilesContainerFactory createContainerFactory(ApplicationContext context) {     return new SpringCompleteAutoloadTilesContainerFactory(). }
false;protected;1;4;;@Override protected LocaleResolver createLocaleResolver(ApplicationContext applicationContext) {     return new SpringLocaleResolver(). }
false;public;0;7;;public AttributeEvaluator createEvaluator() {     ELAttributeEvaluator evaluator = new ELAttributeEvaluator().     evaluator.setExpressionFactory(JspFactory.getDefaultFactory().getJspApplicationContext(servletContext).getExpressionFactory()).     evaluator.setResolver(new CompositeELResolverImpl()).     return evaluator. }
