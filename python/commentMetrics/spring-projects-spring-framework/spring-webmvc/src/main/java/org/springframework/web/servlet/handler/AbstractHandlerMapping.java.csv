commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the default handler for this handler mapping.  * This handler will be returned if no specific mapping was found.  * <p>Default is {@code null}, indicating no default handler.  */ ;/**  * Set the default handler for this handler mapping.  * This handler will be returned if no specific mapping was found.  * <p>Default is {@code null}, indicating no default handler.  */ public void setDefaultHandler(@Nullable Object defaultHandler) {     this.defaultHandler = defaultHandler. }
true;public;0;4;/**  * Return the default handler for this handler mapping,  * or {@code null} if none.  */ ;/**  * Return the default handler for this handler mapping,  * or {@code null} if none.  */ @Nullable public Object getDefaultHandler() {     return this.defaultHandler. }
true;public;1;6;/**  * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.  * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath(boolean)  */ ;/**  * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.  * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath(boolean)  */ public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {     this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath).     if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource) {         ((UrlBasedCorsConfigurationSource) this.corsConfigurationSource).setAlwaysUseFullPath(alwaysUseFullPath).     } }
true;public;1;6;/**  * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.  * @see org.springframework.web.util.UrlPathHelper#setUrlDecode(boolean)  */ ;/**  * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.  * @see org.springframework.web.util.UrlPathHelper#setUrlDecode(boolean)  */ public void setUrlDecode(boolean urlDecode) {     this.urlPathHelper.setUrlDecode(urlDecode).     if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource) {         ((UrlBasedCorsConfigurationSource) this.corsConfigurationSource).setUrlDecode(urlDecode).     } }
true;public;1;6;/**  * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.  * @see org.springframework.web.util.UrlPathHelper#setRemoveSemicolonContent(boolean)  */ ;/**  * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.  * @see org.springframework.web.util.UrlPathHelper#setRemoveSemicolonContent(boolean)  */ public void setRemoveSemicolonContent(boolean removeSemicolonContent) {     this.urlPathHelper.setRemoveSemicolonContent(removeSemicolonContent).     if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource) {         ((UrlBasedCorsConfigurationSource) this.corsConfigurationSource).setRemoveSemicolonContent(removeSemicolonContent).     } }
true;public;1;7;/**  * Set the UrlPathHelper to use for resolution of lookup paths.  * <p>Use this to override the default UrlPathHelper with a custom subclass,  * or to share common UrlPathHelper settings across multiple HandlerMappings  * and MethodNameResolvers.  */ ;/**  * Set the UrlPathHelper to use for resolution of lookup paths.  * <p>Use this to override the default UrlPathHelper with a custom subclass,  * or to share common UrlPathHelper settings across multiple HandlerMappings  * and MethodNameResolvers.  */ public void setUrlPathHelper(UrlPathHelper urlPathHelper) {     Assert.notNull(urlPathHelper, "UrlPathHelper must not be null").     this.urlPathHelper = urlPathHelper.     if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource) {         ((UrlBasedCorsConfigurationSource) this.corsConfigurationSource).setUrlPathHelper(urlPathHelper).     } }
true;public;0;3;/**  * Return the UrlPathHelper implementation to use for resolution of lookup paths.  */ ;/**  * Return the UrlPathHelper implementation to use for resolution of lookup paths.  */ public UrlPathHelper getUrlPathHelper() {     return this.urlPathHelper. }
true;public;1;7;/**  * Set the PathMatcher implementation to use for matching URL paths  * against registered URL patterns. Default is AntPathMatcher.  * @see org.springframework.util.AntPathMatcher  */ ;/**  * Set the PathMatcher implementation to use for matching URL paths  * against registered URL patterns. Default is AntPathMatcher.  * @see org.springframework.util.AntPathMatcher  */ public void setPathMatcher(PathMatcher pathMatcher) {     Assert.notNull(pathMatcher, "PathMatcher must not be null").     this.pathMatcher = pathMatcher.     if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource) {         ((UrlBasedCorsConfigurationSource) this.corsConfigurationSource).setPathMatcher(pathMatcher).     } }
true;public;0;3;/**  * Return the PathMatcher implementation to use for matching URL paths  * against registered URL patterns.  */ ;/**  * Return the PathMatcher implementation to use for matching URL paths  * against registered URL patterns.  */ public PathMatcher getPathMatcher() {     return this.pathMatcher. }
true;public;1;3;/**  * Set the interceptors to apply for all handlers mapped by this handler mapping.  * <p>Supported interceptor types are HandlerInterceptor, WebRequestInterceptor, and MappedInterceptor.  * Mapped interceptors apply only to request URLs that match its path patterns.  * Mapped interceptor beans are also detected by type during initialization.  * @param interceptors array of handler interceptors  * @see #adaptInterceptor  * @see org.springframework.web.servlet.HandlerInterceptor  * @see org.springframework.web.context.request.WebRequestInterceptor  */ ;/**  * Set the interceptors to apply for all handlers mapped by this handler mapping.  * <p>Supported interceptor types are HandlerInterceptor, WebRequestInterceptor, and MappedInterceptor.  * Mapped interceptors apply only to request URLs that match its path patterns.  * Mapped interceptor beans are also detected by type during initialization.  * @param interceptors array of handler interceptors  * @see #adaptInterceptor  * @see org.springframework.web.servlet.HandlerInterceptor  * @see org.springframework.web.context.request.WebRequestInterceptor  */ public void setInterceptors(Object... interceptors) {     this.interceptors.addAll(Arrays.asList(interceptors)). }
true;public;1;8;/**  * Set the "global" CORS configurations based on URL patterns. By default the first  * matching URL pattern is combined with the CORS configuration for the handler, if any.  * @since 4.2  * @see #setCorsConfigurationSource(CorsConfigurationSource)  */ ;/**  * Set the "global" CORS configurations based on URL patterns. By default the first  * matching URL pattern is combined with the CORS configuration for the handler, if any.  * @since 4.2  * @see #setCorsConfigurationSource(CorsConfigurationSource)  */ public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {     Assert.notNull(corsConfigurations, "corsConfigurations must not be null").     UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource().     source.setCorsConfigurations(corsConfigurations).     source.setPathMatcher(this.pathMatcher).     source.setUrlPathHelper(this.urlPathHelper).     this.corsConfigurationSource = source. }
true;public;1;4;/**  * Set the "global" CORS configuration source. By default the first matching URL  * pattern is combined with the CORS configuration for the handler, if any.  * @since 5.1  * @see #setCorsConfigurations(Map)  */ ;/**  * Set the "global" CORS configuration source. By default the first matching URL  * pattern is combined with the CORS configuration for the handler, if any.  * @since 5.1  * @see #setCorsConfigurations(Map)  */ public void setCorsConfigurationSource(CorsConfigurationSource corsConfigurationSource) {     Assert.notNull(corsConfigurationSource, "corsConfigurationSource must not be null").     this.corsConfigurationSource = corsConfigurationSource. }
true;public;0;10;/**  * Get the "global" CORS configurations.  * @deprecated as of 5.1 since it is now possible to set a {@link CorsConfigurationSource} which is not a  * {@link UrlBasedCorsConfigurationSource}. Expected to be removed in 5.2.  */ ;/**  * Get the "global" CORS configurations.  * @deprecated as of 5.1 since it is now possible to set a {@link CorsConfigurationSource} which is not a  * {@link UrlBasedCorsConfigurationSource}. Expected to be removed in 5.2.  */ @Deprecated public Map<String, CorsConfiguration> getCorsConfigurations() {     if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource) {         return ((UrlBasedCorsConfigurationSource) this.corsConfigurationSource).getCorsConfigurations().     } else {         throw new IllegalStateException("No CORS configurations available when the source " + "is not an UrlBasedCorsConfigurationSource").     } }
true;public;1;4;/**  * Configure a custom {@link CorsProcessor} to use to apply the matched  * {@link CorsConfiguration} for a request.  * <p>By default {@link DefaultCorsProcessor} is used.  * @since 4.2  */ ;/**  * Configure a custom {@link CorsProcessor} to use to apply the matched  * {@link CorsConfiguration} for a request.  * <p>By default {@link DefaultCorsProcessor} is used.  * @since 4.2  */ public void setCorsProcessor(CorsProcessor corsProcessor) {     Assert.notNull(corsProcessor, "CorsProcessor must not be null").     this.corsProcessor = corsProcessor. }
true;public;0;3;/**  * Return the configured {@link CorsProcessor}.  */ ;/**  * Return the configured {@link CorsProcessor}.  */ public CorsProcessor getCorsProcessor() {     return this.corsProcessor. }
true;public;1;3;/**  * Specify the order value for this HandlerMapping bean.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @see org.springframework.core.Ordered#getOrder()  */ ;/**  * Specify the order value for this HandlerMapping bean.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @see org.springframework.core.Ordered#getOrder()  */ public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;public;1;4;;@Override public void setBeanName(String name) {     this.beanName = name. }
false;protected;0;3;;protected String formatMappingName() {     return this.beanName != null ? "'" + this.beanName + "'" : "<unknown>". }
true;protected;0;6;/**  * Initializes the interceptors.  * @see #extendInterceptors(java.util.List)  * @see #initInterceptors()  */ ;/**  * Initializes the interceptors.  * @see #extendInterceptors(java.util.List)  * @see #initInterceptors()  */ @Override protected void initApplicationContext() throws BeansException {     extendInterceptors(this.interceptors).     detectMappedInterceptors(this.adaptedInterceptors).     initInterceptors(). }
true;protected;1;2;/**  * Extension hook that subclasses can override to register additional interceptors,  * given the configured interceptors (see {@link #setInterceptors}).  * <p>Will be invoked before {@link #initInterceptors()} adapts the specified  * interceptors into {@link HandlerInterceptor} instances.  * <p>The default implementation is empty.  * @param interceptors the configured interceptor List (never {@code null}), allowing  * to add further interceptors before as well as after the existing interceptors  */ ;/**  * Extension hook that subclasses can override to register additional interceptors,  * given the configured interceptors (see {@link #setInterceptors}).  * <p>Will be invoked before {@link #initInterceptors()} adapts the specified  * interceptors into {@link HandlerInterceptor} instances.  * <p>The default implementation is empty.  * @param interceptors the configured interceptor List (never {@code null}), allowing  * to add further interceptors before as well as after the existing interceptors  */ protected void extendInterceptors(List<Object> interceptors) { }
true;protected;1;5;/**  * Detect beans of type {@link MappedInterceptor} and add them to the list of mapped interceptors.  * <p>This is called in addition to any {@link MappedInterceptor MappedInterceptors} that may have been provided  * via {@link #setInterceptors}, by default adding all beans of type {@link MappedInterceptor}  * from the current context and its ancestors. Subclasses can override and refine this policy.  * @param mappedInterceptors an empty list to add {@link MappedInterceptor} instances to  */ ;/**  * Detect beans of type {@link MappedInterceptor} and add them to the list of mapped interceptors.  * <p>This is called in addition to any {@link MappedInterceptor MappedInterceptors} that may have been provided  * via {@link #setInterceptors}, by default adding all beans of type {@link MappedInterceptor}  * from the current context and its ancestors. Subclasses can override and refine this policy.  * @param mappedInterceptors an empty list to add {@link MappedInterceptor} instances to  */ protected void detectMappedInterceptors(List<HandlerInterceptor> mappedInterceptors) {     mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), MappedInterceptor.class, true, false).values()). }
true;protected;0;11;/**  * Initialize the specified interceptors, checking for {@link MappedInterceptor MappedInterceptors} and  * adapting {@link HandlerInterceptor}s and {@link WebRequestInterceptor HandlerInterceptor}s and  * {@link WebRequestInterceptor}s if necessary.  * @see #setInterceptors  * @see #adaptInterceptor  */ ;/**  * Initialize the specified interceptors, checking for {@link MappedInterceptor MappedInterceptors} and  * adapting {@link HandlerInterceptor}s and {@link WebRequestInterceptor HandlerInterceptor}s and  * {@link WebRequestInterceptor}s if necessary.  * @see #setInterceptors  * @see #adaptInterceptor  */ protected void initInterceptors() {     if (!this.interceptors.isEmpty()) {         for (int i = 0. i < this.interceptors.size(). i++) {             Object interceptor = this.interceptors.get(i).             if (interceptor == null) {                 throw new IllegalArgumentException("Entry number " + i + " in interceptors array is null").             }             this.adaptedInterceptors.add(adaptInterceptor(interceptor)).         }     } }
true;protected;1;11;/**  * Adapt the given interceptor object to the {@link HandlerInterceptor} interface.  * <p>By default, the supported interceptor types are {@link HandlerInterceptor}  * and {@link WebRequestInterceptor}. Each given {@link WebRequestInterceptor}  * will be wrapped in a {@link WebRequestHandlerInterceptorAdapter}.  * Can be overridden in subclasses.  * @param interceptor the specified interceptor object  * @return the interceptor wrapped as HandlerInterceptor  * @see org.springframework.web.servlet.HandlerInterceptor  * @see org.springframework.web.context.request.WebRequestInterceptor  * @see WebRequestHandlerInterceptorAdapter  */ ;/**  * Adapt the given interceptor object to the {@link HandlerInterceptor} interface.  * <p>By default, the supported interceptor types are {@link HandlerInterceptor}  * and {@link WebRequestInterceptor}. Each given {@link WebRequestInterceptor}  * will be wrapped in a {@link WebRequestHandlerInterceptorAdapter}.  * Can be overridden in subclasses.  * @param interceptor the specified interceptor object  * @return the interceptor wrapped as HandlerInterceptor  * @see org.springframework.web.servlet.HandlerInterceptor  * @see org.springframework.web.context.request.WebRequestInterceptor  * @see WebRequestHandlerInterceptorAdapter  */ protected HandlerInterceptor adaptInterceptor(Object interceptor) {     if (interceptor instanceof HandlerInterceptor) {         return (HandlerInterceptor) interceptor.     } else if (interceptor instanceof WebRequestInterceptor) {         return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor).     } else {         throw new IllegalArgumentException("Interceptor type not supported: " + interceptor.getClass().getName()).     } }
true;protected,final;0;5;/**  * Return the adapted interceptors as {@link HandlerInterceptor} array.  * @return the array of {@link HandlerInterceptor HandlerInterceptors}, or {@code null} if none  */ ;/**  * Return the adapted interceptors as {@link HandlerInterceptor} array.  * @return the array of {@link HandlerInterceptor HandlerInterceptors}, or {@code null} if none  */ @Nullable protected final HandlerInterceptor[] getAdaptedInterceptors() {     return (!this.adaptedInterceptors.isEmpty() ? this.adaptedInterceptors.toArray(new HandlerInterceptor[0]) : null). }
true;protected,final;0;10;/**  * Return all configured {@link MappedInterceptor MappedInterceptors} as an array.  * @return the array of {@link MappedInterceptor MappedInterceptors}, or {@code null} if none  */ ;/**  * Return all configured {@link MappedInterceptor MappedInterceptors} as an array.  * @return the array of {@link MappedInterceptor MappedInterceptors}, or {@code null} if none  */ @Nullable protected final MappedInterceptor[] getMappedInterceptors() {     List<MappedInterceptor> mappedInterceptors = new ArrayList<>(this.adaptedInterceptors.size()).     for (HandlerInterceptor interceptor : this.adaptedInterceptors) {         if (interceptor instanceof MappedInterceptor) {             mappedInterceptors.add((MappedInterceptor) interceptor).         }     }     return (!mappedInterceptors.isEmpty() ? mappedInterceptors.toArray(new MappedInterceptor[0]) : null). }
true;public,final;1;34;/**  * Look up a handler for the given request, falling back to the default  * handler if no specific one is found.  * @param request current HTTP request  * @return the corresponding handler instance, or the default handler  * @see #getHandlerInternal  */ ;/**  * Look up a handler for the given request, falling back to the default  * handler if no specific one is found.  * @param request current HTTP request  * @return the corresponding handler instance, or the default handler  * @see #getHandlerInternal  */ @Override @Nullable public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {     Object handler = getHandlerInternal(request).     if (handler == null) {         handler = getDefaultHandler().     }     if (handler == null) {         return null.     }     // Bean name or resolved handler?     if (handler instanceof String) {         String handlerName = (String) handler.         handler = obtainApplicationContext().getBean(handlerName).     }     HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request).     if (logger.isTraceEnabled()) {         logger.trace("Mapped to " + handler).     } else if (logger.isDebugEnabled() && !request.getDispatcherType().equals(DispatcherType.ASYNC)) {         logger.debug("Mapped to " + executionChain.getHandler()).     }     if (CorsUtils.isCorsRequest(request)) {         CorsConfiguration globalConfig = this.corsConfigurationSource.getCorsConfiguration(request).         CorsConfiguration handlerConfig = getCorsConfiguration(handler, request).         CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig).         executionChain = getCorsHandlerExecutionChain(request, executionChain, config).     }     return executionChain. }
true;protected,abstract;1;2;/**  * Look up a handler for the given request, returning {@code null} if no  * specific one is found. This method is called by {@link #getHandler}.  * a {@code null} return value will lead to the default handler, if one is set.  * <p>On CORS pre-flight requests this method should return a match not for  * the pre-flight request but for the expected actual request based on the URL  * path, the HTTP methods from the "Access-Control-Request-Method" header, and  * the headers from the "Access-Control-Request-Headers" header thus allowing  * the CORS configuration to be obtained via {@link #getCorsConfiguration(Object, HttpServletRequest)},  * <p>Note: This method may also return a pre-built {@link HandlerExecutionChain},  * combining a handler object with dynamically determined interceptors.  * Statically specified interceptors will get merged into such an existing chain.  * @param request current HTTP request  * @return the corresponding handler instance, or {@code null} if none found  * @throws Exception if there is an internal error  */ ;/**  * Look up a handler for the given request, returning {@code null} if no  * specific one is found. This method is called by {@link #getHandler}.  * a {@code null} return value will lead to the default handler, if one is set.  * <p>On CORS pre-flight requests this method should return a match not for  * the pre-flight request but for the expected actual request based on the URL  * path, the HTTP methods from the "Access-Control-Request-Method" header, and  * the headers from the "Access-Control-Request-Headers" header thus allowing  * the CORS configuration to be obtained via {@link #getCorsConfiguration(Object, HttpServletRequest)},  * <p>Note: This method may also return a pre-built {@link HandlerExecutionChain},  * combining a handler object with dynamically determined interceptors.  * Statically specified interceptors will get merged into such an existing chain.  * @param request current HTTP request  * @return the corresponding handler instance, or {@code null} if none found  * @throws Exception if there is an internal error  */ @Nullable protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception.
true;protected;2;18;/**  * Build a {@link HandlerExecutionChain} for the given handler, including  * applicable interceptors.  * <p>The default implementation builds a standard {@link HandlerExecutionChain}  * with the given handler, the handler mapping's common interceptors, and any  * {@link MappedInterceptor MappedInterceptors} matching to the current request URL. Interceptors  * are added in the order they were registered. Subclasses may override this  * in order to extend/rearrange the list of interceptors.  * <p><b>NOTE:</b> The passed-in handler object may be a raw handler or a  * pre-built {@link HandlerExecutionChain}. This method should handle those  * two cases explicitly, either building a new {@link HandlerExecutionChain}  * or extending the existing chain.  * <p>For simply adding an interceptor in a custom subclass, consider calling  * {@code super.getHandlerExecutionChain(handler, request)} and invoking  * {@link HandlerExecutionChain#addInterceptor} on the returned chain object.  * @param handler the resolved handler instance (never {@code null})  * @param request current HTTP request  * @return the HandlerExecutionChain (never {@code null})  * @see #getAdaptedInterceptors()  */ ;/**  * Build a {@link HandlerExecutionChain} for the given handler, including  * applicable interceptors.  * <p>The default implementation builds a standard {@link HandlerExecutionChain}  * with the given handler, the handler mapping's common interceptors, and any  * {@link MappedInterceptor MappedInterceptors} matching to the current request URL. Interceptors  * are added in the order they were registered. Subclasses may override this  * in order to extend/rearrange the list of interceptors.  * <p><b>NOTE:</b> The passed-in handler object may be a raw handler or a  * pre-built {@link HandlerExecutionChain}. This method should handle those  * two cases explicitly, either building a new {@link HandlerExecutionChain}  * or extending the existing chain.  * <p>For simply adding an interceptor in a custom subclass, consider calling  * {@code super.getHandlerExecutionChain(handler, request)} and invoking  * {@link HandlerExecutionChain#addInterceptor} on the returned chain object.  * @param handler the resolved handler instance (never {@code null})  * @param request current HTTP request  * @return the HandlerExecutionChain (never {@code null})  * @see #getAdaptedInterceptors()  */ protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {     HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler)).     String lookupPath = this.urlPathHelper.getLookupPathForRequest(request).     for (HandlerInterceptor interceptor : this.adaptedInterceptors) {         if (interceptor instanceof MappedInterceptor) {             MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor.             if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {                 chain.addInterceptor(mappedInterceptor.getInterceptor()).             }         } else {             chain.addInterceptor(interceptor).         }     }     return chain. }
true;protected;2;11;/**  * Retrieve the CORS configuration for the given handler.  * @param handler the handler to check (never {@code null}).  * @param request the current request.  * @return the CORS configuration for the handler, or {@code null} if none  * @since 4.2  */ ;/**  * Retrieve the CORS configuration for the given handler.  * @param handler the handler to check (never {@code null}).  * @param request the current request.  * @return the CORS configuration for the handler, or {@code null} if none  * @since 4.2  */ @Nullable protected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) {     Object resolvedHandler = handler.     if (handler instanceof HandlerExecutionChain) {         resolvedHandler = ((HandlerExecutionChain) handler).getHandler().     }     if (resolvedHandler instanceof CorsConfigurationSource) {         return ((CorsConfigurationSource) resolvedHandler).getCorsConfiguration(request).     }     return null. }
true;protected;3;12;/**  * Update the HandlerExecutionChain for CORS-related handling.  * <p>For pre-flight requests, the default implementation replaces the selected  * handler with a simple HttpRequestHandler that invokes the configured  * {@link #setCorsProcessor}.  * <p>For actual requests, the default implementation inserts a  * HandlerInterceptor that makes CORS-related checks and adds CORS headers.  * @param request the current request  * @param chain the handler chain  * @param config the applicable CORS configuration (possibly {@code null})  * @since 4.2  */ ;/**  * Update the HandlerExecutionChain for CORS-related handling.  * <p>For pre-flight requests, the default implementation replaces the selected  * handler with a simple HttpRequestHandler that invokes the configured  * {@link #setCorsProcessor}.  * <p>For actual requests, the default implementation inserts a  * HandlerInterceptor that makes CORS-related checks and adds CORS headers.  * @param request the current request  * @param chain the handler chain  * @param config the applicable CORS configuration (possibly {@code null})  * @since 4.2  */ protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request, HandlerExecutionChain chain, @Nullable CorsConfiguration config) {     if (CorsUtils.isPreFlightRequest(request)) {         HandlerInterceptor[] interceptors = chain.getInterceptors().         chain = new HandlerExecutionChain(new PreFlightHandler(config), interceptors).     } else {         chain.addInterceptor(new CorsInterceptor(config)).     }     return chain. }
false;public;2;4;;@Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {     corsProcessor.processRequest(this.config, request, response). }
false;public;1;5;;@Override @Nullable public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {     return this.config. }
false;public;3;6;;@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {     return corsProcessor.processRequest(this.config, request, response). }
false;public;1;5;;@Override @Nullable public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {     return this.config. }
