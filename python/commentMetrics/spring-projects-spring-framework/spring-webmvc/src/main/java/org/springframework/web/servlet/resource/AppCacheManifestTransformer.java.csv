commented;modifiers;parameterAmount;loc;comment;code
false;public;3;34;;@Override public Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain chain) throws IOException {     resource = chain.transform(request, resource).     if (!this.fileExtension.equals(StringUtils.getFilenameExtension(resource.getFilename()))) {         return resource.     }     byte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream()).     String content = new String(bytes, DEFAULT_CHARSET).     if (!content.startsWith(MANIFEST_HEADER)) {         if (logger.isTraceEnabled()) {             logger.trace("Skipping " + resource + ": Manifest does not start with 'CACHE MANIFEST'").         }         return resource.     }     @SuppressWarnings("resource")     Scanner scanner = new Scanner(content).     LineInfo previous = null.     LineAggregator aggregator = new LineAggregator(resource, content).     while (scanner.hasNext()) {         String line = scanner.nextLine().         LineInfo current = new LineInfo(line, previous).         LineOutput lineOutput = processLine(current, request, resource, chain).         aggregator.add(lineOutput).         previous = current.     }     return aggregator.createResource(). }
false;private,static;1;3;;private static byte[] getResourceBytes(Resource resource) throws IOException {     return FileCopyUtils.copyToByteArray(resource.getInputStream()). }
false;private;4;16;;private LineOutput processLine(LineInfo info, HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain) {     if (!info.isLink()) {         return new LineOutput(info.getLine(), null).     }     Resource appCacheResource = transformerChain.getResolverChain().resolveResource(null, info.getLine(), Collections.singletonList(resource)).     String path = info.getLine().     String absolutePath = toAbsolutePath(path, request).     String newPath = resolveUrlPath(absolutePath, request, resource, transformerChain).     return new LineOutput((newPath != null ? newPath : path), appCacheResource). }
false;private,static;2;10;;private static boolean initCacheSectionFlag(String line, @Nullable LineInfo previousLine) {     if (MANIFEST_SECTION_HEADERS.contains(line.trim())) {         return line.trim().equals(CACHE_HEADER).     } else if (previousLine != null) {         return previousLine.isCacheSection().     }     throw new IllegalStateException("Manifest does not start with " + MANIFEST_HEADER + ": " + line). }
false;private,static;2;4;;private static boolean iniLinkFlag(String line, boolean isCacheSection) {     return (isCacheSection && StringUtils.hasText(line) && !line.startsWith("#") && !line.startsWith("//") && !hasScheme(line)). }
false;private,static;1;4;;private static boolean hasScheme(String line) {     int index = line.indexOf(':').     return (line.startsWith("//") || (index > 0 && !line.substring(0, index).contains("/"))). }
false;public;0;3;;public String getLine() {     return this.line. }
false;public;0;3;;public boolean isCacheSection() {     return this.cacheSection. }
false;public;0;3;;public boolean isLink() {     return this.link. }
false;public;0;3;;public String getLine() {     return this.line. }
false;public;0;4;;@Nullable public Resource getResource() {     return this.resource. }
false;public;1;7;;public void add(LineOutput lineOutput) throws IOException {     this.writer.write(lineOutput.getLine() + "\n").     byte[] bytes = (lineOutput.getResource() != null ? DigestUtils.md5Digest(getResourceBytes(lineOutput.getResource())) : lineOutput.getLine().getBytes(DEFAULT_CHARSET)).     this.baos.write(bytes). }
false;public;0;6;;public TransformedResource createResource() {     String hash = DigestUtils.md5DigestAsHex(this.baos.toByteArray()).     this.writer.write("\n" + "# Hash: " + hash).     byte[] bytes = this.writer.toString().getBytes(DEFAULT_CHARSET).     return new TransformedResource(this.resource, bytes). }
