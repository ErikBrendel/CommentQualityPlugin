commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether to detect handler beans in ancestor ApplicationContexts.  * <p>Default is "false": Only handler beans in the current ApplicationContext  * will be detected, i.e. only in the context that this HandlerMapping itself  * is defined in (typically the current DispatcherServlet's context).  * <p>Switch this flag on to detect handler beans in ancestor contexts  * (typically the Spring root WebApplicationContext) as well.  */ ;/**  * Set whether to detect handler beans in ancestor ApplicationContexts.  * <p>Default is "false": Only handler beans in the current ApplicationContext  * will be detected, i.e. only in the context that this HandlerMapping itself  * is defined in (typically the current DispatcherServlet's context).  * <p>Switch this flag on to detect handler beans in ancestor contexts  * (typically the Spring root WebApplicationContext) as well.  */ public void setDetectHandlersInAncestorContexts(boolean detectHandlersInAncestorContexts) {     this.detectHandlersInAncestorContexts = detectHandlersInAncestorContexts. }
true;public;0;5;/**  * Calls the {@link #detectHandlers()} method in addition to the  * superclass's initialization.  */ ;/**  * Calls the {@link #detectHandlers()} method in addition to the  * superclass's initialization.  */ @Override public void initApplicationContext() throws ApplicationContextException {     super.initApplicationContext().     detectHandlers(). }
true;protected;0;19;/**  * Register all handlers found in the current ApplicationContext.  * <p>The actual URL determination for a handler is up to the concrete  * {@link #determineUrlsForHandler(String)} implementation. A bean for  * which no such URLs could be determined is simply not considered a handler.  * @throws org.springframework.beans.BeansException if the handler couldn't be registered  * @see #determineUrlsForHandler(String)  */ ;/**  * Register all handlers found in the current ApplicationContext.  * <p>The actual URL determination for a handler is up to the concrete  * {@link #determineUrlsForHandler(String)} implementation. A bean for  * which no such URLs could be determined is simply not considered a handler.  * @throws org.springframework.beans.BeansException if the handler couldn't be registered  * @see #determineUrlsForHandler(String)  */ protected void detectHandlers() throws BeansException {     ApplicationContext applicationContext = obtainApplicationContext().     String[] beanNames = (this.detectHandlersInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) : applicationContext.getBeanNamesForType(Object.class)).     // Take any bean name that we can determine URLs for.     for (String beanName : beanNames) {         String[] urls = determineUrlsForHandler(beanName).         if (!ObjectUtils.isEmpty(urls)) {             // URL paths found: Let's consider it a handler.             registerHandler(urls, beanName).         }     }     if ((logger.isDebugEnabled() && !getHandlerMap().isEmpty()) || logger.isTraceEnabled()) {         logger.debug("Detected " + getHandlerMap().size() + " mappings in " + formatMappingName()).     } }
true;protected,abstract;1;1;/**  * Determine the URLs for the given handler bean.  * @param beanName the name of the candidate bean  * @return the URLs determined for the bean, or an empty array if none  */ ;/**  * Determine the URLs for the given handler bean.  * @param beanName the name of the candidate bean  * @return the URLs determined for the bean, or an empty array if none  */ protected abstract String[] determineUrlsForHandler(String beanName).
