commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;9;/**  * Set the HTTP methods that this content generator should support.  * <p>Default is GET, HEAD and POST for simple form controller types.  * unrestricted for general controllers and interceptors.  */ ;/**  * Set the HTTP methods that this content generator should support.  * <p>Default is GET, HEAD and POST for simple form controller types.  * unrestricted for general controllers and interceptors.  */ public final void setSupportedMethods(@Nullable String... methods) {     if (!ObjectUtils.isEmpty(methods)) {         this.supportedMethods = new LinkedHashSet<>(Arrays.asList(methods)).     } else {         this.supportedMethods = null.     }     initAllowHeader(). }
true;public,final;0;4;/**  * Return the HTTP methods that this content generator supports.  */ ;/**  * Return the HTTP methods that this content generator supports.  */ @Nullable public final String[] getSupportedMethods() {     return (this.supportedMethods != null ? StringUtils.toStringArray(this.supportedMethods) : null). }
false;private;0;20;;private void initAllowHeader() {     Collection<String> allowedMethods.     if (this.supportedMethods == null) {         allowedMethods = new ArrayList<>(HttpMethod.values().length - 1).         for (HttpMethod method : HttpMethod.values()) {             if (method != HttpMethod.TRACE) {                 allowedMethods.add(method.name()).             }         }     } else if (this.supportedMethods.contains(HttpMethod.OPTIONS.name())) {         allowedMethods = this.supportedMethods.     } else {         allowedMethods = new ArrayList<>(this.supportedMethods).         allowedMethods.add(HttpMethod.OPTIONS.name()).     }     this.allowHeader = StringUtils.collectionToCommaDelimitedString(allowedMethods). }
true;protected;0;4;/**  * Return the "Allow" header value to use in response to an HTTP OPTIONS request  * based on the configured {@link #setSupportedMethods supported methods} also  * automatically adding "OPTIONS" to the list even if not present as a supported  * method. This means subclasses don't have to explicitly list "OPTIONS" as a  * supported method as long as HTTP OPTIONS requests are handled before making a  * call to {@link #checkRequest(HttpServletRequest)}.  * @since 4.3  */ ;/**  * Return the "Allow" header value to use in response to an HTTP OPTIONS request  * based on the configured {@link #setSupportedMethods supported methods} also  * automatically adding "OPTIONS" to the list even if not present as a supported  * method. This means subclasses don't have to explicitly list "OPTIONS" as a  * supported method as long as HTTP OPTIONS requests are handled before making a  * call to {@link #checkRequest(HttpServletRequest)}.  * @since 4.3  */ @Nullable protected String getAllowHeader() {     return this.allowHeader. }
true;public,final;1;3;/**  * Set whether a session should be required to handle requests.  */ ;/**  * Set whether a session should be required to handle requests.  */ public final void setRequireSession(boolean requireSession) {     this.requireSession = requireSession. }
true;public,final;0;3;/**  * Return whether a session is required to handle requests.  */ ;/**  * Return whether a session is required to handle requests.  */ public final boolean isRequireSession() {     return this.requireSession. }
true;public,final;1;3;/**  * Set the {@link org.springframework.http.CacheControl} instance to build  * the Cache-Control HTTP response header.  * @since 4.2  */ ;/**  * Set the {@link org.springframework.http.CacheControl} instance to build  * the Cache-Control HTTP response header.  * @since 4.2  */ public final void setCacheControl(@Nullable CacheControl cacheControl) {     this.cacheControl = cacheControl. }
true;public,final;0;4;/**  * Get the {@link org.springframework.http.CacheControl} instance  * that builds the Cache-Control HTTP response header.  * @since 4.2  */ ;/**  * Get the {@link org.springframework.http.CacheControl} instance  * that builds the Cache-Control HTTP response header.  * @since 4.2  */ @Nullable public final CacheControl getCacheControl() {     return this.cacheControl. }
true;public,final;1;3;/**  * Cache content for the given number of seconds, by writing  * cache-related HTTP headers to the response:  * <ul>  * <li>seconds == -1 (default value): no generation cache-related headers</li>  * <li>seconds == 0: "Cache-Control: no-store" will prevent caching</li>  * <li>seconds > 0: "Cache-Control: max-age=seconds" will ask to cache content</li>  * </ul>  * <p>For more specific needs, a custom {@link org.springframework.http.CacheControl}  * should be used.  * @see #setCacheControl  */ ;/**  * Cache content for the given number of seconds, by writing  * cache-related HTTP headers to the response:  * <ul>  * <li>seconds == -1 (default value): no generation cache-related headers</li>  * <li>seconds == 0: "Cache-Control: no-store" will prevent caching</li>  * <li>seconds > 0: "Cache-Control: max-age=seconds" will ask to cache content</li>  * </ul>  * <p>For more specific needs, a custom {@link org.springframework.http.CacheControl}  * should be used.  * @see #setCacheControl  */ public final void setCacheSeconds(int seconds) {     this.cacheSeconds = seconds. }
true;public,final;0;3;/**  * Return the number of seconds that content is cached.  */ ;/**  * Return the number of seconds that content is cached.  */ public final int getCacheSeconds() {     return this.cacheSeconds. }
true;public,final;1;3;/**  * Configure one or more request header names (e.g. "Accept-Language") to  * add to the "Vary" response header to inform clients that the response is  * subject to content negotiation and variances based on the value of the  * given request headers. The configured request header names are added only  * if not already present in the response "Vary" header.  * @param varyByRequestHeaders one or more request header names  * @since 4.3  */ ;/**  * Configure one or more request header names (e.g. "Accept-Language") to  * add to the "Vary" response header to inform clients that the response is  * subject to content negotiation and variances based on the value of the  * given request headers. The configured request header names are added only  * if not already present in the response "Vary" header.  * @param varyByRequestHeaders one or more request header names  * @since 4.3  */ public final void setVaryByRequestHeaders(@Nullable String... varyByRequestHeaders) {     this.varyByRequestHeaders = varyByRequestHeaders. }
true;public,final;0;4;/**  * Return the configured request header names for the "Vary" response header.  * @since 4.3  */ ;/**  * Return the configured request header names for the "Vary" response header.  * @since 4.3  */ @Nullable public final String[] getVaryByRequestHeaders() {     return this.varyByRequestHeaders. }
true;public,final;1;4;/**  * Set whether to use the HTTP 1.0 expires header. Default is "false",  * as of 4.2.  * <p>Note: Cache headers will only get applied if caching is enabled  * (or explicitly prevented) for the current request.  * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-control  * header will be required, with the HTTP 1.0 headers disappearing  */ ;/**  * Set whether to use the HTTP 1.0 expires header. Default is "false",  * as of 4.2.  * <p>Note: Cache headers will only get applied if caching is enabled  * (or explicitly prevented) for the current request.  * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-control  * header will be required, with the HTTP 1.0 headers disappearing  */ @Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader) {     this.useExpiresHeader = useExpiresHeader. }
true;public,final;0;4;/**  * Return whether the HTTP 1.0 expires header is used.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ ;/**  * Return whether the HTTP 1.0 expires header is used.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ @Deprecated public final boolean isUseExpiresHeader() {     return this.useExpiresHeader. }
true;public,final;1;4;/**  * Set whether to use the HTTP 1.1 cache-control header. Default is "true".  * <p>Note: Cache headers will only get applied if caching is enabled  * (or explicitly prevented) for the current request.  * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-control  * header will be required, with the HTTP 1.0 headers disappearing  */ ;/**  * Set whether to use the HTTP 1.1 cache-control header. Default is "true".  * <p>Note: Cache headers will only get applied if caching is enabled  * (or explicitly prevented) for the current request.  * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-control  * header will be required, with the HTTP 1.0 headers disappearing  */ @Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader) {     this.useCacheControlHeader = useCacheControlHeader. }
true;public,final;0;4;/**  * Return whether the HTTP 1.1 cache-control header is used.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ ;/**  * Return whether the HTTP 1.1 cache-control header is used.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ @Deprecated public final boolean isUseCacheControlHeader() {     return this.useCacheControlHeader. }
true;public,final;1;4;/**  * Set whether to use the HTTP 1.1 cache-control header value "no-store"  * when preventing caching. Default is "true".  * @deprecated as of 4.2, in favor of {@link #setCacheControl}  */ ;/**  * Set whether to use the HTTP 1.1 cache-control header value "no-store"  * when preventing caching. Default is "true".  * @deprecated as of 4.2, in favor of {@link #setCacheControl}  */ @Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore) {     this.useCacheControlNoStore = useCacheControlNoStore. }
true;public,final;0;4;/**  * Return whether the HTTP 1.1 cache-control header value "no-store" is used.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ ;/**  * Return whether the HTTP 1.1 cache-control header value "no-store" is used.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ @Deprecated public final boolean isUseCacheControlNoStore() {     return this.useCacheControlNoStore. }
true;public,final;1;4;/**  * An option to add 'must-revalidate' to every Cache-Control header.  * This may be useful with annotated controller methods, which can  * programmatically do a last-modified calculation as described in  * {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}.  * <p>Default is "false".  * @deprecated as of 4.2, in favor of {@link #setCacheControl}  */ ;/**  * An option to add 'must-revalidate' to every Cache-Control header.  * This may be useful with annotated controller methods, which can  * programmatically do a last-modified calculation as described in  * {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}.  * <p>Default is "false".  * @deprecated as of 4.2, in favor of {@link #setCacheControl}  */ @Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate) {     this.alwaysMustRevalidate = mustRevalidate. }
true;public,final;0;4;/**  * Return whether 'must-revalidate' is added to every Cache-Control header.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ ;/**  * Return whether 'must-revalidate' is added to every Cache-Control header.  * @deprecated as of 4.2, in favor of {@link #getCacheControl()}  */ @Deprecated public final boolean isAlwaysMustRevalidate() {     return this.alwaysMustRevalidate. }
true;protected,final;1;12;/**  * Check the given request for supported methods and a required session, if any.  * @param request current HTTP request  * @throws ServletException if the request cannot be handled because a check failed  * @since 4.2  */ ;/**  * Check the given request for supported methods and a required session, if any.  * @param request current HTTP request  * @throws ServletException if the request cannot be handled because a check failed  * @since 4.2  */ protected final void checkRequest(HttpServletRequest request) throws ServletException {     // Check whether we should support the request method.     String method = request.getMethod().     if (this.supportedMethods != null && !this.supportedMethods.contains(method)) {         throw new HttpRequestMethodNotSupportedException(method, this.supportedMethods).     }     // Check whether a session is required.     if (this.requireSession && request.getSession(false) == null) {         throw new HttpSessionRequiredException("Pre-existing session required but none found").     } }
true;protected,final;1;13;/**  * Prepare the given response according to the settings of this generator.  * Applies the number of cache seconds specified for this generator.  * @param response current HTTP response  * @since 4.2  */ ;/**  * Prepare the given response according to the settings of this generator.  * Applies the number of cache seconds specified for this generator.  * @param response current HTTP response  * @since 4.2  */ protected final void prepareResponse(HttpServletResponse response) {     if (this.cacheControl != null) {         applyCacheControl(response, this.cacheControl).     } else {         applyCacheSeconds(response, this.cacheSeconds).     }     if (this.varyByRequestHeaders != null) {         for (String value : getVaryRequestHeadersToAdd(response, this.varyByRequestHeaders)) {             response.addHeader("Vary", value).         }     } }
true;protected,final;2;16;/**  * Set the HTTP Cache-Control header according to the given settings.  * @param response current HTTP response  * @param cacheControl the pre-configured cache control settings  * @since 4.2  */ ;/**  * Set the HTTP Cache-Control header according to the given settings.  * @param response current HTTP response  * @param cacheControl the pre-configured cache control settings  * @since 4.2  */ protected final void applyCacheControl(HttpServletResponse response, CacheControl cacheControl) {     String ccValue = cacheControl.getHeaderValue().     if (ccValue != null) {         // Set computed HTTP 1.1 Cache-Control header         response.setHeader(HEADER_CACHE_CONTROL, ccValue).         if (response.containsHeader(HEADER_PRAGMA)) {             // Reset HTTP 1.0 Pragma header if present             response.setHeader(HEADER_PRAGMA, "").         }         if (response.containsHeader(HEADER_EXPIRES)) {             // Reset HTTP 1.0 Expires header if present             response.setHeader(HEADER_EXPIRES, "").         }     } }
true;protected,final;2;28;/**  * Apply the given cache seconds and generate corresponding HTTP headers,  * i.e. allow caching for the given number of seconds in case of a positive  * value, prevent caching if given a 0 value, do nothing else.  * Does not tell the browser to revalidate the resource.  * @param response current HTTP response  * @param cacheSeconds positive number of seconds into the future that the  * response should be cacheable for, 0 to prevent caching  */ ;/**  * Apply the given cache seconds and generate corresponding HTTP headers,  * i.e. allow caching for the given number of seconds in case of a positive  * value, prevent caching if given a 0 value, do nothing else.  * Does not tell the browser to revalidate the resource.  * @param response current HTTP response  * @param cacheSeconds positive number of seconds into the future that the  * response should be cacheable for, 0 to prevent caching  */ @SuppressWarnings("deprecation") protected final void applyCacheSeconds(HttpServletResponse response, int cacheSeconds) {     if (this.useExpiresHeader || !this.useCacheControlHeader) {         // Deprecated HTTP 1.0 cache behavior, as in previous Spring versions         if (cacheSeconds > 0) {             cacheForSeconds(response, cacheSeconds).         } else if (cacheSeconds == 0) {             preventCaching(response).         }     } else {         CacheControl cControl.         if (cacheSeconds > 0) {             cControl = CacheControl.maxAge(cacheSeconds, TimeUnit.SECONDS).             if (this.alwaysMustRevalidate) {                 cControl = cControl.mustRevalidate().             }         } else if (cacheSeconds == 0) {             cControl = (this.useCacheControlNoStore ? CacheControl.noStore() : CacheControl.noCache()).         } else {             cControl = CacheControl.empty().         }         applyCacheControl(response, cControl).     } }
true;protected,final;3;7;/**  * Check and prepare the given request and response according to the settings  * of this generator.  * @see #checkRequest(HttpServletRequest)  * @see #prepareResponse(HttpServletResponse)  * @deprecated as of 4.2, since the {@code lastModified} flag is effectively ignored,  * with a must-revalidate header only generated if explicitly configured  */ ;/**  * Check and prepare the given request and response according to the settings  * of this generator.  * @see #checkRequest(HttpServletRequest)  * @see #prepareResponse(HttpServletResponse)  * @deprecated as of 4.2, since the {@code lastModified} flag is effectively ignored,  * with a must-revalidate header only generated if explicitly configured  */ @Deprecated protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, boolean lastModified) throws ServletException {     checkRequest(request).     prepareResponse(response). }
true;protected,final;4;8;/**  * Check and prepare the given request and response according to the settings  * of this generator.  * @see #checkRequest(HttpServletRequest)  * @see #applyCacheSeconds(HttpServletResponse, int)  * @deprecated as of 4.2, since the {@code lastModified} flag is effectively ignored,  * with a must-revalidate header only generated if explicitly configured  */ ;/**  * Check and prepare the given request and response according to the settings  * of this generator.  * @see #checkRequest(HttpServletRequest)  * @see #applyCacheSeconds(HttpServletResponse, int)  * @deprecated as of 4.2, since the {@code lastModified} flag is effectively ignored,  * with a must-revalidate header only generated if explicitly configured  */ @Deprecated protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, int cacheSeconds, boolean lastModified) throws ServletException {     checkRequest(request).     applyCacheSeconds(response, cacheSeconds). }
true;protected,final;3;9;/**  * Apply the given cache seconds and generate respective HTTP headers.  * <p>That is, allow caching for the given number of seconds in the  * case of a positive value, prevent caching if given a 0 value, else  * do nothing (i.e. leave caching to the client).  * @param response the current HTTP response  * @param cacheSeconds the (positive) number of seconds into the future  * that the response should be cacheable for. 0 to prevent caching. and  * a negative value to leave caching to the client.  * @param mustRevalidate whether the client should revalidate the resource  * (typically only necessary for controllers with last-modified support)  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ ;/**  * Apply the given cache seconds and generate respective HTTP headers.  * <p>That is, allow caching for the given number of seconds in the  * case of a positive value, prevent caching if given a 0 value, else  * do nothing (i.e. leave caching to the client).  * @param response the current HTTP response  * @param cacheSeconds the (positive) number of seconds into the future  * that the response should be cacheable for. 0 to prevent caching. and  * a negative value to leave caching to the client.  * @param mustRevalidate whether the client should revalidate the resource  * (typically only necessary for controllers with last-modified support)  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ @Deprecated protected final void applyCacheSeconds(HttpServletResponse response, int cacheSeconds, boolean mustRevalidate) {     if (cacheSeconds > 0) {         cacheForSeconds(response, cacheSeconds, mustRevalidate).     } else if (cacheSeconds == 0) {         preventCaching(response).     } }
true;protected,final;2;4;/**  * Set HTTP headers to allow caching for the given number of seconds.  * Does not tell the browser to revalidate the resource.  * @param response current HTTP response  * @param seconds number of seconds into the future that the response  * should be cacheable for  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ ;/**  * Set HTTP headers to allow caching for the given number of seconds.  * Does not tell the browser to revalidate the resource.  * @param response current HTTP response  * @param seconds number of seconds into the future that the response  * should be cacheable for  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ @Deprecated protected final void cacheForSeconds(HttpServletResponse response, int seconds) {     cacheForSeconds(response, seconds, false). }
true;protected,final;3;25;/**  * Set HTTP headers to allow caching for the given number of seconds.  * Tells the browser to revalidate the resource if mustRevalidate is  * {@code true}.  * @param response the current HTTP response  * @param seconds number of seconds into the future that the response  * should be cacheable for  * @param mustRevalidate whether the client should revalidate the resource  * (typically only necessary for controllers with last-modified support)  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ ;/**  * Set HTTP headers to allow caching for the given number of seconds.  * Tells the browser to revalidate the resource if mustRevalidate is  * {@code true}.  * @param response the current HTTP response  * @param seconds number of seconds into the future that the response  * should be cacheable for  * @param mustRevalidate whether the client should revalidate the resource  * (typically only necessary for controllers with last-modified support)  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ @Deprecated protected final void cacheForSeconds(HttpServletResponse response, int seconds, boolean mustRevalidate) {     if (this.useExpiresHeader) {         // HTTP 1.0 header         response.setDateHeader(HEADER_EXPIRES, System.currentTimeMillis() + seconds * 1000L).     } else if (response.containsHeader(HEADER_EXPIRES)) {         // Reset HTTP 1.0 Expires header if present         response.setHeader(HEADER_EXPIRES, "").     }     if (this.useCacheControlHeader) {         // HTTP 1.1 header         String headerValue = "max-age=" + seconds.         if (mustRevalidate || this.alwaysMustRevalidate) {             headerValue += ", must-revalidate".         }         response.setHeader(HEADER_CACHE_CONTROL, headerValue).     }     if (response.containsHeader(HEADER_PRAGMA)) {         // Reset HTTP 1.0 Pragma header if present         response.setHeader(HEADER_PRAGMA, "").     } }
true;protected,final;1;18;/**  * Prevent the response from being cached.  * Only called in HTTP 1.0 compatibility mode.  * <p>See {@code http://www.mnot.net/cache_docs}.  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ ;/**  * Prevent the response from being cached.  * Only called in HTTP 1.0 compatibility mode.  * <p>See {@code http://www.mnot.net/cache_docs}.  * @deprecated as of 4.2, in favor of {@link #applyCacheControl}  */ @Deprecated protected final void preventCaching(HttpServletResponse response) {     response.setHeader(HEADER_PRAGMA, "no-cache").     if (this.useExpiresHeader) {         // HTTP 1.0 Expires header         response.setDateHeader(HEADER_EXPIRES, 1L).     }     if (this.useCacheControlHeader) {         // HTTP 1.1 Cache-Control header: "no-cache" is the standard value,         // "no-store" is necessary to prevent caching on Firefox.         response.setHeader(HEADER_CACHE_CONTROL, "no-cache").         if (this.useCacheControlNoStore) {             response.addHeader(HEADER_CACHE_CONTROL, "no-store").         }     } }
false;private;2;20;;private Collection<String> getVaryRequestHeadersToAdd(HttpServletResponse response, String[] varyByRequestHeaders) {     if (!response.containsHeader(HttpHeaders.VARY)) {         return Arrays.asList(varyByRequestHeaders).     }     Collection<String> result = new ArrayList<>(varyByRequestHeaders.length).     Collections.addAll(result, varyByRequestHeaders).     for (String header : response.getHeaders(HttpHeaders.VARY)) {         for (String existing : StringUtils.tokenizeToStringArray(header, ",")) {             if ("*".equals(existing)) {                 return Collections.emptyList().             }             for (String value : varyByRequestHeaders) {                 if (value.equalsIgnoreCase(existing)) {                     result.remove(value).                 }             }         }     }     return result. }
