commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override @Nullable public String getContentType() {     return null. }
false;public;3;3;;@Override public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) { }
false;protected;1;10;;@Override protected boolean removeEldestEntry(Map.Entry<Object, View> eldest) {     if (size() > getCacheLimit()) {         viewAccessCache.remove(eldest.getKey()).         return true.     } else {         return false.     } }
true;public;1;3;/**  * Specify the maximum number of entries for the view cache.  * Default is 1024.  */ ;/**  * Specify the maximum number of entries for the view cache.  * Default is 1024.  */ public void setCacheLimit(int cacheLimit) {     this.cacheLimit = cacheLimit. }
true;public;0;3;/**  * Return the maximum number of entries for the view cache.  */ ;/**  * Return the maximum number of entries for the view cache.  */ public int getCacheLimit() {     return this.cacheLimit. }
true;public;1;3;/**  * Enable or disable caching.  * <p>This is equivalent to setting the {@link #setCacheLimit "cacheLimit"}  * property to the default limit (1024) or to 0, respectively.  * <p>Default is "true": caching is enabled.  * Disable this only for debugging and development.  */ ;/**  * Enable or disable caching.  * <p>This is equivalent to setting the {@link #setCacheLimit "cacheLimit"}  * property to the default limit (1024) or to 0, respectively.  * <p>Default is "true": caching is enabled.  * Disable this only for debugging and development.  */ public void setCache(boolean cache) {     this.cacheLimit = (cache ? DEFAULT_CACHE_LIMIT : 0). }
true;public;0;3;/**  * Return if caching is enabled.  */ ;/**  * Return if caching is enabled.  */ public boolean isCache() {     return (this.cacheLimit > 0). }
true;public;1;3;/**  * Whether a view name once resolved to {@code null} should be cached and  * automatically resolved to {@code null} subsequently.  * <p>Default is "true": unresolved view names are being cached, as of Spring 3.1.  * Note that this flag only applies if the general {@link #setCache "cache"}  * flag is kept at its default of "true" as well.  * <p>Of specific interest is the ability for some AbstractUrlBasedView  * implementations (FreeMarker, Tiles) to check if an underlying resource  * exists via {@link AbstractUrlBasedView#checkResource(Locale)}.  * With this flag set to "false", an underlying resource that re-appears  * is noticed and used. With the flag set to "true", one check is made only.  */ ;/**  * Whether a view name once resolved to {@code null} should be cached and  * automatically resolved to {@code null} subsequently.  * <p>Default is "true": unresolved view names are being cached, as of Spring 3.1.  * Note that this flag only applies if the general {@link #setCache "cache"}  * flag is kept at its default of "true" as well.  * <p>Of specific interest is the ability for some AbstractUrlBasedView  * implementations (FreeMarker, Tiles) to check if an underlying resource  * exists via {@link AbstractUrlBasedView#checkResource(Locale)}.  * With this flag set to "false", an underlying resource that re-appears  * is noticed and used. With the flag set to "true", one check is made only.  */ public void setCacheUnresolved(boolean cacheUnresolved) {     this.cacheUnresolved = cacheUnresolved. }
true;public;0;3;/**  * Return if caching of unresolved views is enabled.  */ ;/**  * Return if caching of unresolved views is enabled.  */ public boolean isCacheUnresolved() {     return this.cacheUnresolved. }
false;public;2;33;;@Override @Nullable public View resolveViewName(String viewName, Locale locale) throws Exception {     if (!isCache()) {         return createView(viewName, locale).     } else {         Object cacheKey = getCacheKey(viewName, locale).         View view = this.viewAccessCache.get(cacheKey).         if (view == null) {             synchronized (this.viewCreationCache) {                 view = this.viewCreationCache.get(cacheKey).                 if (view == null) {                     // Ask the subclass to create the View object.                     view = createView(viewName, locale).                     if (view == null && this.cacheUnresolved) {                         view = UNRESOLVED_VIEW.                     }                     if (view != null) {                         this.viewAccessCache.put(cacheKey, view).                         this.viewCreationCache.put(cacheKey, view).                     }                 }             }         } else {             if (logger.isTraceEnabled()) {                 logger.trace(formatKey(cacheKey) + "served from cache").             }         }         return (view != UNRESOLVED_VIEW ? view : null).     } }
false;private,static;1;3;;private static String formatKey(Object cacheKey) {     return "View with key [" + cacheKey + "] ". }
true;protected;2;3;/**  * Return the cache key for the given view name and the given locale.  * <p>Default is a String consisting of view name and locale suffix.  * Can be overridden in subclasses.  * <p>Needs to respect the locale in general, as a different locale can  * lead to a different view resource.  */ ;/**  * Return the cache key for the given view name and the given locale.  * <p>Default is a String consisting of view name and locale suffix.  * Can be overridden in subclasses.  * <p>Needs to respect the locale in general, as a different locale can  * lead to a different view resource.  */ protected Object getCacheKey(String viewName, Locale locale) {     return viewName + '_' + locale. }
true;public;2;18;/**  * Provides functionality to clear the cache for a certain view.  * <p>This can be handy in case developer are able to modify views  * (e.g. FreeMarker templates) at runtime after which you'd need to  * clear the cache for the specified view.  * @param viewName the view name for which the cached view object  * (if any) needs to be removed  * @param locale the locale for which the view object should be removed  */ ;/**  * Provides functionality to clear the cache for a certain view.  * <p>This can be handy in case developer are able to modify views  * (e.g. FreeMarker templates) at runtime after which you'd need to  * clear the cache for the specified view.  * @param viewName the view name for which the cached view object  * (if any) needs to be removed  * @param locale the locale for which the view object should be removed  */ public void removeFromCache(String viewName, Locale locale) {     if (!isCache()) {         logger.warn("Caching is OFF (removal not necessary)").     } else {         Object cacheKey = getCacheKey(viewName, locale).         Object cachedView.         synchronized (this.viewCreationCache) {             this.viewAccessCache.remove(cacheKey).             cachedView = this.viewCreationCache.remove(cacheKey).         }         if (logger.isDebugEnabled()) {             // Some debug output might be useful...             logger.debug(formatKey(cacheKey) + (cachedView != null ? "cleared from cache" : "not found in the cache")).         }     } }
true;public;0;7;/**  * Clear the entire view cache, removing all cached view objects.  * Subsequent resolve calls will lead to recreation of demanded view objects.  */ ;/**  * Clear the entire view cache, removing all cached view objects.  * Subsequent resolve calls will lead to recreation of demanded view objects.  */ public void clearCache() {     logger.debug("Clearing all views from the cache").     synchronized (this.viewCreationCache) {         this.viewAccessCache.clear().         this.viewCreationCache.clear().     } }
true;protected;2;4;/**  * Create the actual View object.  * <p>The default implementation delegates to {@link #loadView}.  * This can be overridden to resolve certain view names in a special fashion,  * before delegating to the actual {@code loadView} implementation  * provided by the subclass.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return the View instance, or {@code null} if not found  * (optional, to allow for ViewResolver chaining)  * @throws Exception if the view couldn't be resolved  * @see #loadView  */ ;/**  * Create the actual View object.  * <p>The default implementation delegates to {@link #loadView}.  * This can be overridden to resolve certain view names in a special fashion,  * before delegating to the actual {@code loadView} implementation  * provided by the subclass.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return the View instance, or {@code null} if not found  * (optional, to allow for ViewResolver chaining)  * @throws Exception if the view couldn't be resolved  * @see #loadView  */ @Nullable protected View createView(String viewName, Locale locale) throws Exception {     return loadView(viewName, locale). }
true;protected,abstract;2;2;/**  * Subclasses must implement this method, building a View object  * for the specified view. The returned View objects will be  * cached by this ViewResolver base class.  * <p>Subclasses are not forced to support internationalization:  * A subclass that does not may simply ignore the locale parameter.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return the View instance, or {@code null} if not found  * (optional, to allow for ViewResolver chaining)  * @throws Exception if the view couldn't be resolved  * @see #resolveViewName  */ ;/**  * Subclasses must implement this method, building a View object  * for the specified view. The returned View objects will be  * cached by this ViewResolver base class.  * <p>Subclasses are not forced to support internationalization:  * A subclass that does not may simply ignore the locale parameter.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return the View instance, or {@code null} if not found  * (optional, to allow for ViewResolver chaining)  * @throws Exception if the view couldn't be resolved  * @see #resolveViewName  */ @Nullable protected abstract View loadView(String viewName, Locale locale) throws Exception.
