commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Set the view class that should be used to create views.  * @param viewClass class that is assignable to the required view class  * (by default, AbstractUrlBasedView)  * @see AbstractUrlBasedView  */ ;/**  * Set the view class that should be used to create views.  * @param viewClass class that is assignable to the required view class  * (by default, AbstractUrlBasedView)  * @see AbstractUrlBasedView  */ public void setViewClass(@Nullable Class<?> viewClass) {     if (viewClass != null && !requiredViewClass().isAssignableFrom(viewClass)) {         throw new IllegalArgumentException("Given view class [" + viewClass.getName() + "] is not of type [" + requiredViewClass().getName() + "]").     }     this.viewClass = viewClass. }
true;protected;0;4;/**  * Return the view class to be used to create views.  */ ;/**  * Return the view class to be used to create views.  */ @Nullable protected Class<?> getViewClass() {     return this.viewClass. }
true;protected;0;3;/**  * Return the required type of view for this resolver.  * This implementation returns AbstractUrlBasedView.  * @see AbstractUrlBasedView  */ ;/**  * Return the required type of view for this resolver.  * This implementation returns AbstractUrlBasedView.  * @see AbstractUrlBasedView  */ protected Class<?> requiredViewClass() {     return AbstractUrlBasedView.class. }
true;public;1;3;/**  * Set the prefix that gets prepended to view names when building a URL.  */ ;/**  * Set the prefix that gets prepended to view names when building a URL.  */ public void setPrefix(@Nullable String prefix) {     this.prefix = (prefix != null ? prefix : ""). }
true;protected;0;3;/**  * Return the prefix that gets prepended to view names when building a URL.  */ ;/**  * Return the prefix that gets prepended to view names when building a URL.  */ protected String getPrefix() {     return this.prefix. }
true;public;1;3;/**  * Set the suffix that gets appended to view names when building a URL.  */ ;/**  * Set the suffix that gets appended to view names when building a URL.  */ public void setSuffix(@Nullable String suffix) {     this.suffix = (suffix != null ? suffix : ""). }
true;protected;0;3;/**  * Return the suffix that gets appended to view names when building a URL.  */ ;/**  * Return the suffix that gets appended to view names when building a URL.  */ protected String getSuffix() {     return this.suffix. }
true;public;1;3;/**  * Set the content type for all views.  * <p>May be ignored by view classes if the view itself is assumed  * to set the content type, e.g. in case of JSPs.  */ ;/**  * Set the content type for all views.  * <p>May be ignored by view classes if the view itself is assumed  * to set the content type, e.g. in case of JSPs.  */ public void setContentType(@Nullable String contentType) {     this.contentType = contentType. }
true;protected;0;4;/**  * Return the content type for all views, if any.  */ ;/**  * Return the content type for all views, if any.  */ @Nullable protected String getContentType() {     return this.contentType. }
true;public;1;3;/**  * Set whether to interpret a given redirect URL that starts with a  * slash ("/") as relative to the current ServletContext, i.e. as  * relative to the web application root.  * <p>Default is "true": A redirect URL that starts with a slash will be  * interpreted as relative to the web application root, i.e. the context  * path will be prepended to the URL.  * <p><b>Redirect URLs can be specified via the "redirect:" prefix.</b>  * E.g.: "redirect:myAction"  * @see RedirectView#setContextRelative  * @see #REDIRECT_URL_PREFIX  */ ;/**  * Set whether to interpret a given redirect URL that starts with a  * slash ("/") as relative to the current ServletContext, i.e. as  * relative to the web application root.  * <p>Default is "true": A redirect URL that starts with a slash will be  * interpreted as relative to the web application root, i.e. the context  * path will be prepended to the URL.  * <p><b>Redirect URLs can be specified via the "redirect:" prefix.</b>  * E.g.: "redirect:myAction"  * @see RedirectView#setContextRelative  * @see #REDIRECT_URL_PREFIX  */ public void setRedirectContextRelative(boolean redirectContextRelative) {     this.redirectContextRelative = redirectContextRelative. }
true;protected;0;3;/**  * Return whether to interpret a given redirect URL that starts with a  * slash ("/") as relative to the current ServletContext, i.e. as  * relative to the web application root.  */ ;/**  * Return whether to interpret a given redirect URL that starts with a  * slash ("/") as relative to the current ServletContext, i.e. as  * relative to the web application root.  */ protected boolean isRedirectContextRelative() {     return this.redirectContextRelative. }
true;public;1;3;/**  * Set whether redirects should stay compatible with HTTP 1.0 clients.  * <p>In the default implementation, this will enforce HTTP status code 302  * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.  * Turning this off will send HTTP status code 303, which is the correct  * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.  * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any  * difference. However, some clients depend on 303 when redirecting  * after a POST request. turn this flag off in such a scenario.  * <p><b>Redirect URLs can be specified via the "redirect:" prefix.</b>  * E.g.: "redirect:myAction"  * @see RedirectView#setHttp10Compatible  * @see #REDIRECT_URL_PREFIX  */ ;/**  * Set whether redirects should stay compatible with HTTP 1.0 clients.  * <p>In the default implementation, this will enforce HTTP status code 302  * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.  * Turning this off will send HTTP status code 303, which is the correct  * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.  * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any  * difference. However, some clients depend on 303 when redirecting  * after a POST request. turn this flag off in such a scenario.  * <p><b>Redirect URLs can be specified via the "redirect:" prefix.</b>  * E.g.: "redirect:myAction"  * @see RedirectView#setHttp10Compatible  * @see #REDIRECT_URL_PREFIX  */ public void setRedirectHttp10Compatible(boolean redirectHttp10Compatible) {     this.redirectHttp10Compatible = redirectHttp10Compatible. }
true;protected;0;3;/**  * Return whether redirects should stay compatible with HTTP 1.0 clients.  */ ;/**  * Return whether redirects should stay compatible with HTTP 1.0 clients.  */ protected boolean isRedirectHttp10Compatible() {     return this.redirectHttp10Compatible. }
true;public;1;3;/**  * Configure one or more hosts associated with the application.  * All other hosts will be considered external hosts.  * <p>In effect, this property provides a way turn off encoding on redirect  * via {@link HttpServletResponse#encodeRedirectURL} for URLs that have a  * host and that host is not listed as a known host.  * <p>If not set (the default) all URLs are encoded through the response.  * @param redirectHosts one or more application hosts  * @since 4.3  */ ;/**  * Configure one or more hosts associated with the application.  * All other hosts will be considered external hosts.  * <p>In effect, this property provides a way turn off encoding on redirect  * via {@link HttpServletResponse#encodeRedirectURL} for URLs that have a  * host and that host is not listed as a known host.  * <p>If not set (the default) all URLs are encoded through the response.  * @param redirectHosts one or more application hosts  * @since 4.3  */ public void setRedirectHosts(@Nullable String... redirectHosts) {     this.redirectHosts = redirectHosts. }
true;public;0;4;/**  * Return the configured application hosts for redirect purposes.  * @since 4.3  */ ;/**  * Return the configured application hosts for redirect purposes.  * @since 4.3  */ @Nullable public String[] getRedirectHosts() {     return this.redirectHosts. }
true;public;1;3;/**  * Set the name of the RequestContext attribute for all views.  * @param requestContextAttribute name of the RequestContext attribute  * @see AbstractView#setRequestContextAttribute  */ ;/**  * Set the name of the RequestContext attribute for all views.  * @param requestContextAttribute name of the RequestContext attribute  * @see AbstractView#setRequestContextAttribute  */ public void setRequestContextAttribute(@Nullable String requestContextAttribute) {     this.requestContextAttribute = requestContextAttribute. }
true;protected;0;4;/**  * Return the name of the RequestContext attribute for all views, if any.  */ ;/**  * Return the name of the RequestContext attribute for all views, if any.  */ @Nullable protected String getRequestContextAttribute() {     return this.requestContextAttribute. }
true;public;1;3;/**  * Set static attributes from a {@code java.util.Properties} object,  * for all views returned by this resolver.  * <p>This is the most convenient way to set static attributes. Note that  * static attributes can be overridden by dynamic attributes, if a value  * with the same name is included in the model.  * <p>Can be populated with a String "value" (parsed via PropertiesEditor)  * or a "props" element in XML bean definitions.  * @see org.springframework.beans.propertyeditors.PropertiesEditor  * @see AbstractView#setAttributes  */ ;/**  * Set static attributes from a {@code java.util.Properties} object,  * for all views returned by this resolver.  * <p>This is the most convenient way to set static attributes. Note that  * static attributes can be overridden by dynamic attributes, if a value  * with the same name is included in the model.  * <p>Can be populated with a String "value" (parsed via PropertiesEditor)  * or a "props" element in XML bean definitions.  * @see org.springframework.beans.propertyeditors.PropertiesEditor  * @see AbstractView#setAttributes  */ public void setAttributes(Properties props) {     CollectionUtils.mergePropertiesIntoMap(props, this.staticAttributes). }
true;public;1;5;/**  * Set static attributes from a Map, for all views returned by this resolver.  * This allows to set any kind of attribute values, for example bean references.  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @param attributes a Map with name Strings as keys and attribute objects as values  * @see AbstractView#setAttributesMap  */ ;/**  * Set static attributes from a Map, for all views returned by this resolver.  * This allows to set any kind of attribute values, for example bean references.  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @param attributes a Map with name Strings as keys and attribute objects as values  * @see AbstractView#setAttributesMap  */ public void setAttributesMap(@Nullable Map<String, ?> attributes) {     if (attributes != null) {         this.staticAttributes.putAll(attributes).     } }
true;public;0;3;/**  * Allow Map access to the static attributes for views returned by  * this resolver, with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via  * "attributesMap[myKey]". This is particularly useful for  * adding or overriding entries in child view definitions.  */ ;/**  * Allow Map access to the static attributes for views returned by  * this resolver, with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via  * "attributesMap[myKey]". This is particularly useful for  * adding or overriding entries in child view definitions.  */ public Map<String, Object> getAttributesMap() {     return this.staticAttributes. }
true;public;1;3;/**  * Specify whether views resolved by this resolver should add path variables to the model or not.  * <p>>The default setting is to let each View decide (see {@link AbstractView#setExposePathVariables}.  * However, you can use this property to override that.  * @param exposePathVariables  * <ul>  * <li>{@code true} - all Views resolved by this resolver will expose path variables  * <li>{@code false} - no Views resolved by this resolver will expose path variables  * <li>{@code null} - individual Views can decide for themselves (this is used by the default)  * </ul>  * @see AbstractView#setExposePathVariables  */ ;/**  * Specify whether views resolved by this resolver should add path variables to the model or not.  * <p>>The default setting is to let each View decide (see {@link AbstractView#setExposePathVariables}.  * However, you can use this property to override that.  * @param exposePathVariables  * <ul>  * <li>{@code true} - all Views resolved by this resolver will expose path variables  * <li>{@code false} - no Views resolved by this resolver will expose path variables  * <li>{@code null} - individual Views can decide for themselves (this is used by the default)  * </ul>  * @see AbstractView#setExposePathVariables  */ public void setExposePathVariables(@Nullable Boolean exposePathVariables) {     this.exposePathVariables = exposePathVariables. }
true;protected;0;4;/**  * Return whether views resolved by this resolver should add path variables to the model or not.  */ ;/**  * Return whether views resolved by this resolver should add path variables to the model or not.  */ @Nullable protected Boolean getExposePathVariables() {     return this.exposePathVariables. }
true;public;1;3;/**  * Set whether to make all Spring beans in the application context accessible  * as request attributes, through lazy checking once an attribute gets accessed.  * <p>This will make all such beans accessible in plain {@code ${...}}  * expressions in a JSP 2.0 page, as well as in JSTL's {@code c:out}  * value expressions.  * <p>Default is "false".  * @see AbstractView#setExposeContextBeansAsAttributes  */ ;/**  * Set whether to make all Spring beans in the application context accessible  * as request attributes, through lazy checking once an attribute gets accessed.  * <p>This will make all such beans accessible in plain {@code ${...}}  * expressions in a JSP 2.0 page, as well as in JSTL's {@code c:out}  * value expressions.  * <p>Default is "false".  * @see AbstractView#setExposeContextBeansAsAttributes  */ public void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes) {     this.exposeContextBeansAsAttributes = exposeContextBeansAsAttributes. }
false;protected;0;4;;@Nullable protected Boolean getExposeContextBeansAsAttributes() {     return this.exposeContextBeansAsAttributes. }
true;public;1;3;/**  * Specify the names of beans in the context which are supposed to be exposed.  * If this is non-null, only the specified beans are eligible for exposure as  * attributes.  * @see AbstractView#setExposedContextBeanNames  */ ;/**  * Specify the names of beans in the context which are supposed to be exposed.  * If this is non-null, only the specified beans are eligible for exposure as  * attributes.  * @see AbstractView#setExposedContextBeanNames  */ public void setExposedContextBeanNames(@Nullable String... exposedContextBeanNames) {     this.exposedContextBeanNames = exposedContextBeanNames. }
false;protected;0;4;;@Nullable protected String[] getExposedContextBeanNames() {     return this.exposedContextBeanNames. }
true;public;1;3;/**  * Set the view names (or name patterns) that can be handled by this  * {@link org.springframework.web.servlet.ViewResolver}. View names can contain  * simple wildcards such that 'my*', '*Report' and '*Repo*' will all match the  * view name 'myReport'.  * @see #canHandle  */ ;/**  * Set the view names (or name patterns) that can be handled by this  * {@link org.springframework.web.servlet.ViewResolver}. View names can contain  * simple wildcards such that 'my*', '*Report' and '*Repo*' will all match the  * view name 'myReport'.  * @see #canHandle  */ public void setViewNames(@Nullable String... viewNames) {     this.viewNames = viewNames. }
true;protected;0;4;/**  * Return the view names (or name patterns) that can be handled by this  * {@link org.springframework.web.servlet.ViewResolver}.  */ ;/**  * Return the view names (or name patterns) that can be handled by this  * {@link org.springframework.web.servlet.ViewResolver}.  */ @Nullable protected String[] getViewNames() {     return this.viewNames. }
true;public;1;3;/**  * Specify the order value for this ViewResolver bean.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @see org.springframework.core.Ordered#getOrder()  */ ;/**  * Specify the order value for this ViewResolver bean.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @see org.springframework.core.Ordered#getOrder()  */ public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;protected;0;7;;@Override protected void initApplicationContext() {     super.initApplicationContext().     if (getViewClass() == null) {         throw new IllegalArgumentException("Property 'viewClass' is required").     } }
true;protected;2;4;/**  * This implementation returns just the view name,  * as this ViewResolver doesn't support localized resolution.  */ ;/**  * This implementation returns just the view name,  * as this ViewResolver doesn't support localized resolution.  */ @Override protected Object getCacheKey(String viewName, Locale locale) {     return viewName. }
true;protected;2;30;/**  * Overridden to implement check for "redirect:" prefix.  * <p>Not possible in {@code loadView}, since overridden  * {@code loadView} versions in subclasses might rely on the  * superclass always creating instances of the required view class.  * @see #loadView  * @see #requiredViewClass  */ ;/**  * Overridden to implement check for "redirect:" prefix.  * <p>Not possible in {@code loadView}, since overridden  * {@code loadView} versions in subclasses might rely on the  * superclass always creating instances of the required view class.  * @see #loadView  * @see #requiredViewClass  */ @Override protected View createView(String viewName, Locale locale) throws Exception {     // return null to pass on to the next resolver in the chain.     if (!canHandle(viewName, locale)) {         return null.     }     // Check for special "redirect:" prefix.     if (viewName.startsWith(REDIRECT_URL_PREFIX)) {         String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length()).         RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()).         String[] hosts = getRedirectHosts().         if (hosts != null) {             view.setHosts(hosts).         }         return applyLifecycleMethods(REDIRECT_URL_PREFIX, view).     }     // Check for special "forward:" prefix.     if (viewName.startsWith(FORWARD_URL_PREFIX)) {         String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length()).         InternalResourceView view = new InternalResourceView(forwardUrl).         return applyLifecycleMethods(FORWARD_URL_PREFIX, view).     }     // Else fall back to superclass implementation: calling loadView.     return super.createView(viewName, locale). }
true;protected;2;4;/**  * Indicates whether or not this {@link org.springframework.web.servlet.ViewResolver} can  * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will  * return {@code null}. The default implementation checks against the configured  * {@link #setViewNames view names}.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return whether this resolver applies to the specified view  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ ;/**  * Indicates whether or not this {@link org.springframework.web.servlet.ViewResolver} can  * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will  * return {@code null}. The default implementation checks against the configured  * {@link #setViewNames view names}.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return whether this resolver applies to the specified view  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ protected boolean canHandle(String viewName, Locale locale) {     String[] viewNames = getViewNames().     return (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName)). }
true;protected;2;6;/**  * Delegates to {@code buildView} for creating a new instance of the  * specified view class. Applies the following Spring lifecycle methods  * (as supported by the generic Spring bean factory):  * <ul>  * <li>ApplicationContextAware's {@code setApplicationContext}  * <li>InitializingBean's {@code afterPropertiesSet}  * </ul>  * @param viewName the name of the view to retrieve  * @return the View instance  * @throws Exception if the view couldn't be resolved  * @see #buildView(String)  * @see org.springframework.context.ApplicationContextAware#setApplicationContext  * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet  */ ;/**  * Delegates to {@code buildView} for creating a new instance of the  * specified view class. Applies the following Spring lifecycle methods  * (as supported by the generic Spring bean factory):  * <ul>  * <li>ApplicationContextAware's {@code setApplicationContext}  * <li>InitializingBean's {@code afterPropertiesSet}  * </ul>  * @param viewName the name of the view to retrieve  * @return the View instance  * @throws Exception if the view couldn't be resolved  * @see #buildView(String)  * @see org.springframework.context.ApplicationContextAware#setApplicationContext  * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet  */ @Override protected View loadView(String viewName, Locale locale) throws Exception {     AbstractUrlBasedView view = buildView(viewName).     View result = applyLifecycleMethods(viewName, view).     return (view.checkResource(locale) ? result : null). }
true;protected;1;30;/**  * Creates a new View instance of the specified view class and configures it.  * Does <i>not</i> perform any lookup for pre-defined View instances.  * <p>Spring lifecycle methods as defined by the bean container do not have to  * be called here. those will be applied by the {@code loadView} method  * after this method returns.  * <p>Subclasses will typically call {@code super.buildView(viewName)}  * first, before setting further properties themselves. {@code loadView}  * will then apply Spring lifecycle methods at the end of this process.  * @param viewName the name of the view to build  * @return the View instance  * @throws Exception if the view couldn't be resolved  * @see #loadView(String, java.util.Locale)  */ ;/**  * Creates a new View instance of the specified view class and configures it.  * Does <i>not</i> perform any lookup for pre-defined View instances.  * <p>Spring lifecycle methods as defined by the bean container do not have to  * be called here. those will be applied by the {@code loadView} method  * after this method returns.  * <p>Subclasses will typically call {@code super.buildView(viewName)}  * first, before setting further properties themselves. {@code loadView}  * will then apply Spring lifecycle methods at the end of this process.  * @param viewName the name of the view to build  * @return the View instance  * @throws Exception if the view couldn't be resolved  * @see #loadView(String, java.util.Locale)  */ protected AbstractUrlBasedView buildView(String viewName) throws Exception {     Class<?> viewClass = getViewClass().     Assert.state(viewClass != null, "No view class").     AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass).     view.setUrl(getPrefix() + viewName + getSuffix()).     String contentType = getContentType().     if (contentType != null) {         view.setContentType(contentType).     }     view.setRequestContextAttribute(getRequestContextAttribute()).     view.setAttributesMap(getAttributesMap()).     Boolean exposePathVariables = getExposePathVariables().     if (exposePathVariables != null) {         view.setExposePathVariables(exposePathVariables).     }     Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes().     if (exposeContextBeansAsAttributes != null) {         view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes).     }     String[] exposedContextBeanNames = getExposedContextBeanNames().     if (exposedContextBeanNames != null) {         view.setExposedContextBeanNames(exposedContextBeanNames).     }     return view. }
true;protected;2;10;/**  * Apply the containing {@link ApplicationContext}'s lifecycle methods  * to the given {@link View} instance, if such a context is available.  * @param viewName the name of the view  * @param view the freshly created View instance, pre-configured with  * {@link AbstractUrlBasedView}'s properties  * @return the {@link View} instance to use (either the original one  * or a decorated variant)  * @since 5.0  * @see #getApplicationContext()  * @see ApplicationContext#getAutowireCapableBeanFactory()  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean  */ ;/**  * Apply the containing {@link ApplicationContext}'s lifecycle methods  * to the given {@link View} instance, if such a context is available.  * @param viewName the name of the view  * @param view the freshly created View instance, pre-configured with  * {@link AbstractUrlBasedView}'s properties  * @return the {@link View} instance to use (either the original one  * or a decorated variant)  * @since 5.0  * @see #getApplicationContext()  * @see ApplicationContext#getAutowireCapableBeanFactory()  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean  */ protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {     ApplicationContext context = getApplicationContext().     if (context != null) {         Object initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName).         if (initialized instanceof View) {             return (View) initialized.         }     }     return view. }
