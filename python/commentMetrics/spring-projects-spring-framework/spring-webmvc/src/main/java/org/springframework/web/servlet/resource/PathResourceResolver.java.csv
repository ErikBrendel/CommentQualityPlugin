commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * By default when a Resource is found, the path of the resolved resource is  * compared to ensure it's under the input location where it was found.  * However sometimes that may not be the case, e.g. when  * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}  * resolves public URLs of links it contains, the CSS file is the location  * and the resources being resolved are css files, images, fonts and others  * located in adjacent or parent directories.  * <p>This property allows configuring a complete list of locations under  * which resources must be so that if a resource is not under the location  * relative to which it was found, this list may be checked as well.  * <p>By default {@link ResourceHttpRequestHandler} initializes this property  * to match its list of locations.  * @param locations the list of allowed locations  * @since 4.1.2  * @see ResourceHttpRequestHandler#initAllowedLocations()  */ ;/**  * By default when a Resource is found, the path of the resolved resource is  * compared to ensure it's under the input location where it was found.  * However sometimes that may not be the case, e.g. when  * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}  * resolves public URLs of links it contains, the CSS file is the location  * and the resources being resolved are css files, images, fonts and others  * located in adjacent or parent directories.  * <p>This property allows configuring a complete list of locations under  * which resources must be so that if a resource is not under the location  * relative to which it was found, this list may be checked as well.  * <p>By default {@link ResourceHttpRequestHandler} initializes this property  * to match its list of locations.  * @param locations the list of allowed locations  * @since 4.1.2  * @see ResourceHttpRequestHandler#initAllowedLocations()  */ public void setAllowedLocations(@Nullable Resource... locations) {     this.allowedLocations = locations. }
false;public;0;4;;@Nullable public Resource[] getAllowedLocations() {     return this.allowedLocations. }
true;public;1;4;/**  * Configure charsets associated with locations. If a static resource is found  * under a {@link org.springframework.core.io.UrlResource URL resource}  * location the charset is used to encode the relative path  * <p><strong>Note:</strong> the charset is used only if the  * {@link #setUrlPathHelper urlPathHelper} property is also configured and  * its {@code urlDecode} property is set to true.  * @since 4.3.13  */ ;/**  * Configure charsets associated with locations. If a static resource is found  * under a {@link org.springframework.core.io.UrlResource URL resource}  * location the charset is used to encode the relative path  * <p><strong>Note:</strong> the charset is used only if the  * {@link #setUrlPathHelper urlPathHelper} property is also configured and  * its {@code urlDecode} property is set to true.  * @since 4.3.13  */ public void setLocationCharsets(Map<Resource, Charset> locationCharsets) {     this.locationCharsets.clear().     this.locationCharsets.putAll(locationCharsets). }
true;public;0;3;/**  * Return charsets associated with static resource locations.  * @since 4.3.13  */ ;/**  * Return charsets associated with static resource locations.  * @since 4.3.13  */ public Map<Resource, Charset> getLocationCharsets() {     return Collections.unmodifiableMap(this.locationCharsets). }
true;public;1;3;/**  * Provide a reference to the {@link UrlPathHelper} used to map requests to  * static resources. This helps to derive information about the lookup path  * such as whether it is decoded or not.  * @since 4.3.13  */ ;/**  * Provide a reference to the {@link UrlPathHelper} used to map requests to  * static resources. This helps to derive information about the lookup path  * such as whether it is decoded or not.  * @since 4.3.13  */ public void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {     this.urlPathHelper = urlPathHelper. }
true;public;0;4;/**  * The configured {@link UrlPathHelper}.  * @since 4.3.13  */ ;/**  * The configured {@link UrlPathHelper}.  * @since 4.3.13  */ @Nullable public UrlPathHelper getUrlPathHelper() {     return this.urlPathHelper. }
false;protected;4;6;;@Override protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {     return getResource(requestPath, request, locations). }
false;protected;3;7;;@Override protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations, ResourceResolverChain chain) {     return (StringUtils.hasText(resourcePath) && getResource(resourcePath, null, locations) != null ? resourcePath : null). }
false;private;3;26;;@Nullable private Resource getResource(String resourcePath, @Nullable HttpServletRequest request, List<? extends Resource> locations) {     for (Resource location : locations) {         try {             String pathToUse = encodeIfNecessary(resourcePath, request, location).             Resource resource = getResource(pathToUse, location).             if (resource != null) {                 return resource.             }         } catch (IOException ex) {             if (logger.isDebugEnabled()) {                 String error = "Skip location [" + location + "] due to error".                 if (logger.isTraceEnabled()) {                     logger.trace(error, ex).                 } else {                     logger.debug(error + ": " + ex.getMessage()).                 }             }         }     }     return null. }
true;protected;2;17;/**  * Find the resource under the given location.  * <p>The default implementation checks if there is a readable  * {@code Resource} for the given path relative to the location.  * @param resourcePath the path to the resource  * @param location the location to check  * @return the resource, or {@code null} if none found  */ ;/**  * Find the resource under the given location.  * <p>The default implementation checks if there is a readable  * {@code Resource} for the given path relative to the location.  * @param resourcePath the path to the resource  * @param location the location to check  * @return the resource, or {@code null} if none found  */ @Nullable protected Resource getResource(String resourcePath, Resource location) throws IOException {     Resource resource = location.createRelative(resourcePath).     if (resource.isReadable()) {         if (checkResource(resource, location)) {             return resource.         } else if (logger.isWarnEnabled()) {             Resource[] allowedLocations = getAllowedLocations().             logger.warn("Resource path \"" + resourcePath + "\" was successfully resolved " + "but resource \"" + resource.getURL() + "\" is neither under the " + "current location \"" + location.getURL() + "\" nor under any of the " + "allowed locations " + (allowedLocations != null ? Arrays.asList(allowedLocations) : "[]")).         }     }     return null. }
true;protected;2;14;/**  * Perform additional checks on a resolved resource beyond checking whether the  * resources exists and is readable. The default implementation also verifies  * the resource is either under the location relative to which it was found or  * is under one of the {@link #setAllowedLocations allowed locations}.  * @param resource the resource to check  * @param location the location relative to which the resource was found  * @return "true" if resource is in a valid location, "false" otherwise.  * @since 4.1.2  */ ;/**  * Perform additional checks on a resolved resource beyond checking whether the  * resources exists and is readable. The default implementation also verifies  * the resource is either under the location relative to which it was found or  * is under one of the {@link #setAllowedLocations allowed locations}.  * @param resource the resource to check  * @param location the location relative to which the resource was found  * @return "true" if resource is in a valid location, "false" otherwise.  * @since 4.1.2  */ protected boolean checkResource(Resource resource, Resource location) throws IOException {     if (isResourceUnderLocation(resource, location)) {         return true.     }     Resource[] allowedLocations = getAllowedLocations().     if (allowedLocations != null) {         for (Resource current : allowedLocations) {             if (isResourceUnderLocation(resource, current)) {                 return true.             }         }     }     return false. }
false;private;2;31;;private boolean isResourceUnderLocation(Resource resource, Resource location) throws IOException {     if (resource.getClass() != location.getClass()) {         return false.     }     String resourcePath.     String locationPath.     if (resource instanceof UrlResource) {         resourcePath = resource.getURL().toExternalForm().         locationPath = StringUtils.cleanPath(location.getURL().toString()).     } else if (resource instanceof ClassPathResource) {         resourcePath = ((ClassPathResource) resource).getPath().         locationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath()).     } else if (resource instanceof ServletContextResource) {         resourcePath = ((ServletContextResource) resource).getPath().         locationPath = StringUtils.cleanPath(((ServletContextResource) location).getPath()).     } else {         resourcePath = resource.getURL().getPath().         locationPath = StringUtils.cleanPath(location.getURL().getPath()).     }     if (locationPath.equals(resourcePath)) {         return true.     }     locationPath = (locationPath.endsWith("/") || locationPath.isEmpty() ? locationPath : locationPath + "/").     return (resourcePath.startsWith(locationPath) && !isInvalidEncodedPath(resourcePath)). }
false;private;3;19;;private String encodeIfNecessary(String path, @Nullable HttpServletRequest request, Resource location) {     if (shouldEncodeRelativePath(location) && request != null) {         Charset charset = this.locationCharsets.getOrDefault(location, StandardCharsets.UTF_8).         StringBuilder sb = new StringBuilder().         StringTokenizer tokenizer = new StringTokenizer(path, "/").         while (tokenizer.hasMoreTokens()) {             String value = UriUtils.encode(tokenizer.nextToken(), charset).             sb.append(value).             sb.append("/").         }         if (!path.endsWith("/")) {             sb.setLength(sb.length() - 1).         }         return sb.toString().     } else {         return path.     } }
false;private;1;3;;private boolean shouldEncodeRelativePath(Resource location) {     return (location instanceof UrlResource && this.urlPathHelper != null && this.urlPathHelper.isUrlDecode()). }
false;private;1;16;;private boolean isInvalidEncodedPath(String resourcePath) {     if (resourcePath.contains("%")) {         // Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...         try {             String decodedPath = URLDecoder.decode(resourcePath, "UTF-8").             if (decodedPath.contains("../") || decodedPath.contains("..\\")) {                 logger.warn("Resolved resource path contains encoded \"../\" or \"..\\\": " + resourcePath).                 return true.             }         } catch (UnsupportedEncodingException ex) {         // Should never happen...         }     }     return false. }
