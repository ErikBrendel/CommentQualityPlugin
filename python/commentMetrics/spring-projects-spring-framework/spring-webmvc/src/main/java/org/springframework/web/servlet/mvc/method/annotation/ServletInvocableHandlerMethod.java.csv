commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Register {@link HandlerMethodReturnValueHandler} instances to use to  * handle return values.  */ ;/**  * Register {@link HandlerMethodReturnValueHandler} instances to use to  * handle return values.  */ public void setHandlerMethodReturnValueHandlers(HandlerMethodReturnValueHandlerComposite returnValueHandlers) {     this.returnValueHandlers = returnValueHandlers. }
true;public;3;30;/**  * Invoke the method and handle the return value through one of the  * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.  * @param webRequest the current request  * @param mavContainer the ModelAndViewContainer for this request  * @param providedArgs "given" arguments matched by type (not resolved)  */ ;/**  * Invoke the method and handle the return value through one of the  * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.  * @param webRequest the current request  * @param mavContainer the ModelAndViewContainer for this request  * @param providedArgs "given" arguments matched by type (not resolved)  */ public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {     Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs).     setResponseStatus(webRequest).     if (returnValue == null) {         if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {             mavContainer.setRequestHandled(true).             return.         }     } else if (StringUtils.hasText(getResponseStatusReason())) {         mavContainer.setRequestHandled(true).         return.     }     mavContainer.setRequestHandled(false).     Assert.state(this.returnValueHandlers != null, "No return value handlers").     try {         this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest).     } catch (Exception ex) {         if (logger.isTraceEnabled()) {             logger.trace(formatErrorForReturnValue(returnValue), ex).         }         throw ex.     } }
true;private;1;20;/**  * Set the response status according to the {@link ResponseStatus} annotation.  */ ;/**  * Set the response status according to the {@link ResponseStatus} annotation.  */ private void setResponseStatus(ServletWebRequest webRequest) throws IOException {     HttpStatus status = getResponseStatus().     if (status == null) {         return.     }     HttpServletResponse response = webRequest.getResponse().     if (response != null) {         String reason = getResponseStatusReason().         if (StringUtils.hasText(reason)) {             response.sendError(status.value(), reason).         } else {             response.setStatus(status.value()).         }     }     // To be picked up by RedirectView     webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, status). }
true;private;1;3;/**  * Does the given request qualify as "not modified"?  * @see ServletWebRequest#checkNotModified(long)  * @see ServletWebRequest#checkNotModified(String)  */ ;/**  * Does the given request qualify as "not modified"?  * @see ServletWebRequest#checkNotModified(long)  * @see ServletWebRequest#checkNotModified(String)  */ private boolean isRequestNotModified(ServletWebRequest webRequest) {     return webRequest.isNotModified(). }
false;private;1;5;;private String formatErrorForReturnValue(@Nullable Object returnValue) {     return "Error handling return value=[" + returnValue + "]" + (returnValue != null ? ", type=" + returnValue.getClass().getName() : "") + " in " + toString(). }
true;;1;3;/**  * Create a nested ServletInvocableHandlerMethod subclass that returns the  * the given value (or raises an Exception if the value is one) rather than  * actually invoking the controller method. This is useful when processing  * async return values (e.g. Callable, DeferredResult, ListenableFuture).  */ ;/**  * Create a nested ServletInvocableHandlerMethod subclass that returns the  * the given value (or raises an Exception if the value is one) rather than  * actually invoking the controller method. This is useful when processing  * async return values (e.g. Callable, DeferredResult, ListenableFuture).  */ ServletInvocableHandlerMethod wrapConcurrentResult(Object result) {     return new ConcurrentResultHandlerMethod(result, new ConcurrentResultMethodParameter(result)). }
true;public;0;4;/**  * Bridge to actual controller type-level annotations.  */ ;/**  * Bridge to actual controller type-level annotations.  */ @Override public Class<?> getBeanType() {     return ServletInvocableHandlerMethod.this.getBeanType(). }
true;public;1;4;/**  * Bridge to actual return value or generic type within the declared  * async return type, e.g. Foo instead of {@code DeferredResult<Foo>}.  */ ;/**  * Bridge to actual return value or generic type within the declared  * async return type, e.g. Foo instead of {@code DeferredResult<Foo>}.  */ @Override public MethodParameter getReturnValueType(@Nullable Object returnValue) {     return this.returnType. }
true;public;1;4;/**  * Bridge to controller method-level annotations.  */ ;/**  * Bridge to controller method-level annotations.  */ @Override public <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {     return ServletInvocableHandlerMethod.this.getMethodAnnotation(annotationType). }
true;public;1;4;/**  * Bridge to controller method-level annotations.  */ ;/**  * Bridge to controller method-level annotations.  */ @Override public <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {     return ServletInvocableHandlerMethod.this.hasMethodAnnotation(annotationType). }
false;public;0;10;;@Override public Class<?> getParameterType() {     if (this.returnValue != null) {         return this.returnValue.getClass().     }     if (!ResolvableType.NONE.equals(this.returnType)) {         return this.returnType.toClass().     }     return super.getParameterType(). }
false;public;0;4;;@Override public Type getGenericParameterType() {     return this.returnType.getType(). }
false;public;1;8;;@Override public <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {     // even if actual return type is ResponseEntity<Flux<T>>     return (super.hasMethodAnnotation(annotationType) || (annotationType == ResponseBody.class && this.returnValue instanceof ReactiveTypeHandler.CollectedValuesList)). }
false;public;0;4;;@Override public ConcurrentResultMethodParameter clone() {     return new ConcurrentResultMethodParameter(this). }
