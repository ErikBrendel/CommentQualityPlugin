commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set a single basename, following {@link java.util.ResourceBundle} conventions.  * The default is "views".  * <p>{@code ResourceBundle} supports different locale suffixes. For example,  * a base name of "views" might map to {@code ResourceBundle} files  * "views", "views_en_au" and "views_de".  * <p>Note that ResourceBundle names are effectively classpath locations: As a  * consequence, the JDK's standard ResourceBundle treats dots as package separators.  * This means that "test.theme" is effectively equivalent to "test/theme",  * just like it is for programmatic {@code java.util.ResourceBundle} usage.  * @see #setBasenames  * @see ResourceBundle#getBundle(String)  * @see ResourceBundle#getBundle(String, Locale)  */ ;/**  * Set a single basename, following {@link java.util.ResourceBundle} conventions.  * The default is "views".  * <p>{@code ResourceBundle} supports different locale suffixes. For example,  * a base name of "views" might map to {@code ResourceBundle} files  * "views", "views_en_au" and "views_de".  * <p>Note that ResourceBundle names are effectively classpath locations: As a  * consequence, the JDK's standard ResourceBundle treats dots as package separators.  * This means that "test.theme" is effectively equivalent to "test/theme",  * just like it is for programmatic {@code java.util.ResourceBundle} usage.  * @see #setBasenames  * @see ResourceBundle#getBundle(String)  * @see ResourceBundle#getBundle(String, Locale)  */ public void setBasename(String basename) {     setBasenames(basename). }
true;public;1;3;/**  * Set an array of basenames, each following {@link java.util.ResourceBundle}  * conventions. The default is a single basename "views".  * <p>{@code ResourceBundle} supports different locale suffixes. For example,  * a base name of "views" might map to {@code ResourceBundle} files  * "views", "views_en_au" and "views_de".  * <p>The associated resource bundles will be checked sequentially when resolving  * a message code. Note that message definitions in a <i>previous</i> resource  * bundle will override ones in a later bundle, due to the sequential lookup.  * <p>Note that ResourceBundle names are effectively classpath locations: As a  * consequence, the JDK's standard ResourceBundle treats dots as package separators.  * This means that "test.theme" is effectively equivalent to "test/theme",  * just like it is for programmatic {@code java.util.ResourceBundle} usage.  * @see #setBasename  * @see ResourceBundle#getBundle(String)  * @see ResourceBundle#getBundle(String, Locale)  */ ;/**  * Set an array of basenames, each following {@link java.util.ResourceBundle}  * conventions. The default is a single basename "views".  * <p>{@code ResourceBundle} supports different locale suffixes. For example,  * a base name of "views" might map to {@code ResourceBundle} files  * "views", "views_en_au" and "views_de".  * <p>The associated resource bundles will be checked sequentially when resolving  * a message code. Note that message definitions in a <i>previous</i> resource  * bundle will override ones in a later bundle, due to the sequential lookup.  * <p>Note that ResourceBundle names are effectively classpath locations: As a  * consequence, the JDK's standard ResourceBundle treats dots as package separators.  * This means that "test.theme" is effectively equivalent to "test/theme",  * just like it is for programmatic {@code java.util.ResourceBundle} usage.  * @see #setBasename  * @see ResourceBundle#getBundle(String)  * @see ResourceBundle#getBundle(String, Locale)  */ public void setBasenames(String... basenames) {     this.basenames = basenames. }
true;public;1;3;/**  * Set the {@link ClassLoader} to load resource bundles with.  * Default is the thread context {@code ClassLoader}.  */ ;/**  * Set the {@link ClassLoader} to load resource bundles with.  * Default is the thread context {@code ClassLoader}.  */ public void setBundleClassLoader(ClassLoader classLoader) {     this.bundleClassLoader = classLoader. }
true;protected;0;3;/**  * Return the {@link ClassLoader} to load resource bundles with.  * <p>Default is the specified bundle {@code ClassLoader},  * usually the thread context {@code ClassLoader}.  */ ;/**  * Return the {@link ClassLoader} to load resource bundles with.  * <p>Default is the specified bundle {@code ClassLoader},  * usually the thread context {@code ClassLoader}.  */ protected ClassLoader getBundleClassLoader() {     return this.bundleClassLoader. }
true;public;1;3;/**  * Set the default parent for views defined in the {@code ResourceBundle}.  * <p>This avoids repeated "yyy1.(parent)=xxx", "yyy2.(parent)=xxx" definitions  * in the bundle, especially if all defined views share the same parent.  * <p>The parent will typically define the view class and common attributes.  * Concrete views might simply consist of an URL definition then:  * a la "yyy1.url=/my.jsp", "yyy2.url=/your.jsp".  * <p>View definitions that define their own parent or carry their own  * class can still override this. Strictly speaking, the rule that a  * default parent setting does not apply to a bean definition that  * carries a class is there for backwards compatibility reasons.  * It still matches the typical use case.  */ ;/**  * Set the default parent for views defined in the {@code ResourceBundle}.  * <p>This avoids repeated "yyy1.(parent)=xxx", "yyy2.(parent)=xxx" definitions  * in the bundle, especially if all defined views share the same parent.  * <p>The parent will typically define the view class and common attributes.  * Concrete views might simply consist of an URL definition then:  * a la "yyy1.url=/my.jsp", "yyy2.url=/your.jsp".  * <p>View definitions that define their own parent or carry their own  * class can still override this. Strictly speaking, the rule that a  * default parent setting does not apply to a bean definition that  * carries a class is there for backwards compatibility reasons.  * It still matches the typical use case.  */ public void setDefaultParentView(String defaultParentView) {     this.defaultParentView = defaultParentView. }
true;public;1;3;/**  * Specify Locales to initialize eagerly, rather than lazily when actually accessed.  * <p>Allows for pre-initialization of common Locales, eagerly checking  * the view configuration for those Locales.  */ ;/**  * Specify Locales to initialize eagerly, rather than lazily when actually accessed.  * <p>Allows for pre-initialization of common Locales, eagerly checking  * the view configuration for those Locales.  */ public void setLocalesToInitialize(Locale... localesToInitialize) {     this.localesToInitialize = localesToInitialize. }
true;public;1;3;/**  * Specify the order value for this ViewResolver bean.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @see org.springframework.core.Ordered#getOrder()  */ ;/**  * Specify the order value for this ViewResolver bean.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @see org.springframework.core.Ordered#getOrder()  */ public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
true;public;0;8;/**  * Eagerly initialize Locales if necessary.  * @see #setLocalesToInitialize  */ ;/**  * Eagerly initialize Locales if necessary.  * @see #setLocalesToInitialize  */ @Override public void afterPropertiesSet() throws BeansException {     if (this.localesToInitialize != null) {         for (Locale locale : this.localesToInitialize) {             initFactory(locale).         }     } }
false;protected;2;11;;@Override protected View loadView(String viewName, Locale locale) throws Exception {     BeanFactory factory = initFactory(locale).     try {         return factory.getBean(viewName, View.class).     } catch (NoSuchBeanDefinitionException ex) {         // Allow for ViewResolver chaining...         return null.     } }
true;protected,synchronized;1;49;/**  * Initialize the View {@link BeanFactory} from the {@code ResourceBundle},  * for the given {@link Locale locale}.  * <p>Synchronized because of access by parallel threads.  * @param locale the target {@code Locale}  * @return the View factory for the given Locale  * @throws BeansException in case of initialization errors  */ ;/**  * Initialize the View {@link BeanFactory} from the {@code ResourceBundle},  * for the given {@link Locale locale}.  * <p>Synchronized because of access by parallel threads.  * @param locale the target {@code Locale}  * @return the View factory for the given Locale  * @throws BeansException in case of initialization errors  */ protected synchronized BeanFactory initFactory(Locale locale) throws BeansException {     // Have we already encountered that Locale before?     if (isCache()) {         BeanFactory cachedFactory = this.localeCache.get(locale).         if (cachedFactory != null) {             return cachedFactory.         }     }     // Build list of ResourceBundle references for Locale.     List<ResourceBundle> bundles = new LinkedList<>().     for (String basename : this.basenames) {         ResourceBundle bundle = getBundle(basename, locale).         bundles.add(bundle).     }     // even if Locale was different, same bundles might have been found.     if (isCache()) {         BeanFactory cachedFactory = this.bundleCache.get(bundles).         if (cachedFactory != null) {             this.localeCache.put(locale, cachedFactory).             return cachedFactory.         }     }     // Create child ApplicationContext for views.     GenericWebApplicationContext factory = new GenericWebApplicationContext().     factory.setParent(getApplicationContext()).     factory.setServletContext(getServletContext()).     // Load bean definitions from resource bundle.     PropertiesBeanDefinitionReader reader = new PropertiesBeanDefinitionReader(factory).     reader.setDefaultParentBean(this.defaultParentView).     for (ResourceBundle bundle : bundles) {         reader.registerBeanDefinitions(bundle).     }     factory.refresh().     // Cache factory for both Locale and ResourceBundle list.     if (isCache()) {         this.localeCache.put(locale, factory).         this.bundleCache.put(bundles, factory).     }     return factory. }
true;protected;2;3;/**  * Obtain the resource bundle for the given basename and {@link Locale}.  * @param basename the basename to look for  * @param locale the {@code Locale} to look for  * @return the corresponding {@code ResourceBundle}  * @throws MissingResourceException if no matching bundle could be found  * @see ResourceBundle#getBundle(String, Locale, ClassLoader)  */ ;/**  * Obtain the resource bundle for the given basename and {@link Locale}.  * @param basename the basename to look for  * @param locale the {@code Locale} to look for  * @return the corresponding {@code ResourceBundle}  * @throws MissingResourceException if no matching bundle could be found  * @see ResourceBundle#getBundle(String, Locale, ClassLoader)  */ protected ResourceBundle getBundle(String basename, Locale locale) throws MissingResourceException {     return ResourceBundle.getBundle(basename, locale, getBundleClassLoader()). }
true;public;0;8;/**  * Close the bundle View factories on context shutdown.  */ ;/**  * Close the bundle View factories on context shutdown.  */ @Override public void destroy() throws BeansException {     for (ConfigurableApplicationContext factory : this.bundleCache.values()) {         factory.close().     }     this.localeCache.clear().     this.bundleCache.clear(). }
