commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify whether to always include the view rather than forward to it.  * <p>Default is "false". Switch this flag on to enforce the use of a  * Servlet include, even if a forward would be possible.  * @see javax.servlet.RequestDispatcher#forward  * @see javax.servlet.RequestDispatcher#include  * @see #useInclude(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)  */ ;/**  * Specify whether to always include the view rather than forward to it.  * <p>Default is "false". Switch this flag on to enforce the use of a  * Servlet include, even if a forward would be possible.  * @see javax.servlet.RequestDispatcher#forward  * @see javax.servlet.RequestDispatcher#include  * @see #useInclude(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)  */ public void setAlwaysInclude(boolean alwaysInclude) {     this.alwaysInclude = alwaysInclude. }
true;public;1;3;/**  * Set whether to explicitly prevent dispatching back to the  * current handler path.  * <p>Default is "false". Switch this to "true" for convention-based  * views where a dispatch back to the current handler path is a  * definitive error.  */ ;/**  * Set whether to explicitly prevent dispatching back to the  * current handler path.  * <p>Default is "false". Switch this to "true" for convention-based  * views where a dispatch back to the current handler path is a  * definitive error.  */ public void setPreventDispatchLoop(boolean preventDispatchLoop) {     this.preventDispatchLoop = preventDispatchLoop. }
true;protected;0;4;/**  * An ApplicationContext is not strictly required for InternalResourceView.  */ ;/**  * An ApplicationContext is not strictly required for InternalResourceView.  */ @Override protected boolean isContextRequired() {     return false. }
true;protected;3;37;/**  * Render the internal resource given the specified model.  * This includes setting the model as request attributes.  */ ;/**  * Render the internal resource given the specified model.  * This includes setting the model as request attributes.  */ @Override protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {     // Expose the model object as request attributes.     exposeModelAsRequestAttributes(model, request).     // Expose helpers as request attributes, if any.     exposeHelpers(request).     // Determine the path for the request dispatcher.     String dispatcherPath = prepareForRendering(request, response).     // Obtain a RequestDispatcher for the target resource (typically a JSP).     RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath).     if (rd == null) {         throw new ServletException("Could not get RequestDispatcher for [" + getUrl() + "]: Check that the corresponding file exists within your web application archive!").     }     // If already included or response already committed, perform include, else forward.     if (useInclude(request, response)) {         response.setContentType(getContentType()).         if (logger.isDebugEnabled()) {             logger.debug("Including [" + getUrl() + "]").         }         rd.include(request, response).     } else {         // Note: The forwarded resource is supposed to determine the content type itself.         if (logger.isDebugEnabled()) {             logger.debug("Forwarding to [" + getUrl() + "]").         }         rd.forward(request, response).     } }
true;protected;1;2;/**  * Expose helpers unique to each rendering operation. This is necessary so that  * different rendering operations can't overwrite each other's contexts etc.  * <p>Called by {@link #renderMergedOutputModel(Map, HttpServletRequest, HttpServletResponse)}.  * The default implementation is empty. This method can be overridden to add  * custom helpers as request attributes.  * @param request current HTTP request  * @throws Exception if there's a fatal error while we're adding attributes  * @see #renderMergedOutputModel  * @see JstlView#exposeHelpers  */ ;/**  * Expose helpers unique to each rendering operation. This is necessary so that  * different rendering operations can't overwrite each other's contexts etc.  * <p>Called by {@link #renderMergedOutputModel(Map, HttpServletRequest, HttpServletResponse)}.  * The default implementation is empty. This method can be overridden to add  * custom helpers as request attributes.  * @param request current HTTP request  * @throws Exception if there's a fatal error while we're adding attributes  * @see #renderMergedOutputModel  * @see JstlView#exposeHelpers  */ protected void exposeHelpers(HttpServletRequest request) throws Exception { }
true;protected;2;16;/**  * Prepare for rendering, and determine the request dispatcher path  * to forward to (or to include).  * <p>This implementation simply returns the configured URL.  * Subclasses can override this to determine a resource to render,  * typically interpreting the URL in a different manner.  * @param request current HTTP request  * @param response current HTTP response  * @return the request dispatcher path to use  * @throws Exception if preparations failed  * @see #getUrl()  */ ;/**  * Prepare for rendering, and determine the request dispatcher path  * to forward to (or to include).  * <p>This implementation simply returns the configured URL.  * Subclasses can override this to determine a resource to render,  * typically interpreting the URL in a different manner.  * @param request current HTTP request  * @param response current HTTP response  * @return the request dispatcher path to use  * @throws Exception if preparations failed  * @see #getUrl()  */ protected String prepareForRendering(HttpServletRequest request, HttpServletResponse response) throws Exception {     String path = getUrl().     Assert.state(path != null, "'url' not set").     if (this.preventDispatchLoop) {         String uri = request.getRequestURI().         if (path.startsWith("/") ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) {             throw new ServletException("Circular view path [" + path + "]: would dispatch back " + "to the current handler URL [" + uri + "] again. Check your ViewResolver setup! " + "(Hint: This may be the result of an unspecified view, due to default view name generation.)").         }     }     return path. }
true;protected;2;4;/**  * Obtain the RequestDispatcher to use for the forward/include.  * <p>The default implementation simply calls  * {@link HttpServletRequest#getRequestDispatcher(String)}.  * Can be overridden in subclasses.  * @param request current HTTP request  * @param path the target URL (as returned from {@link #prepareForRendering})  * @return a corresponding RequestDispatcher  */ ;/**  * Obtain the RequestDispatcher to use for the forward/include.  * <p>The default implementation simply calls  * {@link HttpServletRequest#getRequestDispatcher(String)}.  * Can be overridden in subclasses.  * @param request current HTTP request  * @param path the target URL (as returned from {@link #prepareForRendering})  * @return a corresponding RequestDispatcher  */ @Nullable protected RequestDispatcher getRequestDispatcher(HttpServletRequest request, String path) {     return request.getRequestDispatcher(path). }
true;protected;2;3;/**  * Determine whether to use RequestDispatcher's {@code include} or  * {@code forward} method.  * <p>Performs a check whether an include URI attribute is found in the request,  * indicating an include request, and whether the response has already been committed.  * In both cases, an include will be performed, as a forward is not possible anymore.  * @param request current HTTP request  * @param response current HTTP response  * @return {@code true} for include, {@code false} for forward  * @see javax.servlet.RequestDispatcher#forward  * @see javax.servlet.RequestDispatcher#include  * @see javax.servlet.ServletResponse#isCommitted  * @see org.springframework.web.util.WebUtils#isIncludeRequest  */ ;/**  * Determine whether to use RequestDispatcher's {@code include} or  * {@code forward} method.  * <p>Performs a check whether an include URI attribute is found in the request,  * indicating an include request, and whether the response has already been committed.  * In both cases, an include will be performed, as a forward is not possible anymore.  * @param request current HTTP request  * @param response current HTTP response  * @return {@code true} for include, {@code false} for forward  * @see javax.servlet.RequestDispatcher#forward  * @see javax.servlet.RequestDispatcher#include  * @see javax.servlet.ServletResponse#isCommitted  * @see org.springframework.web.util.WebUtils#isIncludeRequest  */ protected boolean useInclude(HttpServletRequest request, HttpServletResponse response) {     return (this.alwaysInclude || WebUtils.isIncludeRequest(request) || response.isCommitted()). }
