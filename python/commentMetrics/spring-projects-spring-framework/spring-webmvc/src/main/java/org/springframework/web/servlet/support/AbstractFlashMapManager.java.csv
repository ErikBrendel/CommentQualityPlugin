commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the amount of time in seconds after a {@link FlashMap} is saved  * (at request completion) and before it expires.  * <p>The default value is 180 seconds.  */ ;/**  * Set the amount of time in seconds after a {@link FlashMap} is saved  * (at request completion) and before it expires.  * <p>The default value is 180 seconds.  */ public void setFlashMapTimeout(int flashMapTimeout) {     this.flashMapTimeout = flashMapTimeout. }
true;public;0;3;/**  * Return the amount of time in seconds before a FlashMap expires.  */ ;/**  * Return the amount of time in seconds before a FlashMap expires.  */ public int getFlashMapTimeout() {     return this.flashMapTimeout. }
true;public;1;4;/**  * Set the UrlPathHelper to use to match FlashMap instances to requests.  */ ;/**  * Set the UrlPathHelper to use to match FlashMap instances to requests.  */ public void setUrlPathHelper(UrlPathHelper urlPathHelper) {     Assert.notNull(urlPathHelper, "UrlPathHelper must not be null").     this.urlPathHelper = urlPathHelper. }
true;public;0;3;/**  * Return the UrlPathHelper implementation to use.  */ ;/**  * Return the UrlPathHelper implementation to use.  */ public UrlPathHelper getUrlPathHelper() {     return this.urlPathHelper. }
false;public,final;2;33;;@Override @Nullable public final FlashMap retrieveAndUpdate(HttpServletRequest request, HttpServletResponse response) {     List<FlashMap> allFlashMaps = retrieveFlashMaps(request).     if (CollectionUtils.isEmpty(allFlashMaps)) {         return null.     }     List<FlashMap> mapsToRemove = getExpiredFlashMaps(allFlashMaps).     FlashMap match = getMatchingFlashMap(allFlashMaps, request).     if (match != null) {         mapsToRemove.add(match).     }     if (!mapsToRemove.isEmpty()) {         Object mutex = getFlashMapsMutex(request).         if (mutex != null) {             synchronized (mutex) {                 allFlashMaps = retrieveFlashMaps(request).                 if (allFlashMaps != null) {                     allFlashMaps.removeAll(mapsToRemove).                     updateFlashMaps(allFlashMaps, request, response).                 }             }         } else {             allFlashMaps.removeAll(mapsToRemove).             updateFlashMaps(allFlashMaps, request, response).         }     }     return match. }
true;private;1;9;/**  * Return a list of expired FlashMap instances contained in the given list.  */ ;/**  * Return a list of expired FlashMap instances contained in the given list.  */ private List<FlashMap> getExpiredFlashMaps(List<FlashMap> allMaps) {     List<FlashMap> result = new LinkedList<>().     for (FlashMap map : allMaps) {         if (map.isExpired()) {             result.add(map).         }     }     return result. }
true;private;2;17;/**  * Return a FlashMap contained in the given list that matches the request.  * @return a matching FlashMap or {@code null}  */ ;/**  * Return a FlashMap contained in the given list that matches the request.  * @return a matching FlashMap or {@code null}  */ @Nullable private FlashMap getMatchingFlashMap(List<FlashMap> allMaps, HttpServletRequest request) {     List<FlashMap> result = new LinkedList<>().     for (FlashMap flashMap : allMaps) {         if (isFlashMapForRequest(flashMap, request)) {             result.add(flashMap).         }     }     if (!result.isEmpty()) {         Collections.sort(result).         if (logger.isTraceEnabled()) {             logger.trace("Found " + result.get(0)).         }         return result.get(0).     }     return null. }
true;protected;2;23;/**  * Whether the given FlashMap matches the current request.  * Uses the expected request path and query parameters saved in the FlashMap.  */ ;/**  * Whether the given FlashMap matches the current request.  * Uses the expected request path and query parameters saved in the FlashMap.  */ protected boolean isFlashMapForRequest(FlashMap flashMap, HttpServletRequest request) {     String expectedPath = flashMap.getTargetRequestPath().     if (expectedPath != null) {         String requestUri = getUrlPathHelper().getOriginatingRequestUri(request).         if (!requestUri.equals(expectedPath) && !requestUri.equals(expectedPath + "/")) {             return false.         }     }     MultiValueMap<String, String> actualParams = getOriginatingRequestParams(request).     MultiValueMap<String, String> expectedParams = flashMap.getTargetRequestParams().     for (String expectedName : expectedParams.keySet()) {         List<String> actualValues = actualParams.get(expectedName).         if (actualValues == null) {             return false.         }         for (String expectedValue : expectedParams.get(expectedName)) {             if (!actualValues.contains(expectedValue)) {                 return false.             }         }     }     return true. }
false;private;1;4;;private MultiValueMap<String, String> getOriginatingRequestParams(HttpServletRequest request) {     String query = getUrlPathHelper().getOriginatingQueryString(request).     return ServletUriComponentsBuilder.fromPath("/").query(query).build().getQueryParams(). }
false;public,final;3;27;;@Override public final void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response) {     if (CollectionUtils.isEmpty(flashMap)) {         return.     }     String path = decodeAndNormalizePath(flashMap.getTargetRequestPath(), request).     flashMap.setTargetRequestPath(path).     flashMap.startExpirationPeriod(getFlashMapTimeout()).     Object mutex = getFlashMapsMutex(request).     if (mutex != null) {         synchronized (mutex) {             List<FlashMap> allFlashMaps = retrieveFlashMaps(request).             allFlashMaps = (allFlashMaps != null ? allFlashMaps : new CopyOnWriteArrayList<>()).             allFlashMaps.add(flashMap).             updateFlashMaps(allFlashMaps, request, response).         }     } else {         List<FlashMap> allFlashMaps = retrieveFlashMaps(request).         allFlashMaps = (allFlashMaps != null ? allFlashMaps : new LinkedList<>()).         allFlashMaps.add(flashMap).         updateFlashMaps(allFlashMaps, request, response).     } }
false;private;2;12;;@Nullable private String decodeAndNormalizePath(@Nullable String path, HttpServletRequest request) {     if (path != null) {         path = getUrlPathHelper().decodeRequestString(request, path).         if (path.charAt(0) != '/') {             String requestUri = getUrlPathHelper().getRequestUri(request).             path = requestUri.substring(0, requestUri.lastIndexOf('/') + 1) + path.             path = StringUtils.cleanPath(path).         }     }     return path. }
true;protected,abstract;1;2;/**  * Retrieve saved FlashMap instances from the underlying storage.  * @param request the current request  * @return a List with FlashMap instances, or {@code null} if none found  */ ;/**  * Retrieve saved FlashMap instances from the underlying storage.  * @param request the current request  * @return a List with FlashMap instances, or {@code null} if none found  */ @Nullable protected abstract List<FlashMap> retrieveFlashMaps(HttpServletRequest request).
true;protected,abstract;3;2;/**  * Update the FlashMap instances in the underlying storage.  * @param flashMaps a (potentially empty) list of FlashMap instances to save  * @param request the current request  * @param response the current response  */ ;/**  * Update the FlashMap instances in the underlying storage.  * @param flashMaps a (potentially empty) list of FlashMap instances to save  * @param request the current request  * @param response the current response  */ protected abstract void updateFlashMaps(List<FlashMap> flashMaps, HttpServletRequest request, HttpServletResponse response).
true;protected;1;4;/**  * Obtain a mutex for modifying the FlashMap List as handled by  * {@link #retrieveFlashMaps} and {@link #updateFlashMaps},  * <p>The default implementation returns a shared static mutex.  * Subclasses are encouraged to return a more specific mutex, or  * {@code null} to indicate that no synchronization is necessary.  * @param request the current request  * @return the mutex to use (may be {@code null} if none applicable)  * @since 4.0.3  */ ;/**  * Obtain a mutex for modifying the FlashMap List as handled by  * {@link #retrieveFlashMaps} and {@link #updateFlashMaps},  * <p>The default implementation returns a shared static mutex.  * Subclasses are encouraged to return a more specific mutex, or  * {@code null} to indicate that no synchronization is necessary.  * @param request the current request  * @return the mutex to use (may be {@code null} if none applicable)  * @since 4.0.3  */ @Nullable protected Object getFlashMapsMutex(HttpServletRequest request) {     return DEFAULT_FLASH_MAPS_MUTEX. }
