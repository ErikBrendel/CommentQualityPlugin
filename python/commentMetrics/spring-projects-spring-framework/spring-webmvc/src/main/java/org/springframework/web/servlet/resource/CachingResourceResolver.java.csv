commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@code Cache}.  */ ;/**  * Return the configured {@code Cache}.  */ public Cache getCache() {     return this.cache. }
true;public;1;5;/**  * Configure the supported content codings from the  * {@literal "Accept-Encoding"} header for which to cache resource variations.  * <p>The codings configured here are generally expected to match those  * configured on {@link EncodedResourceResolver#setContentCodings(List)}.  * <p>By default this property is set to {@literal ["br", "gzip"]} based on  * the value of {@link EncodedResourceResolver#DEFAULT_CODINGS}.  * @param codings one or more supported content codings  * @since 5.1  */ ;/**  * Configure the supported content codings from the  * {@literal "Accept-Encoding"} header for which to cache resource variations.  * <p>The codings configured here are generally expected to match those  * configured on {@link EncodedResourceResolver#setContentCodings(List)}.  * <p>By default this property is set to {@literal ["br", "gzip"]} based on  * the value of {@link EncodedResourceResolver#DEFAULT_CODINGS}.  * @param codings one or more supported content codings  * @since 5.1  */ public void setContentCodings(List<String> codings) {     Assert.notEmpty(codings, "At least one content coding expected").     this.contentCodings.clear().     this.contentCodings.addAll(codings). }
true;public;0;3;/**  * Return a read-only list with the supported content codings.  * @since 5.1  */ ;/**  * Return a read-only list with the supported content codings.  * @since 5.1  */ public List<String> getContentCodings() {     return Collections.unmodifiableList(this.contentCodings). }
false;protected;4;21;;@Override protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {     String key = computeKey(request, requestPath).     Resource resource = this.cache.get(key, Resource.class).     if (resource != null) {         if (logger.isTraceEnabled()) {             logger.trace("Resource resolved from cache").         }         return resource.     }     resource = chain.resolveResource(request, requestPath, locations).     if (resource != null) {         this.cache.put(key, resource).     }     return resource. }
false;protected;2;11;;protected String computeKey(@Nullable HttpServletRequest request, String requestPath) {     StringBuilder key = new StringBuilder(RESOLVED_RESOURCE_CACHE_KEY_PREFIX).     key.append(requestPath).     if (request != null) {         String codingKey = getContentCodingKey(request).         if (StringUtils.hasText(codingKey)) {             key.append("+encoding=").append(codingKey).         }     }     return key.toString(). }
false;private;1;15;;@Nullable private String getContentCodingKey(HttpServletRequest request) {     String header = request.getHeader(HttpHeaders.ACCEPT_ENCODING).     if (!StringUtils.hasText(header)) {         return null.     }     return Arrays.stream(StringUtils.tokenizeToStringArray(header, ",")).map(token -> {         int index = token.indexOf('.').         return (index >= 0 ? token.substring(0, index) : token).trim().toLowerCase().     }).filter(this.contentCodings::contains).sorted().collect(Collectors.joining(",")). }
false;protected;3;21;;@Override protected String resolveUrlPathInternal(String resourceUrlPath, List<? extends Resource> locations, ResourceResolverChain chain) {     String key = RESOLVED_URL_PATH_CACHE_KEY_PREFIX + resourceUrlPath.     String resolvedUrlPath = this.cache.get(key, String.class).     if (resolvedUrlPath != null) {         if (logger.isTraceEnabled()) {             logger.trace("Path resolved from cache").         }         return resolvedUrlPath.     }     resolvedUrlPath = chain.resolveUrlPath(resourceUrlPath, locations).     if (resolvedUrlPath != null) {         this.cache.put(key, resolvedUrlPath).     }     return resolvedUrlPath. }
