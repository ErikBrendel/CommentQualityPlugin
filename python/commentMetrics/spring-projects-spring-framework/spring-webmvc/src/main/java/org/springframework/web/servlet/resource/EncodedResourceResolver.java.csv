commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Configure the supported content codings in order of preference. The first  * coding that is present in the {@literal "Accept-Encoding"} header for a  * given request, and that has a file present with the associated extension,  * is used.  * <p><strong>Note:</strong> Each coding must be associated with a file  * extension via {@link #registerExtension} or {@link #setExtensions}. Also  * customizations to the list of codings here should be matched by  * customizations to the same list in {@link CachingResourceResolver} to  * ensure encoded variants of a resource are cached under separate keys.  * <p>By default this property is set to {@literal ["br", "gzip"]}.  * @param codings one or more supported content codings  */ ;/**  * Configure the supported content codings in order of preference. The first  * coding that is present in the {@literal "Accept-Encoding"} header for a  * given request, and that has a file present with the associated extension,  * is used.  * <p><strong>Note:</strong> Each coding must be associated with a file  * extension via {@link #registerExtension} or {@link #setExtensions}. Also  * customizations to the list of codings here should be matched by  * customizations to the same list in {@link CachingResourceResolver} to  * ensure encoded variants of a resource are cached under separate keys.  * <p>By default this property is set to {@literal ["br", "gzip"]}.  * @param codings one or more supported content codings  */ public void setContentCodings(List<String> codings) {     Assert.notEmpty(codings, "At least one content coding expected").     this.contentCodings.clear().     this.contentCodings.addAll(codings). }
true;public;0;3;/**  * Return a read-only list with the supported content codings.  */ ;/**  * Return a read-only list with the supported content codings.  */ public List<String> getContentCodings() {     return Collections.unmodifiableList(this.contentCodings). }
true;public;1;3;/**  * Configure mappings from content codings to file extensions. A dot "."  * will be prepended in front of the extension value if not present.  * <p>By default this is configured with {@literal ["br" -> ".br"]} and  * {@literal ["gzip" -> ".gz"]}.  * @param extensions the extensions to use.  * @see #registerExtension(String, String)  */ ;/**  * Configure mappings from content codings to file extensions. A dot "."  * will be prepended in front of the extension value if not present.  * <p>By default this is configured with {@literal ["br" -> ".br"]} and  * {@literal ["gzip" -> ".gz"]}.  * @param extensions the extensions to use.  * @see #registerExtension(String, String)  */ public void setExtensions(Map<String, String> extensions) {     extensions.forEach(this::registerExtension). }
true;public;0;3;/**  * Return a read-only map with coding-to-extension mappings.  */ ;/**  * Return a read-only map with coding-to-extension mappings.  */ public Map<String, String> getExtensions() {     return Collections.unmodifiableMap(this.extensions). }
true;public;2;3;/**  * Java config friendly alternative to {@link #setExtensions(Map)}.  * @param coding the content coding  * @param extension the associated file extension  */ ;/**  * Java config friendly alternative to {@link #setExtensions(Map)}.  * @param coding the content coding  * @param extension the associated file extension  */ public void registerExtension(String coding, String extension) {     this.extensions.put(coding, (extension.startsWith(".") ? extension : "." + extension)). }
false;protected;4;33;;@Override protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {     Resource resource = chain.resolveResource(request, requestPath, locations).     if (resource == null || request == null) {         return resource.     }     String acceptEncoding = getAcceptEncoding(request).     if (acceptEncoding == null) {         return resource.     }     for (String coding : this.contentCodings) {         if (acceptEncoding.contains(coding)) {             try {                 String extension = getExtension(coding).                 Resource encoded = new EncodedResource(resource, coding, extension).                 if (encoded.exists()) {                     return encoded.                 }             } catch (IOException ex) {                 if (logger.isTraceEnabled()) {                     logger.trace("No " + coding + " resource for [" + resource.getFilename() + "]", ex).                 }             }         }     }     return resource. }
false;private;1;5;;@Nullable private String getAcceptEncoding(HttpServletRequest request) {     String header = request.getHeader(HttpHeaders.ACCEPT_ENCODING).     return (header != null ? header.toLowerCase() : null). }
false;private;1;5;;private String getExtension(String coding) {     String extension = this.extensions.get(coding).     Assert.state(extension != null, () -> "No file extension associated with content coding " + coding).     return extension. }
false;protected;3;6;;@Override protected String resolveUrlPathInternal(String resourceUrlPath, List<? extends Resource> locations, ResourceResolverChain chain) {     return chain.resolveUrlPath(resourceUrlPath, locations). }
false;public;0;4;;@Override public InputStream getInputStream() throws IOException {     return this.encoded.getInputStream(). }
false;public;0;4;;@Override public boolean exists() {     return this.encoded.exists(). }
false;public;0;4;;@Override public boolean isReadable() {     return this.encoded.isReadable(). }
false;public;0;4;;@Override public boolean isOpen() {     return this.encoded.isOpen(). }
false;public;0;4;;@Override public boolean isFile() {     return this.encoded.isFile(). }
false;public;0;4;;@Override public URL getURL() throws IOException {     return this.encoded.getURL(). }
false;public;0;4;;@Override public URI getURI() throws IOException {     return this.encoded.getURI(). }
false;public;0;4;;@Override public File getFile() throws IOException {     return this.encoded.getFile(). }
false;public;0;4;;@Override public long contentLength() throws IOException {     return this.encoded.contentLength(). }
false;public;0;4;;@Override public long lastModified() throws IOException {     return this.encoded.lastModified(). }
false;public;1;4;;@Override public Resource createRelative(String relativePath) throws IOException {     return this.encoded.createRelative(relativePath). }
false;public;0;5;;@Override @Nullable public String getFilename() {     return this.original.getFilename(). }
false;public;0;4;;@Override public String getDescription() {     return this.encoded.getDescription(). }
false;public;0;13;;@Override public HttpHeaders getResponseHeaders() {     HttpHeaders headers.     if (this.original instanceof HttpResource) {         headers = ((HttpResource) this.original).getResponseHeaders().     } else {         headers = new HttpHeaders().     }     headers.add(HttpHeaders.CONTENT_ENCODING, this.coding).     headers.add(HttpHeaders.VARY, HttpHeaders.ACCEPT_ENCODING).     return headers. }
