commented;modifiers;parameterAmount;loc;comment;code
false;private;2;17;;private Set<ProduceMediaTypeExpression> parseExpressions(String[] produces, @Nullable String[] headers) {     Set<ProduceMediaTypeExpression> result = new LinkedHashSet<>().     if (headers != null) {         for (String header : headers) {             HeaderExpression expr = new HeaderExpression(header).             if ("Accept".equalsIgnoreCase(expr.name) && expr.value != null) {                 for (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {                     result.add(new ProduceMediaTypeExpression(mediaType, expr.isNegated)).                 }             }         }     }     for (String produce : produces) {         result.add(new ProduceMediaTypeExpression(produce)).     }     return result. }
true;public;0;3;/**  * Return the contained "produces" expressions.  */ ;/**  * Return the contained "produces" expressions.  */ public Set<MediaTypeExpression> getExpressions() {     return new LinkedHashSet<>(this.expressions). }
true;public;0;9;/**  * Return the contained producible media types excluding negated expressions.  */ ;/**  * Return the contained producible media types excluding negated expressions.  */ public Set<MediaType> getProducibleMediaTypes() {     Set<MediaType> result = new LinkedHashSet<>().     for (ProduceMediaTypeExpression expression : this.expressions) {         if (!expression.isNegated()) {             result.add(expression.getMediaType()).         }     }     return result. }
true;public;0;4;/**  * Whether the condition has any media type expressions.  */ ;/**  * Whether the condition has any media type expressions.  */ @Override public boolean isEmpty() {     return this.expressions.isEmpty(). }
false;protected;0;4;;@Override protected List<ProduceMediaTypeExpression> getContent() {     return this.expressions. }
false;protected;0;4;;@Override protected String getToStringInfix() {     return " || ". }
true;public;1;4;/**  * Returns the "other" instance if it has any expressions. returns "this"  * instance otherwise. Practically that means a method-level "produces"  * overrides a type-level "produces" condition.  */ ;/**  * Returns the "other" instance if it has any expressions. returns "this"  * instance otherwise. Practically that means a method-level "produces"  * overrides a type-level "produces" condition.  */ @Override public ProducesRequestCondition combine(ProducesRequestCondition other) {     return (!other.expressions.isEmpty() ? other : this). }
true;public;1;30;/**  * Checks if any of the contained media type expressions match the given  * request 'Content-Type' header and returns an instance that is guaranteed  * to contain matching expressions only. The match is performed via  * {@link MediaType#isCompatibleWith(MediaType)}.  * @param request the current request  * @return the same instance if there are no expressions.  * or a new condition with matching expressions.  * or {@code null} if no expressions match.  */ ;/**  * Checks if any of the contained media type expressions match the given  * request 'Content-Type' header and returns an instance that is guaranteed  * to contain matching expressions only. The match is performed via  * {@link MediaType#isCompatibleWith(MediaType)}.  * @param request the current request  * @return the same instance if there are no expressions.  * or a new condition with matching expressions.  * or {@code null} if no expressions match.  */ @Override @Nullable public ProducesRequestCondition getMatchingCondition(HttpServletRequest request) {     if (CorsUtils.isPreFlightRequest(request)) {         return PRE_FLIGHT_MATCH.     }     if (isEmpty()) {         return this.     }     List<MediaType> acceptedMediaTypes.     try {         acceptedMediaTypes = getAcceptedMediaTypes(request).     } catch (HttpMediaTypeException ex) {         return null.     }     Set<ProduceMediaTypeExpression> result = new LinkedHashSet<>(this.expressions).     result.removeIf(expression -> !expression.match(acceptedMediaTypes)).     if (!result.isEmpty()) {         return new ProducesRequestCondition(result, this.contentNegotiationManager).     } else if (MediaType.ALL.isPresentIn(acceptedMediaTypes)) {         return EMPTY_CONDITION.     } else {         return null.     } }
true;public;2;25;/**  * Compares this and another "produces" condition as follows:  * <ol>  * <li>Sort 'Accept' header media types by quality value via  * {@link MediaType#sortByQualityValue(List)} and iterate the list.  * <li>Get the first index of matching media types in each "produces"  * condition first matching with {@link MediaType#equals(Object)} and  * then with {@link MediaType#includes(MediaType)}.  * <li>If a lower index is found, the condition at that index wins.  * <li>If both indexes are equal, the media types at the index are  * compared further with {@link MediaType#SPECIFICITY_COMPARATOR}.  * </ol>  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(HttpServletRequest)} and each instance  * contains the matching producible media type expression only or  * is otherwise empty.  */ ;/**  * Compares this and another "produces" condition as follows:  * <ol>  * <li>Sort 'Accept' header media types by quality value via  * {@link MediaType#sortByQualityValue(List)} and iterate the list.  * <li>Get the first index of matching media types in each "produces"  * condition first matching with {@link MediaType#equals(Object)} and  * then with {@link MediaType#includes(MediaType)}.  * <li>If a lower index is found, the condition at that index wins.  * <li>If both indexes are equal, the media types at the index are  * compared further with {@link MediaType#SPECIFICITY_COMPARATOR}.  * </ol>  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(HttpServletRequest)} and each instance  * contains the matching producible media type expression only or  * is otherwise empty.  */ @Override public int compareTo(ProducesRequestCondition other, HttpServletRequest request) {     try {         List<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(request).         for (MediaType acceptedMediaType : acceptedMediaTypes) {             int thisIndex = this.indexOfEqualMediaType(acceptedMediaType).             int otherIndex = other.indexOfEqualMediaType(acceptedMediaType).             int result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex).             if (result != 0) {                 return result.             }             thisIndex = this.indexOfIncludedMediaType(acceptedMediaType).             otherIndex = other.indexOfIncludedMediaType(acceptedMediaType).             result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex).             if (result != 0) {                 return result.             }         }         return 0.     } catch (HttpMediaTypeNotAcceptableException ex) {         // should never happen         throw new IllegalStateException("Cannot compare without having any requested media types", ex).     } }
false;private;1;3;;private List<MediaType> getAcceptedMediaTypes(HttpServletRequest request) throws HttpMediaTypeNotAcceptableException {     return this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request)). }
false;private;1;10;;private int indexOfEqualMediaType(MediaType mediaType) {     for (int i = 0. i < getExpressionsToCompare().size(). i++) {         MediaType currentMediaType = getExpressionsToCompare().get(i).getMediaType().         if (mediaType.getType().equalsIgnoreCase(currentMediaType.getType()) && mediaType.getSubtype().equalsIgnoreCase(currentMediaType.getSubtype())) {             return i.         }     }     return -1. }
false;private;1;8;;private int indexOfIncludedMediaType(MediaType mediaType) {     for (int i = 0. i < getExpressionsToCompare().size(). i++) {         if (mediaType.includes(getExpressionsToCompare().get(i).getMediaType())) {             return i.         }     }     return -1. }
false;private;4;15;;private int compareMatchingMediaTypes(ProducesRequestCondition condition1, int index1, ProducesRequestCondition condition2, int index2) {     int result = 0.     if (index1 != index2) {         result = index2 - index1.     } else if (index1 != -1) {         ProduceMediaTypeExpression expr1 = condition1.getExpressionsToCompare().get(index1).         ProduceMediaTypeExpression expr2 = condition2.getExpressionsToCompare().get(index2).         result = expr1.compareTo(expr2).         result = (result != 0) ? result : expr1.getMediaType().compareTo(expr2.getMediaType()).     }     return result. }
true;private;0;3;/**  * Return the contained "produces" expressions or if that's empty, a list  * with a {@value MediaType#ALL_VALUE} expression.  */ ;/**  * Return the contained "produces" expressions or if that's empty, a list  * with a {@value MediaType#ALL_VALUE} expression.  */ private List<ProduceMediaTypeExpression> getExpressionsToCompare() {     return (this.expressions.isEmpty() ? MEDIA_TYPE_ALL_LIST : this.expressions). }
false;public,final;1;4;;public final boolean match(List<MediaType> acceptedMediaTypes) {     boolean match = matchMediaType(acceptedMediaTypes).     return (!isNegated() ? match : !match). }
false;private;1;8;;private boolean matchMediaType(List<MediaType> acceptedMediaTypes) {     for (MediaType acceptedMediaType : acceptedMediaTypes) {         if (getMediaType().isCompatibleWith(acceptedMediaType)) {             return true.         }     }     return false. }
