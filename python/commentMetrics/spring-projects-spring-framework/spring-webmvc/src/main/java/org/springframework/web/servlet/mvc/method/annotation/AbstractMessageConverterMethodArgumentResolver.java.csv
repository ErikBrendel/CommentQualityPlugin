commented;modifiers;parameterAmount;loc;comment;code
true;private,static;1;9;/**  * Return the media types supported by all provided message converters sorted  * by specificity via {@link MediaType#sortBySpecificity(List)}.  */ ;/**  * Return the media types supported by all provided message converters sorted  * by specificity via {@link MediaType#sortBySpecificity(List)}.  */ private static List<MediaType> getAllSupportedMediaTypes(List<HttpMessageConverter<?>> messageConverters) {     Set<MediaType> allSupportedMediaTypes = new LinkedHashSet<>().     for (HttpMessageConverter<?> messageConverter : messageConverters) {         allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes()).     }     List<MediaType> result = new ArrayList<>(allSupportedMediaTypes).     MediaType.sortBySpecificity(result).     return Collections.unmodifiableList(result). }
true;;0;3;/**  * Return the configured {@link RequestBodyAdvice} and  * {@link RequestBodyAdvice} where each instance may be wrapped as a  * {@link org.springframework.web.method.ControllerAdviceBean ControllerAdviceBean}.  */ ;/**  * Return the configured {@link RequestBodyAdvice} and  * {@link RequestBodyAdvice} where each instance may be wrapped as a  * {@link org.springframework.web.method.ControllerAdviceBean ControllerAdviceBean}.  */ RequestResponseBodyAdviceChain getAdvice() {     return this.advice. }
true;protected;3;7;/**  * Create the method argument value of the expected parameter type by  * reading from the given request.  * @param <T> the expected type of the argument value to be created  * @param webRequest the current request  * @param parameter the method parameter descriptor (may be {@code null})  * @param paramType the type of the argument value to be created  * @return the created method argument value  * @throws IOException if the reading from the request fails  * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found  */ ;/**  * Create the method argument value of the expected parameter type by  * reading from the given request.  * @param <T> the expected type of the argument value to be created  * @param webRequest the current request  * @param parameter the method parameter descriptor (may be {@code null})  * @param paramType the type of the argument value to be created  * @return the created method argument value  * @throws IOException if the reading from the request fails  * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found  */ @Nullable protected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {     HttpInputMessage inputMessage = createInputMessage(webRequest).     return readWithMessageConverters(inputMessage, parameter, paramType). }
true;protected;3;73;/**  * Create the method argument value of the expected parameter type by reading  * from the given HttpInputMessage.  * @param <T> the expected type of the argument value to be created  * @param inputMessage the HTTP input message representing the current request  * @param parameter the method parameter descriptor  * @param targetType the target type, not necessarily the same as the method  * parameter type, e.g. for {@code HttpEntity<String>}.  * @return the created method argument value  * @throws IOException if the reading from the request fails  * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found  */ ;/**  * Create the method argument value of the expected parameter type by reading  * from the given HttpInputMessage.  * @param <T> the expected type of the argument value to be created  * @param inputMessage the HTTP input message representing the current request  * @param parameter the method parameter descriptor  * @param targetType the target type, not necessarily the same as the method  * parameter type, e.g. for {@code HttpEntity<String>}.  * @return the created method argument value  * @throws IOException if the reading from the request fails  * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found  */ @SuppressWarnings("unchecked") @Nullable protected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {     MediaType contentType.     boolean noContentType = false.     try {         contentType = inputMessage.getHeaders().getContentType().     } catch (InvalidMediaTypeException ex) {         throw new HttpMediaTypeNotSupportedException(ex.getMessage()).     }     if (contentType == null) {         noContentType = true.         contentType = MediaType.APPLICATION_OCTET_STREAM.     }     Class<?> contextClass = parameter.getContainingClass().     Class<T> targetClass = (targetType instanceof Class ? (Class<T>) targetType : null).     if (targetClass == null) {         ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter).         targetClass = (Class<T>) resolvableType.resolve().     }     HttpMethod httpMethod = (inputMessage instanceof HttpRequest ? ((HttpRequest) inputMessage).getMethod() : null).     Object body = NO_VALUE.     EmptyBodyCheckingHttpInputMessage message.     try {         message = new EmptyBodyCheckingHttpInputMessage(inputMessage).         for (HttpMessageConverter<?> converter : this.messageConverters) {             Class<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass().             GenericHttpMessageConverter<?> genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null).             if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) : (targetClass != null && converter.canRead(targetClass, contentType))) {                 if (message.hasBody()) {                     HttpInputMessage msgToUse = getAdvice().beforeBodyRead(message, parameter, targetType, converterType).                     body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) : ((HttpMessageConverter<T>) converter).read(targetClass, msgToUse)).                     body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType).                 } else {                     body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType).                 }                 break.             }         }     } catch (IOException ex) {         throw new HttpMessageNotReadableException("I/O error while reading input message", ex, inputMessage).     }     if (body == NO_VALUE) {         if (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) || (noContentType && !message.hasBody())) {             return null.         }         throw new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes).     }     MediaType selectedContentType = contentType.     Object theBody = body.     LogFormatUtils.traceDebug(logger, traceOn -> {         String formatted = LogFormatUtils.formatValue(theBody, !traceOn).         return "Read \"" + selectedContentType + "\" to [" + formatted + "]".     }).     return body. }
true;protected;1;5;/**  * Create a new {@link HttpInputMessage} from the given {@link NativeWebRequest}.  * @param webRequest the web request to create an input message from  * @return the input message  */ ;/**  * Create a new {@link HttpInputMessage} from the given {@link NativeWebRequest}.  * @param webRequest the web request to create an input message from  * @return the input message  */ protected ServletServerHttpRequest createInputMessage(NativeWebRequest webRequest) {     HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class).     Assert.state(servletRequest != null, "No HttpServletRequest").     return new ServletServerHttpRequest(servletRequest). }
true;protected;2;12;/**  * Validate the binding target if applicable.  * <p>The default implementation checks for {@code @javax.validation.Valid},  * Spring's {@link org.springframework.validation.annotation.Validated},  * and custom annotations whose name starts with "Valid".  * @param binder the DataBinder to be used  * @param parameter the method parameter descriptor  * @since 4.1.5  * @see #isBindExceptionRequired  */ ;/**  * Validate the binding target if applicable.  * <p>The default implementation checks for {@code @javax.validation.Valid},  * Spring's {@link org.springframework.validation.annotation.Validated},  * and custom annotations whose name starts with "Valid".  * @param binder the DataBinder to be used  * @param parameter the method parameter descriptor  * @since 4.1.5  * @see #isBindExceptionRequired  */ protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {     Annotation[] annotations = parameter.getParameterAnnotations().     for (Annotation ann : annotations) {         Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class).         if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {             Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)).             Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] { hints }).             binder.validate(validationHints).             break.         }     } }
true;protected;2;6;/**  * Whether to raise a fatal bind exception on validation errors.  * @param binder the data binder used to perform data binding  * @param parameter the method parameter descriptor  * @return {@code true} if the next method argument is not of type {@link Errors}  * @since 4.1.5  */ ;/**  * Whether to raise a fatal bind exception on validation errors.  * @param binder the data binder used to perform data binding  * @param parameter the method parameter descriptor  * @return {@code true} if the next method argument is not of type {@link Errors}  * @since 4.1.5  */ protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {     int i = parameter.getParameterIndex().     Class<?>[] paramTypes = parameter.getExecutable().getParameterTypes().     boolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1])).     return !hasBindingResult. }
true;protected;2;13;/**  * Adapt the given argument against the method parameter, if necessary.  * @param arg the resolved argument  * @param parameter the method parameter descriptor  * @return the adapted argument, or the original resolved argument as-is  * @since 4.3.5  */ ;/**  * Adapt the given argument against the method parameter, if necessary.  * @param arg the resolved argument  * @param parameter the method parameter descriptor  * @return the adapted argument, or the original resolved argument as-is  * @since 4.3.5  */ @Nullable protected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter) {     if (parameter.getParameterType() == Optional.class) {         if (arg == null || (arg instanceof Collection && ((Collection<?>) arg).isEmpty()) || (arg instanceof Object[] && ((Object[]) arg).length == 0)) {             return Optional.empty().         } else {             return Optional.of(arg).         }     }     return arg. }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return this.headers. }
false;public;0;4;;@Override public InputStream getBody() {     return (this.body != null ? this.body : StreamUtils.emptyInput()). }
false;public;0;3;;public boolean hasBody() {     return (this.body != null). }
