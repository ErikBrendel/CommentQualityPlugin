commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public boolean supportsReturnType(MethodParameter returnType) {     Class<?> bodyType = ResponseEntity.class.isAssignableFrom(returnType.getParameterType()) ? ResolvableType.forMethodParameter(returnType).getGeneric().resolve() : returnType.getParameterType().     return (bodyType != null && (ResponseBodyEmitter.class.isAssignableFrom(bodyType) || this.reactiveHandler.isReactiveType(bodyType))). }
false;public;4;62;;@Override @SuppressWarnings("resource") public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {     if (returnValue == null) {         mavContainer.setRequestHandled(true).         return.     }     HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class).     Assert.state(response != null, "No HttpServletResponse").     ServerHttpResponse outputMessage = new ServletServerHttpResponse(response).     if (returnValue instanceof ResponseEntity) {         ResponseEntity<?> responseEntity = (ResponseEntity<?>) returnValue.         response.setStatus(responseEntity.getStatusCodeValue()).         outputMessage.getHeaders().putAll(responseEntity.getHeaders()).         returnValue = responseEntity.getBody().         returnType = returnType.nested().         if (returnValue == null) {             mavContainer.setRequestHandled(true).             outputMessage.flush().             return.         }     }     ServletRequest request = webRequest.getNativeRequest(ServletRequest.class).     Assert.state(request != null, "No ServletRequest").     ResponseBodyEmitter emitter.     if (returnValue instanceof ResponseBodyEmitter) {         emitter = (ResponseBodyEmitter) returnValue.     } else {         emitter = this.reactiveHandler.handleValue(returnValue, returnType, mavContainer, webRequest).         if (emitter == null) {             // Not streaming: write headers without committing response..             outputMessage.getHeaders().forEach((headerName, headerValues) -> {                 for (String headerValue : headerValues) {                     response.addHeader(headerName, headerValue).                 }             }).             return.         }     }     emitter.extendResponse(outputMessage).     // At this point we know we're streaming..     ShallowEtagHeaderFilter.disableContentCaching(request).     // Commit the response and wrap to ignore further header changes     outputMessage.getBody().     outputMessage.flush().     outputMessage = new StreamingServletServerHttpResponse(outputMessage).     DeferredResult<?> deferredResult = new DeferredResult<>(emitter.getTimeout()).     WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer).     HttpMessageConvertingHandler handler = new HttpMessageConvertingHandler(outputMessage, deferredResult).     emitter.initialize(handler). }
false;public;2;4;;@Override public void send(Object data, @Nullable MediaType mediaType) throws IOException {     sendInternal(data, mediaType). }
false;private;2;11;;@SuppressWarnings("unchecked") private <T> void sendInternal(T data, @Nullable MediaType mediaType) throws IOException {     for (HttpMessageConverter<?> converter : ResponseBodyEmitterReturnValueHandler.this.messageConverters) {         if (converter.canWrite(data.getClass(), mediaType)) {             ((HttpMessageConverter<T>) converter).write(data, mediaType, this.outputMessage).             this.outputMessage.flush().             return.         }     }     throw new IllegalArgumentException("No suitable converter for " + data.getClass()). }
false;public;0;4;;@Override public void complete() {     this.deferredResult.setResult(null). }
false;public;1;4;;@Override public void completeWithError(Throwable failure) {     this.deferredResult.setErrorResult(failure). }
false;public;1;4;;@Override public void onTimeout(Runnable callback) {     this.deferredResult.onTimeout(callback). }
false;public;1;4;;@Override public void onError(Consumer<Throwable> callback) {     this.deferredResult.onError(callback). }
false;public;1;4;;@Override public void onCompletion(Runnable callback) {     this.deferredResult.onCompletion(callback). }
false;public;1;4;;@Override public void setStatusCode(HttpStatus status) {     this.delegate.setStatusCode(status). }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return this.mutableHeaders. }
false;public;0;4;;@Override public OutputStream getBody() throws IOException {     return this.delegate.getBody(). }
false;public;0;4;;@Override public void flush() throws IOException {     this.delegate.flush(). }
false;public;0;4;;@Override public void close() {     this.delegate.close(). }
