commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Configure a {@code UrlPathHelper} to use in  * {@link #getForRequestUrl(javax.servlet.http.HttpServletRequest, String)}  * in order to derive the lookup path for a target request URL path.  */ ;/**  * Configure a {@code UrlPathHelper} to use in  * {@link #getForRequestUrl(javax.servlet.http.HttpServletRequest, String)}  * in order to derive the lookup path for a target request URL path.  */ public void setUrlPathHelper(UrlPathHelper urlPathHelper) {     this.urlPathHelper = urlPathHelper. }
true;public;0;3;/**  * Return the configured {@code UrlPathHelper}.  * @since 4.2.8  */ ;/**  * Return the configured {@code UrlPathHelper}.  * @since 4.2.8  */ public UrlPathHelper getUrlPathHelper() {     return this.urlPathHelper. }
true;public;1;3;/**  * Configure a {@code PathMatcher} to use when comparing target lookup path  * against resource mappings.  */ ;/**  * Configure a {@code PathMatcher} to use when comparing target lookup path  * against resource mappings.  */ public void setPathMatcher(PathMatcher pathMatcher) {     this.pathMatcher = pathMatcher. }
true;public;0;3;/**  * Return the configured {@code PathMatcher}.  */ ;/**  * Return the configured {@code PathMatcher}.  */ public PathMatcher getPathMatcher() {     return this.pathMatcher. }
true;public;1;7;/**  * Manually configure the resource mappings.  * <p><strong>Note:</strong> by default resource mappings are auto-detected  * from the Spring {@code ApplicationContext}. However if this property is  * used, the auto-detection is turned off.  */ ;/**  * Manually configure the resource mappings.  * <p><strong>Note:</strong> by default resource mappings are auto-detected  * from the Spring {@code ApplicationContext}. However if this property is  * used, the auto-detection is turned off.  */ public void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap) {     if (handlerMap != null) {         this.handlerMap.clear().         this.handlerMap.putAll(handlerMap).         this.autodetect = false.     } }
true;public;0;3;/**  * Return the resource mappings, either manually configured or auto-detected  * when the Spring {@code ApplicationContext} is refreshed.  */ ;/**  * Return the resource mappings, either manually configured or auto-detected  * when the Spring {@code ApplicationContext} is refreshed.  */ public Map<String, ResourceHttpRequestHandler> getHandlerMap() {     return this.handlerMap. }
true;public;0;3;/**  * Return {@code false} if resource mappings were manually configured,  * {@code true} otherwise.  */ ;/**  * Return {@code false} if resource mappings were manually configured,  * {@code true} otherwise.  */ public boolean isAutodetect() {     return this.autodetect. }
false;public;1;10;;@Override public void onApplicationEvent(ContextRefreshedEvent event) {     if (isAutodetect()) {         this.handlerMap.clear().         detectResourceHandlers(event.getApplicationContext()).         if (!this.handlerMap.isEmpty()) {             this.autodetect = false.         }     } }
false;protected;1;19;;protected void detectResourceHandlers(ApplicationContext appContext) {     Map<String, SimpleUrlHandlerMapping> beans = appContext.getBeansOfType(SimpleUrlHandlerMapping.class).     List<SimpleUrlHandlerMapping> mappings = new ArrayList<>(beans.values()).     AnnotationAwareOrderComparator.sort(mappings).     for (SimpleUrlHandlerMapping mapping : mappings) {         for (String pattern : mapping.getHandlerMap().keySet()) {             Object handler = mapping.getHandlerMap().get(pattern).             if (handler instanceof ResourceHttpRequestHandler) {                 ResourceHttpRequestHandler resourceHandler = (ResourceHttpRequestHandler) handler.                 this.handlerMap.put(pattern, resourceHandler).             }         }     }     if (this.handlerMap.isEmpty()) {         logger.trace("No resource handling mappings found").     } }
true;public,final;2;13;/**  * A variation on {@link #getForLookupPath(String)} that accepts a full request  * URL path (i.e. including context and servlet path) and returns the full request  * URL path to expose for public use.  * @param request the current request  * @param requestUrl the request URL path to resolve  * @return the resolved public URL path, or {@code null} if unresolved  */ ;/**  * A variation on {@link #getForLookupPath(String)} that accepts a full request  * URL path (i.e. including context and servlet path) and returns the full request  * URL path to expose for public use.  * @param request the current request  * @param requestUrl the request URL path to resolve  * @return the resolved public URL path, or {@code null} if unresolved  */ @Nullable public final String getForRequestUrl(HttpServletRequest request, String requestUrl) {     int prefixIndex = getLookupPathIndex(request).     int suffixIndex = getEndPathIndex(requestUrl).     if (prefixIndex >= suffixIndex) {         return null.     }     String prefix = requestUrl.substring(0, prefixIndex).     String suffix = requestUrl.substring(suffixIndex).     String lookupPath = requestUrl.substring(prefixIndex, suffixIndex).     String resolvedLookupPath = getForLookupPath(lookupPath).     return (resolvedLookupPath != null ? prefix + resolvedLookupPath + suffix : null). }
false;private;1;6;;private int getLookupPathIndex(HttpServletRequest request) {     UrlPathHelper pathHelper = getUrlPathHelper().     String requestUri = pathHelper.getRequestUri(request).     String lookupPath = pathHelper.getLookupPathForRequest(request).     return requestUri.indexOf(lookupPath). }
false;private;1;12;;private int getEndPathIndex(String lookupPath) {     int suffixIndex = lookupPath.length().     int queryIndex = lookupPath.indexOf('?').     if (queryIndex > 0) {         suffixIndex = queryIndex.     }     int hashIndex = lookupPath.indexOf('#').     if (hashIndex > 0) {         suffixIndex = Math.min(suffixIndex, hashIndex).     }     return suffixIndex. }
true;public,final;1;39;/**  * Compare the given path against configured resource handler mappings and  * if a match is found use the {@code ResourceResolver} chain of the matched  * {@code ResourceHttpRequestHandler} to resolve the URL path to expose for  * public use.  * <p>It is expected that the given path is what Spring MVC would use for  * request mapping purposes, i.e. excluding context and servlet path portions.  * <p>If several handler mappings match, the handler used will be the one  * configured with the most specific pattern.  * @param lookupPath the lookup path to check  * @return the resolved public URL path, or {@code null} if unresolved  */ ;/**  * Compare the given path against configured resource handler mappings and  * if a match is found use the {@code ResourceResolver} chain of the matched  * {@code ResourceHttpRequestHandler} to resolve the URL path to expose for  * public use.  * <p>It is expected that the given path is what Spring MVC would use for  * request mapping purposes, i.e. excluding context and servlet path portions.  * <p>If several handler mappings match, the handler used will be the one  * configured with the most specific pattern.  * @param lookupPath the lookup path to check  * @return the resolved public URL path, or {@code null} if unresolved  */ @Nullable public final String getForLookupPath(String lookupPath) {     // Clean duplicate slashes or pathWithinPattern won't match lookupPath     String previous.     do {         previous = lookupPath.         lookupPath = StringUtils.replace(lookupPath, "//", "/").     } while (!lookupPath.equals(previous)).     List<String> matchingPatterns = new ArrayList<>().     for (String pattern : this.handlerMap.keySet()) {         if (getPathMatcher().match(pattern, lookupPath)) {             matchingPatterns.add(pattern).         }     }     if (!matchingPatterns.isEmpty()) {         Comparator<String> patternComparator = getPathMatcher().getPatternComparator(lookupPath).         matchingPatterns.sort(patternComparator).         for (String pattern : matchingPatterns) {             String pathWithinMapping = getPathMatcher().extractPathWithinPattern(pattern, lookupPath).             String pathMapping = lookupPath.substring(0, lookupPath.indexOf(pathWithinMapping)).             ResourceHttpRequestHandler handler = this.handlerMap.get(pattern).             ResourceResolverChain chain = new DefaultResourceResolverChain(handler.getResourceResolvers()).             String resolved = chain.resolveUrlPath(pathWithinMapping, handler.getLocations()).             if (resolved == null) {                 continue.             }             return pathMapping + resolved.         }     }     if (logger.isTraceEnabled()) {         logger.trace("No match for \"" + lookupPath + "\"").     }     return null. }
