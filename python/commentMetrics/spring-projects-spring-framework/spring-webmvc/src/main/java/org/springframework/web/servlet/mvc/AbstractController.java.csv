commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;3;/**  * Set if controller execution should be synchronized on the session,  * to serialize parallel invocations from the same client.  * <p>More specifically, the execution of the {@code handleRequestInternal}  * method will get synchronized if this flag is "true". The best available  * session mutex will be used for the synchronization. ideally, this will  * be a mutex exposed by HttpSessionMutexListener.  * <p>The session mutex is guaranteed to be the same object during  * the entire lifetime of the session, available under the key defined  * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a  * safe reference to synchronize on for locking on the current session.  * <p>In many cases, the HttpSession reference itself is a safe mutex  * as well, since it will always be the same object reference for the  * same active logical session. However, this is not guaranteed across  * different servlet containers. the only 100% safe way is a session mutex.  * @see AbstractController#handleRequestInternal  * @see org.springframework.web.util.HttpSessionMutexListener  * @see org.springframework.web.util.WebUtils#getSessionMutex(javax.servlet.http.HttpSession)  */ ;/**  * Set if controller execution should be synchronized on the session,  * to serialize parallel invocations from the same client.  * <p>More specifically, the execution of the {@code handleRequestInternal}  * method will get synchronized if this flag is "true". The best available  * session mutex will be used for the synchronization. ideally, this will  * be a mutex exposed by HttpSessionMutexListener.  * <p>The session mutex is guaranteed to be the same object during  * the entire lifetime of the session, available under the key defined  * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a  * safe reference to synchronize on for locking on the current session.  * <p>In many cases, the HttpSession reference itself is a safe mutex  * as well, since it will always be the same object reference for the  * same active logical session. However, this is not guaranteed across  * different servlet containers. the only 100% safe way is a session mutex.  * @see AbstractController#handleRequestInternal  * @see org.springframework.web.util.HttpSessionMutexListener  * @see org.springframework.web.util.WebUtils#getSessionMutex(javax.servlet.http.HttpSession)  */ public final void setSynchronizeOnSession(boolean synchronizeOnSession) {     this.synchronizeOnSession = synchronizeOnSession. }
true;public,final;0;3;/**  * Return whether controller execution should be synchronized on the session.  */ ;/**  * Return whether controller execution should be synchronized on the session.  */ public final boolean isSynchronizeOnSession() {     return this.synchronizeOnSession. }
false;public;2;27;;@Override @Nullable public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {     if (HttpMethod.OPTIONS.matches(request.getMethod())) {         response.setHeader("Allow", getAllowHeader()).         return null.     }     // Delegate to WebContentGenerator for checking and preparing.     checkRequest(request).     prepareResponse(response).     // Execute handleRequestInternal in synchronized block if required.     if (this.synchronizeOnSession) {         HttpSession session = request.getSession(false).         if (session != null) {             Object mutex = WebUtils.getSessionMutex(session).             synchronized (mutex) {                 return handleRequestInternal(request, response).             }         }     }     return handleRequestInternal(request, response). }
true;protected,abstract;2;3;/**  * Template method. Subclasses must implement this.  * The contract is the same as for {@code handleRequest}.  * @see #handleRequest  */ ;/**  * Template method. Subclasses must implement this.  * The contract is the same as for {@code handleRequest}.  * @see #handleRequest  */ @Nullable protected abstract ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception.
