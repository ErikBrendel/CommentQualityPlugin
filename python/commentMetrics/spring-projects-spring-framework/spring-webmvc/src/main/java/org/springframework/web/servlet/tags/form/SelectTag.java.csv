commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the {@link Collection}, {@link Map} or array of objects used to  * generate the inner '{@code option}' tags.  * <p>Required when wishing to render '{@code option}' tags from  * an array, {@link Collection} or {@link Map}.  * <p>Typically a runtime expression.  * @param items the items that comprise the options of this selection  */ ;/**  * Set the {@link Collection}, {@link Map} or array of objects used to  * generate the inner '{@code option}' tags.  * <p>Required when wishing to render '{@code option}' tags from  * an array, {@link Collection} or {@link Map}.  * <p>Typically a runtime expression.  * @param items the items that comprise the options of this selection  */ public void setItems(@Nullable Object items) {     this.items = (items != null ? items : EMPTY). }
true;protected;0;4;/**  * Get the value of the '{@code items}' attribute.  * <p>May be a runtime expression.  */ ;/**  * Get the value of the '{@code items}' attribute.  * <p>May be a runtime expression.  */ @Nullable protected Object getItems() {     return this.items. }
true;public;1;3;/**  * Set the name of the property mapped to the '{@code value}'  * attribute of the '{@code option}' tag.  * <p>Required when wishing to render '{@code option}' tags from  * an array or {@link Collection}.  * <p>May be a runtime expression.  */ ;/**  * Set the name of the property mapped to the '{@code value}'  * attribute of the '{@code option}' tag.  * <p>Required when wishing to render '{@code option}' tags from  * an array or {@link Collection}.  * <p>May be a runtime expression.  */ public void setItemValue(String itemValue) {     this.itemValue = itemValue. }
true;protected;0;4;/**  * Get the value of the '{@code itemValue}' attribute.  * <p>May be a runtime expression.  */ ;/**  * Get the value of the '{@code itemValue}' attribute.  * <p>May be a runtime expression.  */ @Nullable protected String getItemValue() {     return this.itemValue. }
true;public;1;3;/**  * Set the name of the property mapped to the label (inner text) of the  * '{@code option}' tag.  * <p>May be a runtime expression.  */ ;/**  * Set the name of the property mapped to the label (inner text) of the  * '{@code option}' tag.  * <p>May be a runtime expression.  */ public void setItemLabel(String itemLabel) {     this.itemLabel = itemLabel. }
true;protected;0;4;/**  * Get the value of the '{@code itemLabel}' attribute.  * <p>May be a runtime expression.  */ ;/**  * Get the value of the '{@code itemLabel}' attribute.  * <p>May be a runtime expression.  */ @Nullable protected String getItemLabel() {     return this.itemLabel. }
true;public;1;3;/**  * Set the value of the HTML '{@code size}' attribute rendered  * on the final '{@code select}' element.  */ ;/**  * Set the value of the HTML '{@code size}' attribute rendered  * on the final '{@code select}' element.  */ public void setSize(String size) {     this.size = size. }
true;protected;0;4;/**  * Get the value of the '{@code size}' attribute.  */ ;/**  * Get the value of the '{@code size}' attribute.  */ @Nullable protected String getSize() {     return this.size. }
true;public;1;3;/**  * Set the value of the HTML '{@code multiple}' attribute rendered  * on the final '{@code select}' element.  */ ;/**  * Set the value of the HTML '{@code multiple}' attribute rendered  * on the final '{@code select}' element.  */ public void setMultiple(Object multiple) {     this.multiple = multiple. }
true;protected;0;4;/**  * Get the value of the HTML '{@code multiple}' attribute rendered  * on the final '{@code select}' element.  */ ;/**  * Get the value of the HTML '{@code multiple}' attribute rendered  * on the final '{@code select}' element.  */ @Nullable protected Object getMultiple() {     return this.multiple. }
false;protected;1;4;;@Override protected String processOptionValue(String resolvedValue) {     return processFieldValue(selectName, resolvedValue, "option"). }
true;protected;1;42;/**  * Renders the HTML '{@code select}' tag to the supplied  * {@link TagWriter}.  * <p>Renders nested '{@code option}' tags if the  * {@link #setItems items} property is set, otherwise exposes the  * bound value for the nested {@link OptionTag OptionTags}.  */ ;/**  * Renders the HTML '{@code select}' tag to the supplied  * {@link TagWriter}.  * <p>Renders nested '{@code option}' tags if the  * {@link #setItems items} property is set, otherwise exposes the  * bound value for the nested {@link OptionTag OptionTags}.  */ @Override protected int writeTagContent(TagWriter tagWriter) throws JspException {     tagWriter.startTag("select").     writeDefaultAttributes(tagWriter).     if (isMultiple()) {         tagWriter.writeAttribute("multiple", "multiple").     }     tagWriter.writeOptionalAttributeValue("size", getDisplayString(evaluate("size", getSize()))).     Object items = getItems().     if (items != null) {         // Items specified, but might still be empty...         if (items != EMPTY) {             Object itemsObject = evaluate("items", items).             if (itemsObject != null) {                 final String selectName = getName().                 String valueProperty = (getItemValue() != null ? ObjectUtils.getDisplayString(evaluate("itemValue", getItemValue())) : null).                 String labelProperty = (getItemLabel() != null ? ObjectUtils.getDisplayString(evaluate("itemLabel", getItemLabel())) : null).                 OptionWriter optionWriter = new OptionWriter(itemsObject, getBindStatus(), valueProperty, labelProperty, isHtmlEscape()) {                      @Override                     protected String processOptionValue(String resolvedValue) {                         return processFieldValue(selectName, resolvedValue, "option").                     }                 }.                 optionWriter.writeOptions(tagWriter).             }         }         tagWriter.endTag(true).         writeHiddenTagIfNecessary(tagWriter).         return SKIP_BODY.     } else {         // Using nested <form:option/> tags, so just expose the value in the PageContext...         tagWriter.forceBlock().         this.tagWriter = tagWriter.         this.pageContext.setAttribute(LIST_VALUE_PAGE_ATTRIBUTE, getBindStatus()).         return EVAL_BODY_INCLUDE.     } }
true;private;1;10;/**  * If using a multi-select, a hidden element is needed to make sure all  * items are correctly unselected on the server-side in response to a  * {@code null} post.  */ ;/**  * If using a multi-select, a hidden element is needed to make sure all  * items are correctly unselected on the server-side in response to a  * {@code null} post.  */ private void writeHiddenTagIfNecessary(TagWriter tagWriter) throws JspException {     if (isMultiple()) {         tagWriter.startTag("input").         tagWriter.writeAttribute("type", "hidden").         String name = WebDataBinder.DEFAULT_FIELD_MARKER_PREFIX + getName().         tagWriter.writeAttribute("name", name).         tagWriter.writeAttribute("value", processFieldValue(name, "1", "hidden")).         tagWriter.endTag().     } }
false;private;0;8;;private boolean isMultiple() throws JspException {     Object multiple = getMultiple().     if (multiple != null) {         String stringValue = multiple.toString().         return ("multiple".equalsIgnoreCase(stringValue) || Boolean.parseBoolean(stringValue)).     }     return forceMultiple(). }
true;private;0;14;/**  * Returns '{@code true}' if the bound value requires the  * resultant '{@code select}' tag to be multi-select.  */ ;/**  * Returns '{@code true}' if the bound value requires the  * resultant '{@code select}' tag to be multi-select.  */ private boolean forceMultiple() throws JspException {     BindStatus bindStatus = getBindStatus().     Class<?> valueType = bindStatus.getValueType().     if (valueType != null && typeRequiresMultiple(valueType)) {         return true.     } else if (bindStatus.getEditor() != null) {         Object editorValue = bindStatus.getEditor().getValue().         if (editorValue != null && typeRequiresMultiple(editorValue.getClass())) {             return true.         }     }     return false. }
true;private,static;1;3;/**  * Returns '{@code true}' for arrays, {@link Collection Collections}  * and {@link Map Maps}.  */ ;/**  * Returns '{@code true}' for arrays, {@link Collection Collections}  * and {@link Map Maps}.  */ private static boolean typeRequiresMultiple(Class<?> type) {     return (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)). }
true;public;0;8;/**  * Closes any block tag that might have been opened when using  * nested {@link OptionTag options}.  */ ;/**  * Closes any block tag that might have been opened when using  * nested {@link OptionTag options}.  */ @Override public int doEndTag() throws JspException {     if (this.tagWriter != null) {         this.tagWriter.endTag().         writeHiddenTagIfNecessary(this.tagWriter).     }     return EVAL_PAGE. }
true;public;0;6;/**  * Clears the {@link TagWriter} that might have been left over when using  * nested {@link OptionTag options}.  */ ;/**  * Clears the {@link TagWriter} that might have been left over when using  * nested {@link OptionTag options}.  */ @Override public void doFinally() {     super.doFinally().     this.tagWriter = null.     this.pageContext.removeAttribute(LIST_VALUE_PAGE_ATTRIBUTE). }
