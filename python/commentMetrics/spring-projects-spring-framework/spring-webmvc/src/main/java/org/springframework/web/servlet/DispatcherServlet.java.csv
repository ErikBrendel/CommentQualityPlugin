commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether to detect all HandlerMapping beans in this servlet's context. Otherwise,  * just a single bean with name "handlerMapping" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * HandlerMapping, despite multiple HandlerMapping beans being defined in the context.  */ ;/**  * Set whether to detect all HandlerMapping beans in this servlet's context. Otherwise,  * just a single bean with name "handlerMapping" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * HandlerMapping, despite multiple HandlerMapping beans being defined in the context.  */ public void setDetectAllHandlerMappings(boolean detectAllHandlerMappings) {     this.detectAllHandlerMappings = detectAllHandlerMappings. }
true;public;1;3;/**  * Set whether to detect all HandlerAdapter beans in this servlet's context. Otherwise,  * just a single bean with name "handlerAdapter" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * HandlerAdapter, despite multiple HandlerAdapter beans being defined in the context.  */ ;/**  * Set whether to detect all HandlerAdapter beans in this servlet's context. Otherwise,  * just a single bean with name "handlerAdapter" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * HandlerAdapter, despite multiple HandlerAdapter beans being defined in the context.  */ public void setDetectAllHandlerAdapters(boolean detectAllHandlerAdapters) {     this.detectAllHandlerAdapters = detectAllHandlerAdapters. }
true;public;1;3;/**  * Set whether to detect all HandlerExceptionResolver beans in this servlet's context. Otherwise,  * just a single bean with name "handlerExceptionResolver" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * HandlerExceptionResolver, despite multiple HandlerExceptionResolver beans being defined in the context.  */ ;/**  * Set whether to detect all HandlerExceptionResolver beans in this servlet's context. Otherwise,  * just a single bean with name "handlerExceptionResolver" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * HandlerExceptionResolver, despite multiple HandlerExceptionResolver beans being defined in the context.  */ public void setDetectAllHandlerExceptionResolvers(boolean detectAllHandlerExceptionResolvers) {     this.detectAllHandlerExceptionResolvers = detectAllHandlerExceptionResolvers. }
true;public;1;3;/**  * Set whether to detect all ViewResolver beans in this servlet's context. Otherwise,  * just a single bean with name "viewResolver" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * ViewResolver, despite multiple ViewResolver beans being defined in the context.  */ ;/**  * Set whether to detect all ViewResolver beans in this servlet's context. Otherwise,  * just a single bean with name "viewResolver" will be expected.  * <p>Default is "true". Turn this off if you want this servlet to use a single  * ViewResolver, despite multiple ViewResolver beans being defined in the context.  */ public void setDetectAllViewResolvers(boolean detectAllViewResolvers) {     this.detectAllViewResolvers = detectAllViewResolvers. }
true;public;1;3;/**  * Set whether to throw a NoHandlerFoundException when no Handler was found for this request.  * This exception can then be caught with a HandlerExceptionResolver or an  * {@code @ExceptionHandler} controller method.  * <p>Note that if {@link org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler}  * is used, then requests will always be forwarded to the default servlet and a  * NoHandlerFoundException would never be thrown in that case.  * <p>Default is "false", meaning the DispatcherServlet sends a NOT_FOUND error through the  * Servlet response.  * @since 4.0  */ ;/**  * Set whether to throw a NoHandlerFoundException when no Handler was found for this request.  * This exception can then be caught with a HandlerExceptionResolver or an  * {@code @ExceptionHandler} controller method.  * <p>Note that if {@link org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler}  * is used, then requests will always be forwarded to the default servlet and a  * NoHandlerFoundException would never be thrown in that case.  * <p>Default is "false", meaning the DispatcherServlet sends a NOT_FOUND error through the  * Servlet response.  * @since 4.0  */ public void setThrowExceptionIfNoHandlerFound(boolean throwExceptionIfNoHandlerFound) {     this.throwExceptionIfNoHandlerFound = throwExceptionIfNoHandlerFound. }
true;public;1;3;/**  * Set whether to perform cleanup of request attributes after an include request, that is,  * whether to reset the original state of all request attributes after the DispatcherServlet  * has processed within an include request. Otherwise, just the DispatcherServlet's own  * request attributes will be reset, but not model attributes for JSPs or special attributes  * set by views (for example, JSTL's).  * <p>Default is "true", which is strongly recommended. Views should not rely on request attributes  * having been set by (dynamic) includes. This allows JSP views rendered by an included controller  * to use any model attributes, even with the same names as in the main JSP, without causing side  * effects. Only turn this off for special needs, for example to deliberately allow main JSPs to  * access attributes from JSP views rendered by an included controller.  */ ;/**  * Set whether to perform cleanup of request attributes after an include request, that is,  * whether to reset the original state of all request attributes after the DispatcherServlet  * has processed within an include request. Otherwise, just the DispatcherServlet's own  * request attributes will be reset, but not model attributes for JSPs or special attributes  * set by views (for example, JSTL's).  * <p>Default is "true", which is strongly recommended. Views should not rely on request attributes  * having been set by (dynamic) includes. This allows JSP views rendered by an included controller  * to use any model attributes, even with the same names as in the main JSP, without causing side  * effects. Only turn this off for special needs, for example to deliberately allow main JSPs to  * access attributes from JSP views rendered by an included controller.  */ public void setCleanupAfterInclude(boolean cleanupAfterInclude) {     this.cleanupAfterInclude = cleanupAfterInclude. }
true;protected;1;4;/**  * This implementation calls {@link #initStrategies}.  */ ;/**  * This implementation calls {@link #initStrategies}.  */ @Override protected void onRefresh(ApplicationContext context) {     initStrategies(context). }
true;protected;1;11;/**  * Initialize the strategy objects that this servlet uses.  * <p>May be overridden in subclasses in order to initialize further strategy objects.  */ ;/**  * Initialize the strategy objects that this servlet uses.  * <p>May be overridden in subclasses in order to initialize further strategy objects.  */ protected void initStrategies(ApplicationContext context) {     initMultipartResolver(context).     initLocaleResolver(context).     initThemeResolver(context).     initHandlerMappings(context).     initHandlerAdapters(context).     initHandlerExceptionResolvers(context).     initRequestToViewNameTranslator(context).     initViewResolvers(context).     initFlashMapManager(context). }
true;private;1;18;/**  * Initialize the MultipartResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * no multipart handling is provided.  */ ;/**  * Initialize the MultipartResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * no multipart handling is provided.  */ private void initMultipartResolver(ApplicationContext context) {     try {         this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("Detected " + this.multipartResolver).         } else if (logger.isDebugEnabled()) {             logger.debug("Detected " + this.multipartResolver.getClass().getSimpleName()).         }     } catch (NoSuchBeanDefinitionException ex) {         // Default is no multipart resolver.         this.multipartResolver = null.         if (logger.isTraceEnabled()) {             logger.trace("No MultipartResolver '" + MULTIPART_RESOLVER_BEAN_NAME + "' declared").         }     } }
true;private;1;19;/**  * Initialize the LocaleResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * we default to AcceptHeaderLocaleResolver.  */ ;/**  * Initialize the LocaleResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * we default to AcceptHeaderLocaleResolver.  */ private void initLocaleResolver(ApplicationContext context) {     try {         this.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("Detected " + this.localeResolver).         } else if (logger.isDebugEnabled()) {             logger.debug("Detected " + this.localeResolver.getClass().getSimpleName()).         }     } catch (NoSuchBeanDefinitionException ex) {         // We need to use the default.         this.localeResolver = getDefaultStrategy(context, LocaleResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("No LocaleResolver '" + LOCALE_RESOLVER_BEAN_NAME + "': using default [" + this.localeResolver.getClass().getSimpleName() + "]").         }     } }
true;private;1;19;/**  * Initialize the ThemeResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * we default to a FixedThemeResolver.  */ ;/**  * Initialize the ThemeResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * we default to a FixedThemeResolver.  */ private void initThemeResolver(ApplicationContext context) {     try {         this.themeResolver = context.getBean(THEME_RESOLVER_BEAN_NAME, ThemeResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("Detected " + this.themeResolver).         } else if (logger.isDebugEnabled()) {             logger.debug("Detected " + this.themeResolver.getClass().getSimpleName()).         }     } catch (NoSuchBeanDefinitionException ex) {         // We need to use the default.         this.themeResolver = getDefaultStrategy(context, ThemeResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("No ThemeResolver '" + THEME_RESOLVER_BEAN_NAME + "': using default [" + this.themeResolver.getClass().getSimpleName() + "]").         }     } }
true;private;1;33;/**  * Initialize the HandlerMappings used by this class.  * <p>If no HandlerMapping beans are defined in the BeanFactory for this namespace,  * we default to BeanNameUrlHandlerMapping.  */ ;/**  * Initialize the HandlerMappings used by this class.  * <p>If no HandlerMapping beans are defined in the BeanFactory for this namespace,  * we default to BeanNameUrlHandlerMapping.  */ private void initHandlerMappings(ApplicationContext context) {     this.handlerMappings = null.     if (this.detectAllHandlerMappings) {         // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.         Map<String, HandlerMapping> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false).         if (!matchingBeans.isEmpty()) {             this.handlerMappings = new ArrayList<>(matchingBeans.values()).             // We keep HandlerMappings in sorted order.             AnnotationAwareOrderComparator.sort(this.handlerMappings).         }     } else {         try {             HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class).             this.handlerMappings = Collections.singletonList(hm).         } catch (NoSuchBeanDefinitionException ex) {         // Ignore, we'll add a default HandlerMapping later.         }     }     // a default HandlerMapping if no other mappings are found.     if (this.handlerMappings == null) {         this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class).         if (logger.isTraceEnabled()) {             logger.trace("No HandlerMappings declared for servlet '" + getServletName() + "': using default strategies from DispatcherServlet.properties").         }     } }
true;private;1;33;/**  * Initialize the HandlerAdapters used by this class.  * <p>If no HandlerAdapter beans are defined in the BeanFactory for this namespace,  * we default to SimpleControllerHandlerAdapter.  */ ;/**  * Initialize the HandlerAdapters used by this class.  * <p>If no HandlerAdapter beans are defined in the BeanFactory for this namespace,  * we default to SimpleControllerHandlerAdapter.  */ private void initHandlerAdapters(ApplicationContext context) {     this.handlerAdapters = null.     if (this.detectAllHandlerAdapters) {         // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.         Map<String, HandlerAdapter> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false).         if (!matchingBeans.isEmpty()) {             this.handlerAdapters = new ArrayList<>(matchingBeans.values()).             // We keep HandlerAdapters in sorted order.             AnnotationAwareOrderComparator.sort(this.handlerAdapters).         }     } else {         try {             HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class).             this.handlerAdapters = Collections.singletonList(ha).         } catch (NoSuchBeanDefinitionException ex) {         // Ignore, we'll add a default HandlerAdapter later.         }     }     // default HandlerAdapters if no other adapters are found.     if (this.handlerAdapters == null) {         this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class).         if (logger.isTraceEnabled()) {             logger.trace("No HandlerAdapters declared for servlet '" + getServletName() + "': using default strategies from DispatcherServlet.properties").         }     } }
true;private;1;34;/**  * Initialize the HandlerExceptionResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * we default to no exception resolver.  */ ;/**  * Initialize the HandlerExceptionResolver used by this class.  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,  * we default to no exception resolver.  */ private void initHandlerExceptionResolvers(ApplicationContext context) {     this.handlerExceptionResolvers = null.     if (this.detectAllHandlerExceptionResolvers) {         // Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.         Map<String, HandlerExceptionResolver> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false).         if (!matchingBeans.isEmpty()) {             this.handlerExceptionResolvers = new ArrayList<>(matchingBeans.values()).             // We keep HandlerExceptionResolvers in sorted order.             AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers).         }     } else {         try {             HandlerExceptionResolver her = context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class).             this.handlerExceptionResolvers = Collections.singletonList(her).         } catch (NoSuchBeanDefinitionException ex) {         // Ignore, no HandlerExceptionResolver is fine too.         }     }     // default HandlerExceptionResolvers if no other resolvers are found.     if (this.handlerExceptionResolvers == null) {         this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("No HandlerExceptionResolvers declared in servlet '" + getServletName() + "': using default strategies from DispatcherServlet.properties").         }     } }
true;private;1;20;/**  * Initialize the RequestToViewNameTranslator used by this servlet instance.  * <p>If no implementation is configured then we default to DefaultRequestToViewNameTranslator.  */ ;/**  * Initialize the RequestToViewNameTranslator used by this servlet instance.  * <p>If no implementation is configured then we default to DefaultRequestToViewNameTranslator.  */ private void initRequestToViewNameTranslator(ApplicationContext context) {     try {         this.viewNameTranslator = context.getBean(REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, RequestToViewNameTranslator.class).         if (logger.isTraceEnabled()) {             logger.trace("Detected " + this.viewNameTranslator.getClass().getSimpleName()).         } else if (logger.isDebugEnabled()) {             logger.debug("Detected " + this.viewNameTranslator).         }     } catch (NoSuchBeanDefinitionException ex) {         // We need to use the default.         this.viewNameTranslator = getDefaultStrategy(context, RequestToViewNameTranslator.class).         if (logger.isTraceEnabled()) {             logger.trace("No RequestToViewNameTranslator '" + REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME + "': using default [" + this.viewNameTranslator.getClass().getSimpleName() + "]").         }     } }
true;private;1;33;/**  * Initialize the ViewResolvers used by this class.  * <p>If no ViewResolver beans are defined in the BeanFactory for this  * namespace, we default to InternalResourceViewResolver.  */ ;/**  * Initialize the ViewResolvers used by this class.  * <p>If no ViewResolver beans are defined in the BeanFactory for this  * namespace, we default to InternalResourceViewResolver.  */ private void initViewResolvers(ApplicationContext context) {     this.viewResolvers = null.     if (this.detectAllViewResolvers) {         // Find all ViewResolvers in the ApplicationContext, including ancestor contexts.         Map<String, ViewResolver> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false).         if (!matchingBeans.isEmpty()) {             this.viewResolvers = new ArrayList<>(matchingBeans.values()).             // We keep ViewResolvers in sorted order.             AnnotationAwareOrderComparator.sort(this.viewResolvers).         }     } else {         try {             ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class).             this.viewResolvers = Collections.singletonList(vr).         } catch (NoSuchBeanDefinitionException ex) {         // Ignore, we'll add a default ViewResolver later.         }     }     // a default ViewResolver if no other resolvers are found.     if (this.viewResolvers == null) {         this.viewResolvers = getDefaultStrategies(context, ViewResolver.class).         if (logger.isTraceEnabled()) {             logger.trace("No ViewResolvers declared for servlet '" + getServletName() + "': using default strategies from DispatcherServlet.properties").         }     } }
true;private;1;19;/**  * Initialize the {@link FlashMapManager} used by this servlet instance.  * <p>If no implementation is configured then we default to  * {@code org.springframework.web.servlet.support.DefaultFlashMapManager}.  */ ;/**  * Initialize the {@link FlashMapManager} used by this servlet instance.  * <p>If no implementation is configured then we default to  * {@code org.springframework.web.servlet.support.DefaultFlashMapManager}.  */ private void initFlashMapManager(ApplicationContext context) {     try {         this.flashMapManager = context.getBean(FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class).         if (logger.isTraceEnabled()) {             logger.trace("Detected " + this.flashMapManager.getClass().getSimpleName()).         } else if (logger.isDebugEnabled()) {             logger.debug("Detected " + this.flashMapManager).         }     } catch (NoSuchBeanDefinitionException ex) {         // We need to use the default.         this.flashMapManager = getDefaultStrategy(context, FlashMapManager.class).         if (logger.isTraceEnabled()) {             logger.trace("No FlashMapManager '" + FLASH_MAP_MANAGER_BEAN_NAME + "': using default [" + this.flashMapManager.getClass().getSimpleName() + "]").         }     } }
true;public,final;0;4;/**  * Return this servlet's ThemeSource, if any. else return {@code null}.  * <p>Default is to return the WebApplicationContext as ThemeSource,  * provided that it implements the ThemeSource interface.  * @return the ThemeSource, if any  * @see #getWebApplicationContext()  */ ;/**  * Return this servlet's ThemeSource, if any. else return {@code null}.  * <p>Default is to return the WebApplicationContext as ThemeSource,  * provided that it implements the ThemeSource interface.  * @return the ThemeSource, if any  * @see #getWebApplicationContext()  */ @Nullable public final ThemeSource getThemeSource() {     return (getWebApplicationContext() instanceof ThemeSource ? (ThemeSource) getWebApplicationContext() : null). }
true;public,final;0;4;/**  * Obtain this servlet's MultipartResolver, if any.  * @return the MultipartResolver used by this servlet, or {@code null} if none  * (indicating that no multipart support is available)  */ ;/**  * Obtain this servlet's MultipartResolver, if any.  * @return the MultipartResolver used by this servlet, or {@code null} if none  * (indicating that no multipart support is available)  */ @Nullable public final MultipartResolver getMultipartResolver() {     return this.multipartResolver. }
true;public,final;0;4;/**  * Return the configured {@link HandlerMapping} beans that were detected by  * type in the {@link WebApplicationContext} or initialized based on the  * default set of strategies from {@literal DispatcherServlet.properties}.  * <p><strong>Note:</strong> This method may return {@code null} if invoked  * prior to {@link #onRefresh(ApplicationContext)}.  * @return an immutable list with the configured mappings, or {@code null}  * if not initialized yet  * @since 5.0  */ ;/**  * Return the configured {@link HandlerMapping} beans that were detected by  * type in the {@link WebApplicationContext} or initialized based on the  * default set of strategies from {@literal DispatcherServlet.properties}.  * <p><strong>Note:</strong> This method may return {@code null} if invoked  * prior to {@link #onRefresh(ApplicationContext)}.  * @return an immutable list with the configured mappings, or {@code null}  * if not initialized yet  * @since 5.0  */ @Nullable public final List<HandlerMapping> getHandlerMappings() {     return (this.handlerMappings != null ? Collections.unmodifiableList(this.handlerMappings) : null). }
true;protected;2;8;/**  * Return the default strategy object for the given strategy interface.  * <p>The default implementation delegates to {@link #getDefaultStrategies},  * expecting a single object in the list.  * @param context the current WebApplicationContext  * @param strategyInterface the strategy interface  * @return the corresponding strategy object  * @see #getDefaultStrategies  */ ;/**  * Return the default strategy object for the given strategy interface.  * <p>The default implementation delegates to {@link #getDefaultStrategies},  * expecting a single object in the list.  * @param context the current WebApplicationContext  * @param strategyInterface the strategy interface  * @return the corresponding strategy object  * @see #getDefaultStrategies  */ protected <T> T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface) {     List<T> strategies = getDefaultStrategies(context, strategyInterface).     if (strategies.size() != 1) {         throw new BeanInitializationException("DispatcherServlet needs exactly 1 strategy for interface [" + strategyInterface.getName() + "]").     }     return strategies.get(0). }
true;protected;2;30;/**  * Create a List of default strategy objects for the given strategy interface.  * <p>The default implementation uses the "DispatcherServlet.properties" file (in the same  * package as the DispatcherServlet class) to determine the class names. It instantiates  * the strategy objects through the context's BeanFactory.  * @param context the current WebApplicationContext  * @param strategyInterface the strategy interface  * @return the List of corresponding strategy objects  */ ;/**  * Create a List of default strategy objects for the given strategy interface.  * <p>The default implementation uses the "DispatcherServlet.properties" file (in the same  * package as the DispatcherServlet class) to determine the class names. It instantiates  * the strategy objects through the context's BeanFactory.  * @param context the current WebApplicationContext  * @param strategyInterface the strategy interface  * @return the List of corresponding strategy objects  */ @SuppressWarnings("unchecked") protected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {     String key = strategyInterface.getName().     String value = defaultStrategies.getProperty(key).     if (value != null) {         String[] classNames = StringUtils.commaDelimitedListToStringArray(value).         List<T> strategies = new ArrayList<>(classNames.length).         for (String className : classNames) {             try {                 Class<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader()).                 Object strategy = createDefaultStrategy(context, clazz).                 strategies.add((T) strategy).             } catch (ClassNotFoundException ex) {                 throw new BeanInitializationException("Could not find DispatcherServlet's default strategy class [" + className + "] for interface [" + key + "]", ex).             } catch (LinkageError err) {                 throw new BeanInitializationException("Unresolvable class definition for DispatcherServlet's default strategy class [" + className + "] for interface [" + key + "]", err).             }         }         return strategies.     } else {         return new LinkedList<>().     } }
true;protected;2;3;/**  * Create a default strategy.  * <p>The default implementation uses  * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean}.  * @param context the current WebApplicationContext  * @param clazz the strategy implementation class to instantiate  * @return the fully configured strategy instance  * @see org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean  */ ;/**  * Create a default strategy.  * <p>The default implementation uses  * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean}.  * @param context the current WebApplicationContext  * @param clazz the strategy implementation class to instantiate  * @return the fully configured strategy instance  * @see org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean  */ protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {     return context.getAutowireCapableBeanFactory().createBean(clazz). }
true;protected;2;45;/**  * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}  * for the actual dispatching.  */ ;/**  * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}  * for the actual dispatching.  */ @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {     logRequest(request).     // Keep a snapshot of the request attributes in case of an include,     // to be able to restore the original attributes after the include.     Map<String, Object> attributesSnapshot = null.     if (WebUtils.isIncludeRequest(request)) {         attributesSnapshot = new HashMap<>().         Enumeration<?> attrNames = request.getAttributeNames().         while (attrNames.hasMoreElements()) {             String attrName = (String) attrNames.nextElement().             if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {                 attributesSnapshot.put(attrName, request.getAttribute(attrName)).             }         }     }     // Make framework objects available to handlers and view objects.     request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()).     request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver).     request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver).     request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()).     if (this.flashMapManager != null) {         FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response).         if (inputFlashMap != null) {             request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)).         }         request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()).         request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager).     }     try {         doDispatch(request, response).     } finally {         if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {             // Restore the original attribute snapshot, in case of an include.             if (attributesSnapshot != null) {                 restoreAttributesAfterInclude(request, attributesSnapshot).             }         }     } }
false;private;1;32;;private void logRequest(HttpServletRequest request) {     LogFormatUtils.traceDebug(logger, traceOn -> {         String params.         if (isEnableLoggingRequestDetails()) {             params = request.getParameterMap().entrySet().stream().map(entry -> entry.getKey() + ":" + Arrays.toString(entry.getValue())).collect(Collectors.joining(", ")).         } else {             params = (request.getParameterMap().isEmpty() ? "" : "masked").         }         String query = StringUtils.isEmpty(request.getQueryString()) ? "" : "?" + request.getQueryString().         String dispatchType = (!request.getDispatcherType().equals(DispatcherType.REQUEST) ? "\"" + request.getDispatcherType().name() + "\" dispatch for " : "").         String message = (dispatchType + request.getMethod() + " \"" + getRequestUri(request) + query + "\", parameters={" + params + "}").         if (traceOn) {             List<String> values = Collections.list(request.getHeaderNames()).             String headers = values.size() > 0 ? "masked" : "".             if (isEnableLoggingRequestDetails()) {                 headers = values.stream().map(name -> name + ":" + Collections.list(request.getHeaders(name))).collect(Collectors.joining(", ")).             }             return message + ", headers={" + headers + "} in DispatcherServlet '" + getServletName() + "'".         } else {             return message.         }     }). }
true;protected;2;81;/**  * Process the actual dispatching to the handler.  * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.  * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters  * to find the first that supports the handler class.  * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers  * themselves to decide which methods are acceptable.  * @param request current HTTP request  * @param response current HTTP response  * @throws Exception in case of any kind of processing failure  */ ;/**  * Process the actual dispatching to the handler.  * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.  * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters  * to find the first that supports the handler class.  * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers  * themselves to decide which methods are acceptable.  * @param request current HTTP request  * @param response current HTTP response  * @throws Exception in case of any kind of processing failure  */ protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {     HttpServletRequest processedRequest = request.     HandlerExecutionChain mappedHandler = null.     boolean multipartRequestParsed = false.     WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request).     try {         ModelAndView mv = null.         Exception dispatchException = null.         try {             processedRequest = checkMultipart(request).             multipartRequestParsed = (processedRequest != request).             // Determine handler for the current request.             mappedHandler = getHandler(processedRequest).             if (mappedHandler == null) {                 noHandlerFound(processedRequest, response).                 return.             }             // Determine handler adapter for the current request.             HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()).             // Process last-modified header, if supported by the handler.             String method = request.getMethod().             boolean isGet = "GET".equals(method).             if (isGet || "HEAD".equals(method)) {                 long lastModified = ha.getLastModified(request, mappedHandler.getHandler()).                 if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {                     return.                 }             }             if (!mappedHandler.applyPreHandle(processedRequest, response)) {                 return.             }             // Actually invoke the handler.             mv = ha.handle(processedRequest, response, mappedHandler.getHandler()).             if (asyncManager.isConcurrentHandlingStarted()) {                 return.             }             applyDefaultViewName(processedRequest, mv).             mappedHandler.applyPostHandle(processedRequest, response, mv).         } catch (Exception ex) {             dispatchException = ex.         } catch (Throwable err) {             // As of 4.3, we're processing Errors thrown from handler methods as well,             // making them available for @ExceptionHandler methods and other scenarios.             dispatchException = new NestedServletException("Handler dispatch failed", err).         }         processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException).     } catch (Exception ex) {         triggerAfterCompletion(processedRequest, response, mappedHandler, ex).     } catch (Throwable err) {         triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", err)).     } finally {         if (asyncManager.isConcurrentHandlingStarted()) {             // Instead of postHandle and afterCompletion             if (mappedHandler != null) {                 mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response).             }         } else {             // Clean up any resources used by a multipart request.             if (multipartRequestParsed) {                 cleanupMultipart(processedRequest).             }         }     } }
true;private;2;8;/**  * Do we need view name translation?  */ ;/**  * Do we need view name translation?  */ private void applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) throws Exception {     if (mv != null && !mv.hasView()) {         String defaultViewName = getDefaultViewName(request).         if (defaultViewName != null) {             mv.setViewName(defaultViewName).         }     } }
true;private;5;40;/**  * Handle the result of handler selection and handler invocation, which is  * either a ModelAndView or an Exception to be resolved to a ModelAndView.  */ ;/**  * Handle the result of handler selection and handler invocation, which is  * either a ModelAndView or an Exception to be resolved to a ModelAndView.  */ private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception {     boolean errorView = false.     if (exception != null) {         if (exception instanceof ModelAndViewDefiningException) {             logger.debug("ModelAndViewDefiningException encountered", exception).             mv = ((ModelAndViewDefiningException) exception).getModelAndView().         } else {             Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null).             mv = processHandlerException(request, response, handler, exception).             errorView = (mv != null).         }     }     // Did the handler return a view to render?     if (mv != null && !mv.wasCleared()) {         render(mv, request, response).         if (errorView) {             WebUtils.clearErrorRequestAttributes(request).         }     } else {         if (logger.isTraceEnabled()) {             logger.trace("No view rendering, null ModelAndView returned.").         }     }     if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {         // Concurrent handling started during a forward         return.     }     if (mappedHandler != null) {         mappedHandler.triggerAfterCompletion(request, response, null).     } }
true;protected;1;10;/**  * Build a LocaleContext for the given request, exposing the request's primary locale as current locale.  * <p>The default implementation uses the dispatcher's LocaleResolver to obtain the current locale,  * which might change during a request.  * @param request current HTTP request  * @return the corresponding LocaleContext  */ ;/**  * Build a LocaleContext for the given request, exposing the request's primary locale as current locale.  * <p>The default implementation uses the dispatcher's LocaleResolver to obtain the current locale,  * which might change during a request.  * @param request current HTTP request  * @return the corresponding LocaleContext  */ @Override protected LocaleContext buildLocaleContext(final HttpServletRequest request) {     LocaleResolver lr = this.localeResolver.     if (lr instanceof LocaleContextResolver) {         return ((LocaleContextResolver) lr).resolveLocaleContext(request).     } else {         return () -> (lr != null ? lr.resolveLocale(request) : request.getLocale()).     } }
true;protected;1;29;/**  * Convert the request into a multipart request, and make multipart resolver available.  * <p>If no multipart resolver is set, simply use the existing request.  * @param request current HTTP request  * @return the processed request (multipart wrapper if necessary)  * @see MultipartResolver#resolveMultipart  */ ;/**  * Convert the request into a multipart request, and make multipart resolver available.  * <p>If no multipart resolver is set, simply use the existing request.  * @param request current HTTP request  * @return the processed request (multipart wrapper if necessary)  * @see MultipartResolver#resolveMultipart  */ protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {     if (this.multipartResolver != null && this.multipartResolver.isMultipart(request)) {         if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {             if (request.getDispatcherType().equals(DispatcherType.REQUEST)) {                 logger.trace("Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter").             }         } else if (hasMultipartException(request)) {             logger.debug("Multipart resolution previously failed for current request - " + "skipping re-resolution for undisturbed error rendering").         } else {             try {                 return this.multipartResolver.resolveMultipart(request).             } catch (MultipartException ex) {                 if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {                     logger.debug("Multipart resolution failed for error dispatch", ex).                 // Keep processing error dispatch with regular request handle below                 } else {                     throw ex.                 }             }         }     }     // If not returned before: return original request.     return request. }
true;private;1;10;/**  * Check "javax.servlet.error.exception" attribute for a multipart exception.  */ ;/**  * Check "javax.servlet.error.exception" attribute for a multipart exception.  */ private boolean hasMultipartException(HttpServletRequest request) {     Throwable error = (Throwable) request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE).     while (error != null) {         if (error instanceof MultipartException) {             return true.         }         error = error.getCause().     }     return false. }
true;protected;1;9;/**  * Clean up any resources used by the given multipart request (if any).  * @param request current HTTP request  * @see MultipartResolver#cleanupMultipart  */ ;/**  * Clean up any resources used by the given multipart request (if any).  * @param request current HTTP request  * @see MultipartResolver#cleanupMultipart  */ protected void cleanupMultipart(HttpServletRequest request) {     if (this.multipartResolver != null) {         MultipartHttpServletRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class).         if (multipartRequest != null) {             this.multipartResolver.cleanupMultipart(multipartRequest).         }     } }
true;protected;1;12;/**  * Return the HandlerExecutionChain for this request.  * <p>Tries all handler mappings in order.  * @param request current HTTP request  * @return the HandlerExecutionChain, or {@code null} if no handler could be found  */ ;/**  * Return the HandlerExecutionChain for this request.  * <p>Tries all handler mappings in order.  * @param request current HTTP request  * @return the HandlerExecutionChain, or {@code null} if no handler could be found  */ @Nullable protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {     if (this.handlerMappings != null) {         for (HandlerMapping mapping : this.handlerMappings) {             HandlerExecutionChain handler = mapping.getHandler(request).             if (handler != null) {                 return handler.             }         }     }     return null. }
true;protected;2;12;/**  * No handler found -> set appropriate HTTP response status.  * @param request current HTTP request  * @param response current HTTP response  * @throws Exception if preparing the response failed  */ ;/**  * No handler found -> set appropriate HTTP response status.  * @param request current HTTP request  * @param response current HTTP response  * @throws Exception if preparing the response failed  */ protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {     if (pageNotFoundLogger.isWarnEnabled()) {         pageNotFoundLogger.warn("No mapping for " + request.getMethod() + " " + getRequestUri(request)).     }     if (this.throwExceptionIfNoHandlerFound) {         throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request), new ServletServerHttpRequest(request).getHeaders()).     } else {         response.sendError(HttpServletResponse.SC_NOT_FOUND).     } }
true;protected;1;11;/**  * Return the HandlerAdapter for this handler object.  * @param handler the handler object to find an adapter for  * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.  */ ;/**  * Return the HandlerAdapter for this handler object.  * @param handler the handler object to find an adapter for  * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.  */ protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {     if (this.handlerAdapters != null) {         for (HandlerAdapter adapter : this.handlerAdapters) {             if (adapter.supports(handler)) {                 return adapter.             }         }     }     throw new ServletException("No adapter for handler [" + handler + "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"). }
true;protected;4;41;/**  * Determine an error ModelAndView via the registered HandlerExceptionResolvers.  * @param request current HTTP request  * @param response current HTTP response  * @param handler the executed handler, or {@code null} if none chosen at the time of the exception  * (for example, if multipart resolution failed)  * @param ex the exception that got thrown during handler execution  * @return a corresponding ModelAndView to forward to  * @throws Exception if no error ModelAndView found  */ ;/**  * Determine an error ModelAndView via the registered HandlerExceptionResolvers.  * @param request current HTTP request  * @param response current HTTP response  * @param handler the executed handler, or {@code null} if none chosen at the time of the exception  * (for example, if multipart resolution failed)  * @param ex the exception that got thrown during handler execution  * @return a corresponding ModelAndView to forward to  * @throws Exception if no error ModelAndView found  */ @Nullable protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {     // Success and error responses may use different content types     request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE).     // Check registered HandlerExceptionResolvers...     ModelAndView exMv = null.     if (this.handlerExceptionResolvers != null) {         for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {             exMv = resolver.resolveException(request, response, handler, ex).             if (exMv != null) {                 break.             }         }     }     if (exMv != null) {         if (exMv.isEmpty()) {             request.setAttribute(EXCEPTION_ATTRIBUTE, ex).             return null.         }         // We might still need view name translation for a plain error model...         if (!exMv.hasView()) {             String defaultViewName = getDefaultViewName(request).             if (defaultViewName != null) {                 exMv.setViewName(defaultViewName).             }         }         if (logger.isTraceEnabled()) {             logger.trace("Using resolved error view: " + exMv, ex).         }         if (logger.isDebugEnabled()) {             logger.debug("Using resolved error view: " + exMv).         }         WebUtils.exposeErrorRequestAttributes(request, ex, getServletName()).         return exMv.     }     throw ex. }
true;protected;3;42;/**  * Render the given ModelAndView.  * <p>This is the last stage in handling a request. It may involve resolving the view by name.  * @param mv the ModelAndView to render  * @param request current HTTP servlet request  * @param response current HTTP servlet response  * @throws ServletException if view is missing or cannot be resolved  * @throws Exception if there's a problem rendering the view  */ ;/**  * Render the given ModelAndView.  * <p>This is the last stage in handling a request. It may involve resolving the view by name.  * @param mv the ModelAndView to render  * @param request current HTTP servlet request  * @param response current HTTP servlet response  * @throws ServletException if view is missing or cannot be resolved  * @throws Exception if there's a problem rendering the view  */ protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {     // Determine locale for request and apply it to the response.     Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()).     response.setLocale(locale).     View view.     String viewName = mv.getViewName().     if (viewName != null) {         // We need to resolve the view name.         view = resolveViewName(viewName, mv.getModelInternal(), locale, request).         if (view == null) {             throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + getServletName() + "'").         }     } else {         // No need to lookup: the ModelAndView object contains the actual View object.         view = mv.getView().         if (view == null) {             throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " + "View object in servlet with name '" + getServletName() + "'").         }     }     // Delegate to the View object for rendering.     if (logger.isTraceEnabled()) {         logger.trace("Rendering view [" + view + "] ").     }     try {         if (mv.getStatus() != null) {             response.setStatus(mv.getStatus().value()).         }         view.render(mv.getModelInternal(), request, response).     } catch (Exception ex) {         if (logger.isDebugEnabled()) {             logger.debug("Error rendering view [" + view + "]", ex).         }         throw ex.     } }
true;protected;1;4;/**  * Translate the supplied request into a default view name.  * @param request current HTTP servlet request  * @return the view name (or {@code null} if no default found)  * @throws Exception if view name translation failed  */ ;/**  * Translate the supplied request into a default view name.  * @param request current HTTP servlet request  * @return the view name (or {@code null} if no default found)  * @throws Exception if view name translation failed  */ @Nullable protected String getDefaultViewName(HttpServletRequest request) throws Exception {     return (this.viewNameTranslator != null ? this.viewNameTranslator.getViewName(request) : null). }
true;protected;4;14;/**  * Resolve the given view name into a View object (to be rendered).  * <p>The default implementations asks all ViewResolvers of this dispatcher.  * Can be overridden for custom resolution strategies, potentially based on  * specific model attributes or request parameters.  * @param viewName the name of the view to resolve  * @param model the model to be passed to the view  * @param locale the current locale  * @param request current HTTP servlet request  * @return the View object, or {@code null} if none found  * @throws Exception if the view cannot be resolved  * (typically in case of problems creating an actual View object)  * @see ViewResolver#resolveViewName  */ ;/**  * Resolve the given view name into a View object (to be rendered).  * <p>The default implementations asks all ViewResolvers of this dispatcher.  * Can be overridden for custom resolution strategies, potentially based on  * specific model attributes or request parameters.  * @param viewName the name of the view to resolve  * @param model the model to be passed to the view  * @param locale the current locale  * @param request current HTTP servlet request  * @return the View object, or {@code null} if none found  * @throws Exception if the view cannot be resolved  * (typically in case of problems creating an actual View object)  * @see ViewResolver#resolveViewName  */ @Nullable protected View resolveViewName(String viewName, @Nullable Map<String, Object> model, Locale locale, HttpServletRequest request) throws Exception {     if (this.viewResolvers != null) {         for (ViewResolver viewResolver : this.viewResolvers) {             View view = viewResolver.resolveViewName(viewName, locale).             if (view != null) {                 return view.             }         }     }     return null. }
false;private;4;8;;private void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, Exception ex) throws Exception {     if (mappedHandler != null) {         mappedHandler.triggerAfterCompletion(request, response, ex).     }     throw ex. }
true;private;2;28;/**  * Restore the request attributes after an include.  * @param request current HTTP request  * @param attributesSnapshot the snapshot of the request attributes before the include  */ ;/**  * Restore the request attributes after an include.  * @param request current HTTP request  * @param attributesSnapshot the snapshot of the request attributes before the include  */ @SuppressWarnings("unchecked") private void restoreAttributesAfterInclude(HttpServletRequest request, Map<?, ?> attributesSnapshot) {     // Need to copy into separate Collection here, to avoid side effects     // on the Enumeration when removing attributes.     Set<String> attrsToCheck = new HashSet<>().     Enumeration<?> attrNames = request.getAttributeNames().     while (attrNames.hasMoreElements()) {         String attrName = (String) attrNames.nextElement().         if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {             attrsToCheck.add(attrName).         }     }     // Add attributes that may have been removed     attrsToCheck.addAll((Set<String>) attributesSnapshot.keySet()).     // or removing the attribute, respectively, if appropriate.     for (String attrName : attrsToCheck) {         Object attrValue = attributesSnapshot.get(attrName).         if (attrValue == null) {             request.removeAttribute(attrName).         } else if (attrValue != request.getAttribute(attrName)) {             request.setAttribute(attrName, attrValue).         }     } }
false;private,static;1;7;;private static String getRequestUri(HttpServletRequest request) {     String uri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE).     if (uri == null) {         uri = request.getRequestURI().     }     return uri. }
