commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the {@link ContentNegotiationManager} to use to determine requested media types.  * <p>If not set, ContentNegotiationManager's default constructor will be used,  * applying a {@link org.springframework.web.accept.HeaderContentNegotiationStrategy}.  * @see ContentNegotiationManager#ContentNegotiationManager()  */ ;/**  * Set the {@link ContentNegotiationManager} to use to determine requested media types.  * <p>If not set, ContentNegotiationManager's default constructor will be used,  * applying a {@link org.springframework.web.accept.HeaderContentNegotiationStrategy}.  * @see ContentNegotiationManager#ContentNegotiationManager()  */ public void setContentNegotiationManager(@Nullable ContentNegotiationManager contentNegotiationManager) {     this.contentNegotiationManager = contentNegotiationManager. }
true;public;0;4;/**  * Return the {@link ContentNegotiationManager} to use to determine requested media types.  * @since 4.1.9  */ ;/**  * Return the {@link ContentNegotiationManager} to use to determine requested media types.  * @since 4.1.9  */ @Nullable public ContentNegotiationManager getContentNegotiationManager() {     return this.contentNegotiationManager. }
true;public;1;3;/**  * Indicate whether a {@link HttpServletResponse#SC_NOT_ACCEPTABLE 406 Not Acceptable}  * status code should be returned if no suitable view can be found.  * <p>Default is {@code false}, meaning that this view resolver returns {@code null} for  * {@link #resolveViewName(String, Locale)} when an acceptable view cannot be found.  * This will allow for view resolvers chaining. When this property is set to {@code true},  * {@link #resolveViewName(String, Locale)} will respond with a view that sets the  * response status to {@code 406 Not Acceptable} instead.  */ ;/**  * Indicate whether a {@link HttpServletResponse#SC_NOT_ACCEPTABLE 406 Not Acceptable}  * status code should be returned if no suitable view can be found.  * <p>Default is {@code false}, meaning that this view resolver returns {@code null} for  * {@link #resolveViewName(String, Locale)} when an acceptable view cannot be found.  * This will allow for view resolvers chaining. When this property is set to {@code true},  * {@link #resolveViewName(String, Locale)} will respond with a view that sets the  * response status to {@code 406 Not Acceptable} instead.  */ public void setUseNotAcceptableStatusCode(boolean useNotAcceptableStatusCode) {     this.useNotAcceptableStatusCode = useNotAcceptableStatusCode. }
true;public;0;3;/**  * Whether to return HTTP Status 406 if no suitable is found.  */ ;/**  * Whether to return HTTP Status 406 if no suitable is found.  */ public boolean isUseNotAcceptableStatusCode() {     return this.useNotAcceptableStatusCode. }
true;public;1;3;/**  * Set the default views to use when a more specific view can not be obtained  * from the {@link ViewResolver} chain.  */ ;/**  * Set the default views to use when a more specific view can not be obtained  * from the {@link ViewResolver} chain.  */ public void setDefaultViews(List<View> defaultViews) {     this.defaultViews = defaultViews. }
false;public;0;4;;public List<View> getDefaultViews() {     return (this.defaultViews != null ? Collections.unmodifiableList(this.defaultViews) : Collections.emptyList()). }
true;public;1;3;/**  * Sets the view resolvers to be wrapped by this view resolver.  * <p>If this property is not set, view resolvers will be detected automatically.  */ ;/**  * Sets the view resolvers to be wrapped by this view resolver.  * <p>If this property is not set, view resolvers will be detected automatically.  */ public void setViewResolvers(List<ViewResolver> viewResolvers) {     this.viewResolvers = viewResolvers. }
false;public;0;4;;public List<ViewResolver> getViewResolvers() {     return (this.viewResolvers != null ? Collections.unmodifiableList(this.viewResolvers) : Collections.emptyList()). }
false;public;1;3;;public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;protected;1;26;;@Override protected void initServletContext(ServletContext servletContext) {     Collection<ViewResolver> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values().     if (this.viewResolvers == null) {         this.viewResolvers = new ArrayList<>(matchingBeans.size()).         for (ViewResolver viewResolver : matchingBeans) {             if (this != viewResolver) {                 this.viewResolvers.add(viewResolver).             }         }     } else {         for (int i = 0. i < this.viewResolvers.size(). i++) {             ViewResolver vr = this.viewResolvers.get(i).             if (matchingBeans.contains(vr)) {                 continue.             }             String name = vr.getClass().getName() + i.             obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name).         }     }     AnnotationAwareOrderComparator.sort(this.viewResolvers).     this.cnmFactoryBean.setServletContext(servletContext). }
false;public;0;9;;@Override public void afterPropertiesSet() {     if (this.contentNegotiationManager == null) {         this.contentNegotiationManager = this.cnmFactoryBean.build().     }     if (this.viewResolvers == null || this.viewResolvers.isEmpty()) {         logger.warn("No ViewResolvers configured").     } }
false;public;2;28;;@Override @Nullable public View resolveViewName(String viewName, Locale locale) throws Exception {     RequestAttributes attrs = RequestContextHolder.getRequestAttributes().     Assert.state(attrs instanceof ServletRequestAttributes, "No current ServletRequestAttributes").     List<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest()).     if (requestedMediaTypes != null) {         List<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes).         View bestView = getBestView(candidateViews, requestedMediaTypes, attrs).         if (bestView != null) {             return bestView.         }     }     String mediaTypeInfo = logger.isDebugEnabled() && requestedMediaTypes != null ? " given " + requestedMediaTypes.toString() : "".     if (this.useNotAcceptableStatusCode) {         if (logger.isDebugEnabled()) {             logger.debug("Using 406 NOT_ACCEPTABLE" + mediaTypeInfo).         }         return NOT_ACCEPTABLE_VIEW.     } else {         logger.debug("View remains unresolved" + mediaTypeInfo).         return null.     } }
true;protected;1;26;/**  * Determines the list of {@link MediaType} for the given {@link HttpServletRequest}.  * @param request the current servlet request  * @return the list of media types requested, if any  */ ;/**  * Determines the list of {@link MediaType} for the given {@link HttpServletRequest}.  * @param request the current servlet request  * @return the list of media types requested, if any  */ @Nullable protected List<MediaType> getMediaTypes(HttpServletRequest request) {     Assert.state(this.contentNegotiationManager != null, "No ContentNegotiationManager set").     try {         ServletWebRequest webRequest = new ServletWebRequest(request).         List<MediaType> acceptableMediaTypes = this.contentNegotiationManager.resolveMediaTypes(webRequest).         List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request).         Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>().         for (MediaType acceptable : acceptableMediaTypes) {             for (MediaType producible : producibleMediaTypes) {                 if (acceptable.isCompatibleWith(producible)) {                     compatibleMediaTypes.add(getMostSpecificMediaType(acceptable, producible)).                 }             }         }         List<MediaType> selectedMediaTypes = new ArrayList<>(compatibleMediaTypes).         MediaType.sortBySpecificityAndQuality(selectedMediaTypes).         return selectedMediaTypes.     } catch (HttpMediaTypeNotAcceptableException ex) {         if (logger.isDebugEnabled()) {             logger.debug(ex.getMessage()).         }         return null.     } }
false;private;1;11;;@SuppressWarnings("unchecked") private List<MediaType> getProducibleMediaTypes(HttpServletRequest request) {     Set<MediaType> mediaTypes = (Set<MediaType>) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE).     if (!CollectionUtils.isEmpty(mediaTypes)) {         return new ArrayList<>(mediaTypes).     } else {         return Collections.singletonList(MediaType.ALL).     } }
true;private;2;4;/**  * Return the more specific of the acceptable and the producible media types  * with the q-value of the former.  */ ;/**  * Return the more specific of the acceptable and the producible media types  * with the q-value of the former.  */ private MediaType getMostSpecificMediaType(MediaType acceptType, MediaType produceType) {     produceType = produceType.copyQualityValue(acceptType).     return (MediaType.SPECIFICITY_COMPARATOR.compare(acceptType, produceType) < 0 ? acceptType : produceType). }
false;private;3;28;;private List<View> getCandidateViews(String viewName, Locale locale, List<MediaType> requestedMediaTypes) throws Exception {     List<View> candidateViews = new ArrayList<>().     if (this.viewResolvers != null) {         Assert.state(this.contentNegotiationManager != null, "No ContentNegotiationManager set").         for (ViewResolver viewResolver : this.viewResolvers) {             View view = viewResolver.resolveViewName(viewName, locale).             if (view != null) {                 candidateViews.add(view).             }             for (MediaType requestedMediaType : requestedMediaTypes) {                 List<String> extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType).                 for (String extension : extensions) {                     String viewNameWithExtension = viewName + '.' + extension.                     view = viewResolver.resolveViewName(viewNameWithExtension, locale).                     if (view != null) {                         candidateViews.add(view).                     }                 }             }         }     }     if (!CollectionUtils.isEmpty(this.defaultViews)) {         candidateViews.addAll(this.defaultViews).     }     return candidateViews. }
false;private;3;26;;@Nullable private View getBestView(List<View> candidateViews, List<MediaType> requestedMediaTypes, RequestAttributes attrs) {     for (View candidateView : candidateViews) {         if (candidateView instanceof SmartView) {             SmartView smartView = (SmartView) candidateView.             if (smartView.isRedirectView()) {                 return candidateView.             }         }     }     for (MediaType mediaType : requestedMediaTypes) {         for (View candidateView : candidateViews) {             if (StringUtils.hasText(candidateView.getContentType())) {                 MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType()).                 if (mediaType.isCompatibleWith(candidateContentType)) {                     if (logger.isDebugEnabled()) {                         logger.debug("Selected '" + mediaType + "' given " + requestedMediaTypes).                     }                     attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, RequestAttributes.SCOPE_REQUEST).                     return candidateView.                 }             }         }     }     return null. }
false;public;0;5;;@Override @Nullable public String getContentType() {     return null. }
false;public;3;4;;@Override public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {     response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE). }
