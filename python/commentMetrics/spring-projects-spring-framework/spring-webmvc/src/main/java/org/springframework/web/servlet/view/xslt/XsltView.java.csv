commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the XSLT TransformerFactory class to use.  * <p>The default constructor of the specified class will be called  * to build the TransformerFactory for this view.  */ ;/**  * Specify the XSLT TransformerFactory class to use.  * <p>The default constructor of the specified class will be called  * to build the TransformerFactory for this view.  */ public void setTransformerFactoryClass(Class<? extends TransformerFactory> transformerFactoryClass) {     this.transformerFactoryClass = transformerFactoryClass. }
true;public;1;3;/**  * Set the name of the model attribute that represents the XSLT Source.  * If not specified, the model map will be searched for a matching value type.  * <p>The following source types are supported out of the box:  * {@link Source}, {@link Document}, {@link Node}, {@link Reader},  * {@link InputStream} and {@link Resource}.  * @see #getSourceTypes  * @see #convertSource  */ ;/**  * Set the name of the model attribute that represents the XSLT Source.  * If not specified, the model map will be searched for a matching value type.  * <p>The following source types are supported out of the box:  * {@link Source}, {@link Document}, {@link Node}, {@link Reader},  * {@link InputStream} and {@link Resource}.  * @see #getSourceTypes  * @see #convertSource  */ public void setSourceKey(String sourceKey) {     this.sourceKey = sourceKey. }
true;public;1;3;/**  * Set the URIResolver used in the transform.  * <p>The URIResolver handles calls to the XSLT {@code document()} function.  */ ;/**  * Set the URIResolver used in the transform.  * <p>The URIResolver handles calls to the XSLT {@code document()} function.  */ public void setUriResolver(URIResolver uriResolver) {     this.uriResolver = uriResolver. }
true;public;1;3;/**  * Set an implementation of the {@link javax.xml.transform.ErrorListener}  * interface for custom handling of transformation errors and warnings.  * <p>If not set, a default  * {@link org.springframework.util.xml.SimpleTransformErrorListener} is  * used that simply logs warnings using the logger instance of the view class,  * and rethrows errors to discontinue the XML transformation.  * @see org.springframework.util.xml.SimpleTransformErrorListener  */ ;/**  * Set an implementation of the {@link javax.xml.transform.ErrorListener}  * interface for custom handling of transformation errors and warnings.  * <p>If not set, a default  * {@link org.springframework.util.xml.SimpleTransformErrorListener} is  * used that simply logs warnings using the logger instance of the view class,  * and rethrows errors to discontinue the XML transformation.  * @see org.springframework.util.xml.SimpleTransformErrorListener  */ public void setErrorListener(@Nullable ErrorListener errorListener) {     this.errorListener = (errorListener != null ? errorListener : new SimpleTransformErrorListener(logger)). }
true;public;1;3;/**  * Set whether the XSLT transformer may add additional whitespace when  * outputting the result tree.  * <p>Default is {@code true} (on). set this to {@code false} (off)  * to not specify an "indent" key, leaving the choice up to the stylesheet.  * @see javax.xml.transform.OutputKeys#INDENT  */ ;/**  * Set whether the XSLT transformer may add additional whitespace when  * outputting the result tree.  * <p>Default is {@code true} (on). set this to {@code false} (off)  * to not specify an "indent" key, leaving the choice up to the stylesheet.  * @see javax.xml.transform.OutputKeys#INDENT  */ public void setIndent(boolean indent) {     this.indent = indent. }
true;public;1;3;/**  * Set arbitrary transformer output properties to be applied to the stylesheet.  * <p>Any values specified here will override defaults that this view sets  * programmatically.  * @see javax.xml.transform.Transformer#setOutputProperty  */ ;/**  * Set arbitrary transformer output properties to be applied to the stylesheet.  * <p>Any values specified here will override defaults that this view sets  * programmatically.  * @see javax.xml.transform.Transformer#setOutputProperty  */ public void setOutputProperties(Properties outputProperties) {     this.outputProperties = outputProperties. }
true;public;1;3;/**  * Turn on/off the caching of the XSLT {@link Templates} instance.  * <p>The default value is "true". Only set this to "false" in development,  * where caching does not seriously impact performance.  */ ;/**  * Turn on/off the caching of the XSLT {@link Templates} instance.  * <p>The default value is "true". Only set this to "false" in development,  * where caching does not seriously impact performance.  */ public void setCacheTemplates(boolean cacheTemplates) {     this.cacheTemplates = cacheTemplates. }
true;protected;0;11;/**  * Initialize this XsltView's TransformerFactory.  */ ;/**  * Initialize this XsltView's TransformerFactory.  */ @Override protected void initApplicationContext() throws BeansException {     this.transformerFactory = newTransformerFactory(this.transformerFactoryClass).     this.transformerFactory.setErrorListener(this.errorListener).     if (this.uriResolver != null) {         this.transformerFactory.setURIResolver(this.uriResolver).     }     if (this.cacheTemplates) {         this.cachedTemplates = loadTemplates().     } }
true;protected;1;15;/**  * Instantiate a new TransformerFactory for this view.  * <p>The default implementation simply calls  * {@link javax.xml.transform.TransformerFactory#newInstance()}.  * If a {@link #setTransformerFactoryClass "transformerFactoryClass"}  * has been specified explicitly, the default constructor of the  * specified class will be called instead.  * <p>Can be overridden in subclasses.  * @param transformerFactoryClass the specified factory class (if any)  * @return the new TransactionFactory instance  * @see #setTransformerFactoryClass  * @see #getTransformerFactory()  */ ;/**  * Instantiate a new TransformerFactory for this view.  * <p>The default implementation simply calls  * {@link javax.xml.transform.TransformerFactory#newInstance()}.  * If a {@link #setTransformerFactoryClass "transformerFactoryClass"}  * has been specified explicitly, the default constructor of the  * specified class will be called instead.  * <p>Can be overridden in subclasses.  * @param transformerFactoryClass the specified factory class (if any)  * @return the new TransactionFactory instance  * @see #setTransformerFactoryClass  * @see #getTransformerFactory()  */ protected TransformerFactory newTransformerFactory(@Nullable Class<? extends TransformerFactory> transformerFactoryClass) {     if (transformerFactoryClass != null) {         try {             return ReflectionUtils.accessibleConstructor(transformerFactoryClass).newInstance().         } catch (Exception ex) {             throw new TransformerFactoryConfigurationError(ex, "Could not instantiate TransformerFactory").         }     } else {         return TransformerFactory.newInstance().     } }
true;protected,final;0;4;/**  * Return the TransformerFactory that this XsltView uses.  * @return the TransformerFactory (never {@code null})  */ ;/**  * Return the TransformerFactory that this XsltView uses.  * @return the TransformerFactory (never {@code null})  */ protected final TransformerFactory getTransformerFactory() {     Assert.state(this.transformerFactory != null, "No TransformerFactory available").     return this.transformerFactory. }
false;protected;3;25;;@Override protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {     Templates templates = this.cachedTemplates.     if (templates == null) {         templates = loadTemplates().     }     Transformer transformer = createTransformer(templates).     configureTransformer(model, response, transformer).     configureResponse(model, response, transformer).     Source source = null.     try {         source = locateSource(model).         if (source == null) {             throw new IllegalArgumentException("Unable to locate Source object in model: " + model).         }         transformer.transform(source, createResult(response)).     } finally {         closeSourceIfNecessary(source).     } }
true;protected;1;3;/**  * Create the XSLT {@link Result} used to render the result of the transformation.  * <p>The default implementation creates a {@link StreamResult} wrapping the supplied  * HttpServletResponse's {@link HttpServletResponse#getOutputStream() OutputStream}.  * @param response current HTTP response  * @return the XSLT Result to use  * @throws Exception if the Result cannot be built  */ ;/**  * Create the XSLT {@link Result} used to render the result of the transformation.  * <p>The default implementation creates a {@link StreamResult} wrapping the supplied  * HttpServletResponse's {@link HttpServletResponse#getOutputStream() OutputStream}.  * @param response current HTTP response  * @return the XSLT Result to use  * @throws Exception if the Result cannot be built  */ protected Result createResult(HttpServletResponse response) throws Exception {     return new StreamResult(response.getOutputStream()). }
true;protected;1;8;/**  * <p>Locate the {@link Source} object in the supplied model,  * converting objects as required.  * The default implementation first attempts to look under the configured  * {@link #setSourceKey source key}, if any, before attempting to locate  * an object of {@link #getSourceTypes() supported type}.  * @param model the merged model Map  * @return the XSLT Source object (or {@code null} if none found)  * @throws Exception if an error occurred during locating the source  * @see #setSourceKey  * @see #convertSource  */ ;/**  * <p>Locate the {@link Source} object in the supplied model,  * converting objects as required.  * The default implementation first attempts to look under the configured  * {@link #setSourceKey source key}, if any, before attempting to locate  * an object of {@link #getSourceTypes() supported type}.  * @param model the merged model Map  * @return the XSLT Source object (or {@code null} if none found)  * @throws Exception if an error occurred during locating the source  * @see #setSourceKey  * @see #convertSource  */ @Nullable protected Source locateSource(Map<String, Object> model) throws Exception {     if (this.sourceKey != null) {         return convertSource(model.get(this.sourceKey)).     }     Object source = CollectionUtils.findValueOfType(model.values(), getSourceTypes()).     return (source != null ? convertSource(source) : null). }
true;protected;0;3;/**  * Return the array of {@link Class Classes} that are supported when converting to an  * XSLT {@link Source}.  * <p>Currently supports {@link Source}, {@link Document}, {@link Node},  * {@link Reader}, {@link InputStream} and {@link Resource}.  * @return the supported source types  */ ;/**  * Return the array of {@link Class Classes} that are supported when converting to an  * XSLT {@link Source}.  * <p>Currently supports {@link Source}, {@link Document}, {@link Node},  * {@link Reader}, {@link InputStream} and {@link Resource}.  * @return the supported source types  */ protected Class<?>[] getSourceTypes() {     return new Class<?>[] { Source.class, Document.class, Node.class, Reader.class, InputStream.class, Resource.class }. }
true;protected;1;24;/**  * Convert the supplied {@link Object} into an XSLT {@link Source} if the  * {@link Object} type is {@link #getSourceTypes() supported}.  * @param source the original source object  * @return the adapted XSLT Source  * @throws IllegalArgumentException if the given Object is not of a supported type  */ ;/**  * Convert the supplied {@link Object} into an XSLT {@link Source} if the  * {@link Object} type is {@link #getSourceTypes() supported}.  * @param source the original source object  * @return the adapted XSLT Source  * @throws IllegalArgumentException if the given Object is not of a supported type  */ protected Source convertSource(Object source) throws Exception {     if (source instanceof Source) {         return (Source) source.     } else if (source instanceof Document) {         return new DOMSource(((Document) source).getDocumentElement()).     } else if (source instanceof Node) {         return new DOMSource((Node) source).     } else if (source instanceof Reader) {         return new StreamSource((Reader) source).     } else if (source instanceof InputStream) {         return new StreamSource((InputStream) source).     } else if (source instanceof Resource) {         Resource resource = (Resource) source.         return new StreamSource(resource.getInputStream(), resource.getURI().toASCIIString()).     } else {         throw new IllegalArgumentException("Value '" + source + "' cannot be converted to XSLT Source").     } }
true;protected;3;7;/**  * Configure the supplied {@link Transformer} instance.  * <p>The default implementation copies parameters from the model into the  * Transformer's {@link Transformer#setParameter parameter set}.  * This implementation also copies the {@link #setOutputProperties output properties}  * into the {@link Transformer} {@link Transformer#setOutputProperty output properties}.  * Indentation properties are set as well.  * @param model merged output Map (never {@code null})  * @param response current HTTP response  * @param transformer the target transformer  * @see #copyModelParameters(Map, Transformer)  * @see #copyOutputProperties(Transformer)  * @see #configureIndentation(Transformer)  */ ;/**  * Configure the supplied {@link Transformer} instance.  * <p>The default implementation copies parameters from the model into the  * Transformer's {@link Transformer#setParameter parameter set}.  * This implementation also copies the {@link #setOutputProperties output properties}  * into the {@link Transformer} {@link Transformer#setOutputProperty output properties}.  * Indentation properties are set as well.  * @param model merged output Map (never {@code null})  * @param response current HTTP response  * @param transformer the target transformer  * @see #copyModelParameters(Map, Transformer)  * @see #copyOutputProperties(Transformer)  * @see #configureIndentation(Transformer)  */ protected void configureTransformer(Map<String, Object> model, HttpServletResponse response, Transformer transformer) {     copyModelParameters(model, transformer).     copyOutputProperties(transformer).     configureIndentation(transformer). }
true;protected,final;1;8;/**  * Configure the indentation settings for the supplied {@link Transformer}.  * @param transformer the target transformer  * @see org.springframework.util.xml.TransformerUtils#enableIndenting(javax.xml.transform.Transformer)  * @see org.springframework.util.xml.TransformerUtils#disableIndenting(javax.xml.transform.Transformer)  */ ;/**  * Configure the indentation settings for the supplied {@link Transformer}.  * @param transformer the target transformer  * @see org.springframework.util.xml.TransformerUtils#enableIndenting(javax.xml.transform.Transformer)  * @see org.springframework.util.xml.TransformerUtils#disableIndenting(javax.xml.transform.Transformer)  */ protected final void configureIndentation(Transformer transformer) {     if (this.indent) {         TransformerUtils.enableIndenting(transformer).     } else {         TransformerUtils.disableIndenting(transformer).     } }
true;protected,final;1;9;/**  * Copy the configured output {@link Properties}, if any, into the  * {@link Transformer#setOutputProperty output property set} of the supplied  * {@link Transformer}.  * @param transformer the target transformer  */ ;/**  * Copy the configured output {@link Properties}, if any, into the  * {@link Transformer#setOutputProperty output property set} of the supplied  * {@link Transformer}.  * @param transformer the target transformer  */ protected final void copyOutputProperties(Transformer transformer) {     if (this.outputProperties != null) {         Enumeration<?> en = this.outputProperties.propertyNames().         while (en.hasMoreElements()) {             String name = (String) en.nextElement().             transformer.setOutputProperty(name, this.outputProperties.getProperty(name)).         }     } }
true;protected,final;2;3;/**  * Copy all entries from the supplied Map into the  * {@link Transformer#setParameter(String, Object) parameter set}  * of the supplied {@link Transformer}.  * @param model merged output Map (never {@code null})  * @param transformer the target transformer  */ ;/**  * Copy all entries from the supplied Map into the  * {@link Transformer#setParameter(String, Object) parameter set}  * of the supplied {@link Transformer}.  * @param model merged output Map (never {@code null})  * @param transformer the target transformer  */ protected final void copyModelParameters(Map<String, Object> model, Transformer transformer) {     model.forEach(transformer::setParameter). }
true;protected;3;15;/**  * Configure the supplied {@link HttpServletResponse}.  * <p>The default implementation of this method sets the  * {@link HttpServletResponse#setContentType content type} and  * {@link HttpServletResponse#setCharacterEncoding encoding}  * from the "media-type" and "encoding" output properties  * specified in the {@link Transformer}.  * @param model merged output Map (never {@code null})  * @param response current HTTP response  * @param transformer the target transformer  */ ;/**  * Configure the supplied {@link HttpServletResponse}.  * <p>The default implementation of this method sets the  * {@link HttpServletResponse#setContentType content type} and  * {@link HttpServletResponse#setCharacterEncoding encoding}  * from the "media-type" and "encoding" output properties  * specified in the {@link Transformer}.  * @param model merged output Map (never {@code null})  * @param response current HTTP response  * @param transformer the target transformer  */ protected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer) {     String contentType = getContentType().     String mediaType = transformer.getOutputProperty(OutputKeys.MEDIA_TYPE).     String encoding = transformer.getOutputProperty(OutputKeys.ENCODING).     if (StringUtils.hasText(mediaType)) {         contentType = mediaType.     }     if (StringUtils.hasText(encoding)) {         // Only apply encoding if content type is specified but does not contain charset clause already.         if (contentType != null && !contentType.toLowerCase().contains(WebUtils.CONTENT_TYPE_CHARSET_PREFIX)) {             contentType = contentType + WebUtils.CONTENT_TYPE_CHARSET_PREFIX + encoding.         }     }     response.setContentType(contentType). }
true;private;0;13;/**  * Load the {@link Templates} instance for the stylesheet at the configured location.  */ ;/**  * Load the {@link Templates} instance for the stylesheet at the configured location.  */ private Templates loadTemplates() throws ApplicationContextException {     Source stylesheetSource = getStylesheetSource().     try {         Templates templates = getTransformerFactory().newTemplates(stylesheetSource).         return templates.     } catch (TransformerConfigurationException ex) {         throw new ApplicationContextException("Can't load stylesheet from '" + getUrl() + "'", ex).     } finally {         closeSourceIfNecessary(stylesheetSource).     } }
true;protected;1;7;/**  * Create the {@link Transformer} instance used to prefer the XSLT transformation.  * <p>The default implementation simply calls {@link Templates#newTransformer()}, and  * configures the {@link Transformer} with the custom {@link URIResolver} if specified.  * @param templates the XSLT Templates instance to create a Transformer for  * @return the Transformer object  * @throws TransformerConfigurationException in case of creation failure  */ ;/**  * Create the {@link Transformer} instance used to prefer the XSLT transformation.  * <p>The default implementation simply calls {@link Templates#newTransformer()}, and  * configures the {@link Transformer} with the custom {@link URIResolver} if specified.  * @param templates the XSLT Templates instance to create a Transformer for  * @return the Transformer object  * @throws TransformerConfigurationException in case of creation failure  */ protected Transformer createTransformer(Templates templates) throws TransformerConfigurationException {     Transformer transformer = templates.newTransformer().     if (this.uriResolver != null) {         transformer.setURIResolver(this.uriResolver).     }     return transformer. }
true;protected;0;15;/**  * Get the XSLT {@link Source} for the XSLT template under the {@link #setUrl configured URL}.  * @return the Source object  */ ;/**  * Get the XSLT {@link Source} for the XSLT template under the {@link #setUrl configured URL}.  * @return the Source object  */ protected Source getStylesheetSource() {     String url = getUrl().     Assert.state(url != null, "'url' not set").     if (logger.isDebugEnabled()) {         logger.debug("Applying stylesheet [" + url + "]").     }     try {         Resource resource = obtainApplicationContext().getResource(url).         return new StreamSource(resource.getInputStream(), resource.getURI().toASCIIString()).     } catch (IOException ex) {         throw new ApplicationContextException("Can't load XSLT stylesheet from '" + url + "'", ex).     } }
true;private;1;21;/**  * Close the underlying resource managed by the supplied {@link Source} if applicable.  * <p>Only works for {@link StreamSource StreamSources}.  * @param source the XSLT Source to close (may be {@code null})  */ ;/**  * Close the underlying resource managed by the supplied {@link Source} if applicable.  * <p>Only works for {@link StreamSource StreamSources}.  * @param source the XSLT Source to close (may be {@code null})  */ private void closeSourceIfNecessary(@Nullable Source source) {     if (source instanceof StreamSource) {         StreamSource streamSource = (StreamSource) source.         if (streamSource.getReader() != null) {             try {                 streamSource.getReader().close().             } catch (IOException ex) {             // ignore             }         }         if (streamSource.getInputStream() != null) {             try {                 streamSource.getInputStream().close().             } catch (IOException ex) {             // ignore             }         }     } }
