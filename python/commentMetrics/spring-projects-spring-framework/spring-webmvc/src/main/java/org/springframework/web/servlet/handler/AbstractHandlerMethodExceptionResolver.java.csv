commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;14;/**  * Checks if the handler is a {@link HandlerMethod} and then delegates to the  * base class implementation of {@code #shouldApplyTo(HttpServletRequest, Object)}  * passing the bean of the {@code HandlerMethod}. Otherwise returns {@code false}.  */ ;/**  * Checks if the handler is a {@link HandlerMethod} and then delegates to the  * base class implementation of {@code #shouldApplyTo(HttpServletRequest, Object)}  * passing the bean of the {@code HandlerMethod}. Otherwise returns {@code false}.  */ @Override protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {     if (handler == null) {         return super.shouldApplyTo(request, null).     } else if (handler instanceof HandlerMethod) {         HandlerMethod handlerMethod = (HandlerMethod) handler.         handler = handlerMethod.getBean().         return super.shouldApplyTo(request, handler).     } else {         return false.     } }
false;protected,final;4;7;;@Override @Nullable protected final ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {     return doResolveHandlerMethodException(request, response, (HandlerMethod) handler, ex). }
true;protected,abstract;4;3;/**  * Actually resolve the given exception that got thrown during on handler execution,  * returning a ModelAndView that represents a specific error page if appropriate.  * <p>May be overridden in subclasses, in order to apply specific exception checks.  * Note that this template method will be invoked <i>after</i> checking whether this  * resolved applies ("mappedHandlers" etc), so an implementation may simply proceed  * with its actual exception handling.  * @param request current HTTP request  * @param response current HTTP response  * @param handlerMethod the executed handler method, or {@code null} if none chosen at the time  * of the exception (for example, if multipart resolution failed)  * @param ex the exception that got thrown during handler execution  * @return a corresponding ModelAndView to forward to, or {@code null} for default processing  */ ;/**  * Actually resolve the given exception that got thrown during on handler execution,  * returning a ModelAndView that represents a specific error page if appropriate.  * <p>May be overridden in subclasses, in order to apply specific exception checks.  * Note that this template method will be invoked <i>after</i> checking whether this  * resolved applies ("mappedHandlers" etc), so an implementation may simply proceed  * with its actual exception handling.  * @param request current HTTP request  * @param response current HTTP response  * @param handlerMethod the executed handler method, or {@code null} if none chosen at the time  * of the exception (for example, if multipart resolution failed)  * @param ex the exception that got thrown during handler execution  * @return a corresponding ModelAndView to forward to, or {@code null} for default processing  */ @Nullable protected abstract ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex).
