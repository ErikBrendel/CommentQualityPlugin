# id;timestamp;commentText;codeText;commentWords;codeWords
PatternsRequestCondition -> private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath);1340674210;Whether to match by known file extensions. Return "true" if file extensions_are configured, and the lookup path has a suffix.;private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath) {_		return (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) __	};whether,to,match,by,known,file,extensions,return,true,if,file,extensions,are,configured,and,the,lookup,path,has,a,suffix;private,boolean,use,smart,suffix,pattern,match,string,pattern,string,lookup,path,return,this,file,extensions,is,empty,lookup,path,index,of,1
PatternsRequestCondition -> private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath);1350317859;Whether to match by known file extensions. Return "true" if file extensions_are configured, and the lookup path has a suffix.;private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath) {_		return (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) __	};whether,to,match,by,known,file,extensions,return,true,if,file,extensions,are,configured,and,the,lookup,path,has,a,suffix;private,boolean,use,smart,suffix,pattern,match,string,pattern,string,lookup,path,return,this,file,extensions,is,empty,lookup,path,index,of,1
PatternsRequestCondition -> private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath);1356735495;Whether to match by known file extensions. Return "true" if file extensions_are configured, and the lookup path has a suffix.;private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath) {_		return (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) __	};whether,to,match,by,known,file,extensions,return,true,if,file,extensions,are,configured,and,the,lookup,path,has,a,suffix;private,boolean,use,smart,suffix,pattern,match,string,pattern,string,lookup,path,return,this,file,extensions,is,empty,lookup,path,index,of,1
PatternsRequestCondition -> private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath);1357119239;Whether to match by known file extensions. Return "true" if file extensions_are configured, and the lookup path has a suffix.;private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath) {_		return (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) __	};whether,to,match,by,known,file,extensions,return,true,if,file,extensions,are,configured,and,the,lookup,path,has,a,suffix;private,boolean,use,smart,suffix,pattern,match,string,pattern,string,lookup,path,return,this,file,extensions,is,empty,lookup,path,index,of,1
PatternsRequestCondition -> public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1328020251;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null : _			new PatternsRequestCondition(matches, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match
PatternsRequestCondition -> public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1340674210;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1350317859;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1357119239;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1362408075;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		String lookupPathNoSemicolonContent = (lookupPath.indexOf('_') != -1) ?_				pathHelperNoSemicolonContent.getLookupPathForRequest(request) : null___		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match == null && lookupPathNoSemicolonContent != null) {_				match = getMatchingPattern(pattern, lookupPathNoSemicolonContent)__			}_			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,string,lookup,path,no,semicolon,content,lookup,path,index,of,1,path,helper,no,semicolon,content,get,lookup,path,for,request,request,null,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,lookup,path,no,semicolon,content,null,match,get,matching,pattern,pattern,lookup,path,no,semicolon,content,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1393536460;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc).__@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1394656936;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc).__@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1395848231;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc).__@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1438166435;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1467730834;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1474905889;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1486634978;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1486635693;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1496837955;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1502974979;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1506097334;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1518772998;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		matches.sort(this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,matches,sort,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1522431380;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		if (matches.size() > 1) {_			matches.sort(this.pathMatcher.getPatternComparator(lookupPath))__		}_		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,if,matches,size,1,matches,sort,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1530190293;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		if (matches.size() > 1) {_			matches.sort(this.pathMatcher.getPatternComparator(lookupPath))__		}_		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,if,matches,size,1,matches,sort,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1551080576;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		if (matches.size() > 1) {_			matches.sort(this.pathMatcher.getPatternComparator(lookupPath))__		}_		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,javax,servlet,http,http,servlet,request,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,if,matches,size,1,matches,sort,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public PatternsRequestCondition combine(PatternsRequestCondition other);1328020251;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match
PatternsRequestCondition -> public PatternsRequestCondition combine(PatternsRequestCondition other);1340674210;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition combine(PatternsRequestCondition other);1350317859;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition combine(PatternsRequestCondition other);1357119239;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition combine(PatternsRequestCondition other);1362408075;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1356735495;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1368204464;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1368581529;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1382665849;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1383090835;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1392410324;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1393536460;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1394656936;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1395848231;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1438166435;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<String>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,string,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1467730834;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1474905889;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486634978;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486635693;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1496837955;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1502974979;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1506097334;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1518772998;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1522431380;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1530190293;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher,_				this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1551080576;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher,_				this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1496837955;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1502974979;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1506097334;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1518772998;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1522431380;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1530190293;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1551080576;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch___		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1340674210;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1350317859;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1356735495;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1357119239;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1362408075;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1368204464;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1368581529;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1382665849;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches.__@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1383090835;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1392410324;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1393536460;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1394656936;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1395848231;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1438166435;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1467730834;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1474905889;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1486634978;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1486635693;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1340674210;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.urlPathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				this.fileExtensions.add("." + fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,url,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1350317859;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.urlPathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,url,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1356735495;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.urlPathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,url,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1357119239;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.urlPathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,url,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1362408075;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1368204464;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1368581529;Private constructor accepting a collection of patterns._@param fileExtensionResolver;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns,param,file,extension,resolver;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1382665849;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1383090835;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1392410324;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1393536460;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1394656936;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1395848231;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper()__		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher()__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1438166435;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1467730834;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1474905889;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1486634978;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1486635693;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (urlPathHelper != null ? urlPathHelper : new UrlPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,url,path,helper,null,url,path,helper,new,url,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1356735495;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,url,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1368204464;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		String lookupPathNoSemicolonContent = (lookupPath.indexOf('_') != -1) ?_				pathHelperNoSemicolonContent.getLookupPathForRequest(request) : null___		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match == null && lookupPathNoSemicolonContent != null) {_				match = getMatchingPattern(pattern, lookupPathNoSemicolonContent)__			}_			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,string,lookup,path,no,semicolon,content,lookup,path,index,of,1,path,helper,no,semicolon,content,get,lookup,path,for,request,request,null,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,lookup,path,no,semicolon,content,null,match,get,matching,pattern,pattern,lookup,path,no,semicolon,content,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1368581529;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)___		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1382665849;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}.__<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>__@param request the current request__@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)___		List<String> matches = new ArrayList<String>()__		for (String pattern : patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1383090835;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1392410324;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = new ArrayList<String>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,new,array,list,string,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1393536460;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1394656936;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1395848231;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1438166435;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1467730834;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1474905889;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1486634978;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1486635693;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1496837955;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1502974979;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1506097334;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1518772998;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1522431380;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {__		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1530190293;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)__		return (!matches.isEmpty() ?_				new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher,_						this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions) : null)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions,null
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request);1551080576;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param request the current request_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {_		if (this.patterns.isEmpty()) {_			return this__		}_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		List<String> matches = getMatchingPatterns(lookupPath)__		return (!matches.isEmpty() ?_				new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher,_						this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions) : null)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,request,the,current,request,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,http,servlet,request,request,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1340674210;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1350317859;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1356735495;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1357119239;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1362408075;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1368204464;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1368581529;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1382665849;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1383090835;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1392410324;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1393536460;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1394656936;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1395848231;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1438166435;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1467730834;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1474905889;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1486634978;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			List<String> fileExtensions);1486635693;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, UrlPathHelper urlPathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			List<String> fileExtensions) {__		this(asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,url,path,helper,url,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,list,string,file,extensions,this,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1328020251;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1340674210;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1350317859;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1356735495;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1357119239;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1362408075;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1368204464;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1368581529;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1382665849;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1383090835;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1392410324;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1393536460;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1394656936;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1395848231;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1438166435;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1467730834;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1474905889;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486634978;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486635693;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1496837955;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1502974979;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1506097334;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1518772998;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1522431380;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1530190293;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1551080576;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(Arrays.asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,arrays,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1496837955;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1502974979;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1506097334;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1518772998;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1522431380;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1530190293;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, 			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions);1551080576;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper a {@link UrlPathHelper} for determining the lookup path for a request_@param pathMatcher a {@link PathMatcher} for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param fileExtensions a list of file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch,_			boolean useTrailingSlashMatch, @Nullable List<String> fileExtensions) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch,_				useTrailingSlashMatch, fileExtensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,a,link,url,path,helper,for,determining,the,lookup,path,for,a,request,param,path,matcher,a,link,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,file,extensions,a,list,of,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,nullable,list,string,file,extensions,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,file,extensions
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1356735495;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1368204464;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1368581529;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1382665849;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1383090835;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1392410324;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1393536460;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1394656936;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1395848231;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1438166435;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1467730834;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1474905889;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1486634978;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1486635693;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1496837955;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1502974979;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1506097334;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1518772998;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1522431380;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1530190293;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1551080576;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1328020251;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1340674210;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1350317859;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1357119239;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,url,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> public int compareTo(PatternsRequestCondition other, HttpServletRequest request);1362408075;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match.__<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(HttpServletRequest)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(request)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)___		Iterator<String> iterator = patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,http,servlet,request,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;public,int,compare,to,patterns,request,condition,other,http,servlet,request,request,string,lookup,path,this,path,helper,get,lookup,path,for,request,request,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1496837955;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1502974979;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1506097334;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1518772998;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1522431380;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1530190293;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper, 			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch);1551080576;Additional constructor with flags for using suffix pattern (.*) and_trailing slash matches._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param urlPathHelper for determining the lookup path of a request_@param pathMatcher for path matching with patterns_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash;public PatternsRequestCondition(String[] patterns, @Nullable UrlPathHelper urlPathHelper,_			@Nullable PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {__		this(Arrays.asList(patterns), urlPathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, null)__	};additional,constructor,with,flags,for,using,suffix,pattern,and,trailing,slash,matches,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,url,path,helper,for,determining,the,lookup,path,of,a,request,param,path,matcher,for,path,matching,with,patterns,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash;public,patterns,request,condition,string,patterns,nullable,url,path,helper,url,path,helper,nullable,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,this,arrays,as,list,patterns,url,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,null
