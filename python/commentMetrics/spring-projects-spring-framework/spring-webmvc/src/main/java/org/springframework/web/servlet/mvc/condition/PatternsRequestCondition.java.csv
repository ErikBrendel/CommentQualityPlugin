commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;10;;private static Set<String> prependLeadingSlash(Collection<String> patterns) {     Set<String> result = new LinkedHashSet<>(patterns.size()).     for (String pattern : patterns) {         if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {             pattern = "/" + pattern.         }         result.add(pattern).     }     return result. }
false;public;0;3;;public Set<String> getPatterns() {     return this.patterns. }
false;protected;0;4;;@Override protected Collection<String> getContent() {     return this.patterns. }
false;protected;0;4;;@Override protected String getToStringInfix() {     return " || ". }
true;public;1;22;/**  * Returns a new instance with URL patterns from the current instance ("this") and  * the "other" instance as follows:  * <ul>  * <li>If there are patterns in both instances, combine the patterns in "this" with  * the patterns in "other" using {@link PathMatcher#combine(String, String)}.  * <li>If only one instance has patterns, use them.  * <li>If neither instance has patterns, use an empty String (i.e. "").  * </ul>  */ ;/**  * Returns a new instance with URL patterns from the current instance ("this") and  * the "other" instance as follows:  * <ul>  * <li>If there are patterns in both instances, combine the patterns in "this" with  * the patterns in "other" using {@link PathMatcher#combine(String, String)}.  * <li>If only one instance has patterns, use them.  * <li>If neither instance has patterns, use an empty String (i.e. "").  * </ul>  */ @Override public PatternsRequestCondition combine(PatternsRequestCondition other) {     Set<String> result = new LinkedHashSet<>().     if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {         for (String pattern1 : this.patterns) {             for (String pattern2 : other.patterns) {                 result.add(this.pathMatcher.combine(pattern1, pattern2)).             }         }     } else if (!this.patterns.isEmpty()) {         result.addAll(this.patterns).     } else if (!other.patterns.isEmpty()) {         result.addAll(other.patterns).     } else {         result.add("").     }     return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions). }
true;public;1;12;/**  * Checks if any of the patterns match the given request and returns an instance  * that is guaranteed to contain matching patterns, sorted via  * {@link PathMatcher#getPatternComparator(String)}.  * <p>A matching pattern is obtained by making checks in the following order:  * <ul>  * <li>Direct match  * <li>Pattern match with ".*" appended if the pattern doesn't already contain a "."  * <li>Pattern match  * <li>Pattern match with "/" appended if the pattern doesn't already end in "/"  * </ul>  * @param request the current request  * @return the same instance if the condition contains no patterns.  * or a new condition with sorted matching patterns.  * or {@code null} if no patterns match.  */ ;/**  * Checks if any of the patterns match the given request and returns an instance  * that is guaranteed to contain matching patterns, sorted via  * {@link PathMatcher#getPatternComparator(String)}.  * <p>A matching pattern is obtained by making checks in the following order:  * <ul>  * <li>Direct match  * <li>Pattern match with ".*" appended if the pattern doesn't already contain a "."  * <li>Pattern match  * <li>Pattern match with "/" appended if the pattern doesn't already end in "/"  * </ul>  * @param request the current request  * @return the same instance if the condition contains no patterns.  * or a new condition with sorted matching patterns.  * or {@code null} if no patterns match.  */ @Override @Nullable public PatternsRequestCondition getMatchingCondition(HttpServletRequest request) {     if (this.patterns.isEmpty()) {         return this.     }     String lookupPath = this.pathHelper.getLookupPathForRequest(request).     List<String> matches = getMatchingPatterns(lookupPath).     return (!matches.isEmpty() ? new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions) : null). }
true;public;1;13;/**  * Find the patterns matching the given lookup path. Invoking this method should  * yield results equivalent to those of calling  * {@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}.  * This method is provided as an alternative to be used if no request is available  * (e.g. introspection, tooling, etc).  * @param lookupPath the lookup path to match to existing patterns  * @return a collection of matching patterns sorted with the closest match at the top  */ ;/**  * Find the patterns matching the given lookup path. Invoking this method should  * yield results equivalent to those of calling  * {@link #getMatchingCondition(javax.servlet.http.HttpServletRequest)}.  * This method is provided as an alternative to be used if no request is available  * (e.g. introspection, tooling, etc).  * @param lookupPath the lookup path to match to existing patterns  * @return a collection of matching patterns sorted with the closest match at the top  */ public List<String> getMatchingPatterns(String lookupPath) {     List<String> matches = new ArrayList<>().     for (String pattern : this.patterns) {         String match = getMatchingPattern(pattern, lookupPath).         if (match != null) {             matches.add(match).         }     }     if (matches.size() > 1) {         matches.sort(this.pathMatcher.getPatternComparator(lookupPath)).     }     return matches. }
false;private;2;30;;@Nullable private String getMatchingPattern(String pattern, String lookupPath) {     if (pattern.equals(lookupPath)) {         return pattern.     }     if (this.useSuffixPatternMatch) {         if (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) {             for (String extension : this.fileExtensions) {                 if (this.pathMatcher.match(pattern + extension, lookupPath)) {                     return pattern + extension.                 }             }         } else {             boolean hasSuffix = pattern.indexOf('.') != -1.             if (!hasSuffix && this.pathMatcher.match(pattern + ".*", lookupPath)) {                 return pattern + ".*".             }         }     }     if (this.pathMatcher.match(pattern, lookupPath)) {         return pattern.     }     if (this.useTrailingSlashMatch) {         if (!pattern.endsWith("/") && this.pathMatcher.match(pattern + "/", lookupPath)) {             return pattern + "/".         }     }     return null. }
true;public;2;22;/**  * Compare the two conditions based on the URL patterns they contain.  * Patterns are compared one at a time, from top to bottom via  * {@link PathMatcher#getPatternComparator(String)}. If all compared  * patterns match equally, but one instance has more patterns, it is  * considered a closer match.  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(HttpServletRequest)} to ensure they  * contain only patterns that match the request and are sorted with  * the best matches on top.  */ ;/**  * Compare the two conditions based on the URL patterns they contain.  * Patterns are compared one at a time, from top to bottom via  * {@link PathMatcher#getPatternComparator(String)}. If all compared  * patterns match equally, but one instance has more patterns, it is  * considered a closer match.  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(HttpServletRequest)} to ensure they  * contain only patterns that match the request and are sorted with  * the best matches on top.  */ @Override public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {     String lookupPath = this.pathHelper.getLookupPathForRequest(request).     Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath).     Iterator<String> iterator = this.patterns.iterator().     Iterator<String> iteratorOther = other.patterns.iterator().     while (iterator.hasNext() && iteratorOther.hasNext()) {         int result = patternComparator.compare(iterator.next(), iteratorOther.next()).         if (result != 0) {             return result.         }     }     if (iterator.hasNext()) {         return -1.     } else if (iteratorOther.hasNext()) {         return 1.     } else {         return 0.     } }
