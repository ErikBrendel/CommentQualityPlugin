commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;4;/**  * Get the URL path patterns associated with this {@link RequestMappingInfo}.  */ ;/**  * Get the URL path patterns associated with this {@link RequestMappingInfo}.  */ @Override protected Set<String> getMappingPathPatterns(RequestMappingInfo info) {     return info.getPatternsCondition().getPatterns(). }
true;protected;2;4;/**  * Check if the given RequestMappingInfo matches the current request and  * return a (potentially new) instance with conditions that match the  * current request -- for example with a subset of URL patterns.  * @return an info in case of a match. or {@code null} otherwise.  */ ;/**  * Check if the given RequestMappingInfo matches the current request and  * return a (potentially new) instance with conditions that match the  * current request -- for example with a subset of URL patterns.  * @return an info in case of a match. or {@code null} otherwise.  */ @Override protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {     return info.getMatchingCondition(request). }
true;protected;1;4;/**  * Provide a Comparator to sort RequestMappingInfos matched to a request.  */ ;/**  * Provide a Comparator to sort RequestMappingInfos matched to a request.  */ @Override protected Comparator<RequestMappingInfo> getMappingComparator(final HttpServletRequest request) {     return (info1, info2) -> info1.compareTo(info2, request). }
true;protected;3;32;/**  * Expose URI template variables, matrix variables, and producible media types in the request.  * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE  * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE  * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE  */ ;/**  * Expose URI template variables, matrix variables, and producible media types in the request.  * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE  * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE  * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE  */ @Override protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {     super.handleMatch(info, lookupPath, request).     String bestPattern.     Map<String, String> uriVariables.     Set<String> patterns = info.getPatternsCondition().getPatterns().     if (patterns.isEmpty()) {         bestPattern = lookupPath.         uriVariables = Collections.emptyMap().     } else {         bestPattern = patterns.iterator().next().         uriVariables = getPathMatcher().extractUriTemplateVariables(bestPattern, lookupPath).     }     request.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern).     if (isMatrixVariableContentAvailable()) {         Map<String, MultiValueMap<String, String>> matrixVars = extractMatrixVariables(request, uriVariables).         request.setAttribute(HandlerMapping.MATRIX_VARIABLES_ATTRIBUTE, matrixVars).     }     Map<String, String> decodedUriVariables = getUrlPathHelper().decodePathVariables(request, uriVariables).     request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, decodedUriVariables).     if (!info.getProducesCondition().getProducibleMediaTypes().isEmpty()) {         Set<MediaType> mediaTypes = info.getProducesCondition().getProducibleMediaTypes().         request.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes).     } }
false;private;0;3;;private boolean isMatrixVariableContentAvailable() {     return !getUrlPathHelper().shouldRemoveSemicolonContent(). }
false;private;2;29;;private Map<String, MultiValueMap<String, String>> extractMatrixVariables(HttpServletRequest request, Map<String, String> uriVariables) {     Map<String, MultiValueMap<String, String>> result = new LinkedHashMap<>().     uriVariables.forEach((uriVarKey, uriVarValue) -> {         int equalsIndex = uriVarValue.indexOf('=').         if (equalsIndex == -1) {             return.         }         int semicolonIndex = uriVarValue.indexOf('.').         if (semicolonIndex != -1 && semicolonIndex != 0) {             uriVariables.put(uriVarKey, uriVarValue.substring(0, semicolonIndex)).         }         String matrixVariables.         if (semicolonIndex == -1 || semicolonIndex == 0 || equalsIndex < semicolonIndex) {             matrixVariables = uriVarValue.         } else {             matrixVariables = uriVarValue.substring(semicolonIndex + 1).         }         MultiValueMap<String, String> vars = WebUtils.parseMatrixVariables(matrixVariables).         result.put(uriVarKey, getUrlPathHelper().decodeMatrixVariables(request, vars)).     }).     return result. }
true;protected;3;44;/**  * Iterate all RequestMappingInfo's once again, look if any match by URL at  * least and raise exceptions according to what doesn't match.  * @throws HttpRequestMethodNotSupportedException if there are matches by URL  * but not by HTTP method  * @throws HttpMediaTypeNotAcceptableException if there are matches by URL  * but not by consumable/producible media types  */ ;/**  * Iterate all RequestMappingInfo's once again, look if any match by URL at  * least and raise exceptions according to what doesn't match.  * @throws HttpRequestMethodNotSupportedException if there are matches by URL  * but not by HTTP method  * @throws HttpMediaTypeNotAcceptableException if there are matches by URL  * but not by consumable/producible media types  */ @Override protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request) throws ServletException {     PartialMatchHelper helper = new PartialMatchHelper(infos, request).     if (helper.isEmpty()) {         return null.     }     if (helper.hasMethodsMismatch()) {         Set<String> methods = helper.getAllowedMethods().         if (HttpMethod.OPTIONS.matches(request.getMethod())) {             HttpOptionsHandler handler = new HttpOptionsHandler(methods).             return new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD).         }         throw new HttpRequestMethodNotSupportedException(request.getMethod(), methods).     }     if (helper.hasConsumesMismatch()) {         Set<MediaType> mediaTypes = helper.getConsumableMediaTypes().         MediaType contentType = null.         if (StringUtils.hasLength(request.getContentType())) {             try {                 contentType = MediaType.parseMediaType(request.getContentType()).             } catch (InvalidMediaTypeException ex) {                 throw new HttpMediaTypeNotSupportedException(ex.getMessage()).             }         }         throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList<>(mediaTypes)).     }     if (helper.hasProducesMismatch()) {         Set<MediaType> mediaTypes = helper.getProducibleMediaTypes().         throw new HttpMediaTypeNotAcceptableException(new ArrayList<>(mediaTypes)).     }     if (helper.hasParamsMismatch()) {         List<String[]> conditions = helper.getParamConditions().         throw new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap()).     }     return null. }
true;public;0;3;/**  * Whether there any partial matches.  */ ;/**  * Whether there any partial matches.  */ public boolean isEmpty() {     return this.partialMatches.isEmpty(). }
true;public;0;8;/**  * Any partial matches for "methods"?  */ ;/**  * Any partial matches for "methods"?  */ public boolean hasMethodsMismatch() {     for (PartialMatch match : this.partialMatches) {         if (match.hasMethodsMatch()) {             return false.         }     }     return true. }
true;public;0;8;/**  * Any partial matches for "methods" and "consumes"?  */ ;/**  * Any partial matches for "methods" and "consumes"?  */ public boolean hasConsumesMismatch() {     for (PartialMatch match : this.partialMatches) {         if (match.hasConsumesMatch()) {             return false.         }     }     return true. }
true;public;0;8;/**  * Any partial matches for "methods", "consumes", and "produces"?  */ ;/**  * Any partial matches for "methods", "consumes", and "produces"?  */ public boolean hasProducesMismatch() {     for (PartialMatch match : this.partialMatches) {         if (match.hasProducesMatch()) {             return false.         }     }     return true. }
true;public;0;8;/**  * Any partial matches for "methods", "consumes", "produces", and "params"?  */ ;/**  * Any partial matches for "methods", "consumes", "produces", and "params"?  */ public boolean hasParamsMismatch() {     for (PartialMatch match : this.partialMatches) {         if (match.hasParamsMatch()) {             return false.         }     }     return true. }
true;public;0;9;/**  * Return declared HTTP methods.  */ ;/**  * Return declared HTTP methods.  */ public Set<String> getAllowedMethods() {     Set<String> result = new LinkedHashSet<>().     for (PartialMatch match : this.partialMatches) {         for (RequestMethod method : match.getInfo().getMethodsCondition().getMethods()) {             result.add(method.name()).         }     }     return result. }
true;public;0;9;/**  * Return declared "consumable" types but only among those that also  * match the "methods" condition.  */ ;/**  * Return declared "consumable" types but only among those that also  * match the "methods" condition.  */ public Set<MediaType> getConsumableMediaTypes() {     Set<MediaType> result = new LinkedHashSet<>().     for (PartialMatch match : this.partialMatches) {         if (match.hasMethodsMatch()) {             result.addAll(match.getInfo().getConsumesCondition().getConsumableMediaTypes()).         }     }     return result. }
true;public;0;9;/**  * Return declared "producible" types but only among those that also  * match the "methods" and "consumes" conditions.  */ ;/**  * Return declared "producible" types but only among those that also  * match the "methods" and "consumes" conditions.  */ public Set<MediaType> getProducibleMediaTypes() {     Set<MediaType> result = new LinkedHashSet<>().     for (PartialMatch match : this.partialMatches) {         if (match.hasConsumesMatch()) {             result.addAll(match.getInfo().getProducesCondition().getProducibleMediaTypes()).         }     }     return result. }
true;public;0;17;/**  * Return declared "params" conditions but only among those that also  * match the "methods", "consumes", and "params" conditions.  */ ;/**  * Return declared "params" conditions but only among those that also  * match the "methods", "consumes", and "params" conditions.  */ public List<String[]> getParamConditions() {     List<String[]> result = new ArrayList<>().     for (PartialMatch match : this.partialMatches) {         if (match.hasProducesMatch()) {             Set<NameValueExpression<String>> set = match.getInfo().getParamsCondition().getExpressions().             if (!CollectionUtils.isEmpty(set)) {                 int i = 0.                 String[] array = new String[set.size()].                 for (NameValueExpression<String> expression : set) {                     array[i++] = expression.toString().                 }                 result.add(array).             }         }     }     return result. }
false;public;0;3;;public RequestMappingInfo getInfo() {     return this.info. }
false;public;0;3;;public boolean hasMethodsMatch() {     return this.methodsMatch. }
false;public;0;3;;public boolean hasConsumesMatch() {     return (hasMethodsMatch() && this.consumesMatch). }
false;public;0;3;;public boolean hasProducesMatch() {     return (hasConsumesMatch() && this.producesMatch). }
false;public;0;3;;public boolean hasParamsMatch() {     return (hasProducesMatch() && this.paramsMatch). }
false;public;0;4;;@Override public String toString() {     return this.info.toString(). }
false;private,static;1;21;;private static Set<HttpMethod> initAllowedHttpMethods(Set<String> declaredMethods) {     Set<HttpMethod> result = new LinkedHashSet<>(declaredMethods.size()).     if (declaredMethods.isEmpty()) {         for (HttpMethod method : HttpMethod.values()) {             if (method != HttpMethod.TRACE) {                 result.add(method).             }         }     } else {         for (String method : declaredMethods) {             HttpMethod httpMethod = HttpMethod.valueOf(method).             result.add(httpMethod).             if (httpMethod == HttpMethod.GET) {                 result.add(HttpMethod.HEAD).             }         }         result.add(HttpMethod.OPTIONS).     }     return result. }
false;public;0;4;;@SuppressWarnings("unused") public HttpHeaders handle() {     return this.headers. }
