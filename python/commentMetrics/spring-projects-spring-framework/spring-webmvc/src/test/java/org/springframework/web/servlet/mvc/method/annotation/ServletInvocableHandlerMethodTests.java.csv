commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Test public void invokeAndHandle_VoidWithResponseStatus() throws Exception {     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "responseStatus").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertTrue("Null return value + @ResponseStatus should result in 'request handled'", this.mavContainer.isRequestHandled()).     assertEquals(HttpStatus.BAD_REQUEST.value(), this.response.getStatus()). }
false;public;0;9;;@Test public void invokeAndHandle_VoidWithComposedResponseStatus() throws Exception {     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "composedResponseStatus").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertTrue("Null return value + @ComposedResponseStatus should result in 'request handled'", this.mavContainer.isRequestHandled()).     assertEquals(HttpStatus.BAD_REQUEST.value(), this.response.getStatus()). }
false;public;0;8;;@Test public void invokeAndHandle_VoidWithTypeLevelResponseStatus() throws Exception {     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new ResponseStatusHandler(), "handle").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertTrue(this.mavContainer.isRequestHandled()).     assertEquals(HttpStatus.BAD_REQUEST.value(), this.response.getStatus()). }
false;public;0;11;;@Test public void invokeAndHandle_VoidWithHttpServletResponseArgument() throws Exception {     this.argumentResolvers.addResolver(new ServletResponseMethodArgumentResolver()).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "httpServletResponse", HttpServletResponse.class).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertTrue("Null return value + HttpServletResponse arg should result in 'request handled'", this.mavContainer.isRequestHandled()). }
false;public;0;12;;@Test public void invokeAndHandle_VoidRequestNotModified() throws Exception {     this.request.addHeader("If-Modified-Since", 10 * 1000 * 1000).     int lastModifiedTimestamp = 1000 * 1000.     this.webRequest.checkNotModified(lastModifiedTimestamp).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "notModified").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertTrue("Null return value + 'not modified' request should result in 'request handled'", this.mavContainer.isRequestHandled()). }
false;public;0;9;;// SPR-9159 @Test public void invokeAndHandle_NotVoidWithResponseStatusAndReason() throws Exception {     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "responseStatusWithReason").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertTrue("When a status reason w/ used, the request is handled", this.mavContainer.isRequestHandled()).     assertEquals(HttpStatus.BAD_REQUEST.value(), this.response.getStatus()).     assertEquals("400 Bad Request", this.response.getErrorMessage()). }
false;public;0;8;;@Test(expected = HttpMessageNotWritableException.class) public void invokeAndHandle_Exception() throws Exception {     this.returnValueHandlers.addHandler(new ExceptionRaisingReturnValueHandler()).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "handle").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     fail("Expected exception"). }
false;public;0;19;;@Test public void invokeAndHandle_DynamicReturnValue() throws Exception {     this.argumentResolvers.addResolver(new RequestParamMethodArgumentResolver(null, false)).     this.returnValueHandlers.addHandler(new ViewMethodReturnValueHandler()).     this.returnValueHandlers.addHandler(new ViewNameMethodReturnValueHandler()).     // Invoke without a request parameter (String return value)     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new Handler(), "dynamicReturnValue", String.class).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertNotNull(this.mavContainer.getView()).     assertEquals(RedirectView.class, this.mavContainer.getView().getClass()).     // Invoke with a request parameter (RedirectView return value)     this.request.setParameter("param", "value").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals("view", this.mavContainer.getViewName()). }
false;public;0;4;;@Test public void wrapConcurrentResult_MethodLevelResponseBody() throws Exception {     wrapConcurrentResult_ResponseBody(new MethodLevelResponseBodyHandler(), "bar", String.class). }
false;public;0;4;;@Test public void wrapConcurrentResult_MethodLevelResponseBodyEmpty() throws Exception {     wrapConcurrentResult_ResponseBody(new MethodLevelResponseBodyHandler(), null, String.class). }
false;public;0;4;;@Test public void wrapConcurrentResult_TypeLevelResponseBody() throws Exception {     wrapConcurrentResult_ResponseBody(new TypeLevelResponseBodyHandler(), "bar", String.class). }
false;public;0;4;;@Test public void wrapConcurrentResult_TypeLevelResponseBodyEmpty() throws Exception {     wrapConcurrentResult_ResponseBody(new TypeLevelResponseBodyHandler(), null, String.class). }
false;public;0;4;;@Test public void wrapConcurrentResult_DeferredResultSubclass() throws Exception {     wrapConcurrentResult_ResponseBody(new DeferredResultSubclassHandler(), "bar", String.class). }
false;public;0;4;;@Test public void wrapConcurrentResult_DeferredResultSubclassEmpty() throws Exception {     wrapConcurrentResult_ResponseBody(new DeferredResultSubclassHandler(), null, CustomDeferredResult.class). }
false;private;3;12;;private void wrapConcurrentResult_ResponseBody(Object handler, Object result, Class<?> expectedReturnType) throws Exception {     this.returnValueHandlers.addHandler(new ModelAndViewMethodReturnValueHandler()).     this.returnValueHandlers.addHandler(new RequestResponseBodyMethodProcessor(this.converters)).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(handler, "handle").     handlerMethod = handlerMethod.wrapConcurrentResult(result).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals((result != null ? result.toString() : ""), this.response.getContentAsString()).     assertEquals(expectedReturnType, handlerMethod.getReturnValueType(result).getParameterType()). }
false;public;0;9;;@Test public void wrapConcurrentResult_ResponseEntity() throws Exception {     this.returnValueHandlers.addHandler(new HttpEntityMethodProcessor(this.converters)).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new ResponseEntityHandler(), "handleDeferred").     handlerMethod = handlerMethod.wrapConcurrentResult(new ResponseEntity<>("bar", HttpStatus.OK)).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals("bar", this.response.getContentAsString()). }
false;public;0;10;;// SPR-12287 @Test public void wrapConcurrentResult_ResponseEntityNullBody() throws Exception {     this.returnValueHandlers.addHandler(new HttpEntityMethodProcessor(this.converters)).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new ResponseEntityHandler(), "handleDeferred").     handlerMethod = handlerMethod.wrapConcurrentResult(new ResponseEntity<>(HttpStatus.OK)).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("", this.response.getContentAsString()). }
false;public;0;10;;@Test public void wrapConcurrentResult_ResponseEntityNullReturnValue() throws Exception {     this.returnValueHandlers.addHandler(new HttpEntityMethodProcessor(this.converters)).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new ResponseEntityHandler(), "handleDeferred").     handlerMethod = handlerMethod.wrapConcurrentResult(null).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("", this.response.getContentAsString()). }
false;public;0;12;;@Test public void wrapConcurrentResult_ResponseBodyEmitter() throws Exception {     this.returnValueHandlers.addHandler(new ResponseBodyEmitterReturnValueHandler(this.converters)).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new StreamingHandler(), "handleEmitter").     handlerMethod = handlerMethod.wrapConcurrentResult(null).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("", this.response.getContentAsString()). }
false;public;0;10;;@Test public void wrapConcurrentResult_StreamingResponseBody() throws Exception {     this.returnValueHandlers.addHandler(new StreamingResponseBodyReturnValueHandler()).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new StreamingHandler(), "handleStreamBody").     handlerMethod = handlerMethod.wrapConcurrentResult(null).     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("", this.response.getContentAsString()). }
false;public;0;17;;@Test public void wrapConcurrentResult_CollectedValuesList() throws Exception {     List<HttpMessageConverter<?>> converters = Collections.singletonList(new MappingJackson2HttpMessageConverter()).     ResolvableType elementType = ResolvableType.forClass(List.class).     ReactiveTypeHandler.CollectedValuesList result = new ReactiveTypeHandler.CollectedValuesList(elementType).     result.add(Arrays.asList("foo1", "bar1")).     result.add(Arrays.asList("foo2", "bar2")).     ContentNegotiationManager manager = new ContentNegotiationManager().     this.returnValueHandlers.addHandler(new RequestResponseBodyMethodProcessor(converters, manager)).     ServletInvocableHandlerMethod hm = getHandlerMethod(new MethodLevelResponseBodyHandler(), "handleFluxOfLists").     hm = hm.wrapConcurrentResult(result).     hm.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("[[\"foo1\",\"bar1\"],[\"foo2\",\"bar2\"]]", this.response.getContentAsString()). }
false;public;0;17;;// SPR-15478 @Test public void wrapConcurrentResult_CollectedValuesListWithResponseEntity() throws Exception {     List<HttpMessageConverter<?>> converters = Collections.singletonList(new MappingJackson2HttpMessageConverter()).     ResolvableType elementType = ResolvableType.forClass(Bar.class).     ReactiveTypeHandler.CollectedValuesList result = new ReactiveTypeHandler.CollectedValuesList(elementType).     result.add(new Bar("foo")).     result.add(new Bar("bar")).     ContentNegotiationManager manager = new ContentNegotiationManager().     this.returnValueHandlers.addHandler(new RequestResponseBodyMethodProcessor(converters, manager)).     ServletInvocableHandlerMethod hm = getHandlerMethod(new ResponseEntityHandler(), "handleFlux").     hm = hm.wrapConcurrentResult(result).     hm.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("[{\"value\":\"foo\"},{\"value\":\"bar\"}]", this.response.getContentAsString()). }
false;public;0;9;;// SPR-12287 (16/Oct/14 comments) @Test public void responseEntityRawTypeWithNullBody() throws Exception {     this.returnValueHandlers.addHandler(new HttpEntityMethodProcessor(this.converters)).     ServletInvocableHandlerMethod handlerMethod = getHandlerMethod(new ResponseEntityHandler(), "handleRawType").     handlerMethod.invokeAndHandle(this.webRequest, this.mavContainer).     assertEquals(200, this.response.getStatus()).     assertEquals("", this.response.getContentAsString()). }
false;private;3;9;;private ServletInvocableHandlerMethod getHandlerMethod(Object controller, String methodName, Class<?>... argTypes) throws NoSuchMethodException {     Method method = controller.getClass().getDeclaredMethod(methodName, argTypes).     ServletInvocableHandlerMethod handlerMethod = new ServletInvocableHandlerMethod(controller, method).     handlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers).     handlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers).     return handlerMethod. }
false;public;0;3;;public String handle() {     return "view". }
false;public;0;3;;@ResponseStatus(HttpStatus.BAD_REQUEST) public void responseStatus() { }
false;public;0;4;;@ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "400 Bad Request") public String responseStatusWithReason() {     return "foo". }
false;public;0;3;;@ComposedResponseStatus(responseStatus = HttpStatus.BAD_REQUEST) public void composedResponseStatus() { }
false;public;1;2;;public void httpServletResponse(HttpServletResponse response) { }
false;public;0;2;;public void notModified() { }
false;public;1;3;;public Object dynamicReturnValue(@RequestParam(required = false) String param) {     return (param != null) ? "view" : new RedirectView("redirectView"). }
false;public;0;1;;public void handle() { }
false;public;0;2;;@ResponseBody public DeferredResult<String> handle() {     return null. }
false;public;0;2;;// Unusual but legal return type // Properly test generic type handling of Flux values collected to a List @ResponseBody public Flux<List<String>> handleFluxOfLists() {     return null. }
false;public;0;1;;public DeferredResult<String> handle() {     return null. }
false;public;0;2;;@ResponseBody public CustomDeferredResult handle() {     return null. }
false;public;0;1;;public DeferredResult<ResponseEntity<String>> handleDeferred() {     return null. }
false;public;0;1;;public ResponseEntity<Void> handleRawType() {     return null. }
false;public;0;1;;public ResponseEntity<Flux<Bar>> handleFlux() {     return null. }
false;public;1;4;;@Override public boolean supportsReturnType(MethodParameter returnType) {     return true. }
false;public;4;5;;@Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {     throw new HttpMessageNotWritableException("oops, can't write"). }
false;public;0;1;;public ResponseBodyEmitter handleEmitter() {     return null. }
false;public;0;1;;public StreamingResponseBody handleStreamBody() {     return null. }
false;public;0;4;;@SuppressWarnings("unused") public String getValue() {     return this.value. }
