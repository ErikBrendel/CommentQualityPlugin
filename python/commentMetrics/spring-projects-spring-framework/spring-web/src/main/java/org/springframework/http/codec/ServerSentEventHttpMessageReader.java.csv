commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the configured {@code Decoder}.  */ ;/**  * Return the configured {@code Decoder}.  */ @Nullable public Decoder<?> getDecoder() {     return this.decoder. }
false;public;0;4;;@Override public List<MediaType> getReadableMediaTypes() {     return Collections.singletonList(MediaType.TEXT_EVENT_STREAM). }
false;public;2;4;;@Override public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {     return (MediaType.TEXT_EVENT_STREAM.includes(mediaType) || isServerSentEvent(elementType)). }
false;private;1;3;;private boolean isServerSentEvent(ResolvableType elementType) {     return ServerSentEvent.class.isAssignableFrom(elementType.toClass()). }
false;public;3;11;;@Override public Flux<Object> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     boolean shouldWrap = isServerSentEvent(elementType).     ResolvableType valueType = (shouldWrap ? elementType.getGeneric() : elementType).     return stringDecoder.decode(message.getBody(), STRING_TYPE, null, hints).bufferUntil(line -> line.equals("")).concatMap(lines -> buildEvent(lines, valueType, shouldWrap, hints)). }
false;private;4;44;;private Mono<?> buildEvent(List<String> lines, ResolvableType valueType, boolean shouldWrap, Map<String, Object> hints) {     ServerSentEvent.Builder<Object> sseBuilder = shouldWrap ? ServerSentEvent.builder() : null.     StringBuilder data = null.     StringBuilder comment = null.     for (String line : lines) {         if (line.startsWith("data:")) {             data = (data != null ? data : new StringBuilder()).             data.append(line.substring(5).trim()).append("\n").         }         if (shouldWrap) {             if (line.startsWith("id:")) {                 sseBuilder.id(line.substring(3).trim()).             } else if (line.startsWith("event:")) {                 sseBuilder.event(line.substring(6).trim()).             } else if (line.startsWith("retry:")) {                 sseBuilder.retry(Duration.ofMillis(Long.valueOf(line.substring(6).trim()))).             } else if (line.startsWith(":")) {                 comment = (comment != null ? comment : new StringBuilder()).                 comment.append(line.substring(1).trim()).append("\n").             }         }     }     Mono<?> decodedData = (data != null ? decodeData(data.toString(), valueType, hints) : Mono.empty()).     if (shouldWrap) {         if (comment != null) {             sseBuilder.comment(comment.toString().substring(0, comment.length() - 1)).         }         return decodedData.map(o -> {             sseBuilder.data(o).             return sseBuilder.build().         }).     } else {         return decodedData.     } }
false;private;3;13;;private Mono<?> decodeData(String data, ResolvableType dataType, Map<String, Object> hints) {     if (String.class == dataType.resolve()) {         return Mono.just(data.substring(0, data.length() - 1)).     }     if (this.decoder == null) {         return Mono.error(new CodecException("No SSE decoder configured and the data is not String.")).     }     byte[] bytes = data.getBytes(StandardCharsets.UTF_8).     Mono<DataBuffer> input = Mono.just(bufferFactory.wrap(bytes)).     return this.decoder.decodeToMono(input, dataType, MediaType.TEXT_EVENT_STREAM, hints). }
false;public;3;15;;@Override public Mono<Object> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     if (elementType.resolve() == String.class) {         Flux<DataBuffer> body = message.getBody().         return stringDecoder.decodeToMono(body, elementType, null, null).cast(Object.class).     }     return Mono.error(new UnsupportedOperationException("ServerSentEventHttpMessageReader only supports reading stream of events as a Flux")). }
