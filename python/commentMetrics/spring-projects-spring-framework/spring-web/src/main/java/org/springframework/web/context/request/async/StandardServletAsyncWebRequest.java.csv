commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * In Servlet 3 async processing, the timeout period begins after the  * container processing thread has exited.  */ ;/**  * In Servlet 3 async processing, the timeout period begins after the  * container processing thread has exited.  */ @Override public void setTimeout(Long timeout) {     Assert.state(!isAsyncStarted(), "Cannot change the timeout with concurrent handling in progress").     this.timeout = timeout. }
false;public;1;4;;@Override public void addTimeoutHandler(Runnable timeoutHandler) {     this.timeoutHandlers.add(timeoutHandler). }
false;public;1;4;;@Override public void addErrorHandler(Consumer<Throwable> exceptionHandler) {     this.exceptionHandlers.add(exceptionHandler). }
false;public;1;4;;@Override public void addCompletionHandler(Runnable runnable) {     this.completionHandlers.add(runnable). }
false;public;0;4;;@Override public boolean isAsyncStarted() {     return (this.asyncContext != null && getRequest().isAsyncStarted()). }
true;public;0;4;/**  * Whether async request processing has completed.  * <p>It is important to avoid use of request and response objects after async  * processing has completed. Servlet containers often re-use them.  */ ;/**  * Whether async request processing has completed.  * <p>It is important to avoid use of request and response objects after async  * processing has completed. Servlet containers often re-use them.  */ @Override public boolean isAsyncComplete() {     return this.asyncCompleted.get(). }
false;public;0;18;;@Override public void startAsync() {     Assert.state(getRequest().isAsyncSupported(), "Async support must be enabled on a servlet and for all filters involved " + "in async request processing. This is done in Java code using the Servlet API " + "or by adding \"<async-supported>true</async-supported>\" to servlet and " + "filter declarations in web.xml.").     Assert.state(!isAsyncComplete(), "Async processing has already completed").     if (isAsyncStarted()) {         return.     }     this.asyncContext = getRequest().startAsync(getRequest(), getResponse()).     this.asyncContext.addListener(this).     if (this.timeout != null) {         this.asyncContext.setTimeout(this.timeout).     } }
false;public;0;5;;@Override public void dispatch() {     Assert.notNull(this.asyncContext, "Cannot dispatch without an AsyncContext").     this.asyncContext.dispatch(). }
false;public;1;3;;// --------------------------------------------------------------------- // Implementation of AsyncListener methods // --------------------------------------------------------------------- @Override public void onStartAsync(AsyncEvent event) throws IOException { }
false;public;1;4;;@Override public void onError(AsyncEvent event) throws IOException {     this.exceptionHandlers.forEach(consumer -> consumer.accept(event.getThrowable())). }
false;public;1;4;;@Override public void onTimeout(AsyncEvent event) throws IOException {     this.timeoutHandlers.forEach(Runnable::run). }
false;public;1;6;;@Override public void onComplete(AsyncEvent event) throws IOException {     this.completionHandlers.forEach(Runnable::run).     this.asyncContext = null.     this.asyncCompleted.set(true). }
