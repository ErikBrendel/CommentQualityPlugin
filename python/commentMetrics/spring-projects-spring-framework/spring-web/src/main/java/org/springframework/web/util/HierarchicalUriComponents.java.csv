commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getPath() {     return "". }
false;public;0;4;;@Override public List<String> getPathSegments() {     return Collections.emptyList(). }
false;public;1;4;;@Override public PathComponent encode(BiFunction<String, Type, String> encoder) {     return this. }
false;public;0;3;;@Override public void verify() { }
false;public;2;4;;@Override public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {     return this. }
false;public;1;3;;@Override public void copyToUriComponentsBuilder(UriComponentsBuilder builder) { }
false;public;1;4;;@Override public boolean equals(Object other) {     return (this == other). }
false;public;0;4;;@Override public int hashCode() {     return getClass().hashCode(). }
false;public;0;5;;// Component getters @Override @Nullable public String getSchemeSpecificPart() {     return null. }
false;public;0;5;;@Override @Nullable public String getUserInfo() {     return this.userInfo. }
false;public;0;5;;@Override @Nullable public String getHost() {     return this.host. }
false;public;0;11;;@Override public int getPort() {     if (this.port == null) {         return -1.     } else if (this.port.contains("{")) {         throw new IllegalStateException("The port contains a URI variable but has not been expanded yet: " + this.port).     }     return Integer.parseInt(this.port). }
false;public;0;5;;@Override @NonNull public String getPath() {     return this.path.getPath(). }
false;public;0;4;;@Override public List<String> getPathSegments() {     return this.path.getPathSegments(). }
false;public;0;30;;@Override @Nullable public String getQuery() {     if (!this.queryParams.isEmpty()) {         StringBuilder queryBuilder = new StringBuilder().         this.queryParams.forEach((name, values) -> {             if (CollectionUtils.isEmpty(values)) {                 if (queryBuilder.length() != 0) {                     queryBuilder.append('&').                 }                 queryBuilder.append(name).             } else {                 for (Object value : values) {                     if (queryBuilder.length() != 0) {                         queryBuilder.append('&').                     }                     queryBuilder.append(name).                     if (value != null) {                         queryBuilder.append('=').append(value.toString()).                     }                 }             }         }).         return queryBuilder.toString().     } else {         return null.     } }
true;public;0;4;/**  * Return the map of query parameters. Empty if no query has been set.  */ ;/**  * Return the map of query parameters. Empty if no query has been set.  */ @Override public MultiValueMap<String, String> getQueryParams() {     return this.queryParams. }
true;;1;19;/**  * Identical to {@link #encode()} but skipping over URI variable placeholders.  * Also {@link #variableEncoder} is initialized with the given charset for  * use later when URI variables are expanded.  */ ;// Encoding /**  * Identical to {@link #encode()} but skipping over URI variable placeholders.  * Also {@link #variableEncoder} is initialized with the given charset for  * use later when URI variables are expanded.  */ HierarchicalUriComponents encodeTemplate(Charset charset) {     if (this.encodeState.isEncoded()) {         return this.     }     // Remember the charset to encode URI variables later..     this.variableEncoder = value -> encodeUriComponent(value, charset, Type.URI).     UriTemplateEncoder encoder = new UriTemplateEncoder(charset).     String schemeTo = (getScheme() != null ? encoder.apply(getScheme(), Type.SCHEME) : null).     String fragmentTo = (getFragment() != null ? encoder.apply(getFragment(), Type.FRAGMENT) : null).     String userInfoTo = (getUserInfo() != null ? encoder.apply(getUserInfo(), Type.USER_INFO) : null).     String hostTo = (getHost() != null ? encoder.apply(getHost(), getHostType()) : null).     PathComponent pathTo = this.path.encode(encoder).     MultiValueMap<String, String> queryParamsTo = encodeQueryParams(encoder).     return new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo, hostTo, this.port, pathTo, queryParamsTo, EncodeState.TEMPLATE_ENCODED, this.variableEncoder). }
false;public;1;18;;@Override public HierarchicalUriComponents encode(Charset charset) {     if (this.encodeState.isEncoded()) {         return this.     }     String scheme = getScheme().     String fragment = getFragment().     String schemeTo = (scheme != null ? encodeUriComponent(scheme, charset, Type.SCHEME) : null).     String fragmentTo = (fragment != null ? encodeUriComponent(fragment, charset, Type.FRAGMENT) : null).     String userInfoTo = (this.userInfo != null ? encodeUriComponent(this.userInfo, charset, Type.USER_INFO) : null).     String hostTo = (this.host != null ? encodeUriComponent(this.host, charset, getHostType()) : null).     BiFunction<String, Type, String> encoder = (s, type) -> encodeUriComponent(s, charset, type).     PathComponent pathTo = this.path.encode(encoder).     MultiValueMap<String, String> queryParamsTo = encodeQueryParams(encoder).     return new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo, hostTo, this.port, pathTo, queryParamsTo, EncodeState.FULLY_ENCODED, null). }
false;private;1;13;;private MultiValueMap<String, String> encodeQueryParams(BiFunction<String, Type, String> encoder) {     int size = this.queryParams.size().     MultiValueMap<String, String> result = new LinkedMultiValueMap<>(size).     this.queryParams.forEach((key, values) -> {         String name = encoder.apply(key, Type.QUERY_PARAM).         List<String> encodedValues = new ArrayList<>(values.size()).         for (String value : values) {             encodedValues.add(value != null ? encoder.apply(value, Type.QUERY_PARAM) : null).         }         result.put(name, encodedValues).     }).     return CollectionUtils.unmodifiableMultiValueMap(result). }
true;static;3;3;/**  * Encode the given source into an encoded String using the rules specified  * by the given component and with the given options.  * @param source the source String  * @param encoding the encoding of the source String  * @param type the URI component for the source  * @return the encoded URI  * @throws IllegalArgumentException when the given value is not a valid URI component  */ ;/**  * Encode the given source into an encoded String using the rules specified  * by the given component and with the given options.  * @param source the source String  * @param encoding the encoding of the source String  * @param type the URI component for the source  * @return the encoded URI  * @throws IllegalArgumentException when the given value is not a valid URI component  */ static String encodeUriComponent(String source, String encoding, Type type) {     return encodeUriComponent(source, Charset.forName(encoding), type). }
true;static;3;28;/**  * Encode the given source into an encoded String using the rules specified  * by the given component and with the given options.  * @param source the source String  * @param charset the encoding of the source String  * @param type the URI component for the source  * @return the encoded URI  * @throws IllegalArgumentException when the given value is not a valid URI component  */ ;/**  * Encode the given source into an encoded String using the rules specified  * by the given component and with the given options.  * @param source the source String  * @param charset the encoding of the source String  * @param type the URI component for the source  * @return the encoded URI  * @throws IllegalArgumentException when the given value is not a valid URI component  */ static String encodeUriComponent(String source, Charset charset, Type type) {     if (!StringUtils.hasLength(source)) {         return source.     }     Assert.notNull(charset, "Charset must not be null").     Assert.notNull(type, "Type must not be null").     byte[] bytes = source.getBytes(charset).     ByteArrayOutputStream bos = new ByteArrayOutputStream(bytes.length).     boolean changed = false.     for (byte b : bytes) {         if (b < 0) {             b += 256.         }         if (type.isAllowed(b)) {             bos.write(b).         } else {             bos.write('%').             char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)).             char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)).             bos.write(hex1).             bos.write(hex2).             changed = true.         }     }     return (changed ? new String(bos.toByteArray(), charset) : source). }
false;private;0;3;;private Type getHostType() {     return (this.host != null && this.host.startsWith("[") ? Type.HOST_IPV6 : Type.HOST_IPV4). }
true;private;0;13;/**  * Check if any of the URI components contain any illegal characters.  * @throws IllegalArgumentException if any component has illegal characters  */ ;// Verifying /**  * Check if any of the URI components contain any illegal characters.  * @throws IllegalArgumentException if any component has illegal characters  */ private void verify() {     verifyUriComponent(getScheme(), Type.SCHEME).     verifyUriComponent(this.userInfo, Type.USER_INFO).     verifyUriComponent(this.host, getHostType()).     this.path.verify().     this.queryParams.forEach((key, values) -> {         verifyUriComponent(key, Type.QUERY_PARAM).         for (String value : values) {             verifyUriComponent(value, Type.QUERY_PARAM).         }     }).     verifyUriComponent(getFragment(), Type.FRAGMENT). }
false;private,static;2;30;;private static void verifyUriComponent(@Nullable String source, Type type) {     if (source == null) {         return.     }     int length = source.length().     for (int i = 0. i < length. i++) {         char ch = source.charAt(i).         if (ch == '%') {             if ((i + 2) < length) {                 char hex1 = source.charAt(i + 1).                 char hex2 = source.charAt(i + 2).                 int u = Character.digit(hex1, 16).                 int l = Character.digit(hex2, 16).                 if (u == -1 || l == -1) {                     throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"").                 }                 i += 2.             } else {                 throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"").             }         } else if (!type.isAllowed(ch)) {             throw new IllegalArgumentException("Invalid character '" + ch + "' for " + type.name() + " in \"" + source + "\"").         }     } }
false;protected;1;17;;// Expanding @Override protected HierarchicalUriComponents expandInternal(UriTemplateVariables uriVariables) {     Assert.state(!this.encodeState.equals(EncodeState.FULLY_ENCODED), "URI components already encoded, and could not possibly contain '{' or '}'.").     String schemeTo = expandUriComponent(getScheme(), uriVariables, this.variableEncoder).     String fragmentTo = expandUriComponent(getFragment(), uriVariables, this.variableEncoder).     String userInfoTo = expandUriComponent(this.userInfo, uriVariables, this.variableEncoder).     String hostTo = expandUriComponent(this.host, uriVariables, this.variableEncoder).     String portTo = expandUriComponent(this.port, uriVariables, this.variableEncoder).     PathComponent pathTo = this.path.expand(uriVariables, this.variableEncoder).     MultiValueMap<String, String> queryParamsTo = expandQueryParams(uriVariables).     return new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo, hostTo, portTo, pathTo, queryParamsTo, this.encodeState, this.variableEncoder). }
false;private;1;14;;private MultiValueMap<String, String> expandQueryParams(UriTemplateVariables variables) {     int size = this.queryParams.size().     MultiValueMap<String, String> result = new LinkedMultiValueMap<>(size).     UriTemplateVariables queryVariables = new QueryUriTemplateVariables(variables).     this.queryParams.forEach((key, values) -> {         String name = expandUriComponent(key, queryVariables, this.variableEncoder).         List<String> expandedValues = new ArrayList<>(values.size()).         for (String value : values) {             expandedValues.add(expandUriComponent(value, queryVariables, this.variableEncoder)).         }         result.put(name, expandedValues).     }).     return CollectionUtils.unmodifiableMultiValueMap(result). }
false;public;0;7;;@Override public UriComponents normalize() {     String normalizedPath = StringUtils.cleanPath(getPath()).     FullPathComponent path = new FullPathComponent(normalizedPath).     return new HierarchicalUriComponents(getScheme(), getFragment(), this.userInfo, this.host, this.port, path, this.queryParams, this.encodeState, this.variableEncoder). }
false;public;0;34;;// Other functionality @Override public String toUriString() {     StringBuilder uriBuilder = new StringBuilder().     if (getScheme() != null) {         uriBuilder.append(getScheme()).append(':').     }     if (this.userInfo != null || this.host != null) {         uriBuilder.append("//").         if (this.userInfo != null) {             uriBuilder.append(this.userInfo).append('@').         }         if (this.host != null) {             uriBuilder.append(this.host).         }         if (getPort() != -1) {             uriBuilder.append(':').append(this.port).         }     }     String path = getPath().     if (StringUtils.hasLength(path)) {         if (uriBuilder.length() != 0 && path.charAt(0) != PATH_DELIMITER) {             uriBuilder.append(PATH_DELIMITER).         }         uriBuilder.append(path).     }     String query = getQuery().     if (query != null) {         uriBuilder.append('?').append(query).     }     if (getFragment() != null) {         uriBuilder.append('#').append(getFragment()).     }     return uriBuilder.toString(). }
false;public;0;21;;@Override public URI toUri() {     try {         if (this.encodeState.isEncoded()) {             return new URI(toUriString()).         } else {             String path = getPath().             if (StringUtils.hasLength(path) && path.charAt(0) != PATH_DELIMITER) {                 // Only prefix the path delimiter if something exists before it                 if (getScheme() != null || getUserInfo() != null || getHost() != null || getPort() != -1) {                     path = PATH_DELIMITER + path.                 }             }             return new URI(getScheme(), getUserInfo(), getHost(), getPort(), path, getQuery(), getFragment()).         }     } catch (URISyntaxException ex) {         throw new IllegalStateException("Could not create URI object: " + ex.getMessage(), ex).     } }
false;protected;1;23;;@Override protected void copyToUriComponentsBuilder(UriComponentsBuilder builder) {     if (getScheme() != null) {         builder.scheme(getScheme()).     }     if (getUserInfo() != null) {         builder.userInfo(getUserInfo()).     }     if (getHost() != null) {         builder.host(getHost()).     }     // Avoid parsing the port, may have URI variable..     if (this.port != null) {         builder.port(this.port).     }     this.path.copyToUriComponentsBuilder(builder).     if (!getQueryParams().isEmpty()) {         builder.queryParams(getQueryParams()).     }     if (getFragment() != null) {         builder.fragment(getFragment()).     } }
false;public;1;17;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof HierarchicalUriComponents)) {         return false.     }     HierarchicalUriComponents otherComp = (HierarchicalUriComponents) other.     return (ObjectUtils.nullSafeEquals(getScheme(), otherComp.getScheme()) && ObjectUtils.nullSafeEquals(getUserInfo(), otherComp.getUserInfo()) && ObjectUtils.nullSafeEquals(getHost(), otherComp.getHost()) && getPort() == otherComp.getPort() && this.path.equals(otherComp.path) && this.queryParams.equals(otherComp.queryParams) && ObjectUtils.nullSafeEquals(getFragment(), otherComp.getFragment())). }
false;public;0;11;;@Override public int hashCode() {     int result = ObjectUtils.nullSafeHashCode(getScheme()).     result = 31 * result + ObjectUtils.nullSafeHashCode(this.userInfo).     result = 31 * result + ObjectUtils.nullSafeHashCode(this.host).     result = 31 * result + ObjectUtils.nullSafeHashCode(this.port).     result = 31 * result + this.path.hashCode().     result = 31 * result + this.queryParams.hashCode().     result = 31 * result + ObjectUtils.nullSafeHashCode(getFragment()).     return result. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isAlpha(c) || isDigit(c) || '+' == c || '-' == c || '.' == c. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isUnreserved(c) || isSubDelimiter(c) || ':' == c || '@' == c. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isUnreserved(c) || isSubDelimiter(c) || ':' == c. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isUnreserved(c) || isSubDelimiter(c). }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isUnreserved(c) || isSubDelimiter(c) || '[' == c || ']' == c || ':' == c. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isDigit(c). }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isPchar(c) || '/' == c. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isPchar(c). }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isPchar(c) || '/' == c || '?' == c. }
false;public;1;9;;@Override public boolean isAllowed(int c) {     if ('=' == c || '&' == c) {         return false.     } else {         return isPchar(c) || '/' == c || '?' == c.     } }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isPchar(c) || '/' == c || '?' == c. }
false;public;1;4;;@Override public boolean isAllowed(int c) {     return isUnreserved(c). }
true;public,abstract;1;1;/**  * Indicates whether the given character is allowed in this URI component.  * @return {@code true} if the character is allowed. {@code false} otherwise  */ ;/**  * Indicates whether the given character is allowed in this URI component.  * @return {@code true} if the character is allowed. {@code false} otherwise  */ public abstract boolean isAllowed(int c).
true;protected;1;3;/**  * Indicates whether the given character is in the {@code ALPHA} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code ALPHA} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isAlpha(int c) {     return (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'). }
true;protected;1;3;/**  * Indicates whether the given character is in the {@code DIGIT} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code DIGIT} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isDigit(int c) {     return (c >= '0' && c <= '9'). }
true;protected;1;3;/**  * Indicates whether the given character is in the {@code gen-delims} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code gen-delims} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isGenericDelimiter(int c) {     return (':' == c || '/' == c || '?' == c || '#' == c || '[' == c || ']' == c || '@' == c). }
true;protected;1;4;/**  * Indicates whether the given character is in the {@code sub-delims} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code sub-delims} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isSubDelimiter(int c) {     return ('!' == c || '$' == c || '&' == c || '\'' == c || '(' == c || ')' == c || '*' == c || '+' == c || ',' == c || '.' == c || '=' == c). }
true;protected;1;3;/**  * Indicates whether the given character is in the {@code reserved} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code reserved} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isReserved(int c) {     return (isGenericDelimiter(c) || isSubDelimiter(c)). }
true;protected;1;3;/**  * Indicates whether the given character is in the {@code unreserved} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code unreserved} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isUnreserved(int c) {     return (isAlpha(c) || isDigit(c) || '-' == c || '.' == c || '_' == c || '~' == c). }
true;protected;1;3;/**  * Indicates whether the given character is in the {@code pchar} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ ;/**  * Indicates whether the given character is in the {@code pchar} set.  * @see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986, appendix A</a>  */ protected boolean isPchar(int c) {     return (isUnreserved(c) || isSubDelimiter(c) || ':' == c || '@' == c). }
false;public;0;3;;public boolean isEncoded() {     return this.equals(FULLY_ENCODED) || this.equals(TEMPLATE_ENCODED). }
false;public;2;46;;@Override public String apply(String source, Type type) {     // Only URI variable (nothing to encode)..     if (source.length() > 1 && source.charAt(0) == '{' && source.charAt(source.length() - 1) == '}') {         return source.     }     // Only literal (encode full source)..     if (source.indexOf('{') == -1) {         return encodeUriComponent(source, this.charset, type).     }     // Mixed literal parts and URI variables, maybe (encode literal parts only)..     int level = 0.     clear(this.currentLiteral).     clear(this.currentVariable).     clear(this.output).     for (char c : source.toCharArray()) {         if (c == '{') {             level++.             if (level == 1) {                 encodeAndAppendCurrentLiteral(type).             }         }         if (c == '}' && level > 0) {             level--.             this.currentVariable.append('}').             if (level == 0) {                 this.output.append(this.currentVariable).                 clear(this.currentVariable).             }         } else if (level > 0) {             this.currentVariable.append(c).         } else {             this.currentLiteral.append(c).         }     }     if (level > 0) {         this.currentLiteral.append(this.currentVariable).     }     encodeAndAppendCurrentLiteral(type).     return this.output.toString(). }
false;private;1;4;;private void encodeAndAppendCurrentLiteral(Type type) {     this.output.append(encodeUriComponent(this.currentLiteral.toString(), this.charset, type)).     clear(this.currentLiteral). }
false;private;1;3;;private void clear(StringBuilder sb) {     sb.delete(0, sb.length()). }
false;;0;1;;String getPath().
false;;0;1;;List<String> getPathSegments().
false;;1;1;;PathComponent encode(BiFunction<String, Type, String> encoder).
false;;0;1;;void verify().
false;;2;1;;PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder).
false;;1;1;;void copyToUriComponentsBuilder(UriComponentsBuilder builder).
false;public;0;4;;@Override public String getPath() {     return this.path. }
false;public;0;5;;@Override public List<String> getPathSegments() {     String[] segments = StringUtils.tokenizeToStringArray(getPath(), PATH_DELIMITER_STRING).     return Collections.unmodifiableList(Arrays.asList(segments)). }
false;public;1;5;;@Override public PathComponent encode(BiFunction<String, Type, String> encoder) {     String encodedPath = encoder.apply(getPath(), Type.PATH).     return new FullPathComponent(encodedPath). }
false;public;0;4;;@Override public void verify() {     verifyUriComponent(getPath(), Type.PATH). }
false;public;2;5;;@Override public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {     String expandedPath = expandUriComponent(getPath(), uriVariables, encoder).     return new FullPathComponent(expandedPath). }
false;public;1;4;;@Override public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {     builder.path(getPath()). }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof FullPathComponent && getPath().equals(((FullPathComponent) other).getPath()))). }
false;public;0;4;;@Override public int hashCode() {     return getPath().hashCode(). }
false;public;0;13;;@Override public String getPath() {     StringBuilder pathBuilder = new StringBuilder().     pathBuilder.append(PATH_DELIMITER).     for (Iterator<String> iterator = this.pathSegments.iterator(). iterator.hasNext(). ) {         String pathSegment = iterator.next().         pathBuilder.append(pathSegment).         if (iterator.hasNext()) {             pathBuilder.append(PATH_DELIMITER).         }     }     return pathBuilder.toString(). }
false;public;0;4;;@Override public List<String> getPathSegments() {     return this.pathSegments. }
false;public;1;10;;@Override public PathComponent encode(BiFunction<String, Type, String> encoder) {     List<String> pathSegments = getPathSegments().     List<String> encodedPathSegments = new ArrayList<>(pathSegments.size()).     for (String pathSegment : pathSegments) {         String encodedPathSegment = encoder.apply(pathSegment, Type.PATH_SEGMENT).         encodedPathSegments.add(encodedPathSegment).     }     return new PathSegmentComponent(encodedPathSegments). }
false;public;0;6;;@Override public void verify() {     for (String pathSegment : getPathSegments()) {         verifyUriComponent(pathSegment, Type.PATH_SEGMENT).     } }
false;public;2;10;;@Override public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {     List<String> pathSegments = getPathSegments().     List<String> expandedPathSegments = new ArrayList<>(pathSegments.size()).     for (String pathSegment : pathSegments) {         String expandedPathSegment = expandUriComponent(pathSegment, uriVariables, encoder).         expandedPathSegments.add(expandedPathSegment).     }     return new PathSegmentComponent(expandedPathSegments). }
false;public;1;4;;@Override public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {     builder.pathSegment(StringUtils.toStringArray(getPathSegments())). }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof PathSegmentComponent && getPathSegments().equals(((PathSegmentComponent) other).getPathSegments()))). }
false;public;0;4;;@Override public int hashCode() {     return getPathSegments().hashCode(). }
false;public;0;8;;@Override public String getPath() {     StringBuilder pathBuilder = new StringBuilder().     for (PathComponent pathComponent : this.pathComponents) {         pathBuilder.append(pathComponent.getPath()).     }     return pathBuilder.toString(). }
false;public;0;8;;@Override public List<String> getPathSegments() {     List<String> result = new ArrayList<>().     for (PathComponent pathComponent : this.pathComponents) {         result.addAll(pathComponent.getPathSegments()).     }     return result. }
false;public;1;8;;@Override public PathComponent encode(BiFunction<String, Type, String> encoder) {     List<PathComponent> encodedComponents = new ArrayList<>(this.pathComponents.size()).     for (PathComponent pathComponent : this.pathComponents) {         encodedComponents.add(pathComponent.encode(encoder)).     }     return new PathComponentComposite(encodedComponents). }
false;public;0;6;;@Override public void verify() {     for (PathComponent pathComponent : this.pathComponents) {         pathComponent.verify().     } }
false;public;2;8;;@Override public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {     List<PathComponent> expandedComponents = new ArrayList<>(this.pathComponents.size()).     for (PathComponent pathComponent : this.pathComponents) {         expandedComponents.add(pathComponent.expand(uriVariables, encoder)).     }     return new PathComponentComposite(expandedComponents). }
false;public;1;6;;@Override public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {     for (PathComponent pathComponent : this.pathComponents) {         pathComponent.copyToUriComponentsBuilder(builder).     } }
false;public;1;8;;@Override public Object getValue(@Nullable String name) {     Object value = this.delegate.getValue(name).     if (ObjectUtils.isArray(value)) {         value = StringUtils.arrayToCommaDelimitedString(ObjectUtils.toObjectArray(value)).     }     return value. }
