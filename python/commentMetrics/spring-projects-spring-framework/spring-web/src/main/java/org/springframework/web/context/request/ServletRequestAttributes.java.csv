commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Exposes the native {@link HttpServletRequest} that we're wrapping.  */ ;/**  * Exposes the native {@link HttpServletRequest} that we're wrapping.  */ public final HttpServletRequest getRequest() {     return this.request. }
true;public,final;0;4;/**  * Exposes the native {@link HttpServletResponse} that we're wrapping (if any).  */ ;/**  * Exposes the native {@link HttpServletResponse} that we're wrapping (if any).  */ @Nullable public final HttpServletResponse getResponse() {     return this.response. }
true;protected,final;1;23;/**  * Exposes the {@link HttpSession} that we're wrapping.  * @param allowCreate whether to allow creation of a new session if none exists yet  */ ;/**  * Exposes the {@link HttpSession} that we're wrapping.  * @param allowCreate whether to allow creation of a new session if none exists yet  */ @Nullable protected final HttpSession getSession(boolean allowCreate) {     if (isRequestActive()) {         HttpSession session = this.request.getSession(allowCreate).         this.session = session.         return session.     } else {         // Access through stored session reference, if any...         HttpSession session = this.session.         if (session == null) {             if (allowCreate) {                 throw new IllegalStateException("No session found and request already completed - cannot create new session!").             } else {                 session = this.request.getSession(false).                 this.session = session.             }         }         return session.     } }
false;private;0;5;;private HttpSession obtainSession() {     HttpSession session = getSession(true).     Assert.state(session != null, "No HttpSession").     return session. }
false;public;2;26;;@Override public Object getAttribute(String name, int scope) {     if (scope == SCOPE_REQUEST) {         if (!isRequestActive()) {             throw new IllegalStateException("Cannot ask for request attribute - request is not active anymore!").         }         return this.request.getAttribute(name).     } else {         HttpSession session = getSession(false).         if (session != null) {             try {                 Object value = session.getAttribute(name).                 if (value != null) {                     this.sessionAttributesToUpdate.put(name, value).                 }                 return value.             } catch (IllegalStateException ex) {             // Session invalidated - shouldn't usually happen.             }         }         return null.     } }
false;public;3;15;;@Override public void setAttribute(String name, Object value, int scope) {     if (scope == SCOPE_REQUEST) {         if (!isRequestActive()) {             throw new IllegalStateException("Cannot set request attribute - request is not active anymore!").         }         this.request.setAttribute(name, value).     } else {         HttpSession session = obtainSession().         this.sessionAttributesToUpdate.remove(name).         session.setAttribute(name, value).     } }
false;public;2;23;;@Override public void removeAttribute(String name, int scope) {     if (scope == SCOPE_REQUEST) {         if (isRequestActive()) {             this.request.removeAttribute(name).             removeRequestDestructionCallback(name).         }     } else {         HttpSession session = getSession(false).         if (session != null) {             this.sessionAttributesToUpdate.remove(name).             try {                 session.removeAttribute(name).                 // Remove any registered destruction callback as well.                 session.removeAttribute(DESTRUCTION_CALLBACK_NAME_PREFIX + name).             } catch (IllegalStateException ex) {             // Session invalidated - shouldn't usually happen.             }         }     } }
false;public;1;22;;@Override public String[] getAttributeNames(int scope) {     if (scope == SCOPE_REQUEST) {         if (!isRequestActive()) {             throw new IllegalStateException("Cannot ask for request attributes - request is not active anymore!").         }         return StringUtils.toStringArray(this.request.getAttributeNames()).     } else {         HttpSession session = getSession(false).         if (session != null) {             try {                 return StringUtils.toStringArray(session.getAttributeNames()).             } catch (IllegalStateException ex) {             // Session invalidated - shouldn't usually happen.             }         }         return new String[0].     } }
false;public;3;9;;@Override public void registerDestructionCallback(String name, Runnable callback, int scope) {     if (scope == SCOPE_REQUEST) {         registerRequestDestructionCallback(name, callback).     } else {         registerSessionDestructionCallback(name, callback).     } }
false;public;1;12;;@Override public Object resolveReference(String key) {     if (REFERENCE_REQUEST.equals(key)) {         return this.request.     } else if (REFERENCE_SESSION.equals(key)) {         return getSession(true).     } else {         return null.     } }
false;public;0;4;;@Override public String getSessionId() {     return obtainSession().getId(). }
false;public;0;4;;@Override public Object getSessionMutex() {     return WebUtils.getSessionMutex(obtainSession()). }
true;protected;0;23;/**  * Update all accessed session attributes through {@code session.setAttribute}  * calls, explicitly indicating to the container that they might have been modified.  */ ;/**  * Update all accessed session attributes through {@code session.setAttribute}  * calls, explicitly indicating to the container that they might have been modified.  */ @Override protected void updateAccessedSessionAttributes() {     if (!this.sessionAttributesToUpdate.isEmpty()) {         // Update all affected session attributes.         HttpSession session = getSession(false).         if (session != null) {             try {                 for (Map.Entry<String, Object> entry : this.sessionAttributesToUpdate.entrySet()) {                     String name = entry.getKey().                     Object newValue = entry.getValue().                     Object oldValue = session.getAttribute(name).                     if (oldValue == newValue && !isImmutableSessionAttribute(name, newValue)) {                         session.setAttribute(name, newValue).                     }                 }             } catch (IllegalStateException ex) {             // Session invalidated - shouldn't usually happen.             }         }         this.sessionAttributesToUpdate.clear().     } }
true;protected;2;3;/**  * Determine whether the given value is to be considered as an immutable session  * attribute, that is, doesn't have to be re-set via {@code session.setAttribute}  * since its value cannot meaningfully change internally.  * <p>The default implementation returns {@code true} for {@code String},  * {@code Character}, {@code Boolean} and standard {@code Number} values.  * @param name the name of the attribute  * @param value the corresponding value to check  * @return {@code true} if the value is to be considered as immutable for the  * purposes of session attribute management. {@code false} otherwise  * @see #updateAccessedSessionAttributes()  */ ;/**  * Determine whether the given value is to be considered as an immutable session  * attribute, that is, doesn't have to be re-set via {@code session.setAttribute}  * since its value cannot meaningfully change internally.  * <p>The default implementation returns {@code true} for {@code String},  * {@code Character}, {@code Boolean} and standard {@code Number} values.  * @param name the name of the attribute  * @param value the corresponding value to check  * @return {@code true} if the value is to be considered as immutable for the  * purposes of session attribute management. {@code false} otherwise  * @see #updateAccessedSessionAttributes()  */ protected boolean isImmutableSessionAttribute(String name, @Nullable Object value) {     return (value == null || immutableValueTypes.contains(value.getClass())). }
true;protected;2;5;/**  * Register the given callback as to be executed after session termination.  * <p>Note: The callback object should be serializable in order to survive  * web app restarts.  * @param name the name of the attribute to register the callback for  * @param callback the callback to be executed for destruction  */ ;/**  * Register the given callback as to be executed after session termination.  * <p>Note: The callback object should be serializable in order to survive  * web app restarts.  * @param name the name of the attribute to register the callback for  * @param callback the callback to be executed for destruction  */ protected void registerSessionDestructionCallback(String name, Runnable callback) {     HttpSession session = obtainSession().     session.setAttribute(DESTRUCTION_CALLBACK_NAME_PREFIX + name, new DestructionCallbackBindingListener(callback)). }
false;public;0;4;;@Override public String toString() {     return this.request.toString(). }
