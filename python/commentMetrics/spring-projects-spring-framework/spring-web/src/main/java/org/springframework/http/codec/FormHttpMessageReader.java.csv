commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the default character set to use for reading form data when the  * request Content-Type header does not explicitly specify it.  * <p>By default this is set to "UTF-8".  */ ;/**  * Set the default character set to use for reading form data when the  * request Content-Type header does not explicitly specify it.  * <p>By default this is set to "UTF-8".  */ public void setDefaultCharset(Charset charset) {     Assert.notNull(charset, "Charset must not be null").     this.defaultCharset = charset. }
true;public;0;3;/**  * Return the configured default charset.  */ ;/**  * Return the configured default charset.  */ public Charset getDefaultCharset() {     return this.defaultCharset. }
false;public;2;7;;@Override public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {     return ((MULTIVALUE_TYPE.isAssignableFrom(elementType) || (elementType.hasUnresolvableGenerics() && MultiValueMap.class.isAssignableFrom(elementType.toClass()))) && (mediaType == null || MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType))). }
false;public;3;6;;@Override public Flux<MultiValueMap<String, String>> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     return Flux.from(readMono(elementType, message, hints)). }
false;public;3;17;;@Override public Mono<MultiValueMap<String, String>> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     MediaType contentType = message.getHeaders().getContentType().     Charset charset = getMediaTypeCharset(contentType).     return DataBufferUtils.join(message.getBody()).map(buffer -> {         CharBuffer charBuffer = charset.decode(buffer.asByteBuffer()).         String body = charBuffer.toString().         DataBufferUtils.release(buffer).         MultiValueMap<String, String> formData = parseFormData(charset, body).         logFormData(formData, hints).         return formData.     }). }
false;private;2;6;;private void logFormData(MultiValueMap<String, String> formData, Map<String, Object> hints) {     LogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + "Read " + (isEnableLoggingRequestDetails() ? LogFormatUtils.formatValue(formData, !traceOn) : "form fields " + formData.keySet() + " (content masked)")). }
false;private;1;8;;private Charset getMediaTypeCharset(@Nullable MediaType mediaType) {     if (mediaType != null && mediaType.getCharset() != null) {         return mediaType.getCharset().     } else {         return getDefaultCharset().     } }
false;private;2;21;;private MultiValueMap<String, String> parseFormData(Charset charset, String body) {     String[] pairs = StringUtils.tokenizeToStringArray(body, "&").     MultiValueMap<String, String> result = new LinkedMultiValueMap<>(pairs.length).     try {         for (String pair : pairs) {             int idx = pair.indexOf('=').             if (idx == -1) {                 result.add(URLDecoder.decode(pair, charset.name()), null).             } else {                 String name = URLDecoder.decode(pair.substring(0, idx), charset.name()).                 String value = URLDecoder.decode(pair.substring(idx + 1), charset.name()).                 result.add(name, value).             }         }     } catch (UnsupportedEncodingException ex) {         throw new IllegalStateException(ex).     }     return result. }
false;public;0;4;;@Override public List<MediaType> getReadableMediaTypes() {     return Collections.singletonList(MediaType.APPLICATION_FORM_URLENCODED). }
