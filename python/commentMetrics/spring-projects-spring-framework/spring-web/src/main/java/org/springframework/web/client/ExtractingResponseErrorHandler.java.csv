commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the message converters to use by this extractor.  */ ;/**  * Set the message converters to use by this extractor.  */ public void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {     this.messageConverters = messageConverters. }
true;public;1;5;/**  * Set the mapping from HTTP status code to {@code RestClientException} subclass.  * If this mapping has a match  * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given  * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return  * {@code true} and {@link #handleError(ClientHttpResponse)} will attempt to use the  * {@linkplain #setMessageConverters(List) configured message converters} to convert the  * response into the mapped subclass of {@link RestClientException}.  */ ;/**  * Set the mapping from HTTP status code to {@code RestClientException} subclass.  * If this mapping has a match  * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given  * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return  * {@code true} and {@link #handleError(ClientHttpResponse)} will attempt to use the  * {@linkplain #setMessageConverters(List) configured message converters} to convert the  * response into the mapped subclass of {@link RestClientException}.  */ public void setStatusMapping(Map<HttpStatus, Class<? extends RestClientException>> statusMapping) {     if (!CollectionUtils.isEmpty(statusMapping)) {         this.statusMapping.putAll(statusMapping).     } }
true;public;1;5;/**  * Set the mapping from HTTP status series to {@code RestClientException} subclass.  * If this mapping has a match  * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given  * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return  * {@code true} and {@link #handleError(ClientHttpResponse)} will attempt to use the  * {@linkplain #setMessageConverters(List) configured message converters} to convert the  * response into the mapped subclass of {@link RestClientException}.  */ ;/**  * Set the mapping from HTTP status series to {@code RestClientException} subclass.  * If this mapping has a match  * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given  * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return  * {@code true} and {@link #handleError(ClientHttpResponse)} will attempt to use the  * {@linkplain #setMessageConverters(List) configured message converters} to convert the  * response into the mapped subclass of {@link RestClientException}.  */ public void setSeriesMapping(Map<HttpStatus.Series, Class<? extends RestClientException>> seriesMapping) {     if (!CollectionUtils.isEmpty(seriesMapping)) {         this.seriesMapping.putAll(seriesMapping).     } }
false;protected;1;12;;@Override protected boolean hasError(HttpStatus statusCode) {     if (this.statusMapping.containsKey(statusCode)) {         return this.statusMapping.get(statusCode) != null.     } else if (this.seriesMapping.containsKey(statusCode.series())) {         return this.seriesMapping.get(statusCode.series()) != null.     } else {         return super.hasError(statusCode).     } }
false;public;2;12;;@Override public void handleError(ClientHttpResponse response, HttpStatus statusCode) throws IOException {     if (this.statusMapping.containsKey(statusCode)) {         extract(this.statusMapping.get(statusCode), response).     } else if (this.seriesMapping.containsKey(statusCode.series())) {         extract(this.seriesMapping.get(statusCode.series()), response).     } else {         super.handleError(response, statusCode).     } }
false;private;2;14;;private void extract(@Nullable Class<? extends RestClientException> exceptionClass, ClientHttpResponse response) throws IOException {     if (exceptionClass == null) {         return.     }     HttpMessageConverterExtractor<? extends RestClientException> extractor = new HttpMessageConverterExtractor<>(exceptionClass, this.messageConverters).     RestClientException exception = extractor.extractData(response).     if (exception != null) {         throw exception.     } }
