commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return {@code true} if this DeferredResult is no longer usable either  * because it was previously set or because the underlying request expired.  * <p>The result may have been set with a call to {@link #setResult(Object)},  * or {@link #setErrorResult(Object)}, or as a result of a timeout, if a  * timeout result was provided to the constructor. The request may also  * expire due to a timeout or network error.  */ ;/**  * Return {@code true} if this DeferredResult is no longer usable either  * because it was previously set or because the underlying request expired.  * <p>The result may have been set with a call to {@link #setResult(Object)},  * or {@link #setErrorResult(Object)}, or as a result of a timeout, if a  * timeout result was provided to the constructor. The request may also  * expire due to a timeout or network error.  */ public final boolean isSetOrExpired() {     return (this.result != RESULT_NONE || this.expired). }
true;public;0;3;/**  * Return {@code true} if the DeferredResult has been set.  * @since 4.0  */ ;/**  * Return {@code true} if the DeferredResult has been set.  * @since 4.0  */ public boolean hasResult() {     return (this.result != RESULT_NONE). }
true;public;0;5;/**  * Return the result, or {@code null} if the result wasn't set. Since the result  * can also be {@code null}, it is recommended to use {@link #hasResult()} first  * to check if there is a result prior to calling this method.  * @since 4.0  */ ;/**  * Return the result, or {@code null} if the result wasn't set. Since the result  * can also be {@code null}, it is recommended to use {@link #hasResult()} first  * to check if there is a result prior to calling this method.  * @since 4.0  */ @Nullable public Object getResult() {     Object resultToCheck = this.result.     return (resultToCheck != RESULT_NONE ? resultToCheck : null). }
true;final;0;4;/**  * Return the configured timeout value in milliseconds.  */ ;/**  * Return the configured timeout value in milliseconds.  */ @Nullable final Long getTimeoutValue() {     return this.timeout. }
true;public;1;3;/**  * Register code to invoke when the async request times out.  * <p>This method is called from a container thread when an async request  * times out before the {@code DeferredResult} has been populated.  * It may invoke {@link DeferredResult#setResult setResult} or  * {@link DeferredResult#setErrorResult setErrorResult} to resume processing.  */ ;/**  * Register code to invoke when the async request times out.  * <p>This method is called from a container thread when an async request  * times out before the {@code DeferredResult} has been populated.  * It may invoke {@link DeferredResult#setResult setResult} or  * {@link DeferredResult#setErrorResult setErrorResult} to resume processing.  */ public void onTimeout(Runnable callback) {     this.timeoutCallback = callback. }
true;public;1;3;/**  * Register code to invoke when an error occurred during the async request.  * <p>This method is called from a container thread when an error occurs  * while processing an async request before the {@code DeferredResult} has  * been populated. It may invoke {@link DeferredResult#setResult setResult}  * or {@link DeferredResult#setErrorResult setErrorResult} to resume  * processing.  * @since 5.0  */ ;/**  * Register code to invoke when an error occurred during the async request.  * <p>This method is called from a container thread when an error occurs  * while processing an async request before the {@code DeferredResult} has  * been populated. It may invoke {@link DeferredResult#setResult setResult}  * or {@link DeferredResult#setErrorResult setErrorResult} to resume  * processing.  * @since 5.0  */ public void onError(Consumer<Throwable> callback) {     this.errorCallback = callback. }
true;public;1;3;/**  * Register code to invoke when the async request completes.  * <p>This method is called from a container thread when an async request  * completed for any reason including timeout and network error. This is useful  * for detecting that a {@code DeferredResult} instance is no longer usable.  */ ;/**  * Register code to invoke when the async request completes.  * <p>This method is called from a container thread when an async request  * completed for any reason including timeout and network error. This is useful  * for detecting that a {@code DeferredResult} instance is no longer usable.  */ public void onCompletion(Runnable callback) {     this.completionCallback = callback. }
true;public,final;1;29;/**  * Provide a handler to use to handle the result value.  * @param resultHandler the handler  * @see DeferredResultProcessingInterceptor  */ ;/**  * Provide a handler to use to handle the result value.  * @param resultHandler the handler  * @see DeferredResultProcessingInterceptor  */ public final void setResultHandler(DeferredResultHandler resultHandler) {     Assert.notNull(resultHandler, "DeferredResultHandler is required").     // Immediate expiration check outside of the result lock     if (this.expired) {         return.     }     Object resultToHandle.     synchronized (this) {         // Got the lock in the meantime: double-check expiration status         if (this.expired) {             return.         }         resultToHandle = this.result.         if (resultToHandle == RESULT_NONE) {             // No result yet: store handler for processing once it comes in             this.resultHandler = resultHandler.             return.         }     }     // of it, avoiding any deadlock potential with Servlet container locks.     try {         resultHandler.handleResult(resultToHandle).     } catch (Throwable ex) {         logger.debug("Failed to process async result", ex).     } }
true;public;1;3;/**  * Set the value for the DeferredResult and handle it.  * @param result the value to set  * @return {@code true} if the result was set and passed on for handling.  * {@code false} if the result was already set or the async request expired  * @see #isSetOrExpired()  */ ;/**  * Set the value for the DeferredResult and handle it.  * @param result the value to set  * @return {@code true} if the result was set and passed on for handling.  * {@code false} if the result was already set or the async request expired  * @see #isSetOrExpired()  */ public boolean setResult(T result) {     return setResultInternal(result). }
false;private;1;29;;private boolean setResultInternal(Object result) {     // Immediate expiration check outside of the result lock     if (isSetOrExpired()) {         return false.     }     DeferredResultHandler resultHandlerToUse.     synchronized (this) {         // Got the lock in the meantime: double-check expiration status         if (isSetOrExpired()) {             return false.         }         // At this point, we got a new result to process         this.result = result.         resultHandlerToUse = this.resultHandler.         if (resultHandlerToUse == null) {             // pick up the result object and invoke the result handler for it.             return true.         }         // Result handler available -> let's clear the stored reference since         // we don't need it anymore.         this.resultHandler = null.     }     // If we get here, we need to process an existing result object immediately.     // The decision is made within the result lock. just the handle call outside     // of it, avoiding any deadlock potential with Servlet container locks.     resultHandlerToUse.handleResult(result).     return true. }
true;public;1;3;/**  * Set an error value for the {@link DeferredResult} and handle it.  * The value may be an {@link Exception} or {@link Throwable} in which case  * it will be processed as if a handler raised the exception.  * @param result the error result value  * @return {@code true} if the result was set to the error value and passed on  * for handling. {@code false} if the result was already set or the async  * request expired  * @see #isSetOrExpired()  */ ;/**  * Set an error value for the {@link DeferredResult} and handle it.  * The value may be an {@link Exception} or {@link Throwable} in which case  * it will be processed as if a handler raised the exception.  * @param result the error result value  * @return {@code true} if the result was set to the error value and passed on  * for handling. {@code false} if the result was already set or the async  * request expired  * @see #isSetOrExpired()  */ public boolean setErrorResult(Object result) {     return setResultInternal(result). }
false;public;2;22;;@Override public <S> boolean handleTimeout(NativeWebRequest request, DeferredResult<S> deferredResult) {     boolean continueProcessing = true.     try {         if (timeoutCallback != null) {             timeoutCallback.run().         }     } finally {         Object value = timeoutResult.get().         if (value != RESULT_NONE) {             continueProcessing = false.             try {                 setResultInternal(value).             } catch (Throwable ex) {                 logger.debug("Failed to handle timeout result", ex).             }         }     }     return continueProcessing. }
false;public;3;17;;@Override public <S> boolean handleError(NativeWebRequest request, DeferredResult<S> deferredResult, Throwable t) {     try {         if (errorCallback != null) {             errorCallback.accept(t).         }     } finally {         try {             setResultInternal(t).         } catch (Throwable ex) {             logger.debug("Failed to handle error result", ex).         }     }     return false. }
false;public;2;7;;@Override public <S> void afterCompletion(NativeWebRequest request, DeferredResult<S> deferredResult) {     expired = true.     if (completionCallback != null) {         completionCallback.run().     } }
false;final;0;50;;final DeferredResultProcessingInterceptor getInterceptor() {     return new DeferredResultProcessingInterceptor() {          @Override         public <S> boolean handleTimeout(NativeWebRequest request, DeferredResult<S> deferredResult) {             boolean continueProcessing = true.             try {                 if (timeoutCallback != null) {                     timeoutCallback.run().                 }             } finally {                 Object value = timeoutResult.get().                 if (value != RESULT_NONE) {                     continueProcessing = false.                     try {                         setResultInternal(value).                     } catch (Throwable ex) {                         logger.debug("Failed to handle timeout result", ex).                     }                 }             }             return continueProcessing.         }          @Override         public <S> boolean handleError(NativeWebRequest request, DeferredResult<S> deferredResult, Throwable t) {             try {                 if (errorCallback != null) {                     errorCallback.accept(t).                 }             } finally {                 try {                     setResultInternal(t).                 } catch (Throwable ex) {                     logger.debug("Failed to handle error result", ex).                 }             }             return false.         }          @Override         public <S> void afterCompletion(NativeWebRequest request, DeferredResult<S> deferredResult) {             expired = true.             if (completionCallback != null) {                 completionCallback.run().             }         }     }. }
false;;1;1;;void handleResult(Object result).
