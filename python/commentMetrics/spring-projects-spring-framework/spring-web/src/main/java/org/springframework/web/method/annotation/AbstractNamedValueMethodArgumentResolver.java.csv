commented;modifiers;parameterAmount;loc;comment;code
false;public,final;4;48;;@Override @Nullable public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {     NamedValueInfo namedValueInfo = getNamedValueInfo(parameter).     MethodParameter nestedParameter = parameter.nestedIfOptional().     Object resolvedName = resolveStringValue(namedValueInfo.name).     if (resolvedName == null) {         throw new IllegalArgumentException("Specified name must not resolve to null: [" + namedValueInfo.name + "]").     }     Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest).     if (arg == null) {         if (namedValueInfo.defaultValue != null) {             arg = resolveStringValue(namedValueInfo.defaultValue).         } else if (namedValueInfo.required && !nestedParameter.isOptional()) {             handleMissingValue(namedValueInfo.name, nestedParameter, webRequest).         }         arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType()).     } else if ("".equals(arg) && namedValueInfo.defaultValue != null) {         arg = resolveStringValue(namedValueInfo.defaultValue).     }     if (binderFactory != null) {         WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name).         try {             arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter).         } catch (ConversionNotSupportedException ex) {             throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()).         } catch (TypeMismatchException ex) {             throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()).         }     }     handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest).     return arg. }
true;private;1;9;/**  * Obtain the named value for the given method parameter.  */ ;/**  * Obtain the named value for the given method parameter.  */ private NamedValueInfo getNamedValueInfo(MethodParameter parameter) {     NamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter).     if (namedValueInfo == null) {         namedValueInfo = createNamedValueInfo(parameter).         namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo).         this.namedValueInfoCache.put(parameter, namedValueInfo).     }     return namedValueInfo. }
true;protected,abstract;1;1;/**  * Create the {@link NamedValueInfo} object for the given method parameter. Implementations typically  * retrieve the method annotation by means of {@link MethodParameter#getParameterAnnotation(Class)}.  * @param parameter the method parameter  * @return the named value information  */ ;/**  * Create the {@link NamedValueInfo} object for the given method parameter. Implementations typically  * retrieve the method annotation by means of {@link MethodParameter#getParameterAnnotation(Class)}.  * @param parameter the method parameter  * @return the named value information  */ protected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter).
true;private;2;13;/**  * Create a new NamedValueInfo based on the given NamedValueInfo with sanitized values.  */ ;/**  * Create a new NamedValueInfo based on the given NamedValueInfo with sanitized values.  */ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {     String name = info.name.     if (info.name.isEmpty()) {         name = parameter.getParameterName().         if (name == null) {             throw new IllegalArgumentException("Name for argument type [" + parameter.getNestedParameterType().getName() + "] not available, and parameter name information not found in class file either.").         }     }     String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue).     return new NamedValueInfo(name, info.required, defaultValue). }
true;private;1;12;/**  * Resolve the given annotation-specified value,  * potentially containing placeholders and expressions.  */ ;/**  * Resolve the given annotation-specified value,  * potentially containing placeholders and expressions.  */ @Nullable private Object resolveStringValue(String value) {     if (this.configurableBeanFactory == null) {         return value.     }     String placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value).     BeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver().     if (exprResolver == null || this.expressionContext == null) {         return value.     }     return exprResolver.evaluate(placeholdersResolved, this.expressionContext). }
true;protected,abstract;3;3;/**  * Resolve the given parameter type and value name into an argument value.  * @param name the name of the value being resolved  * @param parameter the method parameter to resolve to an argument value  * (pre-nested in case of a {@link java.util.Optional} declaration)  * @param request the current request  * @return the resolved argument (may be {@code null})  * @throws Exception in case of errors  */ ;/**  * Resolve the given parameter type and value name into an argument value.  * @param name the name of the value being resolved  * @param parameter the method parameter to resolve to an argument value  * (pre-nested in case of a {@link java.util.Optional} declaration)  * @param request the current request  * @return the resolved argument (may be {@code null})  * @throws Exception in case of errors  */ @Nullable protected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception.
true;protected;3;5;/**  * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}  * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.  * @param name the name for the value  * @param parameter the method parameter  * @param request the current request  * @since 4.3  */ ;/**  * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}  * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.  * @param name the name for the value  * @param parameter the method parameter  * @param request the current request  * @since 4.3  */ protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {     handleMissingValue(name, parameter). }
true;protected;2;4;/**  * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}  * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.  * @param name the name for the value  * @param parameter the method parameter  */ ;/**  * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}  * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.  * @param name the name for the value  * @param parameter the method parameter  */ protected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {     throw new ServletRequestBindingException("Missing argument '" + name + "' for method parameter of type " + parameter.getNestedParameterType().getSimpleName()). }
true;private;3;14;/**  * A {@code null} results in a {@code false} value for {@code boolean}s or an exception for other primitives.  */ ;/**  * A {@code null} results in a {@code false} value for {@code boolean}s or an exception for other primitives.  */ @Nullable private Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {     if (value == null) {         if (Boolean.TYPE.equals(paramType)) {             return Boolean.FALSE.         } else if (paramType.isPrimitive()) {             throw new IllegalStateException("Optional " + paramType.getSimpleName() + " parameter '" + name + "' is present but cannot be translated into a null value due to being declared as a " + "primitive type. Consider declaring it as object wrapper for the corresponding primitive type.").         }     }     return value. }
true;protected;5;3;/**  * Invoked after a value is resolved.  * @param arg the resolved argument value  * @param name the argument name  * @param parameter the argument parameter type  * @param mavContainer the {@link ModelAndViewContainer} (may be {@code null})  * @param webRequest the current request  */ ;/**  * Invoked after a value is resolved.  * @param arg the resolved argument value  * @param name the argument name  * @param parameter the argument parameter type  * @param mavContainer the {@link ModelAndViewContainer} (may be {@code null})  * @param webRequest the current request  */ protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest) { }
