commented;modifiers;parameterAmount;loc;comment;code
true;public;2;3;/**  * Add a part from an Object.  * @param name the name of the part to add  * @param part the part data  * @return builder that allows for further customization of part headers  */ ;/**  * Add a part from an Object.  * @param name the name of the part to add  * @param part the part data  * @return builder that allows for further customization of part headers  */ public PartBuilder part(String name, Object part) {     return part(name, part, null). }
true;public;3;35;/**  * Variant of {@link #part(String, Object)} that also accepts a MediaType  * which is used to determine how to encode the part.  * @param name the name of the part to add  * @param part the part data  * @param contentType the media type for the part  * @return builder that allows for further customization of part headers  */ ;/**  * Variant of {@link #part(String, Object)} that also accepts a MediaType  * which is used to determine how to encode the part.  * @param name the name of the part to add  * @param part the part data  * @param contentType the media type for the part  * @return builder that allows for further customization of part headers  */ public PartBuilder part(String name, Object part, @Nullable MediaType contentType) {     Assert.hasLength(name, "'name' must not be empty").     Assert.notNull(part, "'part' must not be null").     if (part instanceof Publisher) {         throw new IllegalArgumentException("Use publisher(String, Publisher, Class) or " + "publisher(String, Publisher, ParameterizedTypeReference) for adding Publisher parts").     }     if (part instanceof PublisherEntity<?, ?>) {         PublisherPartBuilder<?, ?> builder = new PublisherPartBuilder<>((PublisherEntity<?, ?>) part).         this.parts.add(name, builder).         return builder.     }     Object partBody.     HttpHeaders partHeaders = new HttpHeaders().     if (part instanceof HttpEntity) {         HttpEntity<?> httpEntity = (HttpEntity<?>) part.         partBody = httpEntity.getBody().         partHeaders.addAll(httpEntity.getHeaders()).     } else {         partBody = part.     }     if (contentType != null) {         partHeaders.setContentType(contentType).     }     DefaultPartBuilder builder = new DefaultPartBuilder(partHeaders, partBody).     this.parts.add(name, builder).     return builder. }
true;public;3;11;/**  * Add an asynchronous part with {@link Publisher}-based content.  * @param name the name of the part to add  * @param publisher the part contents  * @param elementClass the type of elements contained in the publisher  * @return builder that allows for further customization of part headers  */ ;/**  * Add an asynchronous part with {@link Publisher}-based content.  * @param name the name of the part to add  * @param publisher the part contents  * @param elementClass the type of elements contained in the publisher  * @return builder that allows for further customization of part headers  */ public <T, P extends Publisher<T>> PartBuilder asyncPart(String name, P publisher, Class<T> elementClass) {     Assert.hasLength(name, "'name' must not be empty").     Assert.notNull(publisher, "'publisher' must not be null").     Assert.notNull(elementClass, "'elementClass' must not be null").     HttpHeaders headers = new HttpHeaders().     PublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(headers, publisher, elementClass).     this.parts.add(name, builder).     return builder. }
true;public;3;12;/**  * Variant of {@link #asyncPart(String, Publisher, Class)} that accepts a  * {@link ParameterizedTypeReference} for the element type, which allows  * specifying generic type information.  * @param name the name of the part to add  * @param publisher the part contents  * @param typeReference the type of elements contained in the publisher  * @return builder that allows for further customization of part headers  */ ;/**  * Variant of {@link #asyncPart(String, Publisher, Class)} that accepts a  * {@link ParameterizedTypeReference} for the element type, which allows  * specifying generic type information.  * @param name the name of the part to add  * @param publisher the part contents  * @param typeReference the type of elements contained in the publisher  * @return builder that allows for further customization of part headers  */ public <T, P extends Publisher<T>> PartBuilder asyncPart(String name, P publisher, ParameterizedTypeReference<T> typeReference) {     Assert.hasLength(name, "'name' must not be empty").     Assert.notNull(publisher, "'publisher' must not be null").     Assert.notNull(typeReference, "'typeReference' must not be null").     HttpHeaders headers = new HttpHeaders().     PublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(headers, publisher, typeReference).     this.parts.add(name, builder).     return builder. }
true;public;0;10;/**  * Return a {@code MultiValueMap} with the configured parts.  */ ;/**  * Return a {@code MultiValueMap} with the configured parts.  */ public MultiValueMap<String, HttpEntity<?>> build() {     MultiValueMap<String, HttpEntity<?>> result = new LinkedMultiValueMap<>(this.parts.size()).     for (Map.Entry<String, List<DefaultPartBuilder>> entry : this.parts.entrySet()) {         for (DefaultPartBuilder builder : entry.getValue()) {             HttpEntity<?> entity = builder.build().             result.add(entry.getKey(), entity).         }     }     return result. }
true;;2;1;/**  * Add part header values.  * @param headerName the part header name  * @param headerValues the part header value(s)  * @return this builder  * @see HttpHeaders#addAll(String, List)  */ ;/**  * Add part header values.  * @param headerName the part header name  * @param headerValues the part header value(s)  * @return this builder  * @see HttpHeaders#addAll(String, List)  */ PartBuilder header(String headerName, String... headerValues).
true;;1;1;/**  * Manipulate the part headers through the given consumer.  * @param headersConsumer consumer to manipulate the part headers with  * @return this builder  */ ;/**  * Manipulate the part headers through the given consumer.  * @param headersConsumer consumer to manipulate the part headers with  * @return this builder  */ PartBuilder headers(Consumer<HttpHeaders> headersConsumer).
false;public;2;5;;@Override public PartBuilder header(String headerName, String... headerValues) {     this.headers.addAll(headerName, Arrays.asList(headerValues)).     return this. }
false;public;1;5;;@Override public PartBuilder headers(Consumer<HttpHeaders> headersConsumer) {     headersConsumer.accept(this.headers).     return this. }
false;public;0;3;;public HttpEntity<?> build() {     return new HttpEntity<>(this.body, this.headers). }
false;public;0;7;;@Override @SuppressWarnings("unchecked") public HttpEntity<?> build() {     P publisher = (P) this.body.     Assert.state(publisher != null, "Publisher must not be null").     return new PublisherEntity<>(this.headers, publisher, this.resolvableType). }
true;public;0;3;/**  * Return the element type for the {@code Publisher} body.  */ ;/**  * Return the element type for the {@code Publisher} body.  */ public ResolvableType getResolvableType() {     return this.resolvableType. }
