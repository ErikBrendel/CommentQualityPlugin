commented;modifiers;parameterAmount;loc;comment;code
true;public;3;17;/**  * Populate the model in the following order:  * <ol>  * <li>Retrieve "known" session attributes listed as {@code @SessionAttributes}.  * <li>Invoke {@code @ModelAttribute} methods  * <li>Find {@code @ModelAttribute} method arguments also listed as  * {@code @SessionAttributes} and ensure they're present in the model raising  * an exception if necessary.  * </ol>  * @param request the current request  * @param container a container with the model to be initialized  * @param handlerMethod the method for which the model is initialized  * @throws Exception may arise from {@code @ModelAttribute} methods  */ ;/**  * Populate the model in the following order:  * <ol>  * <li>Retrieve "known" session attributes listed as {@code @SessionAttributes}.  * <li>Invoke {@code @ModelAttribute} methods  * <li>Find {@code @ModelAttribute} method arguments also listed as  * {@code @SessionAttributes} and ensure they're present in the model raising  * an exception if necessary.  * </ol>  * @param request the current request  * @param container a container with the model to be initialized  * @param handlerMethod the method for which the model is initialized  * @throws Exception may arise from {@code @ModelAttribute} methods  */ public void initModel(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod) throws Exception {     Map<String, ?> sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request).     container.mergeAttributes(sessionAttributes).     invokeModelAttributeMethods(request, container).     for (String name : findSessionAttributeArguments(handlerMethod)) {         if (!container.containsAttribute(name)) {             Object value = this.sessionAttributesHandler.retrieveAttribute(request, name).             if (value == null) {                 throw new HttpSessionRequiredException("Expected session attribute '" + name + "'", name).             }             container.addAttribute(name, value).         }     } }
true;private;2;26;/**  * Invoke model attribute methods to populate the model.  * Attributes are added only if not already present in the model.  */ ;/**  * Invoke model attribute methods to populate the model.  * Attributes are added only if not already present in the model.  */ private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer container) throws Exception {     while (!this.modelMethods.isEmpty()) {         InvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod().         ModelAttribute ann = modelMethod.getMethodAnnotation(ModelAttribute.class).         Assert.state(ann != null, "No ModelAttribute annotation").         if (container.containsAttribute(ann.name())) {             if (!ann.binding()) {                 container.setBindingDisabled(ann.name()).             }             continue.         }         Object returnValue = modelMethod.invokeForRequest(request, container).         if (!modelMethod.isVoid()) {             String returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType()).             if (!ann.binding()) {                 container.setBindingDisabled(returnValueName).             }             if (!container.containsAttribute(returnValueName)) {                 container.addAttribute(returnValueName, returnValue).             }         }     } }
false;private;1;11;;private ModelMethod getNextModelMethod(ModelAndViewContainer container) {     for (ModelMethod modelMethod : this.modelMethods) {         if (modelMethod.checkDependencies(container)) {             this.modelMethods.remove(modelMethod).             return modelMethod.         }     }     ModelMethod modelMethod = this.modelMethods.get(0).     this.modelMethods.remove(modelMethod).     return modelMethod. }
true;private;1;13;/**  * Find {@code @ModelAttribute} arguments also listed as {@code @SessionAttributes}.  */ ;/**  * Find {@code @ModelAttribute} arguments also listed as {@code @SessionAttributes}.  */ private List<String> findSessionAttributeArguments(HandlerMethod handlerMethod) {     List<String> result = new ArrayList<>().     for (MethodParameter parameter : handlerMethod.getMethodParameters()) {         if (parameter.hasParameterAnnotation(ModelAttribute.class)) {             String name = getNameForParameter(parameter).             Class<?> paramType = parameter.getParameterType().             if (this.sessionAttributesHandler.isHandlerSessionAttribute(name, paramType)) {                 result.add(name).             }         }     }     return result. }
true;public;2;12;/**  * Promote model attributes listed as {@code @SessionAttributes} to the session.  * Add {@link BindingResult} attributes where necessary.  * @param request the current request  * @param container contains the model to update  * @throws Exception if creating BindingResult attributes fails  */ ;/**  * Promote model attributes listed as {@code @SessionAttributes} to the session.  * Add {@link BindingResult} attributes where necessary.  * @param request the current request  * @param container contains the model to update  * @throws Exception if creating BindingResult attributes fails  */ public void updateModel(NativeWebRequest request, ModelAndViewContainer container) throws Exception {     ModelMap defaultModel = container.getDefaultModel().     if (container.getSessionStatus().isComplete()) {         this.sessionAttributesHandler.cleanupAttributes(request).     } else {         this.sessionAttributesHandler.storeAttributes(request, defaultModel).     }     if (!container.isRequestHandled() && container.getModel() == defaultModel) {         updateBindingResult(request, defaultModel).     } }
true;private;2;13;/**  * Add {@link BindingResult} attributes to the model for attributes that require it.  */ ;/**  * Add {@link BindingResult} attributes to the model for attributes that require it.  */ private void updateBindingResult(NativeWebRequest request, ModelMap model) throws Exception {     List<String> keyNames = new ArrayList<>(model.keySet()).     for (String name : keyNames) {         Object value = model.get(name).         if (value != null && isBindingCandidate(name, value)) {             String bindingResultKey = BindingResult.MODEL_KEY_PREFIX + name.             if (!model.containsAttribute(bindingResultKey)) {                 WebDataBinder dataBinder = this.dataBinderFactory.createBinder(request, value, name).                 model.put(bindingResultKey, dataBinder.getBindingResult()).             }         }     } }
true;private;2;12;/**  * Whether the given attribute requires a {@link BindingResult} in the model.  */ ;/**  * Whether the given attribute requires a {@link BindingResult} in the model.  */ private boolean isBindingCandidate(String attributeName, Object value) {     if (attributeName.startsWith(BindingResult.MODEL_KEY_PREFIX)) {         return false.     }     if (this.sessionAttributesHandler.isHandlerSessionAttribute(attributeName, value.getClass())) {         return true.     }     return (!value.getClass().isArray() && !(value instanceof Collection) && !(value instanceof Map) && !BeanUtils.isSimpleValueType(value.getClass())). }
true;public,static;1;5;/**  * Derive the model attribute name for the given method parameter based on  * a {@code @ModelAttribute} parameter annotation (if present) or falling  * back on parameter type based conventions.  * @param parameter a descriptor for the method parameter  * @return the derived name  * @see Conventions#getVariableNameForParameter(MethodParameter)  */ ;/**  * Derive the model attribute name for the given method parameter based on  * a {@code @ModelAttribute} parameter annotation (if present) or falling  * back on parameter type based conventions.  * @param parameter a descriptor for the method parameter  * @return the derived name  * @see Conventions#getVariableNameForParameter(MethodParameter)  */ public static String getNameForParameter(MethodParameter parameter) {     ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class).     String name = (ann != null ? ann.value() : null).     return (StringUtils.hasText(name) ? name : Conventions.getVariableNameForParameter(parameter)). }
true;public,static;2;13;/**  * Derive the model attribute name for the given return value. Results will be  * based on:  * <ol>  * <li>the method {@code ModelAttribute} annotation value  * <li>the declared return type if it is more specific than {@code Object}  * <li>the actual return value type  * </ol>  * @param returnValue the value returned from a method invocation  * @param returnType a descriptor for the return type of the method  * @return the derived name (never {@code null} or empty String)  */ ;/**  * Derive the model attribute name for the given return value. Results will be  * based on:  * <ol>  * <li>the method {@code ModelAttribute} annotation value  * <li>the declared return type if it is more specific than {@code Object}  * <li>the actual return value type  * </ol>  * @param returnValue the value returned from a method invocation  * @param returnType a descriptor for the return type of the method  * @return the derived name (never {@code null} or empty String)  */ public static String getNameForReturnValue(@Nullable Object returnValue, MethodParameter returnType) {     ModelAttribute ann = returnType.getMethodAnnotation(ModelAttribute.class).     if (ann != null && StringUtils.hasText(ann.value())) {         return ann.value().     } else {         Method method = returnType.getMethod().         Assert.state(method != null, "No handler method").         Class<?> containingClass = returnType.getContainingClass().         Class<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass).         return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue).     } }
false;public;0;3;;public InvocableHandlerMethod getHandlerMethod() {     return this.handlerMethod. }
false;public;1;8;;public boolean checkDependencies(ModelAndViewContainer mavContainer) {     for (String name : this.dependencies) {         if (!mavContainer.containsAttribute(name)) {             return false.         }     }     return true. }
false;public;1;9;;public List<String> getUnresolvedDependencies(ModelAndViewContainer mavContainer) {     List<String> result = new ArrayList<>(this.dependencies.size()).     for (String name : this.dependencies) {         if (!mavContainer.containsAttribute(name)) {             result.add(name).         }     }     return result. }
false;public;0;4;;@Override public String toString() {     return this.handlerMethod.getMethod().toGenericString(). }
