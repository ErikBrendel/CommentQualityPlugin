commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {     return Message.class.isAssignableFrom(elementType.toClass()) && supportsMimeType(mimeType). }
false;public;5;8;;@Override public Flux<DataBuffer> encode(Publisher<? extends Message> inputStream, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     return Flux.from(inputStream).map(message -> encodeMessage(message, bufferFactory, !(inputStream instanceof Mono))). }
false;private;3;16;;private DataBuffer encodeMessage(Message message, DataBufferFactory bufferFactory, boolean streaming) {     DataBuffer buffer = bufferFactory.allocateBuffer().     OutputStream outputStream = buffer.asOutputStream().     try {         if (streaming) {             message.writeDelimitedTo(outputStream).         } else {             message.writeTo(outputStream).         }         return buffer.     } catch (IOException ex) {         throw new IllegalStateException("Unexpected I/O error while writing to data buffer", ex).     } }
false;public;0;4;;@Override public List<MediaType> getStreamingMediaTypes() {     return streamingMediaTypes. }
false;public;0;4;;@Override public List<MimeType> getEncodableMimeTypes() {     return getMimeTypes(). }
