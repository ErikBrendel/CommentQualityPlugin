commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ObjectMapper getObjectMapper() {     return this.objectMapper. }
true;protected;0;3;/**  * Subclasses should expose this as "decodable" or "encodable" mime types.  */ ;/**  * Subclasses should expose this as "decodable" or "encodable" mime types.  */ protected List<MimeType> getMimeTypes() {     return this.mimeTypes. }
false;protected;1;3;;protected boolean supportsMimeType(@Nullable MimeType mimeType) {     return (mimeType == null || this.mimeTypes.stream().anyMatch(m -> m.isCompatibleWith(mimeType))). }
false;protected;2;4;;protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {     TypeFactory typeFactory = this.objectMapper.getTypeFactory().     return typeFactory.constructType(GenericTypeResolver.resolveType(type, contextClass)). }
false;protected;1;12;;protected Map<String, Object> getHints(ResolvableType resolvableType) {     MethodParameter param = getParameter(resolvableType).     if (param != null) {         JsonView annotation = getAnnotation(param, JsonView.class).         if (annotation != null) {             Class<?>[] classes = annotation.value().             Assert.isTrue(classes.length == 1, JSON_VIEW_HINT_ERROR + param).             return Hints.from(JSON_VIEW_HINT, classes[0]).         }     }     return Hints.none(). }
false;protected;1;4;;@Nullable protected MethodParameter getParameter(ResolvableType type) {     return type.getSource() instanceof MethodParameter ? (MethodParameter) type.getSource() : null. }
false;protected,abstract;2;2;;@Nullable protected abstract <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType).
