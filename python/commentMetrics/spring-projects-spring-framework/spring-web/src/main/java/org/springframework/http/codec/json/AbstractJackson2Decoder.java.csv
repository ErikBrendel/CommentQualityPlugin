commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {     JavaType javaType = getObjectMapper().getTypeFactory().constructType(elementType.getType()).     // Skip String: CharSequenceDecoder + "*/*" comes after     return (!CharSequence.class.isAssignableFrom(elementType.toClass()) && getObjectMapper().canDeserialize(javaType) && supportsMimeType(mimeType)). }
false;public;4;7;;@Override public Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(Flux.from(input), this.jsonFactory, true).     return decodeInternal(tokens, elementType, mimeType, hints). }
false;public;4;7;;@Override public Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(Flux.from(input), this.jsonFactory, false).     return decodeInternal(tokens, elementType, mimeType, hints).singleOrEmpty(). }
false;private;4;37;;private Flux<Object> decodeInternal(Flux<TokenBuffer> tokens, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Assert.notNull(tokens, "'tokens' must not be null").     Assert.notNull(elementType, "'elementType' must not be null").     MethodParameter param = getParameter(elementType).     Class<?> contextClass = (param != null ? param.getContainingClass() : null).     JavaType javaType = getJavaType(elementType.getType(), contextClass).     Class<?> jsonView = (hints != null ? (Class<?>) hints.get(Jackson2CodecSupport.JSON_VIEW_HINT) : null).     ObjectReader reader = (jsonView != null ? getObjectMapper().readerWithView(jsonView).forType(javaType) : getObjectMapper().readerFor(javaType)).     return tokens.flatMap(tokenBuffer -> {         try {             Object value = reader.readValue(tokenBuffer.asParser(getObjectMapper())).             if (!Hints.isLoggingSuppressed(hints)) {                 LogFormatUtils.traceDebug(logger, traceOn -> {                     String formatted = LogFormatUtils.formatValue(value, !traceOn).                     return Hints.getLogPrefix(hints) + "Decoded [" + formatted + "]".                 }).             }             return Mono.justOrEmpty(value).         } catch (InvalidDefinitionException ex) {             return Mono.error(new CodecException("Type definition error: " + ex.getType(), ex)).         } catch (JsonProcessingException ex) {             return Mono.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex)).         } catch (IOException ex) {             return Mono.error(new DecodingException("I/O error while parsing input stream", ex)).         }     }). }
false;public;4;6;;// HttpMessageDecoder... @Override public Map<String, Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response) {     return getHints(actualType). }
false;public;0;4;;@Override public List<MimeType> getDecodableMimeTypes() {     return getMimeTypes(). }
false;protected;2;4;;// Jackson2CodecSupport ... @Override protected <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType) {     return parameter.getParameterAnnotation(annotType). }
