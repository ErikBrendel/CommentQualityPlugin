commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;5;;private static HttpHeaders createHeaders(HttpServerExchange exchange) {     UndertowHeadersAdapter headersMap = new UndertowHeadersAdapter(exchange.getResponseHeaders()).     return new HttpHeaders(headersMap). }
false;public;0;5;;@SuppressWarnings("unchecked") @Override public <T> T getNativeResponse() {     return (T) this.exchange. }
false;public;0;5;;@Override public HttpStatus getStatusCode() {     HttpStatus httpStatus = super.getStatusCode().     return httpStatus != null ? httpStatus : HttpStatus.resolve(this.exchange.getStatusCode()). }
false;protected;0;7;;@Override protected void applyStatusCode() {     Integer statusCode = getStatusCodeValue().     if (statusCode != null) {         this.exchange.setStatusCode(statusCode).     } }
false;protected;0;3;;@Override protected void applyHeaders() { }
false;protected;0;20;;@Override protected void applyCookies() {     for (String name : getCookies().keySet()) {         for (ResponseCookie httpCookie : getCookies().get(name)) {             Cookie cookie = new CookieImpl(name, httpCookie.getValue()).             if (!httpCookie.getMaxAge().isNegative()) {                 cookie.setMaxAge((int) httpCookie.getMaxAge().getSeconds()).             }             if (httpCookie.getDomain() != null) {                 cookie.setDomain(httpCookie.getDomain()).             }             if (httpCookie.getPath() != null) {                 cookie.setPath(httpCookie.getPath()).             }             cookie.setSecure(httpCookie.isSecure()).             cookie.setHttpOnly(httpCookie.isHttpOnly()).             this.exchange.getResponseCookies().putIfAbsent(name, cookie).         }     } }
false;public;3;14;;@Override public Mono<Void> writeWith(Path file, long position, long count) {     return doCommit(() -> Mono.defer(() -> {         try (FileChannel source = FileChannel.open(file, StandardOpenOption.READ)) {             StreamSinkChannel destination = this.exchange.getResponseChannel().             Channels.transferBlocking(destination, source, position, count).             return Mono.empty().         } catch (IOException ex) {             return Mono.error(ex).         }     })). }
false;protected;0;4;;@Override protected Processor<? super Publisher<? extends DataBuffer>, Void> createBodyFlushProcessor() {     return new ResponseBodyFlushProcessor(). }
false;private;0;6;;private ResponseBodyProcessor createBodyProcessor() {     if (this.responseChannel == null) {         this.responseChannel = this.exchange.getResponseChannel().     }     return new ResponseBodyProcessor(this.responseChannel). }
false;protected;0;5;;@Override protected boolean isWritePossible() {     this.channel.resumeWrites().     return this.writePossible. }
false;protected;1;31;;@Override protected boolean write(DataBuffer dataBuffer) throws IOException {     ByteBuffer buffer = this.byteBuffer.     if (buffer == null) {         return false.     }     // Track write listener calls from here on..     this.writePossible = false.     // In case of IOException, onError handling should call discardData(DataBuffer)..     int total = buffer.remaining().     int written = writeByteBuffer(buffer).     if (logger.isTraceEnabled()) {         logger.trace(getLogPrefix() + "Wrote " + written + " of " + total + " bytes").     } else if (rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "Wrote " + written + " of " + total + " bytes").     }     if (written != total) {         return false.     }     // We wrote all, so can still write more..     this.writePossible = true.     DataBufferUtils.release(dataBuffer).     this.byteBuffer = null.     return true. }
false;private;1;10;;private int writeByteBuffer(ByteBuffer byteBuffer) throws IOException {     int written.     int totalWritten = 0.     do {         written = this.channel.write(byteBuffer).         totalWritten += written.     } while (byteBuffer.hasRemaining() && written > 0).     return totalWritten. }
false;protected;1;5;;@Override protected void dataReceived(DataBuffer dataBuffer) {     super.dataReceived(dataBuffer).     this.byteBuffer = dataBuffer.asByteBuffer(). }
false;protected;1;4;;@Override protected boolean isDataEmpty(DataBuffer dataBuffer) {     return (dataBuffer.readableByteCount() == 0). }
false;protected;0;5;;@Override protected void writingComplete() {     this.channel.getWriteSetter().set(null).     this.channel.resumeWrites(). }
false;protected;1;5;;@Override protected void writingFailed(Throwable ex) {     cancel().     onError(ex). }
false;protected;1;4;;@Override protected void discardData(DataBuffer dataBuffer) {     DataBufferUtils.release(dataBuffer). }
false;protected;0;4;;@Override protected Processor<? super DataBuffer, Void> createWriteProcessor() {     return UndertowServerHttpResponse.this.createBodyProcessor(). }
false;protected;0;10;;@Override protected void flush() throws IOException {     StreamSinkChannel channel = UndertowServerHttpResponse.this.responseChannel.     if (channel != null) {         if (rsWriteFlushLogger.isTraceEnabled()) {             rsWriteFlushLogger.trace(getLogPrefix() + "flush").         }         channel.flush().     } }
false;protected;1;5;;@Override protected void flushingFailed(Throwable t) {     cancel().     onError(t). }
false;protected;0;10;;@Override protected boolean isWritePossible() {     StreamSinkChannel channel = UndertowServerHttpResponse.this.responseChannel.     if (channel != null) {         // We can always call flush, just ensure writes are on..         channel.resumeWrites().         return true.     }     return false. }
false;protected;0;4;;@Override protected boolean isFlushPending() {     return false. }
