commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether the query string should be included in the log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includeQueryString" in the filter definition in {@code web.xml}.  */ ;/**  * Set whether the query string should be included in the log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includeQueryString" in the filter definition in {@code web.xml}.  */ public void setIncludeQueryString(boolean includeQueryString) {     this.includeQueryString = includeQueryString. }
true;protected;0;3;/**  * Return whether the query string should be included in the log message.  */ ;/**  * Return whether the query string should be included in the log message.  */ protected boolean isIncludeQueryString() {     return this.includeQueryString. }
true;public;1;3;/**  * Set whether the client address and session id should be included in the  * log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includeClientInfo" in the filter definition in {@code web.xml}.  */ ;/**  * Set whether the client address and session id should be included in the  * log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includeClientInfo" in the filter definition in {@code web.xml}.  */ public void setIncludeClientInfo(boolean includeClientInfo) {     this.includeClientInfo = includeClientInfo. }
true;protected;0;3;/**  * Return whether the client address and session id should be included in the  * log message.  */ ;/**  * Return whether the client address and session id should be included in the  * log message.  */ protected boolean isIncludeClientInfo() {     return this.includeClientInfo. }
true;public;1;3;/**  * Set whether the request headers should be included in the log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includeHeaders" in the filter definition in {@code web.xml}.  * @since 4.3  */ ;/**  * Set whether the request headers should be included in the log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includeHeaders" in the filter definition in {@code web.xml}.  * @since 4.3  */ public void setIncludeHeaders(boolean includeHeaders) {     this.includeHeaders = includeHeaders. }
true;protected;0;3;/**  * Return whether the request headers should be included in the log message.  * @since 4.3  */ ;/**  * Return whether the request headers should be included in the log message.  * @since 4.3  */ protected boolean isIncludeHeaders() {     return this.includeHeaders. }
true;public;1;3;/**  * Set whether the request payload (body) should be included in the log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includePayload" in the filter definition in {@code web.xml}.  * @since 3.0  */ ;/**  * Set whether the request payload (body) should be included in the log message.  * <p>Should be configured using an {@code <init-param>} for parameter name  * "includePayload" in the filter definition in {@code web.xml}.  * @since 3.0  */ public void setIncludePayload(boolean includePayload) {     this.includePayload = includePayload. }
true;protected;0;3;/**  * Return whether the request payload (body) should be included in the log message.  * @since 3.0  */ ;/**  * Return whether the request payload (body) should be included in the log message.  * @since 3.0  */ protected boolean isIncludePayload() {     return this.includePayload. }
true;public;1;4;/**  * Set the maximum length of the payload body to be included in the log message.  * Default is 50 characters.  * @since 3.0  */ ;/**  * Set the maximum length of the payload body to be included in the log message.  * Default is 50 characters.  * @since 3.0  */ public void setMaxPayloadLength(int maxPayloadLength) {     Assert.isTrue(maxPayloadLength >= 0, "'maxPayloadLength' should be larger than or equal to 0").     this.maxPayloadLength = maxPayloadLength. }
true;protected;0;3;/**  * Return the maximum length of the payload body to be included in the log message.  * @since 3.0  */ ;/**  * Return the maximum length of the payload body to be included in the log message.  * @since 3.0  */ protected int getMaxPayloadLength() {     return this.maxPayloadLength. }
true;public;1;3;/**  * Set the value that should be prepended to the log message written  * <i>before</i> a request is processed.  */ ;/**  * Set the value that should be prepended to the log message written  * <i>before</i> a request is processed.  */ public void setBeforeMessagePrefix(String beforeMessagePrefix) {     this.beforeMessagePrefix = beforeMessagePrefix. }
true;public;1;3;/**  * Set the value that should be appended to the log message written  * <i>before</i> a request is processed.  */ ;/**  * Set the value that should be appended to the log message written  * <i>before</i> a request is processed.  */ public void setBeforeMessageSuffix(String beforeMessageSuffix) {     this.beforeMessageSuffix = beforeMessageSuffix. }
true;public;1;3;/**  * Set the value that should be prepended to the log message written  * <i>after</i> a request is processed.  */ ;/**  * Set the value that should be prepended to the log message written  * <i>after</i> a request is processed.  */ public void setAfterMessagePrefix(String afterMessagePrefix) {     this.afterMessagePrefix = afterMessagePrefix. }
true;public;1;3;/**  * Set the value that should be appended to the log message written  * <i>after</i> a request is processed.  */ ;/**  * Set the value that should be appended to the log message written  * <i>after</i> a request is processed.  */ public void setAfterMessageSuffix(String afterMessageSuffix) {     this.afterMessageSuffix = afterMessageSuffix. }
true;protected;0;4;/**  * The default value is "false" so that the filter may log a "before" message  * at the start of request processing and an "after" message at the end from  * when the last asynchronously dispatched thread is exiting.  */ ;/**  * The default value is "false" so that the filter may log a "before" message  * at the start of request processing and an "after" message at the end from  * when the last asynchronously dispatched thread is exiting.  */ @Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
true;protected;3;24;/**  * Forwards the request to the next filter in the chain and delegates down to the subclasses  * to perform the actual request logging both before and after the request is processed.  * @see #beforeRequest  * @see #afterRequest  */ ;/**  * Forwards the request to the next filter in the chain and delegates down to the subclasses  * to perform the actual request logging both before and after the request is processed.  * @see #beforeRequest  * @see #afterRequest  */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     boolean isFirstRequest = !isAsyncDispatch(request).     HttpServletRequest requestToUse = request.     if (isIncludePayload() && isFirstRequest && !(request instanceof ContentCachingRequestWrapper)) {         requestToUse = new ContentCachingRequestWrapper(request, getMaxPayloadLength()).     }     boolean shouldLog = shouldLog(requestToUse).     if (shouldLog && isFirstRequest) {         beforeRequest(requestToUse, getBeforeMessage(requestToUse)).     }     try {         filterChain.doFilter(requestToUse, response).     } finally {         if (shouldLog && !isAsyncStarted(requestToUse)) {             afterRequest(requestToUse, getAfterMessage(requestToUse)).         }     } }
true;private;1;3;/**  * Get the message to write to the log before the request.  * @see #createMessage  */ ;/**  * Get the message to write to the log before the request.  * @see #createMessage  */ private String getBeforeMessage(HttpServletRequest request) {     return createMessage(request, this.beforeMessagePrefix, this.beforeMessageSuffix). }
true;private;1;3;/**  * Get the message to write to the log after the request.  * @see #createMessage  */ ;/**  * Get the message to write to the log after the request.  * @see #createMessage  */ private String getAfterMessage(HttpServletRequest request) {     return createMessage(request, this.afterMessagePrefix, this.afterMessageSuffix). }
true;protected;3;41;/**  * Create a log message for the given request, prefix and suffix.  * <p>If {@code includeQueryString} is {@code true}, then the inner part  * of the log message will take the form {@code request_uri?query_string}.  * otherwise the message will simply be of the form {@code request_uri}.  * <p>The final message is composed of the inner part as described and  * the supplied prefix and suffix.  */ ;/**  * Create a log message for the given request, prefix and suffix.  * <p>If {@code includeQueryString} is {@code true}, then the inner part  * of the log message will take the form {@code request_uri?query_string}.  * otherwise the message will simply be of the form {@code request_uri}.  * <p>The final message is composed of the inner part as described and  * the supplied prefix and suffix.  */ protected String createMessage(HttpServletRequest request, String prefix, String suffix) {     StringBuilder msg = new StringBuilder().     msg.append(prefix).     msg.append("uri=").append(request.getRequestURI()).     if (isIncludeQueryString()) {         String queryString = request.getQueryString().         if (queryString != null) {             msg.append('?').append(queryString).         }     }     if (isIncludeClientInfo()) {         String client = request.getRemoteAddr().         if (StringUtils.hasLength(client)) {             msg.append(".client=").append(client).         }         HttpSession session = request.getSession(false).         if (session != null) {             msg.append(".session=").append(session.getId()).         }         String user = request.getRemoteUser().         if (user != null) {             msg.append(".user=").append(user).         }     }     if (isIncludeHeaders()) {         msg.append(".headers=").append(new ServletServerHttpRequest(request).getHeaders()).     }     if (isIncludePayload()) {         String payload = getMessagePayload(request).         if (payload != null) {             msg.append(".payload=").append(payload).         }     }     msg.append(suffix).     return msg.toString(). }
true;protected;1;18;/**  * Extracts the message payload portion of the message created by  * {@link #createMessage(HttpServletRequest, String, String)} when  * {@link #isIncludePayload()} returns true.  * @since 5.0.3  */ ;/**  * Extracts the message payload portion of the message created by  * {@link #createMessage(HttpServletRequest, String, String)} when  * {@link #isIncludePayload()} returns true.  * @since 5.0.3  */ @Nullable protected String getMessagePayload(HttpServletRequest request) {     ContentCachingRequestWrapper wrapper = WebUtils.getNativeRequest(request, ContentCachingRequestWrapper.class).     if (wrapper != null) {         byte[] buf = wrapper.getContentAsByteArray().         if (buf.length > 0) {             int length = Math.min(buf.length, getMaxPayloadLength()).             try {                 return new String(buf, 0, length, wrapper.getCharacterEncoding()).             } catch (UnsupportedEncodingException ex) {                 return "[unknown]".             }         }     }     return null. }
true;protected;1;3;/**  * Determine whether to call the {@link #beforeRequest}/{@link #afterRequest}  * methods for the current request, i.e. whether logging is currently active  * (and the log message is worth building).  * <p>The default implementation always returns {@code true}. Subclasses may  * override this with a log level check.  * @param request current HTTP request  * @return {@code true} if the before/after method should get called.  * {@code false} otherwise  * @since 4.1.5  */ ;/**  * Determine whether to call the {@link #beforeRequest}/{@link #afterRequest}  * methods for the current request, i.e. whether logging is currently active  * (and the log message is worth building).  * <p>The default implementation always returns {@code true}. Subclasses may  * override this with a log level check.  * @param request current HTTP request  * @return {@code true} if the before/after method should get called.  * {@code false} otherwise  * @since 4.1.5  */ protected boolean shouldLog(HttpServletRequest request) {     return true. }
true;protected,abstract;2;1;/**  * Concrete subclasses should implement this method to write a log message  * <i>before</i> the request is processed.  * @param request current HTTP request  * @param message the message to log  */ ;/**  * Concrete subclasses should implement this method to write a log message  * <i>before</i> the request is processed.  * @param request current HTTP request  * @param message the message to log  */ protected abstract void beforeRequest(HttpServletRequest request, String message).
true;protected,abstract;2;1;/**  * Concrete subclasses should implement this method to write a log message  * <i>after</i> the request is processed.  * @param request current HTTP request  * @param message the message to log  */ ;/**  * Concrete subclasses should implement this method to write a log message  * <i>after</i> the request is processed.  * @param request current HTTP request  * @param message the message to log  */ protected abstract void afterRequest(HttpServletRequest request, String message).
