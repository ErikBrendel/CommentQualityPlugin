commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the maximum number of sessions that can be stored. Once the limit is  * reached, any attempt to store an additional session will result in an  * {@link IllegalStateException}.  * <p>By default set to 10000.  * @param maxSessions the maximum number of sessions  * @since 5.0.8  */ ;/**  * Set the maximum number of sessions that can be stored. Once the limit is  * reached, any attempt to store an additional session will result in an  * {@link IllegalStateException}.  * <p>By default set to 10000.  * @param maxSessions the maximum number of sessions  * @since 5.0.8  */ public void setMaxSessions(int maxSessions) {     this.maxSessions = maxSessions. }
true;public;0;3;/**  * Return the maximum number of sessions that can be stored.  * @since 5.0.8  */ ;/**  * Return the maximum number of sessions that can be stored.  * @since 5.0.8  */ public int getMaxSessions() {     return this.maxSessions. }
true;public;1;5;/**  * Configure the {@link Clock} to use to set lastAccessTime on every created  * session and to calculate if it is expired.  * <p>This may be useful to align to different timezone or to set the clock  * back in a test, e.g. {@code Clock.offset(clock, Duration.ofMinutes(-31))}  * in order to simulate session expiration.  * <p>By default this is {@code Clock.system(ZoneId.of("GMT"))}.  * @param clock the clock to use  */ ;/**  * Configure the {@link Clock} to use to set lastAccessTime on every created  * session and to calculate if it is expired.  * <p>This may be useful to align to different timezone or to set the clock  * back in a test, e.g. {@code Clock.offset(clock, Duration.ofMinutes(-31))}  * in order to simulate session expiration.  * <p>By default this is {@code Clock.system(ZoneId.of("GMT"))}.  * @param clock the clock to use  */ public void setClock(Clock clock) {     Assert.notNull(clock, "Clock is required").     this.clock = clock.     removeExpiredSessions(). }
true;public;0;3;/**  * Return the configured clock for session lastAccessTime calculations.  */ ;/**  * Return the configured clock for session lastAccessTime calculations.  */ public Clock getClock() {     return this.clock. }
true;public;0;3;/**  * Return the map of sessions with an {@link Collections#unmodifiableMap  * unmodifiable} wrapper. This could be used for management purposes, to  * list active sessions, invalidate expired ones, etc.  * @since 5.0.8  */ ;/**  * Return the map of sessions with an {@link Collections#unmodifiableMap  * unmodifiable} wrapper. This could be used for management purposes, to  * list active sessions, invalidate expired ones, etc.  * @since 5.0.8  */ public Map<String, WebSession> getSessions() {     return Collections.unmodifiableMap(this.sessions). }
false;public;0;6;;@Override public Mono<WebSession> createWebSession() {     Instant now = this.clock.instant().     this.expiredSessionChecker.checkIfNecessary(now).     return Mono.fromSupplier(() -> new InMemoryWebSession(now)). }
false;public;1;17;;@Override public Mono<WebSession> retrieveSession(String id) {     Instant now = this.clock.instant().     this.expiredSessionChecker.checkIfNecessary(now).     InMemoryWebSession session = this.sessions.get(id).     if (session == null) {         return Mono.empty().     } else if (session.isExpired(now)) {         this.sessions.remove(id).         return Mono.empty().     } else {         session.updateLastAccessTime(now).         return Mono.just(session).     } }
false;public;1;5;;@Override public Mono<Void> removeSession(String id) {     this.sessions.remove(id).     return Mono.empty(). }
false;public;1;7;;public Mono<WebSession> updateLastAccessTime(WebSession session) {     return Mono.fromSupplier(() -> {         Assert.isInstanceOf(InMemoryWebSession.class, session).         ((InMemoryWebSession) session).updateLastAccessTime(this.clock.instant()).         return session.     }). }
true;public;0;3;/**  * Check for expired sessions and remove them. Typically such checks are  * kicked off lazily during calls to {@link #createWebSession() create} or  * {@link #retrieveSession retrieve}, no less than 60 seconds apart.  * This method can be called to force a check at a specific time.  * @since 5.0.8  */ ;/**  * Check for expired sessions and remove them. Typically such checks are  * kicked off lazily during calls to {@link #createWebSession() create} or  * {@link #retrieveSession retrieve}, no less than 60 seconds apart.  * This method can be called to force a check at a specific time.  * @since 5.0.8  */ public void removeExpiredSessions() {     this.expiredSessionChecker.removeExpiredSessions(this.clock.instant()). }
false;public;0;4;;@Override public String getId() {     return this.id.get(). }
false;public;0;4;;@Override public Map<String, Object> getAttributes() {     return this.attributes. }
false;public;0;4;;@Override public Instant getCreationTime() {     return this.creationTime. }
false;public;0;4;;@Override public Instant getLastAccessTime() {     return this.lastAccessTime. }
false;public;1;4;;@Override public void setMaxIdleTime(Duration maxIdleTime) {     this.maxIdleTime = maxIdleTime. }
false;public;0;4;;@Override public Duration getMaxIdleTime() {     return this.maxIdleTime. }
false;public;0;4;;@Override public void start() {     this.state.compareAndSet(State.NEW, State.STARTED). }
false;public;0;4;;@Override public boolean isStarted() {     return this.state.get().equals(State.STARTED) || !getAttributes().isEmpty(). }
false;public;0;9;;@Override public Mono<Void> changeSessionId() {     String currentId = this.id.get().     InMemoryWebSessionStore.this.sessions.remove(currentId).     String newId = String.valueOf(idGenerator.generateId()).     this.id.set(newId).     InMemoryWebSessionStore.this.sessions.put(this.getId(), this).     return Mono.empty(). }
false;public;0;7;;@Override public Mono<Void> invalidate() {     this.state.set(State.EXPIRED).     getAttributes().clear().     InMemoryWebSessionStore.this.sessions.remove(this.id.get()).     return Mono.empty(). }
false;public;0;23;;@Override public Mono<Void> save() {     checkMaxSessionsLimit().     // Implicitly started session..     if (!getAttributes().isEmpty()) {         this.state.compareAndSet(State.NEW, State.STARTED).     }     if (isStarted()) {         // Save         InMemoryWebSessionStore.this.sessions.put(this.getId(), this).         // Unless it was invalidated         if (this.state.get().equals(State.EXPIRED)) {             InMemoryWebSessionStore.this.sessions.remove(this.getId()).             return Mono.error(new IllegalStateException("Session was invalidated")).         }     }     return Mono.empty(). }
false;private;0;8;;private void checkMaxSessionsLimit() {     if (sessions.size() >= maxSessions) {         expiredSessionChecker.removeExpiredSessions(clock.instant()).         if (sessions.size() >= maxSessions) {             throw new IllegalStateException("Max sessions limit reached: " + sessions.size()).         }     } }
false;public;0;4;;@Override public boolean isExpired() {     return isExpired(clock.instant()). }
false;private;1;10;;private boolean isExpired(Instant now) {     if (this.state.get().equals(State.EXPIRED)) {         return true.     }     if (checkExpired(now)) {         this.state.set(State.EXPIRED).         return true.     }     return false. }
false;private;1;4;;private boolean checkExpired(Instant currentTime) {     return isStarted() && !this.maxIdleTime.isNegative() && currentTime.minus(this.maxIdleTime).isAfter(this.lastAccessTime). }
false;private;1;3;;private void updateLastAccessTime(Instant currentTime) {     this.lastAccessTime = currentTime. }
false;public;1;5;;public void checkIfNecessary(Instant now) {     if (this.checkTime.isBefore(now)) {         removeExpiredSessions(now).     } }
false;public;1;21;;public void removeExpiredSessions(Instant now) {     if (sessions.isEmpty()) {         return.     }     if (this.lock.tryLock()) {         try {             Iterator<InMemoryWebSession> iterator = sessions.values().iterator().             while (iterator.hasNext()) {                 InMemoryWebSession session = iterator.next().                 if (session.isExpired(now)) {                     iterator.remove().                     session.invalidate().                 }             }         } finally {             this.checkTime = now.plus(CHECK_PERIOD, ChronoUnit.MILLIS).             this.lock.unlock().         }     } }
