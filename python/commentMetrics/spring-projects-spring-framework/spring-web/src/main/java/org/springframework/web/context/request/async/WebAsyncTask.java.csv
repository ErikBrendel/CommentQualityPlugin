commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the {@link Callable} to use for concurrent handling (never {@code null}).  */ ;/**  * Return the {@link Callable} to use for concurrent handling (never {@code null}).  */ public Callable<?> getCallable() {     return this.callable. }
true;public;0;4;/**  * Return the timeout value in milliseconds, or {@code null} if no timeout is set.  */ ;/**  * Return the timeout value in milliseconds, or {@code null} if no timeout is set.  */ @Nullable public Long getTimeout() {     return this.timeout. }
true;public;1;3;/**  * A {@link BeanFactory} to use for resolving an executor name.  * <p>This factory reference will automatically be set when  * {@code WebAsyncTask} is used within a Spring MVC controller.  */ ;/**  * A {@link BeanFactory} to use for resolving an executor name.  * <p>This factory reference will automatically be set when  * {@code WebAsyncTask} is used within a Spring MVC controller.  */ public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
true;public;0;13;/**  * Return the AsyncTaskExecutor to use for concurrent handling,  * or {@code null} if none specified.  */ ;/**  * Return the AsyncTaskExecutor to use for concurrent handling,  * or {@code null} if none specified.  */ @Nullable public AsyncTaskExecutor getExecutor() {     if (this.executor != null) {         return this.executor.     } else if (this.executorName != null) {         Assert.state(this.beanFactory != null, "BeanFactory is required to look up an executor bean by name").         return this.beanFactory.getBean(this.executorName, AsyncTaskExecutor.class).     } else {         return null.     } }
true;public;1;3;/**  * Register code to invoke when the async request times out.  * <p>This method is called from a container thread when an async request times  * out before the {@code Callable} has completed. The callback is executed in  * the same thread and therefore should return without blocking. It may return  * an alternative value to use, including an {@link Exception} or return  * {@link CallableProcessingInterceptor#RESULT_NONE RESULT_NONE}.  */ ;/**  * Register code to invoke when the async request times out.  * <p>This method is called from a container thread when an async request times  * out before the {@code Callable} has completed. The callback is executed in  * the same thread and therefore should return without blocking. It may return  * an alternative value to use, including an {@link Exception} or return  * {@link CallableProcessingInterceptor#RESULT_NONE RESULT_NONE}.  */ public void onTimeout(Callable<V> callback) {     this.timeoutCallback = callback. }
true;public;1;3;/**  * Register code to invoke for an error during async request processing.  * <p>This method is called from a container thread when an error occurred  * while processing an async request before the {@code Callable} has  * completed. The callback is executed in the same thread and therefore  * should return without blocking. It may return an alternative value to  * use, including an {@link Exception} or return  * {@link CallableProcessingInterceptor#RESULT_NONE RESULT_NONE}.  * @since 5.0  */ ;/**  * Register code to invoke for an error during async request processing.  * <p>This method is called from a container thread when an error occurred  * while processing an async request before the {@code Callable} has  * completed. The callback is executed in the same thread and therefore  * should return without blocking. It may return an alternative value to  * use, including an {@link Exception} or return  * {@link CallableProcessingInterceptor#RESULT_NONE RESULT_NONE}.  * @since 5.0  */ public void onError(Callable<V> callback) {     this.errorCallback = callback. }
true;public;1;3;/**  * Register code to invoke when the async request completes.  * <p>This method is called from a container thread when an async request  * completed for any reason, including timeout and network error.  */ ;/**  * Register code to invoke when the async request completes.  * <p>This method is called from a container thread when an async request  * completed for any reason, including timeout and network error.  */ public void onCompletion(Runnable callback) {     this.completionCallback = callback. }
false;public;2;4;;@Override public <T> Object handleTimeout(NativeWebRequest request, Callable<T> task) throws Exception {     return (timeoutCallback != null ? timeoutCallback.call() : CallableProcessingInterceptor.RESULT_NONE). }
false;public;3;4;;@Override public <T> Object handleError(NativeWebRequest request, Callable<T> task, Throwable t) throws Exception {     return (errorCallback != null ? errorCallback.call() : CallableProcessingInterceptor.RESULT_NONE). }
false;public;2;6;;@Override public <T> void afterCompletion(NativeWebRequest request, Callable<T> task) throws Exception {     if (completionCallback != null) {         completionCallback.run().     } }
false;;0;18;;CallableProcessingInterceptor getInterceptor() {     return new CallableProcessingInterceptor() {          @Override         public <T> Object handleTimeout(NativeWebRequest request, Callable<T> task) throws Exception {             return (timeoutCallback != null ? timeoutCallback.call() : CallableProcessingInterceptor.RESULT_NONE).         }          @Override         public <T> Object handleError(NativeWebRequest request, Callable<T> task, Throwable t) throws Exception {             return (errorCallback != null ? errorCallback.call() : CallableProcessingInterceptor.RESULT_NONE).         }          @Override         public <T> void afterCompletion(NativeWebRequest request, Callable<T> task) throws Exception {             if (completionCallback != null) {                 completionCallback.run().             }         }     }. }
