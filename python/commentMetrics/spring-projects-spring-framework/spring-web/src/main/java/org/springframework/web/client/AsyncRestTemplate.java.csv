commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the error handler.  * <p>By default, AsyncRestTemplate uses a  * {@link org.springframework.web.client.DefaultResponseErrorHandler}.  */ ;/**  * Set the error handler.  * <p>By default, AsyncRestTemplate uses a  * {@link org.springframework.web.client.DefaultResponseErrorHandler}.  */ public void setErrorHandler(ResponseErrorHandler errorHandler) {     this.syncTemplate.setErrorHandler(errorHandler). }
true;public;0;3;/**  * Return the error handler.  */ ;/**  * Return the error handler.  */ public ResponseErrorHandler getErrorHandler() {     return this.syncTemplate.getErrorHandler(). }
true;public;1;15;/**  * Configure default URI variable values. This is a shortcut for:  * <pre class="code">  * DefaultUriTemplateHandler handler = new DefaultUriTemplateHandler().  * handler.setDefaultUriVariables(...).  *  * AsyncRestTemplate restTemplate = new AsyncRestTemplate().  * restTemplate.setUriTemplateHandler(handler).  * </pre>  * @param defaultUriVariables the default URI variable values  * @since 4.3  */ ;/**  * Configure default URI variable values. This is a shortcut for:  * <pre class="code">  * DefaultUriTemplateHandler handler = new DefaultUriTemplateHandler().  * handler.setDefaultUriVariables(...).  *  * AsyncRestTemplate restTemplate = new AsyncRestTemplate().  * restTemplate.setUriTemplateHandler(handler).  * </pre>  * @param defaultUriVariables the default URI variable values  * @since 4.3  */ @SuppressWarnings("deprecation") public void setDefaultUriVariables(Map<String, ?> defaultUriVariables) {     UriTemplateHandler handler = this.syncTemplate.getUriTemplateHandler().     if (handler instanceof DefaultUriBuilderFactory) {         ((DefaultUriBuilderFactory) handler).setDefaultUriVariables(defaultUriVariables).     } else if (handler instanceof org.springframework.web.util.AbstractUriTemplateHandler) {         ((org.springframework.web.util.AbstractUriTemplateHandler) handler).setDefaultUriVariables(defaultUriVariables).     } else {         throw new IllegalArgumentException("This property is not supported with the configured UriTemplateHandler.").     } }
true;public;1;3;/**  * This property has the same purpose as the corresponding property on the  * {@code RestTemplate}. For more details see  * {@link RestTemplate#setUriTemplateHandler}.  * @param handler the URI template handler to use  */ ;/**  * This property has the same purpose as the corresponding property on the  * {@code RestTemplate}. For more details see  * {@link RestTemplate#setUriTemplateHandler}.  * @param handler the URI template handler to use  */ public void setUriTemplateHandler(UriTemplateHandler handler) {     this.syncTemplate.setUriTemplateHandler(handler). }
true;public;0;3;/**  * Return the configured URI template handler.  */ ;/**  * Return the configured URI template handler.  */ public UriTemplateHandler getUriTemplateHandler() {     return this.syncTemplate.getUriTemplateHandler(). }
false;public;0;4;;@Override public RestOperations getRestOperations() {     return this.syncTemplate. }
true;public;1;3;/**  * Set the message body converters to use.  * <p>These converters are used to convert from and to HTTP requests and responses.  */ ;/**  * Set the message body converters to use.  * <p>These converters are used to convert from and to HTTP requests and responses.  */ public void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {     this.syncTemplate.setMessageConverters(messageConverters). }
true;public;0;3;/**  * Return the message body converters.  */ ;/**  * Return the message body converters.  */ public List<HttpMessageConverter<?>> getMessageConverters() {     return this.syncTemplate.getMessageConverters(). }
false;public;3;8;;// GET @Override public <T> ListenableFuture<ResponseEntity<T>> getForEntity(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {     AsyncRequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables). }
false;public;3;8;;@Override public <T> ListenableFuture<ResponseEntity<T>> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     AsyncRequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables). }
false;public;2;8;;@Override public <T> ListenableFuture<ResponseEntity<T>> getForEntity(URI url, Class<T> responseType) throws RestClientException {     AsyncRequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, HttpMethod.GET, requestCallback, responseExtractor). }
false;public;2;7;;// HEAD @Override public ListenableFuture<HttpHeaders> headForHeaders(String url, Object... uriVariables) throws RestClientException {     ResponseExtractor<HttpHeaders> headersExtractor = headersExtractor().     return execute(url, HttpMethod.HEAD, null, headersExtractor, uriVariables). }
false;public;2;7;;@Override public ListenableFuture<HttpHeaders> headForHeaders(String url, Map<String, ?> uriVariables) throws RestClientException {     ResponseExtractor<HttpHeaders> headersExtractor = headersExtractor().     return execute(url, HttpMethod.HEAD, null, headersExtractor, uriVariables). }
false;public;1;5;;@Override public ListenableFuture<HttpHeaders> headForHeaders(URI url) throws RestClientException {     ResponseExtractor<HttpHeaders> headersExtractor = headersExtractor().     return execute(url, HttpMethod.HEAD, null, headersExtractor). }
false;public;3;9;;// POST @Override public ListenableFuture<URI> postForLocation(String url, @Nullable HttpEntity<?> request, Object... uriVars) throws RestClientException {     AsyncRequestCallback callback = httpEntityCallback(request).     ResponseExtractor<HttpHeaders> extractor = headersExtractor().     ListenableFuture<HttpHeaders> future = execute(url, HttpMethod.POST, callback, extractor, uriVars).     return adaptToLocationHeader(future). }
false;public;3;9;;@Override public ListenableFuture<URI> postForLocation(String url, @Nullable HttpEntity<?> request, Map<String, ?> uriVars) throws RestClientException {     AsyncRequestCallback callback = httpEntityCallback(request).     ResponseExtractor<HttpHeaders> extractor = headersExtractor().     ListenableFuture<HttpHeaders> future = execute(url, HttpMethod.POST, callback, extractor, uriVars).     return adaptToLocationHeader(future). }
false;public;2;9;;@Override public ListenableFuture<URI> postForLocation(URI url, @Nullable HttpEntity<?> request) throws RestClientException {     AsyncRequestCallback callback = httpEntityCallback(request).     ResponseExtractor<HttpHeaders> extractor = headersExtractor().     ListenableFuture<HttpHeaders> future = execute(url, HttpMethod.POST, callback, extractor).     return adaptToLocationHeader(future). }
false;protected;1;5;;@Override @Nullable protected URI adapt(HttpHeaders headers) throws ExecutionException {     return headers.getLocation(). }
false;private,static;1;9;;private static ListenableFuture<URI> adaptToLocationHeader(ListenableFuture<HttpHeaders> future) {     return new ListenableFutureAdapter<URI, HttpHeaders>(future) {          @Override         @Nullable         protected URI adapt(HttpHeaders headers) throws ExecutionException {             return headers.getLocation().         }     }. }
false;public;4;8;;@Override public <T> ListenableFuture<ResponseEntity<T>> postForEntity(String url, @Nullable HttpEntity<?> request, Class<T> responseType, Object... uriVariables) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(request, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables). }
false;public;4;8;;@Override public <T> ListenableFuture<ResponseEntity<T>> postForEntity(String url, @Nullable HttpEntity<?> request, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(request, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables). }
false;public;3;8;;@Override public <T> ListenableFuture<ResponseEntity<T>> postForEntity(URI url, @Nullable HttpEntity<?> request, Class<T> responseType) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(request, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, HttpMethod.POST, requestCallback, responseExtractor). }
false;public;3;7;;// PUT @Override public ListenableFuture<?> put(String url, @Nullable HttpEntity<?> request, Object... uriVars) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(request).     return execute(url, HttpMethod.PUT, requestCallback, null, uriVars). }
false;public;3;7;;@Override public ListenableFuture<?> put(String url, @Nullable HttpEntity<?> request, Map<String, ?> uriVars) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(request).     return execute(url, HttpMethod.PUT, requestCallback, null, uriVars). }
false;public;2;5;;@Override public ListenableFuture<?> put(URI url, @Nullable HttpEntity<?> request) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(request).     return execute(url, HttpMethod.PUT, requestCallback, null). }
false;public;2;4;;// DELETE @Override public ListenableFuture<?> delete(String url, Object... uriVariables) throws RestClientException {     return execute(url, HttpMethod.DELETE, null, null, uriVariables). }
false;public;2;4;;@Override public ListenableFuture<?> delete(String url, Map<String, ?> uriVariables) throws RestClientException {     return execute(url, HttpMethod.DELETE, null, null, uriVariables). }
false;public;1;4;;@Override public ListenableFuture<?> delete(URI url) throws RestClientException {     return execute(url, HttpMethod.DELETE, null, null). }
false;public;2;8;;// OPTIONS @Override public ListenableFuture<Set<HttpMethod>> optionsForAllow(String url, Object... uriVars) throws RestClientException {     ResponseExtractor<HttpHeaders> extractor = headersExtractor().     ListenableFuture<HttpHeaders> future = execute(url, HttpMethod.OPTIONS, null, extractor, uriVars).     return adaptToAllowHeader(future). }
false;public;2;8;;@Override public ListenableFuture<Set<HttpMethod>> optionsForAllow(String url, Map<String, ?> uriVars) throws RestClientException {     ResponseExtractor<HttpHeaders> extractor = headersExtractor().     ListenableFuture<HttpHeaders> future = execute(url, HttpMethod.OPTIONS, null, extractor, uriVars).     return adaptToAllowHeader(future). }
false;public;1;6;;@Override public ListenableFuture<Set<HttpMethod>> optionsForAllow(URI url) throws RestClientException {     ResponseExtractor<HttpHeaders> extractor = headersExtractor().     ListenableFuture<HttpHeaders> future = execute(url, HttpMethod.OPTIONS, null, extractor).     return adaptToAllowHeader(future). }
false;protected;1;4;;@Override protected Set<HttpMethod> adapt(HttpHeaders headers) throws ExecutionException {     return headers.getAllow(). }
false;private,static;1;8;;private static ListenableFuture<Set<HttpMethod>> adaptToAllowHeader(ListenableFuture<HttpHeaders> future) {     return new ListenableFutureAdapter<Set<HttpMethod>, HttpHeaders>(future) {          @Override         protected Set<HttpMethod> adapt(HttpHeaders headers) throws ExecutionException {             return headers.getAllow().         }     }. }
false;public;5;9;;// exchange @Override public <T> ListenableFuture<ResponseEntity<T>> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, method, requestCallback, responseExtractor, uriVariables). }
false;public;5;9;;@Override public <T> ListenableFuture<ResponseEntity<T>> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, method, requestCallback, responseExtractor, uriVariables). }
false;public;4;8;;@Override public <T> ListenableFuture<ResponseEntity<T>> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType) throws RestClientException {     AsyncRequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return execute(url, method, requestCallback, responseExtractor). }
false;public;5;10;;@Override public <T> ListenableFuture<ResponseEntity<T>> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException {     Type type = responseType.getType().     AsyncRequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return execute(url, method, requestCallback, responseExtractor, uriVariables). }
false;public;5;10;;@Override public <T> ListenableFuture<ResponseEntity<T>> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     Type type = responseType.getType().     AsyncRequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return execute(url, method, requestCallback, responseExtractor, uriVariables). }
false;public;4;10;;@Override public <T> ListenableFuture<ResponseEntity<T>> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType) throws RestClientException {     Type type = responseType.getType().     AsyncRequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return execute(url, method, requestCallback, responseExtractor). }
false;public;5;7;;// general execution @Override public <T> ListenableFuture<T> execute(String url, HttpMethod method, @Nullable AsyncRequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {     URI expanded = getUriTemplateHandler().expand(url, uriVariables).     return doExecute(expanded, method, requestCallback, responseExtractor). }
false;public;5;8;;@Override public <T> ListenableFuture<T> execute(String url, HttpMethod method, @Nullable AsyncRequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables) throws RestClientException {     URI expanded = getUriTemplateHandler().expand(url, uriVariables).     return doExecute(expanded, method, requestCallback, responseExtractor). }
false;public;4;7;;@Override public <T> ListenableFuture<T> execute(URI url, HttpMethod method, @Nullable AsyncRequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {     return doExecute(url, method, requestCallback, responseExtractor). }
true;protected;4;19;/**  * Execute the given method on the provided URI. The  * {@link org.springframework.http.client.ClientHttpRequest}  * is processed using the {@link RequestCallback}. the response with  * the {@link ResponseExtractor}.  * @param url the fully-expanded URL to connect to  * @param method the HTTP method to execute (GET, POST, etc.)  * @param requestCallback object that prepares the request (can be {@code null})  * @param responseExtractor object that extracts the return value from the response (can  * be {@code null})  * @return an arbitrary object, as returned by the {@link ResponseExtractor}  */ ;/**  * Execute the given method on the provided URI. The  * {@link org.springframework.http.client.ClientHttpRequest}  * is processed using the {@link RequestCallback}. the response with  * the {@link ResponseExtractor}.  * @param url the fully-expanded URL to connect to  * @param method the HTTP method to execute (GET, POST, etc.)  * @param requestCallback object that prepares the request (can be {@code null})  * @param responseExtractor object that extracts the return value from the response (can  * be {@code null})  * @return an arbitrary object, as returned by the {@link ResponseExtractor}  */ protected <T> ListenableFuture<T> doExecute(URI url, HttpMethod method, @Nullable AsyncRequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {     Assert.notNull(url, "'url' must not be null").     Assert.notNull(method, "'method' must not be null").     try {         org.springframework.http.client.AsyncClientHttpRequest request = createAsyncRequest(url, method).         if (requestCallback != null) {             requestCallback.doWithRequest(request).         }         ListenableFuture<ClientHttpResponse> responseFuture = request.executeAsync().         return new ResponseExtractorFuture<>(method, url, responseFuture, responseExtractor).     } catch (IOException ex) {         throw new ResourceAccessException("I/O error on " + method.name() + " request for \"" + url + "\":" + ex.getMessage(), ex).     } }
false;private;3;11;;private void logResponseStatus(HttpMethod method, URI url, ClientHttpResponse response) {     if (logger.isDebugEnabled()) {         try {             logger.debug("Async " + method.name() + " request for \"" + url + "\" resulted in " + response.getRawStatusCode() + " (" + response.getStatusText() + ")").         } catch (IOException ex) {         // ignore         }     } }
false;private;3;12;;private void handleResponseError(HttpMethod method, URI url, ClientHttpResponse response) throws IOException {     if (logger.isWarnEnabled()) {         try {             logger.warn("Async " + method.name() + " request for \"" + url + "\" resulted in " + response.getRawStatusCode() + " (" + response.getStatusText() + "). invoking error handler").         } catch (IOException ex) {         // ignore         }     }     getErrorHandler().handleError(url, method, response). }
true;protected;1;3;/**  * Returns a request callback implementation that prepares the request {@code Accept}  * headers based on the given response type and configured {@linkplain  * #getMessageConverters() message converters}.  */ ;/**  * Returns a request callback implementation that prepares the request {@code Accept}  * headers based on the given response type and configured {@linkplain  * #getMessageConverters() message converters}.  */ protected <T> AsyncRequestCallback acceptHeaderRequestCallback(Class<T> responseType) {     return new AsyncRequestCallbackAdapter(this.syncTemplate.acceptHeaderRequestCallback(responseType)). }
true;protected;1;3;/**  * Returns a request callback implementation that writes the given object to the  * request stream.  */ ;/**  * Returns a request callback implementation that writes the given object to the  * request stream.  */ protected <T> AsyncRequestCallback httpEntityCallback(@Nullable HttpEntity<T> requestBody) {     return new AsyncRequestCallbackAdapter(this.syncTemplate.httpEntityCallback(requestBody)). }
true;protected;2;3;/**  * Returns a request callback implementation that writes the given object to the  * request stream.  */ ;/**  * Returns a request callback implementation that writes the given object to the  * request stream.  */ protected <T> AsyncRequestCallback httpEntityCallback(@Nullable HttpEntity<T> request, Type responseType) {     return new AsyncRequestCallbackAdapter(this.syncTemplate.httpEntityCallback(request, responseType)). }
true;protected;1;3;/**  * Returns a response extractor for {@link ResponseEntity}.  */ ;/**  * Returns a response extractor for {@link ResponseEntity}.  */ protected <T> ResponseExtractor<ResponseEntity<T>> responseEntityExtractor(Type responseType) {     return this.syncTemplate.responseEntityExtractor(responseType). }
true;protected;0;3;/**  * Returns a response extractor for {@link HttpHeaders}.  */ ;/**  * Returns a response extractor for {@link HttpHeaders}.  */ protected ResponseExtractor<HttpHeaders> headersExtractor() {     return this.syncTemplate.headersExtractor(). }
false;protected,final;1;19;;@Override @Nullable protected final T adapt(ClientHttpResponse response) throws ExecutionException {     try {         if (!getErrorHandler().hasError(response)) {             logResponseStatus(this.method, this.url, response).         } else {             handleResponseError(this.method, this.url, response).         }         return convertResponse(response).     } catch (Throwable ex) {         throw new ExecutionException(ex).     } finally {         response.close().     } }
false;protected;1;4;;@Nullable protected T convertResponse(ClientHttpResponse response) throws IOException {     return (this.responseExtractor != null ? this.responseExtractor.extractData(response) : null). }
false;public;0;4;;@Override public ClientHttpResponse execute() throws IOException {     throw new UnsupportedOperationException("execute not supported"). }
false;public;0;4;;@Override public OutputStream getBody() throws IOException {     return request.getBody(). }
false;public;0;5;;@Override @Nullable public HttpMethod getMethod() {     return request.getMethod(). }
false;public;0;4;;@Override public String getMethodValue() {     return request.getMethodValue(). }
false;public;0;4;;@Override public URI getURI() {     return request.getURI(). }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return request.getHeaders(). }
false;public;1;32;;@Override public void doWithRequest(final org.springframework.http.client.AsyncClientHttpRequest request) throws IOException {     this.adaptee.doWithRequest(new ClientHttpRequest() {          @Override         public ClientHttpResponse execute() throws IOException {             throw new UnsupportedOperationException("execute not supported").         }          @Override         public OutputStream getBody() throws IOException {             return request.getBody().         }          @Override         @Nullable         public HttpMethod getMethod() {             return request.getMethod().         }          @Override         public String getMethodValue() {             return request.getMethodValue().         }          @Override         public URI getURI() {             return request.getURI().         }          @Override         public HttpHeaders getHeaders() {             return request.getHeaders().         }     }). }
