commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;5;;private static DefaultUriBuilderFactory initUriTemplateHandler() {     DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory().     // for backwards compatibility..     uriFactory.setEncodingMode(EncodingMode.URI_COMPONENT).     return uriFactory. }
true;public;1;8;/**  * Set the message body converters to use.  * <p>These converters are used to convert from and to HTTP requests and responses.  */ ;/**  * Set the message body converters to use.  * <p>These converters are used to convert from and to HTTP requests and responses.  */ public void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {     Assert.notEmpty(messageConverters, "At least one HttpMessageConverter required").     // Take getMessageConverters() List as-is when passed in here     if (this.messageConverters != messageConverters) {         this.messageConverters.clear().         this.messageConverters.addAll(messageConverters).     } }
true;public;0;3;/**  * Return the list of message body converters.  * <p>The returned {@link List} is active and may get appended to.  */ ;/**  * Return the list of message body converters.  * <p>The returned {@link List} is active and may get appended to.  */ public List<HttpMessageConverter<?>> getMessageConverters() {     return this.messageConverters. }
true;public;1;4;/**  * Set the error handler.  * <p>By default, RestTemplate uses a {@link DefaultResponseErrorHandler}.  */ ;/**  * Set the error handler.  * <p>By default, RestTemplate uses a {@link DefaultResponseErrorHandler}.  */ public void setErrorHandler(ResponseErrorHandler errorHandler) {     Assert.notNull(errorHandler, "ResponseErrorHandler must not be null").     this.errorHandler = errorHandler. }
true;public;0;3;/**  * Return the error handler.  */ ;/**  * Return the error handler.  */ public ResponseErrorHandler getErrorHandler() {     return this.errorHandler. }
true;public;1;14;/**  * Configure default URI variable values. This is a shortcut for:  * <pre class="code">  * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory().  * handler.setDefaultUriVariables(...).  *  * RestTemplate restTemplate = new RestTemplate().  * restTemplate.setUriTemplateHandler(handler).  * </pre>  * @param uriVars the default URI variable values  * @since 4.3  */ ;/**  * Configure default URI variable values. This is a shortcut for:  * <pre class="code">  * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory().  * handler.setDefaultUriVariables(...).  *  * RestTemplate restTemplate = new RestTemplate().  * restTemplate.setUriTemplateHandler(handler).  * </pre>  * @param uriVars the default URI variable values  * @since 4.3  */ @SuppressWarnings("deprecation") public void setDefaultUriVariables(Map<String, ?> uriVars) {     if (this.uriTemplateHandler instanceof DefaultUriBuilderFactory) {         ((DefaultUriBuilderFactory) this.uriTemplateHandler).setDefaultUriVariables(uriVars).     } else if (this.uriTemplateHandler instanceof org.springframework.web.util.AbstractUriTemplateHandler) {         ((org.springframework.web.util.AbstractUriTemplateHandler) this.uriTemplateHandler).setDefaultUriVariables(uriVars).     } else {         throw new IllegalArgumentException("This property is not supported with the configured UriTemplateHandler.").     } }
true;public;1;4;/**  * Configure a strategy for expanding URI templates.  * <p>By default, {@link DefaultUriBuilderFactory} is used and for  * backwards compatibility, the encoding mode is set to  * {@link EncodingMode#URI_COMPONENT URI_COMPONENT}. As of 5.0.8, prefer  * using {@link EncodingMode#TEMPLATE_AND_VALUES TEMPLATE_AND_VALUES}.  * <p><strong>Note:</strong> in 5.0 the switch from  * {@link org.springframework.web.util.DefaultUriTemplateHandler  * DefaultUriTemplateHandler} (deprecated in 4.3), as the default to use, to  * {@link DefaultUriBuilderFactory} brings in a different default for the  * {@code parsePath} property (switching from false to true).  * @param handler the URI template handler to use  */ ;/**  * Configure a strategy for expanding URI templates.  * <p>By default, {@link DefaultUriBuilderFactory} is used and for  * backwards compatibility, the encoding mode is set to  * {@link EncodingMode#URI_COMPONENT URI_COMPONENT}. As of 5.0.8, prefer  * using {@link EncodingMode#TEMPLATE_AND_VALUES TEMPLATE_AND_VALUES}.  * <p><strong>Note:</strong> in 5.0 the switch from  * {@link org.springframework.web.util.DefaultUriTemplateHandler  * DefaultUriTemplateHandler} (deprecated in 4.3), as the default to use, to  * {@link DefaultUriBuilderFactory} brings in a different default for the  * {@code parsePath} property (switching from false to true).  * @param handler the URI template handler to use  */ public void setUriTemplateHandler(UriTemplateHandler handler) {     Assert.notNull(handler, "UriTemplateHandler must not be null").     this.uriTemplateHandler = handler. }
true;public;0;3;/**  * Return the configured URI template handler.  */ ;/**  * Return the configured URI template handler.  */ public UriTemplateHandler getUriTemplateHandler() {     return this.uriTemplateHandler. }
false;public;3;8;;// GET @Override @Nullable public <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables). }
false;public;3;8;;@Override @Nullable public <T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables). }
false;public;2;8;;@Override @Nullable public <T> T getForObject(URI url, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.GET, requestCallback, responseExtractor). }
false;public;3;8;;@Override public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables)). }
false;public;3;8;;@Override public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables)). }
false;public;2;6;;@Override public <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = acceptHeaderRequestCallback(responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor)). }
false;public;2;4;;// HEAD @Override public HttpHeaders headForHeaders(String url, Object... uriVariables) throws RestClientException {     return nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables)). }
false;public;2;4;;@Override public HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables) throws RestClientException {     return nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables)). }
false;public;1;4;;@Override public HttpHeaders headForHeaders(URI url) throws RestClientException {     return nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor())). }
false;public;3;9;;// POST @Override @Nullable public URI postForLocation(String url, @Nullable Object request, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request).     HttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables).     return (headers != null ? headers.getLocation() : null). }
false;public;3;9;;@Override @Nullable public URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request).     HttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables).     return (headers != null ? headers.getLocation() : null). }
false;public;2;7;;@Override @Nullable public URI postForLocation(URI url, @Nullable Object request) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request).     HttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor()).     return (headers != null ? headers.getLocation() : null). }
false;public;4;10;;@Override @Nullable public <T> T postForObject(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables). }
false;public;4;10;;@Override @Nullable public <T> T postForObject(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables). }
false;public;3;10;;@Override @Nullable public <T> T postForObject(URI url, @Nullable Object request, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters()).     return execute(url, HttpMethod.POST, requestCallback, responseExtractor). }
false;public;4;8;;@Override public <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables)). }
false;public;4;8;;@Override public <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables)). }
false;public;3;8;;@Override public <T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor)). }
false;public;3;7;;// PUT @Override public void put(String url, @Nullable Object request, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request).     execute(url, HttpMethod.PUT, requestCallback, null, uriVariables). }
false;public;3;7;;@Override public void put(String url, @Nullable Object request, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request).     execute(url, HttpMethod.PUT, requestCallback, null, uriVariables). }
false;public;2;5;;@Override public void put(URI url, @Nullable Object request) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request).     execute(url, HttpMethod.PUT, requestCallback, null). }
false;public;4;10;;// PATCH @Override @Nullable public <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables). }
false;public;4;10;;@Override @Nullable public <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger).     return execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables). }
false;public;3;10;;@Override @Nullable public <T> T patchForObject(URI url, @Nullable Object request, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(request, responseType).     HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor<>(responseType, getMessageConverters()).     return execute(url, HttpMethod.PATCH, requestCallback, responseExtractor). }
false;public;2;4;;// DELETE @Override public void delete(String url, Object... uriVariables) throws RestClientException {     execute(url, HttpMethod.DELETE, null, null, uriVariables). }
false;public;2;4;;@Override public void delete(String url, Map<String, ?> uriVariables) throws RestClientException {     execute(url, HttpMethod.DELETE, null, null, uriVariables). }
false;public;1;4;;@Override public void delete(URI url) throws RestClientException {     execute(url, HttpMethod.DELETE, null, null). }
false;public;2;6;;// OPTIONS @Override public Set<HttpMethod> optionsForAllow(String url, Object... uriVariables) throws RestClientException {     ResponseExtractor<HttpHeaders> headersExtractor = headersExtractor().     HttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables).     return (headers != null ? headers.getAllow() : Collections.emptySet()). }
false;public;2;6;;@Override public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables) throws RestClientException {     ResponseExtractor<HttpHeaders> headersExtractor = headersExtractor().     HttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables).     return (headers != null ? headers.getAllow() : Collections.emptySet()). }
false;public;1;6;;@Override public Set<HttpMethod> optionsForAllow(URI url) throws RestClientException {     ResponseExtractor<HttpHeaders> headersExtractor = headersExtractor().     HttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor).     return (headers != null ? headers.getAllow() : Collections.emptySet()). }
false;public;5;9;;// exchange @Override public <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables)). }
false;public;5;9;;@Override public <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables)). }
false;public;4;8;;@Override public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(execute(url, method, requestCallback, responseExtractor)). }
false;public;5;9;;@Override public <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException {     Type type = responseType.getType().     RequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables)). }
false;public;5;9;;@Override public <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException {     Type type = responseType.getType().     RequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables)). }
false;public;4;9;;@Override public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType) throws RestClientException {     Type type = responseType.getType().     RequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return nonNull(execute(url, method, requestCallback, responseExtractor)). }
false;public;2;8;;@Override public <T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, Class<T> responseType) throws RestClientException {     RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType).     return nonNull(doExecute(requestEntity.getUrl(), requestEntity.getMethod(), requestCallback, responseExtractor)). }
false;public;2;9;;@Override public <T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, ParameterizedTypeReference<T> responseType) throws RestClientException {     Type type = responseType.getType().     RequestCallback requestCallback = httpEntityCallback(requestEntity, type).     ResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type).     return nonNull(doExecute(requestEntity.getUrl(), requestEntity.getMethod(), requestCallback, responseExtractor)). }
true;public;5;8;/**  * {@inheritDoc}  * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,  * but not both, consider using:  * <ul>  * <li>{@link #acceptHeaderRequestCallback(Class)}  * <li>{@link #httpEntityCallback(Object)}  * <li>{@link #httpEntityCallback(Object, Type)}  * <li>{@link #responseEntityExtractor(Type)}  * </ul>  */ ;// General execution /**  * {@inheritDoc}  * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,  * but not both, consider using:  * <ul>  * <li>{@link #acceptHeaderRequestCallback(Class)}  * <li>{@link #httpEntityCallback(Object)}  * <li>{@link #httpEntityCallback(Object, Type)}  * <li>{@link #responseEntityExtractor(Type)}  * </ul>  */ @Override @Nullable public <T> T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {     URI expanded = getUriTemplateHandler().expand(url, uriVariables).     return doExecute(expanded, method, requestCallback, responseExtractor). }
true;public;5;9;/**  * {@inheritDoc}  * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,  * but not both, consider using:  * <ul>  * <li>{@link #acceptHeaderRequestCallback(Class)}  * <li>{@link #httpEntityCallback(Object)}  * <li>{@link #httpEntityCallback(Object, Type)}  * <li>{@link #responseEntityExtractor(Type)}  * </ul>  */ ;/**  * {@inheritDoc}  * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,  * but not both, consider using:  * <ul>  * <li>{@link #acceptHeaderRequestCallback(Class)}  * <li>{@link #httpEntityCallback(Object)}  * <li>{@link #httpEntityCallback(Object, Type)}  * <li>{@link #responseEntityExtractor(Type)}  * </ul>  */ @Override @Nullable public <T> T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables) throws RestClientException {     URI expanded = getUriTemplateHandler().expand(url, uriVariables).     return doExecute(expanded, method, requestCallback, responseExtractor). }
true;public;4;7;/**  * {@inheritDoc}  * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,  * but not both, consider using:  * <ul>  * <li>{@link #acceptHeaderRequestCallback(Class)}  * <li>{@link #httpEntityCallback(Object)}  * <li>{@link #httpEntityCallback(Object, Type)}  * <li>{@link #responseEntityExtractor(Type)}  * </ul>  */ ;/**  * {@inheritDoc}  * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,  * but not both, consider using:  * <ul>  * <li>{@link #acceptHeaderRequestCallback(Class)}  * <li>{@link #httpEntityCallback(Object)}  * <li>{@link #httpEntityCallback(Object, Type)}  * <li>{@link #responseEntityExtractor(Type)}  * </ul>  */ @Override @Nullable public <T> T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {     return doExecute(url, method, requestCallback, responseExtractor). }
true;protected;4;29;/**  * Execute the given method on the provided URI.  * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback}.  * the response with the {@link ResponseExtractor}.  * @param url the fully-expanded URL to connect to  * @param method the HTTP method to execute (GET, POST, etc.)  * @param requestCallback object that prepares the request (can be {@code null})  * @param responseExtractor object that extracts the return value from the response (can be {@code null})  * @return an arbitrary object, as returned by the {@link ResponseExtractor}  */ ;/**  * Execute the given method on the provided URI.  * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback}.  * the response with the {@link ResponseExtractor}.  * @param url the fully-expanded URL to connect to  * @param method the HTTP method to execute (GET, POST, etc.)  * @param requestCallback object that prepares the request (can be {@code null})  * @param responseExtractor object that extracts the return value from the response (can be {@code null})  * @return an arbitrary object, as returned by the {@link ResponseExtractor}  */ @Nullable protected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {     Assert.notNull(url, "URI is required").     Assert.notNull(method, "HttpMethod is required").     ClientHttpResponse response = null.     try {         ClientHttpRequest request = createRequest(url, method).         if (requestCallback != null) {             requestCallback.doWithRequest(request).         }         response = request.execute().         handleResponse(url, method, response).         return (responseExtractor != null ? responseExtractor.extractData(response) : null).     } catch (IOException ex) {         String resource = url.toString().         String query = url.getRawQuery().         resource = (query != null ? resource.substring(0, resource.indexOf('?')) : resource).         throw new ResourceAccessException("I/O error on " + method.name() + " request for \"" + resource + "\": " + ex.getMessage(), ex).     } finally {         if (response != null) {             response.close().         }     } }
true;protected;3;17;/**  * Handle the given response, performing appropriate logging and  * invoking the {@link ResponseErrorHandler} if necessary.  * <p>Can be overridden in subclasses.  * @param url the fully-expanded URL to connect to  * @param method the HTTP method to execute (GET, POST, etc.)  * @param response the resulting {@link ClientHttpResponse}  * @throws IOException if propagated from {@link ResponseErrorHandler}  * @since 4.1.6  * @see #setErrorHandler  */ ;/**  * Handle the given response, performing appropriate logging and  * invoking the {@link ResponseErrorHandler} if necessary.  * <p>Can be overridden in subclasses.  * @param url the fully-expanded URL to connect to  * @param method the HTTP method to execute (GET, POST, etc.)  * @param response the resulting {@link ClientHttpResponse}  * @throws IOException if propagated from {@link ResponseErrorHandler}  * @since 4.1.6  * @see #setErrorHandler  */ protected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {     ResponseErrorHandler errorHandler = getErrorHandler().     boolean hasError = errorHandler.hasError(response).     if (logger.isDebugEnabled()) {         try {             int code = response.getRawStatusCode().             HttpStatus status = HttpStatus.resolve(code).             logger.debug("Response " + (status != null ? status : code)).         } catch (IOException ex) {         // ignore         }     }     if (hasError) {         errorHandler.handleError(url, method, response).     } }
true;public;1;3;/**  * Return a {@code RequestCallback} that sets the request {@code Accept}  * header based on the given response type, cross-checked against the  * configured message converters.  */ ;/**  * Return a {@code RequestCallback} that sets the request {@code Accept}  * header based on the given response type, cross-checked against the  * configured message converters.  */ public <T> RequestCallback acceptHeaderRequestCallback(Class<T> responseType) {     return new AcceptHeaderRequestCallback(responseType). }
true;public;1;3;/**  * Return a {@code RequestCallback} implementation that writes the given  * object to the request stream.  */ ;/**  * Return a {@code RequestCallback} implementation that writes the given  * object to the request stream.  */ public <T> RequestCallback httpEntityCallback(@Nullable Object requestBody) {     return new HttpEntityRequestCallback(requestBody). }
true;public;2;3;/**  * Return a {@code RequestCallback} implementation that:  * <ol>  * <li>Sets the request {@code Accept} header based on the given response  * type, cross-checked against the configured message converters.  * <li>Writes the given object to the request stream.  * </ol>  */ ;/**  * Return a {@code RequestCallback} implementation that:  * <ol>  * <li>Sets the request {@code Accept} header based on the given response  * type, cross-checked against the configured message converters.  * <li>Writes the given object to the request stream.  * </ol>  */ public <T> RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType) {     return new HttpEntityRequestCallback(requestBody, responseType). }
true;public;1;3;/**  * Return a {@code ResponseExtractor} that prepares a {@link ResponseEntity}.  */ ;/**  * Return a {@code ResponseExtractor} that prepares a {@link ResponseEntity}.  */ public <T> ResponseExtractor<ResponseEntity<T>> responseEntityExtractor(Type responseType) {     return new ResponseEntityResponseExtractor<>(responseType). }
true;protected;0;3;/**  * Return a response extractor for {@link HttpHeaders}.  */ ;/**  * Return a response extractor for {@link HttpHeaders}.  */ protected ResponseExtractor<HttpHeaders> headersExtractor() {     return this.headersExtractor. }
false;private,static;1;4;;private static <T> T nonNull(@Nullable T result) {     Assert.state(result != null, "No result").     return result. }
false;public;1;15;;@Override public void doWithRequest(ClientHttpRequest request) throws IOException {     if (this.responseType != null) {         List<MediaType> allSupportedMediaTypes = getMessageConverters().stream().filter(converter -> canReadResponse(this.responseType, converter)).flatMap(this::getSupportedMediaTypes).distinct().sorted(MediaType.SPECIFICITY_COMPARATOR).collect(Collectors.toList()).         if (logger.isDebugEnabled()) {             logger.debug("Accept=" + allSupportedMediaTypes).         }         request.getHeaders().setAccept(allSupportedMediaTypes).     } }
false;private;2;11;;private boolean canReadResponse(Type responseType, HttpMessageConverter<?> converter) {     Class<?> responseClass = (responseType instanceof Class ? (Class<?>) responseType : null).     if (responseClass != null) {         return converter.canRead(responseClass, null).     } else if (converter instanceof GenericHttpMessageConverter) {         GenericHttpMessageConverter<?> genericConverter = (GenericHttpMessageConverter<?>) converter.         return genericConverter.canRead(responseType, null, null).     }     return false. }
false;private;1;10;;private Stream<MediaType> getSupportedMediaTypes(HttpMessageConverter<?> messageConverter) {     return messageConverter.getSupportedMediaTypes().stream().map(mediaType -> {         if (mediaType.getCharset() != null) {             return new MediaType(mediaType.getType(), mediaType.getSubtype()).         }         return mediaType.     }). }
false;public;1;52;;@Override @SuppressWarnings("unchecked") public void doWithRequest(ClientHttpRequest httpRequest) throws IOException {     super.doWithRequest(httpRequest).     Object requestBody = this.requestEntity.getBody().     if (requestBody == null) {         HttpHeaders httpHeaders = httpRequest.getHeaders().         HttpHeaders requestHeaders = this.requestEntity.getHeaders().         if (!requestHeaders.isEmpty()) {             requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values))).         }         if (httpHeaders.getContentLength() < 0) {             httpHeaders.setContentLength(0L).         }     } else {         Class<?> requestBodyClass = requestBody.getClass().         Type requestBodyType = (this.requestEntity instanceof RequestEntity ? ((RequestEntity<?>) this.requestEntity).getType() : requestBodyClass).         HttpHeaders httpHeaders = httpRequest.getHeaders().         HttpHeaders requestHeaders = this.requestEntity.getHeaders().         MediaType requestContentType = requestHeaders.getContentType().         for (HttpMessageConverter<?> messageConverter : getMessageConverters()) {             if (messageConverter instanceof GenericHttpMessageConverter) {                 GenericHttpMessageConverter<Object> genericConverter = (GenericHttpMessageConverter<Object>) messageConverter.                 if (genericConverter.canWrite(requestBodyType, requestBodyClass, requestContentType)) {                     if (!requestHeaders.isEmpty()) {                         requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values))).                     }                     logBody(requestBody, requestContentType, genericConverter).                     genericConverter.write(requestBody, requestBodyType, requestContentType, httpRequest).                     return.                 }             } else if (messageConverter.canWrite(requestBodyClass, requestContentType)) {                 if (!requestHeaders.isEmpty()) {                     requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values))).                 }                 logBody(requestBody, requestContentType, messageConverter).                 ((HttpMessageConverter<Object>) messageConverter).write(requestBody, requestContentType, httpRequest).                 return.             }         }         String message = "No HttpMessageConverter for [" + requestBodyClass.getName() + "]".         if (requestContentType != null) {             message += " and content type [" + requestContentType + "]".         }         throw new RestClientException(message).     } }
false;private;3;11;;private void logBody(Object body, @Nullable MediaType mediaType, HttpMessageConverter<?> converter) {     if (logger.isDebugEnabled()) {         if (mediaType != null) {             logger.debug("Writing [" + body + "] as \"" + mediaType + "\"").         } else {             String classname = converter.getClass().getName().             logger.debug("Writing [" + body + "] with " + classname).         }     } }
false;public;1;10;;@Override public ResponseEntity<T> extractData(ClientHttpResponse response) throws IOException {     if (this.delegate != null) {         T body = this.delegate.extractData(response).         return ResponseEntity.status(response.getRawStatusCode()).headers(response.getHeaders()).body(body).     } else {         return ResponseEntity.status(response.getRawStatusCode()).headers(response.getHeaders()).build().     } }
false;public;1;4;;@Override public HttpHeaders extractData(ClientHttpResponse response) {     return response.getHeaders(). }
