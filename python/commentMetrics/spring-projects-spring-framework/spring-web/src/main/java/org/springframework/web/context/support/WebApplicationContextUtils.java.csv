commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;7;/**  * Find the root {@code WebApplicationContext} for this web app, typically  * loaded via {@link org.springframework.web.context.ContextLoaderListener}.  * <p>Will rethrow an exception that happened on root context startup,  * to differentiate between a failed context startup and no context at all.  * @param sc the ServletContext to find the web application context for  * @return the root WebApplicationContext for this web app  * @throws IllegalStateException if the root WebApplicationContext could not be found  * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE  */ ;/**  * Find the root {@code WebApplicationContext} for this web app, typically  * loaded via {@link org.springframework.web.context.ContextLoaderListener}.  * <p>Will rethrow an exception that happened on root context startup,  * to differentiate between a failed context startup and no context at all.  * @param sc the ServletContext to find the web application context for  * @return the root WebApplicationContext for this web app  * @throws IllegalStateException if the root WebApplicationContext could not be found  * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE  */ public static WebApplicationContext getRequiredWebApplicationContext(ServletContext sc) throws IllegalStateException {     WebApplicationContext wac = getWebApplicationContext(sc).     if (wac == null) {         throw new IllegalStateException("No WebApplicationContext found: no ContextLoaderListener registered?").     }     return wac. }
true;public,static;1;4;/**  * Find the root {@code WebApplicationContext} for this web app, typically  * loaded via {@link org.springframework.web.context.ContextLoaderListener}.  * <p>Will rethrow an exception that happened on root context startup,  * to differentiate between a failed context startup and no context at all.  * @param sc the ServletContext to find the web application context for  * @return the root WebApplicationContext for this web app, or {@code null} if none  * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE  */ ;/**  * Find the root {@code WebApplicationContext} for this web app, typically  * loaded via {@link org.springframework.web.context.ContextLoaderListener}.  * <p>Will rethrow an exception that happened on root context startup,  * to differentiate between a failed context startup and no context at all.  * @param sc the ServletContext to find the web application context for  * @return the root WebApplicationContext for this web app, or {@code null} if none  * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE  */ @Nullable public static WebApplicationContext getWebApplicationContext(ServletContext sc) {     return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE). }
true;public,static;2;21;/**  * Find a custom {@code WebApplicationContext} for this web app.  * @param sc the ServletContext to find the web application context for  * @param attrName the name of the ServletContext attribute to look for  * @return the desired WebApplicationContext for this web app, or {@code null} if none  */ ;/**  * Find a custom {@code WebApplicationContext} for this web app.  * @param sc the ServletContext to find the web application context for  * @param attrName the name of the ServletContext attribute to look for  * @return the desired WebApplicationContext for this web app, or {@code null} if none  */ @Nullable public static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {     Assert.notNull(sc, "ServletContext must not be null").     Object attr = sc.getAttribute(attrName).     if (attr == null) {         return null.     }     if (attr instanceof RuntimeException) {         throw (RuntimeException) attr.     }     if (attr instanceof Error) {         throw (Error) attr.     }     if (attr instanceof Exception) {         throw new IllegalStateException((Exception) attr).     }     if (!(attr instanceof WebApplicationContext)) {         throw new IllegalStateException("Context attribute is not of type WebApplicationContext: " + attr).     }     return (WebApplicationContext) attr. }
true;public,static;1;19;/**  * Find a unique {@code WebApplicationContext} for this web app: either the  * root web app context (preferred) or a unique {@code WebApplicationContext}  * among the registered {@code ServletContext} attributes (typically coming  * from a single {@code DispatcherServlet} in the current web application).  * <p>Note that {@code DispatcherServlet}'s exposure of its context can be  * controlled through its {@code publishContext} property, which is {@code true}  * by default but can be selectively switched to only publish a single context  * despite multiple {@code DispatcherServlet} registrations in the web app.  * @param sc the ServletContext to find the web application context for  * @return the desired WebApplicationContext for this web app, or {@code null} if none  * @since 4.2  * @see #getWebApplicationContext(ServletContext)  * @see ServletContext#getAttributeNames()  */ ;/**  * Find a unique {@code WebApplicationContext} for this web app: either the  * root web app context (preferred) or a unique {@code WebApplicationContext}  * among the registered {@code ServletContext} attributes (typically coming  * from a single {@code DispatcherServlet} in the current web application).  * <p>Note that {@code DispatcherServlet}'s exposure of its context can be  * controlled through its {@code publishContext} property, which is {@code true}  * by default but can be selectively switched to only publish a single context  * despite multiple {@code DispatcherServlet} registrations in the web app.  * @param sc the ServletContext to find the web application context for  * @return the desired WebApplicationContext for this web app, or {@code null} if none  * @since 4.2  * @see #getWebApplicationContext(ServletContext)  * @see ServletContext#getAttributeNames()  */ @Nullable public static WebApplicationContext findWebApplicationContext(ServletContext sc) {     WebApplicationContext wac = getWebApplicationContext(sc).     if (wac == null) {         Enumeration<String> attrNames = sc.getAttributeNames().         while (attrNames.hasMoreElements()) {             String attrName = attrNames.nextElement().             Object attrValue = sc.getAttribute(attrName).             if (attrValue instanceof WebApplicationContext) {                 if (wac != null) {                     throw new IllegalStateException("No unique WebApplicationContext found: more than one " + "DispatcherServlet registered with publishContext=true?").                 }                 wac = (WebApplicationContext) attrValue.             }         }     }     return wac. }
true;public,static;1;3;/**  * Register web-specific scopes ("request", "session", "globalSession")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param beanFactory the BeanFactory to configure  */ ;/**  * Register web-specific scopes ("request", "session", "globalSession")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param beanFactory the BeanFactory to configure  */ public static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory) {     registerWebApplicationScopes(beanFactory, null). }
true;public,static;2;20;/**  * Register web-specific scopes ("request", "session", "globalSession", "application")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param beanFactory the BeanFactory to configure  * @param sc the ServletContext that we're running within  */ ;/**  * Register web-specific scopes ("request", "session", "globalSession", "application")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param beanFactory the BeanFactory to configure  * @param sc the ServletContext that we're running within  */ public static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory, @Nullable ServletContext sc) {     beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope()).     beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope()).     if (sc != null) {         ServletContextScope appScope = new ServletContextScope(sc).         beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope).         // Register as ServletContext attribute, for ContextCleanupListener to detect it.         sc.setAttribute(ServletContextScope.class.getName(), appScope).     }     beanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory()).     beanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory()).     beanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory()).     beanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory()).     if (jsfPresent) {         FacesDependencyRegistrar.registerFacesDependencies(beanFactory).     } }
true;public,static;2;3;/**  * Register web-specific environment beans ("contextParameters", "contextAttributes")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param bf the BeanFactory to configure  * @param sc the ServletContext that we're running within  */ ;/**  * Register web-specific environment beans ("contextParameters", "contextAttributes")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param bf the BeanFactory to configure  * @param sc the ServletContext that we're running within  */ public static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {     registerEnvironmentBeans(bf, sc, null). }
true;public,static;3;44;/**  * Register web-specific environment beans ("contextParameters", "contextAttributes")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param bf the BeanFactory to configure  * @param servletContext the ServletContext that we're running within  * @param servletConfig the ServletConfig  */ ;/**  * Register web-specific environment beans ("contextParameters", "contextAttributes")  * with the given BeanFactory, as used by the WebApplicationContext.  * @param bf the BeanFactory to configure  * @param servletContext the ServletContext that we're running within  * @param servletConfig the ServletConfig  */ public static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {     if (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {         bf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext).     }     if (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {         bf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig).     }     if (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {         Map<String, String> parameterMap = new HashMap<>().         if (servletContext != null) {             Enumeration<?> paramNameEnum = servletContext.getInitParameterNames().             while (paramNameEnum.hasMoreElements()) {                 String paramName = (String) paramNameEnum.nextElement().                 parameterMap.put(paramName, servletContext.getInitParameter(paramName)).             }         }         if (servletConfig != null) {             Enumeration<?> paramNameEnum = servletConfig.getInitParameterNames().             while (paramNameEnum.hasMoreElements()) {                 String paramName = (String) paramNameEnum.nextElement().                 parameterMap.put(paramName, servletConfig.getInitParameter(paramName)).             }         }         bf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME, Collections.unmodifiableMap(parameterMap)).     }     if (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {         Map<String, Object> attributeMap = new HashMap<>().         if (servletContext != null) {             Enumeration<?> attrNameEnum = servletContext.getAttributeNames().             while (attrNameEnum.hasMoreElements()) {                 String attrName = (String) attrNameEnum.nextElement().                 attributeMap.put(attrName, servletContext.getAttribute(attrName)).             }         }         bf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME, Collections.unmodifiableMap(attributeMap)).     } }
true;public,static;2;3;/**  * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,  * ServletContext, ServletConfig)} that always provides {@code null} for the  * {@link ServletConfig} parameter.  * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)  */ ;/**  * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,  * ServletContext, ServletConfig)} that always provides {@code null} for the  * {@link ServletConfig} parameter.  * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)  */ public static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {     initServletPropertySources(propertySources, servletContext, null). }
true;public,static;3;13;/**  * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with  * actual instances populated with the given {@code servletContext} and  * {@code servletConfig} objects.  * <p>This method is idempotent with respect to the fact it may be called any number  * of times but will perform replacement of stub property sources with their  * corresponding actual property sources once and only once.  * @param sources the {@link MutablePropertySources} to initialize (must not  * be {@code null})  * @param servletContext the current {@link ServletContext} (ignored if {@code null}  * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME  * servlet context property source} has already been initialized)  * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}  * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME  * servlet config property source} has already been initialized)  * @see org.springframework.core.env.PropertySource.StubPropertySource  * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()  */ ;/**  * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with  * actual instances populated with the given {@code servletContext} and  * {@code servletConfig} objects.  * <p>This method is idempotent with respect to the fact it may be called any number  * of times but will perform replacement of stub property sources with their  * corresponding actual property sources once and only once.  * @param sources the {@link MutablePropertySources} to initialize (must not  * be {@code null})  * @param servletContext the current {@link ServletContext} (ignored if {@code null}  * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME  * servlet context property source} has already been initialized)  * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}  * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME  * servlet config property source} has already been initialized)  * @see org.springframework.core.env.PropertySource.StubPropertySource  * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()  */ public static void initServletPropertySources(MutablePropertySources sources, @Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {     Assert.notNull(sources, "'propertySources' must not be null").     String name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME.     if (servletContext != null && sources.contains(name) && sources.get(name) instanceof StubPropertySource) {         sources.replace(name, new ServletContextPropertySource(name, servletContext)).     }     name = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME.     if (servletConfig != null && sources.contains(name) && sources.get(name) instanceof StubPropertySource) {         sources.replace(name, new ServletConfigPropertySource(name, servletConfig)).     } }
true;private,static;0;7;/**  * Return the current RequestAttributes instance as ServletRequestAttributes.  * @see RequestContextHolder#currentRequestAttributes()  */ ;/**  * Return the current RequestAttributes instance as ServletRequestAttributes.  * @see RequestContextHolder#currentRequestAttributes()  */ private static ServletRequestAttributes currentRequestAttributes() {     RequestAttributes requestAttr = RequestContextHolder.currentRequestAttributes().     if (!(requestAttr instanceof ServletRequestAttributes)) {         throw new IllegalStateException("Current request is not a servlet request").     }     return (ServletRequestAttributes) requestAttr. }
false;public;0;4;;@Override public ServletRequest getObject() {     return currentRequestAttributes().getRequest(). }
false;public;0;4;;@Override public String toString() {     return "Current HttpServletRequest". }
false;public;0;9;;@Override public ServletResponse getObject() {     ServletResponse response = currentRequestAttributes().getResponse().     if (response == null) {         throw new IllegalStateException("Current servlet response not available - " + "consider using RequestContextFilter instead of RequestContextListener").     }     return response. }
false;public;0;4;;@Override public String toString() {     return "Current HttpServletResponse". }
false;public;0;4;;@Override public HttpSession getObject() {     return currentRequestAttributes().getRequest().getSession(). }
false;public;0;4;;@Override public String toString() {     return "Current HttpSession". }
false;public;0;5;;@Override public WebRequest getObject() {     ServletRequestAttributes requestAttr = currentRequestAttributes().     return new ServletWebRequest(requestAttr.getRequest(), requestAttr.getResponse()). }
false;public;0;4;;@Override public String toString() {     return "Current ServletWebRequest". }
false;public;0;4;;@Override public FacesContext getObject() {     return FacesContext.getCurrentInstance(). }
false;public;0;4;;@Override public String toString() {     return "Current JSF FacesContext". }
false;public;0;4;;@Override public ExternalContext getObject() {     return FacesContext.getCurrentInstance().getExternalContext(). }
false;public;0;4;;@Override public String toString() {     return "Current JSF ExternalContext". }
false;public,static;1;22;;public static void registerFacesDependencies(ConfigurableListableBeanFactory beanFactory) {     beanFactory.registerResolvableDependency(FacesContext.class, new ObjectFactory<FacesContext>() {          @Override         public FacesContext getObject() {             return FacesContext.getCurrentInstance().         }          @Override         public String toString() {             return "Current JSF FacesContext".         }     }).     beanFactory.registerResolvableDependency(ExternalContext.class, new ObjectFactory<ExternalContext>() {          @Override         public ExternalContext getObject() {             return FacesContext.getCurrentInstance().getExternalContext().         }          @Override         public String toString() {             return "Current JSF ExternalContext".         }     }). }
