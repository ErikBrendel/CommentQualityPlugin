commented;modifiers;parameterAmount;loc;comment;code
true;public;1;13;/**  * Reads a remote invocation from the request, executes it,  * and writes the remote invocation result to the response.  * @see #readRemoteInvocation(HttpExchange)  * @see #invokeAndCreateResult(RemoteInvocation, Object)  * @see #writeRemoteInvocationResult(HttpExchange, RemoteInvocationResult)  */ ;/**  * Reads a remote invocation from the request, executes it,  * and writes the remote invocation result to the response.  * @see #readRemoteInvocation(HttpExchange)  * @see #invokeAndCreateResult(RemoteInvocation, Object)  * @see #writeRemoteInvocationResult(HttpExchange, RemoteInvocationResult)  */ @Override public void handle(HttpExchange exchange) throws IOException {     try {         RemoteInvocation invocation = readRemoteInvocation(exchange).         RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy()).         writeRemoteInvocationResult(exchange, result).         exchange.close().     } catch (ClassNotFoundException ex) {         exchange.sendResponseHeaders(500, -1).         logger.error("Class not found during deserialization", ex).     } }
true;protected;1;5;/**  * Read a RemoteInvocation from the given HTTP request.  * <p>Delegates to {@link #readRemoteInvocation(HttpExchange, InputStream)}  * with the {@link HttpExchange#getRequestBody()} request's input stream}.  * @param exchange current HTTP request/response  * @return the RemoteInvocation object  * @throws java.io.IOException in case of I/O failure  * @throws ClassNotFoundException if thrown by deserialization  */ ;/**  * Read a RemoteInvocation from the given HTTP request.  * <p>Delegates to {@link #readRemoteInvocation(HttpExchange, InputStream)}  * with the {@link HttpExchange#getRequestBody()} request's input stream}.  * @param exchange current HTTP request/response  * @return the RemoteInvocation object  * @throws java.io.IOException in case of I/O failure  * @throws ClassNotFoundException if thrown by deserialization  */ protected RemoteInvocation readRemoteInvocation(HttpExchange exchange) throws IOException, ClassNotFoundException {     return readRemoteInvocation(exchange, exchange.getRequestBody()). }
true;protected;2;6;/**  * Deserialize a RemoteInvocation object from the given InputStream.  * <p>Gives {@link #decorateInputStream} a chance to decorate the stream  * first (for example, for custom encryption or compression). Creates a  * {@link org.springframework.remoting.rmi.CodebaseAwareObjectInputStream}  * and calls {@link #doReadRemoteInvocation} to actually read the object.  * <p>Can be overridden for custom serialization of the invocation.  * @param exchange current HTTP request/response  * @param is the InputStream to read from  * @return the RemoteInvocation object  * @throws java.io.IOException in case of I/O failure  * @throws ClassNotFoundException if thrown during deserialization  */ ;/**  * Deserialize a RemoteInvocation object from the given InputStream.  * <p>Gives {@link #decorateInputStream} a chance to decorate the stream  * first (for example, for custom encryption or compression). Creates a  * {@link org.springframework.remoting.rmi.CodebaseAwareObjectInputStream}  * and calls {@link #doReadRemoteInvocation} to actually read the object.  * <p>Can be overridden for custom serialization of the invocation.  * @param exchange current HTTP request/response  * @param is the InputStream to read from  * @return the RemoteInvocation object  * @throws java.io.IOException in case of I/O failure  * @throws ClassNotFoundException if thrown during deserialization  */ protected RemoteInvocation readRemoteInvocation(HttpExchange exchange, InputStream is) throws IOException, ClassNotFoundException {     ObjectInputStream ois = createObjectInputStream(decorateInputStream(exchange, is)).     return doReadRemoteInvocation(ois). }
true;protected;2;3;/**  * Return the InputStream to use for reading remote invocations,  * potentially decorating the given original InputStream.  * <p>The default implementation returns the given stream as-is.  * Can be overridden, for example, for custom encryption or compression.  * @param exchange current HTTP request/response  * @param is the original InputStream  * @return the potentially decorated InputStream  * @throws java.io.IOException in case of I/O failure  */ ;/**  * Return the InputStream to use for reading remote invocations,  * potentially decorating the given original InputStream.  * <p>The default implementation returns the given stream as-is.  * Can be overridden, for example, for custom encryption or compression.  * @param exchange current HTTP request/response  * @param is the original InputStream  * @return the potentially decorated InputStream  * @throws java.io.IOException in case of I/O failure  */ protected InputStream decorateInputStream(HttpExchange exchange, InputStream is) throws IOException {     return is. }
true;protected;2;7;/**  * Write the given RemoteInvocationResult to the given HTTP response.  * @param exchange current HTTP request/response  * @param result the RemoteInvocationResult object  * @throws java.io.IOException in case of I/O failure  */ ;/**  * Write the given RemoteInvocationResult to the given HTTP response.  * @param exchange current HTTP request/response  * @param result the RemoteInvocationResult object  * @throws java.io.IOException in case of I/O failure  */ protected void writeRemoteInvocationResult(HttpExchange exchange, RemoteInvocationResult result) throws IOException {     exchange.getResponseHeaders().set("Content-Type", getContentType()).     exchange.sendResponseHeaders(200, 0).     writeRemoteInvocationResult(exchange, result, exchange.getResponseBody()). }
true;protected;3;7;/**  * Serialize the given RemoteInvocation to the given OutputStream.  * <p>The default implementation gives {@link #decorateOutputStream} a chance  * to decorate the stream first (for example, for custom encryption or compression).  * Creates an {@link java.io.ObjectOutputStream} for the final stream and calls  * {@link #doWriteRemoteInvocationResult} to actually write the object.  * <p>Can be overridden for custom serialization of the invocation.  * @param exchange current HTTP request/response  * @param result the RemoteInvocationResult object  * @param os the OutputStream to write to  * @throws java.io.IOException in case of I/O failure  * @see #decorateOutputStream  * @see #doWriteRemoteInvocationResult  */ ;/**  * Serialize the given RemoteInvocation to the given OutputStream.  * <p>The default implementation gives {@link #decorateOutputStream} a chance  * to decorate the stream first (for example, for custom encryption or compression).  * Creates an {@link java.io.ObjectOutputStream} for the final stream and calls  * {@link #doWriteRemoteInvocationResult} to actually write the object.  * <p>Can be overridden for custom serialization of the invocation.  * @param exchange current HTTP request/response  * @param result the RemoteInvocationResult object  * @param os the OutputStream to write to  * @throws java.io.IOException in case of I/O failure  * @see #decorateOutputStream  * @see #doWriteRemoteInvocationResult  */ protected void writeRemoteInvocationResult(HttpExchange exchange, RemoteInvocationResult result, OutputStream os) throws IOException {     ObjectOutputStream oos = createObjectOutputStream(decorateOutputStream(exchange, os)).     doWriteRemoteInvocationResult(result, oos).     oos.flush(). }
true;protected;2;3;/**  * Return the OutputStream to use for writing remote invocation results,  * potentially decorating the given original OutputStream.  * <p>The default implementation returns the given stream as-is.  * Can be overridden, for example, for custom encryption or compression.  * @param exchange current HTTP request/response  * @param os the original OutputStream  * @return the potentially decorated OutputStream  * @throws java.io.IOException in case of I/O failure  */ ;/**  * Return the OutputStream to use for writing remote invocation results,  * potentially decorating the given original OutputStream.  * <p>The default implementation returns the given stream as-is.  * Can be overridden, for example, for custom encryption or compression.  * @param exchange current HTTP request/response  * @param os the original OutputStream  * @return the potentially decorated OutputStream  * @throws java.io.IOException in case of I/O failure  */ protected OutputStream decorateOutputStream(HttpExchange exchange, OutputStream os) throws IOException {     return os. }
