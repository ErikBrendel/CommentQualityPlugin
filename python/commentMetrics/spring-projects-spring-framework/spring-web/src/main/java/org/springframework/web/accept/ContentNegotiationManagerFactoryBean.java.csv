commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the exact list of strategies to use.  * <p><strong>Note:</strong> use of this method is mutually exclusive with  * use of all other setters in this class which customize a default, fixed  * set of strategies. See class level doc for more details.  * @param strategies the strategies to use  * @since 5.0  */ ;/**  * Set the exact list of strategies to use.  * <p><strong>Note:</strong> use of this method is mutually exclusive with  * use of all other setters in this class which customize a default, fixed  * set of strategies. See class level doc for more details.  * @param strategies the strategies to use  * @since 5.0  */ public void setStrategies(@Nullable List<ContentNegotiationStrategy> strategies) {     this.strategies = (strategies != null ? new ArrayList<>(strategies) : null). }
true;public;1;3;/**  * Whether the path extension in the URL path should be used to determine  * the requested media type.  * <p>By default this is set to {@code true} in which case a request  * for {@code /hotels.pdf} will be interpreted as a request for  * {@code "application/pdf"} regardless of the 'Accept' header.  */ ;/**  * Whether the path extension in the URL path should be used to determine  * the requested media type.  * <p>By default this is set to {@code true} in which case a request  * for {@code /hotels.pdf} will be interpreted as a request for  * {@code "application/pdf"} regardless of the 'Accept' header.  */ public void setFavorPathExtension(boolean favorPathExtension) {     this.favorPathExtension = favorPathExtension. }
true;public;1;9;/**  * Add a mapping from a key, extracted from a path extension or a query  * parameter, to a MediaType. This is required in order for the parameter  * strategy to work. Any extensions explicitly registered here are also  * whitelisted for the purpose of Reflected File Download attack detection  * (see Spring Framework reference documentation for more details on RFD  * attack protection).  * <p>The path extension strategy will also try to use  * {@link ServletContext#getMimeType} and  * {@link org.springframework.http.MediaTypeFactory} to resolve path extensions.  * @param mediaTypes media type mappings  * @see #addMediaType(String, MediaType)  * @see #addMediaTypes(Map)  */ ;/**  * Add a mapping from a key, extracted from a path extension or a query  * parameter, to a MediaType. This is required in order for the parameter  * strategy to work. Any extensions explicitly registered here are also  * whitelisted for the purpose of Reflected File Download attack detection  * (see Spring Framework reference documentation for more details on RFD  * attack protection).  * <p>The path extension strategy will also try to use  * {@link ServletContext#getMimeType} and  * {@link org.springframework.http.MediaTypeFactory} to resolve path extensions.  * @param mediaTypes media type mappings  * @see #addMediaType(String, MediaType)  * @see #addMediaTypes(Map)  */ public void setMediaTypes(Properties mediaTypes) {     if (!CollectionUtils.isEmpty(mediaTypes)) {         mediaTypes.forEach((key, value) -> {             String extension = ((String) key).toLowerCase(Locale.ENGLISH).             MediaType mediaType = MediaType.valueOf((String) value).             this.mediaTypes.put(extension, mediaType).         }).     } }
true;public;2;3;/**  * An alternative to {@link #setMediaTypes} for use in Java code.  * @see #setMediaTypes  * @see #addMediaTypes  */ ;/**  * An alternative to {@link #setMediaTypes} for use in Java code.  * @see #setMediaTypes  * @see #addMediaTypes  */ public void addMediaType(String fileExtension, MediaType mediaType) {     this.mediaTypes.put(fileExtension, mediaType). }
true;public;1;5;/**  * An alternative to {@link #setMediaTypes} for use in Java code.  * @see #setMediaTypes  * @see #addMediaType  */ ;/**  * An alternative to {@link #setMediaTypes} for use in Java code.  * @see #setMediaTypes  * @see #addMediaType  */ public void addMediaTypes(@Nullable Map<String, MediaType> mediaTypes) {     if (mediaTypes != null) {         this.mediaTypes.putAll(mediaTypes).     } }
true;public;1;3;/**  * Whether to ignore requests with path extension that cannot be resolved  * to any media type. Setting this to {@code false} will result in an  * {@code HttpMediaTypeNotAcceptableException} if there is no match.  * <p>By default this is set to {@code true}.  */ ;/**  * Whether to ignore requests with path extension that cannot be resolved  * to any media type. Setting this to {@code false} will result in an  * {@code HttpMediaTypeNotAcceptableException} if there is no match.  * <p>By default this is set to {@code true}.  */ public void setIgnoreUnknownPathExtensions(boolean ignore) {     this.ignoreUnknownPathExtensions = ignore. }
true;public;1;4;/**  * Indicate whether to use the Java Activation Framework as a fallback option  * to map from file extensions to media types.  * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which  * has reverse behavior.  */ ;/**  * Indicate whether to use the Java Activation Framework as a fallback option  * to map from file extensions to media types.  * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which  * has reverse behavior.  */ @Deprecated public void setUseJaf(boolean useJaf) {     setUseRegisteredExtensionsOnly(!useJaf). }
true;public;1;3;/**  * When {@link #setFavorPathExtension favorPathExtension} or  * {@link #setFavorParameter(boolean)} is set, this property determines  * whether to use only registered {@code MediaType} mappings or to allow  * dynamic resolution, e.g. via {@link MediaTypeFactory}.  * <p>By default this is not set in which case dynamic resolution is on.  */ ;/**  * When {@link #setFavorPathExtension favorPathExtension} or  * {@link #setFavorParameter(boolean)} is set, this property determines  * whether to use only registered {@code MediaType} mappings or to allow  * dynamic resolution, e.g. via {@link MediaTypeFactory}.  * <p>By default this is not set in which case dynamic resolution is on.  */ public void setUseRegisteredExtensionsOnly(boolean useRegisteredExtensionsOnly) {     this.useRegisteredExtensionsOnly = useRegisteredExtensionsOnly. }
false;private;0;3;;private boolean useRegisteredExtensionsOnly() {     return (this.useRegisteredExtensionsOnly != null && this.useRegisteredExtensionsOnly). }
true;public;1;3;/**  * Whether a request parameter ("format" by default) should be used to  * determine the requested media type. For this option to work you must  * register {@link #setMediaTypes media type mappings}.  * <p>By default this is set to {@code false}.  * @see #setParameterName  */ ;/**  * Whether a request parameter ("format" by default) should be used to  * determine the requested media type. For this option to work you must  * register {@link #setMediaTypes media type mappings}.  * <p>By default this is set to {@code false}.  * @see #setParameterName  */ public void setFavorParameter(boolean favorParameter) {     this.favorParameter = favorParameter. }
true;public;1;4;/**  * Set the query parameter name to use when {@link #setFavorParameter} is on.  * <p>The default parameter name is {@code "format"}.  */ ;/**  * Set the query parameter name to use when {@link #setFavorParameter} is on.  * <p>The default parameter name is {@code "format"}.  */ public void setParameterName(String parameterName) {     Assert.notNull(parameterName, "parameterName is required").     this.parameterName = parameterName. }
true;public;1;3;/**  * Whether to disable checking the 'Accept' request header.  * <p>By default this value is set to {@code false}.  */ ;/**  * Whether to disable checking the 'Accept' request header.  * <p>By default this value is set to {@code false}.  */ public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader) {     this.ignoreAcceptHeader = ignoreAcceptHeader. }
true;public;1;3;/**  * Set the default content type to use when no content type is requested.  * <p>By default this is not set.  * @see #setDefaultContentTypeStrategy  */ ;/**  * Set the default content type to use when no content type is requested.  * <p>By default this is not set.  * @see #setDefaultContentTypeStrategy  */ public void setDefaultContentType(MediaType contentType) {     this.defaultNegotiationStrategy = new FixedContentNegotiationStrategy(contentType). }
true;public;1;3;/**  * Set the default content types to use when no content type is requested.  * <p>By default this is not set.  * @since 5.0  * @see #setDefaultContentTypeStrategy  */ ;/**  * Set the default content types to use when no content type is requested.  * <p>By default this is not set.  * @since 5.0  * @see #setDefaultContentTypeStrategy  */ public void setDefaultContentTypes(List<MediaType> contentTypes) {     this.defaultNegotiationStrategy = new FixedContentNegotiationStrategy(contentTypes). }
true;public;1;3;/**  * Set a custom {@link ContentNegotiationStrategy} to use to determine  * the content type to use when no content type is requested.  * <p>By default this is not set.  * @since 4.1.2  * @see #setDefaultContentType  */ ;/**  * Set a custom {@link ContentNegotiationStrategy} to use to determine  * the content type to use when no content type is requested.  * <p>By default this is not set.  * @since 4.1.2  * @see #setDefaultContentType  */ public void setDefaultContentTypeStrategy(ContentNegotiationStrategy strategy) {     this.defaultNegotiationStrategy = strategy. }
true;public;1;4;/**  * Invoked by Spring to inject the ServletContext.  */ ;/**  * Invoked by Spring to inject the ServletContext.  */ @Override public void setServletContext(ServletContext servletContext) {     this.servletContext = servletContext. }
false;public;0;4;;@Override public void afterPropertiesSet() {     build(). }
true;public;0;46;/**  * Actually build the {@link ContentNegotiationManager}.  * @since 5.0  */ ;/**  * Actually build the {@link ContentNegotiationManager}.  * @since 5.0  */ public ContentNegotiationManager build() {     List<ContentNegotiationStrategy> strategies = new ArrayList<>().     if (this.strategies != null) {         strategies.addAll(this.strategies).     } else {         if (this.favorPathExtension) {             PathExtensionContentNegotiationStrategy strategy.             if (this.servletContext != null && !useRegisteredExtensionsOnly()) {                 strategy = new ServletPathExtensionContentNegotiationStrategy(this.servletContext, this.mediaTypes).             } else {                 strategy = new PathExtensionContentNegotiationStrategy(this.mediaTypes).             }             strategy.setIgnoreUnknownExtensions(this.ignoreUnknownPathExtensions).             if (this.useRegisteredExtensionsOnly != null) {                 strategy.setUseRegisteredExtensionsOnly(this.useRegisteredExtensionsOnly).             }             strategies.add(strategy).         }         if (this.favorParameter) {             ParameterContentNegotiationStrategy strategy = new ParameterContentNegotiationStrategy(this.mediaTypes).             strategy.setParameterName(this.parameterName).             if (this.useRegisteredExtensionsOnly != null) {                 strategy.setUseRegisteredExtensionsOnly(this.useRegisteredExtensionsOnly).             } else {                 // backwards compatibility                 strategy.setUseRegisteredExtensionsOnly(true).             }             strategies.add(strategy).         }         if (!this.ignoreAcceptHeader) {             strategies.add(new HeaderContentNegotiationStrategy()).         }         if (this.defaultNegotiationStrategy != null) {             strategies.add(this.defaultNegotiationStrategy).         }     }     this.contentNegotiationManager = new ContentNegotiationManager(strategies).     return this.contentNegotiationManager. }
false;public;0;5;;@Override @Nullable public ContentNegotiationManager getObject() {     return this.contentNegotiationManager. }
false;public;0;4;;@Override public Class<?> getObjectType() {     return ContentNegotiationManager.class. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
