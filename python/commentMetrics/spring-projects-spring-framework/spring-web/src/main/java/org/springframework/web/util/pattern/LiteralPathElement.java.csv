commented;modifiers;parameterAmount;loc;comment;code
false;public;2;54;;@Override public boolean matches(int pathIndex, MatchingContext matchingContext) {     if (pathIndex >= matchingContext.pathLength) {         // no more path left to match this element         return false.     }     Element element = matchingContext.pathElements.get(pathIndex).     if (!(element instanceof PathContainer.PathSegment)) {         return false.     }     String value = ((PathSegment) element).valueToMatch().     if (value.length() != this.len) {         // Not enough data to match this path element         return false.     }     char[] data = ((PathContainer.PathSegment) element).valueToMatchAsChars().     if (this.caseSensitive) {         for (int i = 0. i < this.len. i++) {             if (data[i] != this.text[i]) {                 return false.             }         }     } else {         for (int i = 0. i < this.len. i++) {             // TODO revisit performance if doing a lot of case insensitive matching             if (Character.toLowerCase(data[i]) != this.text[i]) {                 return false.             }         }     }     pathIndex++.     if (isNoMorePattern()) {         if (matchingContext.determineRemainingPath) {             matchingContext.remainingPathIndex = pathIndex.             return true.         } else {             if (pathIndex == matchingContext.pathLength) {                 return true.             } else {                 return (matchingContext.isMatchOptionalTrailingSeparator() && (pathIndex + 1) == matchingContext.pathLength && matchingContext.isSeparator(pathIndex)).             }         }     } else {         return (this.next != null && this.next.matches(pathIndex, matchingContext)).     } }
false;public;0;4;;@Override public int getNormalizedLength() {     return this.len. }
false;public;0;3;;public char[] getChars() {     return this.text. }
false;public;0;3;;public String toString() {     return "Literal(" + String.valueOf(this.text) + ")". }
