commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Sets the default {@code Content-Type} to be used for writing.  * @throws IllegalArgumentException if the given content type is not supported by the Java Image I/O API  */ ;/**  * Sets the default {@code Content-Type} to be used for writing.  * @throws IllegalArgumentException if the given content type is not supported by the Java Image I/O API  */ public void setDefaultContentType(@Nullable MediaType defaultContentType) {     if (defaultContentType != null) {         Iterator<ImageWriter> imageWriters = ImageIO.getImageWritersByMIMEType(defaultContentType.toString()).         if (!imageWriters.hasNext()) {             throw new IllegalArgumentException("Content-Type [" + defaultContentType + "] is not supported by the Java Image I/O API").         }     }     this.defaultContentType = defaultContentType. }
true;public;0;4;/**  * Returns the default {@code Content-Type} to be used for writing.  * Called when {@link #write} is invoked without a specified content type parameter.  */ ;/**  * Returns the default {@code Content-Type} to be used for writing.  * Called when {@link #write} is invoked without a specified content type parameter.  */ @Nullable public MediaType getDefaultContentType() {     return this.defaultContentType. }
true;public;1;5;/**  * Sets the cache directory. If this property is set to an existing directory,  * this converter will cache image data.  */ ;/**  * Sets the cache directory. If this property is set to an existing directory,  * this converter will cache image data.  */ public void setCacheDir(File cacheDir) {     Assert.notNull(cacheDir, "'cacheDir' must not be null").     Assert.isTrue(cacheDir.isDirectory(), "'cacheDir' is not a directory").     this.cacheDir = cacheDir. }
false;public;2;4;;@Override public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {     return (BufferedImage.class == clazz && isReadable(mediaType)). }
false;private;1;7;;private boolean isReadable(@Nullable MediaType mediaType) {     if (mediaType == null) {         return true.     }     Iterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(mediaType.toString()).     return imageReaders.hasNext(). }
false;public;2;4;;@Override public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {     return (BufferedImage.class == clazz && isWritable(mediaType)). }
false;private;1;7;;private boolean isWritable(@Nullable MediaType mediaType) {     if (mediaType == null || MediaType.ALL.equalsTypeAndSubtype(mediaType)) {         return true.     }     Iterator<ImageWriter> imageWriters = ImageIO.getImageWritersByMIMEType(mediaType.toString()).     return imageWriters.hasNext(). }
false;public;0;4;;@Override public List<MediaType> getSupportedMediaTypes() {     return Collections.unmodifiableList(this.readableMediaTypes). }
false;public;2;40;;@Override public BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {     ImageInputStream imageInputStream = null.     ImageReader imageReader = null.     try {         imageInputStream = createImageInputStream(inputMessage.getBody()).         MediaType contentType = inputMessage.getHeaders().getContentType().         if (contentType == null) {             throw new HttpMessageNotReadableException("No Content-Type header", inputMessage).         }         Iterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(contentType.toString()).         if (imageReaders.hasNext()) {             imageReader = imageReaders.next().             ImageReadParam irp = imageReader.getDefaultReadParam().             process(irp).             imageReader.setInput(imageInputStream, true).             return imageReader.read(0, irp).         } else {             throw new HttpMessageNotReadableException("Could not find javax.imageio.ImageReader for Content-Type [" + contentType + "]", inputMessage).         }     } finally {         if (imageReader != null) {             imageReader.dispose().         }         if (imageInputStream != null) {             try {                 imageInputStream.close().             } catch (IOException ex) {             // ignore             }         }     } }
false;private;1;8;;private ImageInputStream createImageInputStream(InputStream is) throws IOException {     if (this.cacheDir != null) {         return new FileCacheImageInputStream(is, this.cacheDir).     } else {         return new MemoryCacheImageInputStream(is).     } }
false;public;3;16;;@Override public void write(final BufferedImage image, @Nullable final MediaType contentType, final HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {     final MediaType selectedContentType = getContentType(contentType).     outputMessage.getHeaders().setContentType(selectedContentType).     if (outputMessage instanceof StreamingHttpOutputMessage) {         StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) outputMessage.         streamingOutputMessage.setBody(outputStream -> writeInternal(image, selectedContentType, outputStream)).     } else {         writeInternal(image, selectedContentType, outputMessage.getBody()).     } }
false;private;1;8;;private MediaType getContentType(@Nullable MediaType contentType) {     if (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {         contentType = getDefaultContentType().     }     Assert.notNull(contentType, "Could not select Content-Type. " + "Please specify one through the 'defaultContentType' property.").     return contentType. }
false;private;3;34;;private void writeInternal(BufferedImage image, MediaType contentType, OutputStream body) throws IOException, HttpMessageNotWritableException {     ImageOutputStream imageOutputStream = null.     ImageWriter imageWriter = null.     try {         Iterator<ImageWriter> imageWriters = ImageIO.getImageWritersByMIMEType(contentType.toString()).         if (imageWriters.hasNext()) {             imageWriter = imageWriters.next().             ImageWriteParam iwp = imageWriter.getDefaultWriteParam().             process(iwp).             imageOutputStream = createImageOutputStream(body).             imageWriter.setOutput(imageOutputStream).             imageWriter.write(null, new IIOImage(image, null, null), iwp).         } else {             throw new HttpMessageNotWritableException("Could not find javax.imageio.ImageWriter for Content-Type [" + contentType + "]").         }     } finally {         if (imageWriter != null) {             imageWriter.dispose().         }         if (imageOutputStream != null) {             try {                 imageOutputStream.close().             } catch (IOException ex) {             // ignore             }         }     } }
false;private;1;8;;private ImageOutputStream createImageOutputStream(OutputStream os) throws IOException {     if (this.cacheDir != null) {         return new FileCacheImageOutputStream(os, this.cacheDir).     } else {         return new MemoryCacheImageOutputStream(os).     } }
true;protected;1;2;/**  * Template method that allows for manipulating the {@link ImageReadParam}  * before it is used to read an image.  * <p>The default implementation is empty.  */ ;/**  * Template method that allows for manipulating the {@link ImageReadParam}  * before it is used to read an image.  * <p>The default implementation is empty.  */ protected void process(ImageReadParam irp) { }
true;protected;1;2;/**  * Template method that allows for manipulating the {@link ImageWriteParam}  * before it is used to write an image.  * <p>The default implementation is empty.  */ ;/**  * Template method that allows for manipulating the {@link ImageWriteParam}  * before it is used to write an image.  * <p>The default implementation is empty.  */ protected void process(ImageWriteParam iwp) { }
