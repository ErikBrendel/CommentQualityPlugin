commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Configure a custom {@link WebSessionManager} to use for managing web  * sessions. The provided instance is set on each created  * {@link DefaultServerWebExchange}.  * <p>By default this is set to {@link DefaultWebSessionManager}.  * @param sessionManager the session manager to use  */ ;/**  * Configure a custom {@link WebSessionManager} to use for managing web  * sessions. The provided instance is set on each created  * {@link DefaultServerWebExchange}.  * <p>By default this is set to {@link DefaultWebSessionManager}.  * @param sessionManager the session manager to use  */ public void setSessionManager(WebSessionManager sessionManager) {     Assert.notNull(sessionManager, "WebSessionManager must not be null").     this.sessionManager = sessionManager. }
true;public;0;3;/**  * Return the configured {@link WebSessionManager}.  */ ;/**  * Return the configured {@link WebSessionManager}.  */ public WebSessionManager getSessionManager() {     return this.sessionManager. }
true;public;1;13;/**  * Configure a custom {@link ServerCodecConfigurer}. The provided instance is set on  * each created {@link DefaultServerWebExchange}.  * <p>By default this is set to {@link ServerCodecConfigurer#create()}.  * @param codecConfigurer the codec configurer to use  */ ;/**  * Configure a custom {@link ServerCodecConfigurer}. The provided instance is set on  * each created {@link DefaultServerWebExchange}.  * <p>By default this is set to {@link ServerCodecConfigurer#create()}.  * @param codecConfigurer the codec configurer to use  */ public void setCodecConfigurer(ServerCodecConfigurer codecConfigurer) {     Assert.notNull(codecConfigurer, "ServerCodecConfigurer is required").     this.codecConfigurer = codecConfigurer.     this.enableLoggingRequestDetails = false.     this.codecConfigurer.getReaders().stream().filter(LoggingCodecSupport.class::isInstance).forEach(reader -> {         if (((LoggingCodecSupport) reader).isEnableLoggingRequestDetails()) {             this.enableLoggingRequestDetails = true.         }     }). }
true;public;0;3;/**  * Return the configured {@link ServerCodecConfigurer}.  */ ;/**  * Return the configured {@link ServerCodecConfigurer}.  */ public ServerCodecConfigurer getCodecConfigurer() {     return this.codecConfigurer. }
true;public;1;4;/**  * Configure a custom {@link LocaleContextResolver}. The provided instance is set on  * each created {@link DefaultServerWebExchange}.  * <p>By default this is set to  * {@link org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver}.  * @param resolver the locale context resolver to use  */ ;/**  * Configure a custom {@link LocaleContextResolver}. The provided instance is set on  * each created {@link DefaultServerWebExchange}.  * <p>By default this is set to  * {@link org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver}.  * @param resolver the locale context resolver to use  */ public void setLocaleContextResolver(LocaleContextResolver resolver) {     Assert.notNull(resolver, "LocaleContextResolver is required").     this.localeContextResolver = resolver. }
true;public;0;3;/**  * Return the configured {@link LocaleContextResolver}.  */ ;/**  * Return the configured {@link LocaleContextResolver}.  */ public LocaleContextResolver getLocaleContextResolver() {     return this.localeContextResolver. }
true;public;1;4;/**  * Enable processing of forwarded headers, either extracting and removing,  * or remove only.  * <p>By default this is not set.  * @param transformer the transformer to use  * @since 5.1  */ ;/**  * Enable processing of forwarded headers, either extracting and removing,  * or remove only.  * <p>By default this is not set.  * @param transformer the transformer to use  * @since 5.1  */ public void setForwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {     Assert.notNull(transformer, "ForwardedHeaderTransformer is required").     this.forwardedHeaderTransformer = transformer. }
true;public;0;4;/**  * Return the configured {@link ForwardedHeaderTransformer}.  * @since 5.1  */ ;/**  * Return the configured {@link ForwardedHeaderTransformer}.  * @since 5.1  */ @Nullable public ForwardedHeaderTransformer getForwardedHeaderTransformer() {     return this.forwardedHeaderTransformer. }
true;public;1;3;/**  * Configure the {@code ApplicationContext} associated with the web application,  * if it was initialized with one via  * {@link org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(ApplicationContext)}.  * @param applicationContext the context  * @since 5.0.3  */ ;/**  * Configure the {@code ApplicationContext} associated with the web application,  * if it was initialized with one via  * {@link org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(ApplicationContext)}.  * @param applicationContext the context  * @since 5.0.3  */ public void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
true;public;0;4;/**  * Return the configured {@code ApplicationContext}, if any.  * @since 5.0.3  */ ;/**  * Return the configured {@code ApplicationContext}, if any.  * @since 5.0.3  */ @Nullable public ApplicationContext getApplicationContext() {     return this.applicationContext. }
true;public;0;9;/**  * This method must be invoked after all properties have been set to  * complete initialization.  */ ;/**  * This method must be invoked after all properties have been set to  * complete initialization.  */ public void afterPropertiesSet() {     if (logger.isDebugEnabled()) {         String value = this.enableLoggingRequestDetails ? "shown which may lead to unsafe logging of potentially sensitive data" : "masked to prevent unsafe logging of potentially sensitive data".         logger.debug("enableLoggingRequestDetails='" + this.enableLoggingRequestDetails + "': form data and headers will be " + value).     } }
false;public;2;16;;@Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {     if (this.forwardedHeaderTransformer != null) {         request = this.forwardedHeaderTransformer.apply(request).     }     ServerWebExchange exchange = createExchange(request, response).     LogFormatUtils.traceDebug(logger, traceOn -> exchange.getLogPrefix() + formatRequest(exchange.getRequest()) + (traceOn ? ", headers=" + formatHeaders(exchange.getRequest().getHeaders()) : "")).     return getDelegate().handle(exchange).doOnSuccess(aVoid -> logResponse(exchange)).onErrorResume(ex -> handleUnresolvedError(exchange, ex)).then(Mono.defer(response::setComplete)). }
false;protected;2;4;;protected ServerWebExchange createExchange(ServerHttpRequest request, ServerHttpResponse response) {     return new DefaultServerWebExchange(request, response, this.sessionManager, getCodecConfigurer(), getLocaleContextResolver(), this.applicationContext). }
false;private;1;5;;private String formatRequest(ServerHttpRequest request) {     String rawQuery = request.getURI().getRawQuery().     String query = StringUtils.hasText(rawQuery) ? "?" + rawQuery : "".     return "HTTP " + request.getMethod() + " \"" + request.getPath() + query + "\"". }
false;private;1;7;;private void logResponse(ServerWebExchange exchange) {     LogFormatUtils.traceDebug(logger, traceOn -> {         HttpStatus status = exchange.getResponse().getStatusCode().         return exchange.getLogPrefix() + "Completed " + (status != null ? status : "200 OK") + (traceOn ? ", headers=" + formatHeaders(exchange.getResponse().getHeaders()) : "").     }). }
false;private;1;4;;private String formatHeaders(HttpHeaders responseHeaders) {     return this.enableLoggingRequestDetails ? responseHeaders.toString() : responseHeaders.isEmpty() ? "{}" : "{masked}". }
false;private;2;26;;private Mono<Void> handleUnresolvedError(ServerWebExchange exchange, Throwable ex) {     ServerHttpRequest request = exchange.getRequest().     ServerHttpResponse response = exchange.getResponse().     String logPrefix = exchange.getLogPrefix().     if (isDisconnectedClientError(ex)) {         if (lostClientLogger.isTraceEnabled()) {             lostClientLogger.trace(logPrefix + "Client went away", ex).         } else if (lostClientLogger.isDebugEnabled()) {             lostClientLogger.debug(logPrefix + "Client went away: " + ex + " (stacktrace at TRACE level for '" + DISCONNECTED_CLIENT_LOG_CATEGORY + "')").         }         return Mono.empty().     } else if (response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR)) {         logger.error(logPrefix + "500 Server Error for " + formatRequest(request), ex).         return Mono.empty().     } else {         // After the response is committed, propagate errors to the server...         logger.error(logPrefix + "Error [" + ex + "] for " + formatRequest(request) + ", but ServerHttpResponse already committed (" + response.getStatusCode() + ")").         return Mono.error(ex).     } }
false;private;1;7;;private boolean isDisconnectedClientError(Throwable ex) {     String message = NestedExceptionUtils.getMostSpecificCause(ex).getMessage().     if (message != null && message.toLowerCase().contains("broken pipe")) {         return true.     }     return DISCONNECTED_CLIENT_EXCEPTIONS.contains(ex.getClass().getSimpleName()). }
