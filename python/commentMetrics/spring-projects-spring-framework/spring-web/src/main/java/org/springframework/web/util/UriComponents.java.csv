commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;4;/**  * Return the scheme. Can be {@code null}.  */ ;// Component getters /**  * Return the scheme. Can be {@code null}.  */ @Nullable public final String getScheme() {     return this.scheme. }
true;public,final;0;4;/**  * Return the fragment. Can be {@code null}.  */ ;/**  * Return the fragment. Can be {@code null}.  */ @Nullable public final String getFragment() {     return this.fragment. }
true;public,abstract;0;2;/**  * Return the scheme specific part. Can be {@code null}.  */ ;/**  * Return the scheme specific part. Can be {@code null}.  */ @Nullable public abstract String getSchemeSpecificPart().
true;public,abstract;0;2;/**  * Return the user info. Can be {@code null}.  */ ;/**  * Return the user info. Can be {@code null}.  */ @Nullable public abstract String getUserInfo().
true;public,abstract;0;2;/**  * Return the host. Can be {@code null}.  */ ;/**  * Return the host. Can be {@code null}.  */ @Nullable public abstract String getHost().
true;public,abstract;0;1;/**  * Return the port. {@code -1} if no port has been set.  */ ;/**  * Return the port. {@code -1} if no port has been set.  */ public abstract int getPort().
true;public,abstract;0;2;/**  * Return the path. Can be {@code null}.  */ ;/**  * Return the path. Can be {@code null}.  */ @Nullable public abstract String getPath().
true;public,abstract;0;1;/**  * Return the list of path segments. Empty if no path has been set.  */ ;/**  * Return the list of path segments. Empty if no path has been set.  */ public abstract List<String> getPathSegments().
true;public,abstract;0;2;/**  * Return the query. Can be {@code null}.  */ ;/**  * Return the query. Can be {@code null}.  */ @Nullable public abstract String getQuery().
true;public,abstract;0;1;/**  * Return the map of query parameters. Empty if no query has been set.  */ ;/**  * Return the map of query parameters. Empty if no query has been set.  */ public abstract MultiValueMap<String, String> getQueryParams().
true;public,final;0;3;/**  * Invoke this <em>after</em> expanding URI variables to encode the  * resulting URI component values.  * <p>In comparison to {@link UriComponentsBuilder#encode()}, this method  * <em>only</em> replaces non-ASCII and illegal (within a given URI  * component type) characters, but not characters with reserved meaning.  * For most cases, {@link UriComponentsBuilder#encode()} is more likely  * to give the expected result.  * @see UriComponentsBuilder#encode()  */ ;/**  * Invoke this <em>after</em> expanding URI variables to encode the  * resulting URI component values.  * <p>In comparison to {@link UriComponentsBuilder#encode()}, this method  * <em>only</em> replaces non-ASCII and illegal (within a given URI  * component type) characters, but not characters with reserved meaning.  * For most cases, {@link UriComponentsBuilder#encode()} is more likely  * to give the expected result.  * @see UriComponentsBuilder#encode()  */ public final UriComponents encode() {     return encode(StandardCharsets.UTF_8). }
true;public,abstract;1;1;/**  * A variant of {@link #encode()} with a charset other than "UTF-8".  * @param charset the charset to use for encoding  * @see UriComponentsBuilder#encode(Charset)  */ ;/**  * A variant of {@link #encode()} with a charset other than "UTF-8".  * @param charset the charset to use for encoding  * @see UriComponentsBuilder#encode(Charset)  */ public abstract UriComponents encode(Charset charset).
true;public,final;1;4;/**  * Replace all URI template variables with the values from a given map.  * <p>The given map keys represent variable names. the corresponding values  * represent variable values. The order of variables is not significant.  * @param uriVariables the map of URI variables  * @return the expanded URI components  */ ;/**  * Replace all URI template variables with the values from a given map.  * <p>The given map keys represent variable names. the corresponding values  * represent variable values. The order of variables is not significant.  * @param uriVariables the map of URI variables  * @return the expanded URI components  */ public final UriComponents expand(Map<String, ?> uriVariables) {     Assert.notNull(uriVariables, "'uriVariables' must not be null").     return expandInternal(new MapTemplateVariables(uriVariables)). }
true;public,final;1;4;/**  * Replace all URI template variables with the values from a given array.  * <p>The given array represents variable values. The order of variables is significant.  * @param uriVariableValues the URI variable values  * @return the expanded URI components  */ ;/**  * Replace all URI template variables with the values from a given array.  * <p>The given array represents variable values. The order of variables is significant.  * @param uriVariableValues the URI variable values  * @return the expanded URI components  */ public final UriComponents expand(Object... uriVariableValues) {     Assert.notNull(uriVariableValues, "'uriVariableValues' must not be null").     return expandInternal(new VarArgsTemplateVariables(uriVariableValues)). }
true;public,final;1;4;/**  * Replace all URI template variables with the values from the given  * {@link UriTemplateVariables}.  * @param uriVariables the URI template values  * @return the expanded URI components  */ ;/**  * Replace all URI template variables with the values from the given  * {@link UriTemplateVariables}.  * @param uriVariables the URI template values  * @return the expanded URI components  */ public final UriComponents expand(UriTemplateVariables uriVariables) {     Assert.notNull(uriVariables, "'uriVariables' must not be null").     return expandInternal(uriVariables). }
true;abstract;1;1;/**  * Replace all URI template variables with the values from the given {@link  * UriTemplateVariables}.  * @param uriVariables the URI template values  * @return the expanded URI components  */ ;/**  * Replace all URI template variables with the values from the given {@link  * UriTemplateVariables}.  * @param uriVariables the URI template values  * @return the expanded URI components  */ abstract UriComponents expandInternal(UriTemplateVariables uriVariables).
true;public,abstract;0;1;/**  * Normalize the path removing sequences like "path/..". Note that  * normalization is applied to the full path, and not to individual path  * segments.  * @see org.springframework.util.StringUtils#cleanPath(String)  */ ;/**  * Normalize the path removing sequences like "path/..". Note that  * normalization is applied to the full path, and not to individual path  * segments.  * @see org.springframework.util.StringUtils#cleanPath(String)  */ public abstract UriComponents normalize().
true;public,abstract;0;1;/**  * Concatenate all URI components to return the fully formed URI String.  * <p>This method does nothing more than a simple concatenation based on  * current values. That means it could produce different results if invoked  * before vs after methods that can change individual values such as  * {@code encode}, {@code expand}, or {@code normalize}.  */ ;/**  * Concatenate all URI components to return the fully formed URI String.  * <p>This method does nothing more than a simple concatenation based on  * current values. That means it could produce different results if invoked  * before vs after methods that can change individual values such as  * {@code encode}, {@code expand}, or {@code normalize}.  */ public abstract String toUriString().
true;public,abstract;0;1;/**  * Create a {@link URI} from this instance as follows:  * <p>If the current instance is {@link #encode() encoded}, form the full  * URI String via {@link #toUriString()}, and then pass it to the single  * argument {@link URI} constructor which preserves percent encoding.  * <p>If not yet encoded, pass individual URI component values to the  * multi-argument {@link URI} constructor which quotes illegal characters  * that cannot appear in their respective URI component.  */ ;/**  * Create a {@link URI} from this instance as follows:  * <p>If the current instance is {@link #encode() encoded}, form the full  * URI String via {@link #toUriString()}, and then pass it to the single  * argument {@link URI} constructor which preserves percent encoding.  * <p>If not yet encoded, pass individual URI component values to the  * multi-argument {@link URI} constructor which quotes illegal characters  * that cannot appear in their respective URI component.  */ public abstract URI toUri().
true;public,final;0;4;/**  * A simple pass-through to {@link #toUriString()}.  */ ;/**  * A simple pass-through to {@link #toUriString()}.  */ @Override public final String toString() {     return toUriString(). }
true;protected,abstract;1;1;/**  * Set all components of the given UriComponentsBuilder.  * @since 4.2  */ ;/**  * Set all components of the given UriComponentsBuilder.  * @since 4.2  */ protected abstract void copyToUriComponentsBuilder(UriComponentsBuilder builder).
false;static;2;4;;// Static expansion helpers @Nullable static String expandUriComponent(@Nullable String source, UriTemplateVariables uriVariables) {     return expandUriComponent(source, uriVariables, null). }
false;static;3;29;;@Nullable static String expandUriComponent(@Nullable String source, UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {     if (source == null) {         return null.     }     if (source.indexOf('{') == -1) {         return source.     }     if (source.indexOf(':') != -1) {         source = sanitizeSource(source).     }     Matcher matcher = NAMES_PATTERN.matcher(source).     StringBuffer sb = new StringBuffer().     while (matcher.find()) {         String match = matcher.group(1).         String varName = getVariableName(match).         Object varValue = uriVariables.getValue(varName).         if (UriTemplateVariables.SKIP_VALUE.equals(varValue)) {             continue.         }         String formatted = getVariableValueAsString(varValue).         formatted = encoder != null ? encoder.apply(formatted) : Matcher.quoteReplacement(formatted).         matcher.appendReplacement(sb, formatted).     }     matcher.appendTail(sb).     return sb.toString(). }
true;private,static;1;17;/**  * Remove nested "{}" such as in URI vars with regular expressions.  */ ;/**  * Remove nested "{}" such as in URI vars with regular expressions.  */ private static String sanitizeSource(String source) {     int level = 0.     StringBuilder sb = new StringBuilder().     for (char c : source.toCharArray()) {         if (c == '{') {             level++.         }         if (c == '}') {             level--.         }         if (level > 1 || (level == 1 && c == '}')) {             continue.         }         sb.append(c).     }     return sb.toString(). }
false;private,static;1;4;;private static String getVariableName(String match) {     int colonIdx = match.indexOf(':').     return (colonIdx != -1 ? match.substring(0, colonIdx) : match). }
false;private,static;1;3;;private static String getVariableValueAsString(@Nullable Object variableValue) {     return (variableValue != null ? variableValue.toString() : ""). }
true;;1;2;/**  * Get the value for the given URI variable name.  * If the value is {@code null}, an empty String is expanded.  * If the value is {@link #SKIP_VALUE}, the URI variable is not expanded.  * @param name the variable name  * @return the variable value, possibly {@code null} or {@link #SKIP_VALUE}  */ ;/**  * Get the value for the given URI variable name.  * If the value is {@code null}, an empty String is expanded.  * If the value is {@link #SKIP_VALUE}, the URI variable is not expanded.  * @param name the variable name  * @return the variable value, possibly {@code null} or {@link #SKIP_VALUE}  */ @Nullable Object getValue(@Nullable String name).
false;public;1;8;;@Override @Nullable public Object getValue(@Nullable String name) {     if (!this.uriVariables.containsKey(name)) {         throw new IllegalArgumentException("Map has no value for '" + name + "'").     }     return this.uriVariables.get(name). }
false;public;1;8;;@Override @Nullable public Object getValue(@Nullable String name) {     if (!this.valueIterator.hasNext()) {         throw new IllegalArgumentException("Not enough variable values available to expand '" + name + "'").     }     return this.valueIterator.next(). }
