commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether to expose the LocaleContext and RequestAttributes as inheritable  * for child threads (using an {@link java.lang.InheritableThreadLocal}).  * <p>Default is "false", to avoid side effects on spawned background threads.  * Switch this to "true" to enable inheritance for custom child threads which  * are spawned during request processing and only used for this request  * (that is, ending after their initial task, without reuse of the thread).  * <p><b>WARNING:</b> Do not use inheritance for child threads if you are  * accessing a thread pool which is configured to potentially add new threads  * on demand (e.g. a JDK {@link java.util.concurrent.ThreadPoolExecutor}),  * since this will expose the inherited context to such a pooled thread.  */ ;/**  * Set whether to expose the LocaleContext and RequestAttributes as inheritable  * for child threads (using an {@link java.lang.InheritableThreadLocal}).  * <p>Default is "false", to avoid side effects on spawned background threads.  * Switch this to "true" to enable inheritance for custom child threads which  * are spawned during request processing and only used for this request  * (that is, ending after their initial task, without reuse of the thread).  * <p><b>WARNING:</b> Do not use inheritance for child threads if you are  * accessing a thread pool which is configured to potentially add new threads  * on demand (e.g. a JDK {@link java.util.concurrent.ThreadPoolExecutor}),  * since this will expose the inherited context to such a pooled thread.  */ public void setThreadContextInheritable(boolean threadContextInheritable) {     this.threadContextInheritable = threadContextInheritable. }
true;protected;0;4;/**  * Returns "false" so that the filter may set up the request context in each  * asynchronously dispatched thread.  */ ;/**  * Returns "false" so that the filter may set up the request context in each  * asynchronously dispatched thread.  */ @Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
true;protected;0;4;/**  * Returns "false" so that the filter may set up the request context in an  * error dispatch.  */ ;/**  * Returns "false" so that the filter may set up the request context in an  * error dispatch.  */ @Override protected boolean shouldNotFilterErrorDispatch() {     return false. }
false;protected;3;19;;@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     ServletRequestAttributes attributes = new ServletRequestAttributes(request, response).     initContextHolders(request, attributes).     try {         filterChain.doFilter(request, response).     } finally {         resetContextHolders().         if (logger.isTraceEnabled()) {             logger.trace("Cleared thread-bound request context: " + request).         }         attributes.requestCompleted().     } }
false;private;2;7;;private void initContextHolders(HttpServletRequest request, ServletRequestAttributes requestAttributes) {     LocaleContextHolder.setLocale(request.getLocale(), this.threadContextInheritable).     RequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable).     if (logger.isTraceEnabled()) {         logger.trace("Bound request context to thread: " + request).     } }
false;private;0;4;;private void resetContextHolders() {     LocaleContextHolder.resetLocaleContext().     RequestContextHolder.resetRequestAttributes(). }
