commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the codebase URL to download classes from if not found locally.  * Can consists of multiple URLs, separated by spaces.  * <p>Follows RMI's codebase conventions for dynamic class download.  * In contrast to RMI, where the server determines the URL for class download  * (via the "java.rmi.server.codebase" system property), it's the client  * that determines the codebase URL here. The server will usually be the  * same as for the service URL, just pointing to a different path there.  * @see #setServiceUrl  * @see org.springframework.remoting.rmi.CodebaseAwareObjectInputStream  * @see java.rmi.server.RMIClassLoader  */ ;/**  * Set the codebase URL to download classes from if not found locally.  * Can consists of multiple URLs, separated by spaces.  * <p>Follows RMI's codebase conventions for dynamic class download.  * In contrast to RMI, where the server determines the URL for class download  * (via the "java.rmi.server.codebase" system property), it's the client  * that determines the codebase URL here. The server will usually be the  * same as for the service URL, just pointing to a different path there.  * @see #setServiceUrl  * @see org.springframework.remoting.rmi.CodebaseAwareObjectInputStream  * @see java.rmi.server.RMIClassLoader  */ public void setCodebaseUrl(@Nullable String codebaseUrl) {     this.codebaseUrl = codebaseUrl. }
true;public;0;5;/**  * Return the codebase URL to download classes from if not found locally.  */ ;/**  * Return the codebase URL to download classes from if not found locally.  */ @Override @Nullable public String getCodebaseUrl() {     return this.codebaseUrl. }
true;public;1;3;/**  * Set the HttpInvokerRequestExecutor implementation to use for executing  * remote invocations.  * <p>Default is {@link SimpleHttpInvokerRequestExecutor}. Alternatively,  * consider using {@link HttpComponentsHttpInvokerRequestExecutor} for more  * sophisticated needs.  * @see SimpleHttpInvokerRequestExecutor  * @see HttpComponentsHttpInvokerRequestExecutor  */ ;/**  * Set the HttpInvokerRequestExecutor implementation to use for executing  * remote invocations.  * <p>Default is {@link SimpleHttpInvokerRequestExecutor}. Alternatively,  * consider using {@link HttpComponentsHttpInvokerRequestExecutor} for more  * sophisticated needs.  * @see SimpleHttpInvokerRequestExecutor  * @see HttpComponentsHttpInvokerRequestExecutor  */ public void setHttpInvokerRequestExecutor(HttpInvokerRequestExecutor httpInvokerRequestExecutor) {     this.httpInvokerRequestExecutor = httpInvokerRequestExecutor. }
true;public;0;8;/**  * Return the HttpInvokerRequestExecutor used by this remote accessor.  * <p>Creates a default SimpleHttpInvokerRequestExecutor if no executor  * has been initialized already.  */ ;/**  * Return the HttpInvokerRequestExecutor used by this remote accessor.  * <p>Creates a default SimpleHttpInvokerRequestExecutor if no executor  * has been initialized already.  */ public HttpInvokerRequestExecutor getHttpInvokerRequestExecutor() {     if (this.httpInvokerRequestExecutor == null) {         SimpleHttpInvokerRequestExecutor executor = new SimpleHttpInvokerRequestExecutor().         executor.setBeanClassLoader(getBeanClassLoader()).         this.httpInvokerRequestExecutor = executor.     }     return this.httpInvokerRequestExecutor. }
false;public;0;7;;@Override public void afterPropertiesSet() {     super.afterPropertiesSet().     // Eagerly initialize the default HttpInvokerRequestExecutor, if needed.     getHttpInvokerRequestExecutor(). }
false;public;1;30;;@Override public Object invoke(MethodInvocation methodInvocation) throws Throwable {     if (AopUtils.isToStringMethod(methodInvocation.getMethod())) {         return "HTTP invoker proxy for service URL [" + getServiceUrl() + "]".     }     RemoteInvocation invocation = createRemoteInvocation(methodInvocation).     RemoteInvocationResult result.     try {         result = executeRequest(invocation, methodInvocation).     } catch (Throwable ex) {         RemoteAccessException rae = convertHttpInvokerAccessException(ex).         throw (rae != null ? rae : ex).     }     try {         return recreateRemoteInvocationResult(result).     } catch (Throwable ex) {         if (result.hasInvocationTargetException()) {             throw ex.         } else {             throw new RemoteInvocationFailureException("Invocation of method [" + methodInvocation.getMethod() + "] failed in HTTP invoker remote service at [" + getServiceUrl() + "]", ex).         }     } }
true;protected;2;5;/**  * Execute the given remote invocation via the {@link HttpInvokerRequestExecutor}.  * <p>This implementation delegates to {@link #executeRequest(RemoteInvocation)}.  * Can be overridden to react to the specific original MethodInvocation.  * @param invocation the RemoteInvocation to execute  * @param originalInvocation the original MethodInvocation (can e.g. be cast  * to the ProxyMethodInvocation interface for accessing user attributes)  * @return the RemoteInvocationResult object  * @throws Exception in case of errors  */ ;/**  * Execute the given remote invocation via the {@link HttpInvokerRequestExecutor}.  * <p>This implementation delegates to {@link #executeRequest(RemoteInvocation)}.  * Can be overridden to react to the specific original MethodInvocation.  * @param invocation the RemoteInvocation to execute  * @param originalInvocation the original MethodInvocation (can e.g. be cast  * to the ProxyMethodInvocation interface for accessing user attributes)  * @return the RemoteInvocationResult object  * @throws Exception in case of errors  */ protected RemoteInvocationResult executeRequest(RemoteInvocation invocation, MethodInvocation originalInvocation) throws Exception {     return executeRequest(invocation). }
true;protected;1;3;/**  * Execute the given remote invocation via the {@link HttpInvokerRequestExecutor}.  * <p>Can be overridden in subclasses to pass a different configuration object  * to the executor. Alternatively, add further configuration properties in a  * subclass of this accessor: By default, the accessor passed itself as  * configuration object to the executor.  * @param invocation the RemoteInvocation to execute  * @return the RemoteInvocationResult object  * @throws IOException if thrown by I/O operations  * @throws ClassNotFoundException if thrown during deserialization  * @throws Exception in case of general errors  * @see #getHttpInvokerRequestExecutor  * @see HttpInvokerClientConfiguration  */ ;/**  * Execute the given remote invocation via the {@link HttpInvokerRequestExecutor}.  * <p>Can be overridden in subclasses to pass a different configuration object  * to the executor. Alternatively, add further configuration properties in a  * subclass of this accessor: By default, the accessor passed itself as  * configuration object to the executor.  * @param invocation the RemoteInvocation to execute  * @return the RemoteInvocationResult object  * @throws IOException if thrown by I/O operations  * @throws ClassNotFoundException if thrown during deserialization  * @throws Exception in case of general errors  * @see #getHttpInvokerRequestExecutor  * @see HttpInvokerClientConfiguration  */ protected RemoteInvocationResult executeRequest(RemoteInvocation invocation) throws Exception {     return getHttpInvokerRequestExecutor().executeRequest(this, invocation). }
true;protected;1;21;/**  * Convert the given HTTP invoker access exception to an appropriate  * Spring {@link RemoteAccessException}.  * @param ex the exception to convert  * @return the RemoteAccessException to throw, or {@code null} to have the  * original exception propagated to the caller  */ ;/**  * Convert the given HTTP invoker access exception to an appropriate  * Spring {@link RemoteAccessException}.  * @param ex the exception to convert  * @return the RemoteAccessException to throw, or {@code null} to have the  * original exception propagated to the caller  */ @Nullable protected RemoteAccessException convertHttpInvokerAccessException(Throwable ex) {     if (ex instanceof ConnectException) {         return new RemoteConnectFailureException("Could not connect to HTTP invoker remote service at [" + getServiceUrl() + "]", ex).     }     if (ex instanceof ClassNotFoundException || ex instanceof NoClassDefFoundError || ex instanceof InvalidClassException) {         return new RemoteAccessException("Could not deserialize result from HTTP invoker remote service [" + getServiceUrl() + "]", ex).     }     if (ex instanceof Exception) {         return new RemoteAccessException("Could not access HTTP invoker remote service at [" + getServiceUrl() + "]", ex).     }     // For any other Throwable, e.g. OutOfMemoryError: let it get propagated as-is.     return null. }
