commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;7;;private static void initLogger(Encoder<?> encoder) {     if (encoder instanceof AbstractEncoder && encoder.getClass().getName().startsWith("org.springframework.core.codec")) {         Log logger = HttpLogging.forLog(((AbstractEncoder) encoder).getLogger()).         ((AbstractEncoder) encoder).setLogger(logger).     } }
false;private,static;1;4;;@Nullable private static MediaType initDefaultMediaType(List<MediaType> mediaTypes) {     return mediaTypes.stream().filter(MediaType::isConcrete).findFirst().orElse(null). }
true;public;0;3;/**  * Return the {@code Encoder} of this writer.  */ ;/**  * Return the {@code Encoder} of this writer.  */ public Encoder<T> getEncoder() {     return this.encoder. }
false;public;0;4;;@Override public List<MediaType> getWritableMediaTypes() {     return this.mediaTypes. }
false;public;2;4;;@Override public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {     return this.encoder.canEncode(elementType, mediaType). }
false;public;5;26;;@SuppressWarnings("unchecked") @Override public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {     MediaType contentType = updateContentType(message, mediaType).     Flux<DataBuffer> body = this.encoder.encode(inputStream, message.bufferFactory(), elementType, contentType, hints).     if (inputStream instanceof Mono) {         HttpHeaders headers = message.getHeaders().         return Mono.from(body).switchIfEmpty(Mono.defer(() -> {             headers.setContentLength(0).             return message.setComplete().then(Mono.empty()).         })).flatMap(buffer -> {             headers.setContentLength(buffer.readableByteCount()).             return message.writeWith(Mono.just(buffer)).         }).     }     return (isStreamingMediaType(contentType) ? message.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body)). }
false;private;2;14;;@Nullable private MediaType updateContentType(ReactiveHttpOutputMessage message, @Nullable MediaType mediaType) {     MediaType result = message.getHeaders().getContentType().     if (result != null) {         return result.     }     MediaType fallback = this.defaultMediaType.     result = (useFallback(mediaType, fallback) ? fallback : mediaType).     if (result != null) {         result = addDefaultCharset(result, fallback).         message.getHeaders().setContentType(result).     }     return result. }
false;private,static;2;4;;private static boolean useFallback(@Nullable MediaType main, @Nullable MediaType fallback) {     return (main == null || !main.isConcrete() || main.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null). }
false;private,static;2;6;;private static MediaType addDefaultCharset(MediaType main, @Nullable MediaType defaultType) {     if (main.getCharset() == null && defaultType != null && defaultType.getCharset() != null) {         return new MediaType(main, defaultType.getCharset()).     }     return main. }
false;private;1;6;;private boolean isStreamingMediaType(@Nullable MediaType contentType) {     return (contentType != null && this.encoder instanceof HttpMessageEncoder && ((HttpMessageEncoder<?>) this.encoder).getStreamingMediaTypes().stream().anyMatch(streamingMediaType -> contentType.isCompatibleWith(streamingMediaType) && contentType.getParameters().entrySet().containsAll(streamingMediaType.getParameters().keySet()))). }
false;public;7;10;;// Server side only... @Override public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType, ResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {     Map<String, Object> allHints = Hints.merge(hints, getWriteHints(actualType, elementType, mediaType, request, response)).     return write(inputStream, elementType, mediaType, response, allHints). }
true;protected;5;9;/**  * Get additional hints for encoding for example based on the server request  * or annotations from controller method parameters. By default, delegate to  * the encoder if it is an instance of {@link HttpMessageEncoder}.  */ ;/**  * Get additional hints for encoding for example based on the server request  * or annotations from controller method parameters. By default, delegate to  * the encoder if it is an instance of {@link HttpMessageEncoder}.  */ protected Map<String, Object> getWriteHints(ResolvableType streamType, ResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {     if (this.encoder instanceof HttpMessageEncoder) {         HttpMessageEncoder<?> encoder = (HttpMessageEncoder<?>) this.encoder.         return encoder.getEncodeHints(streamType, elementType, mediaType, request, response).     }     return Hints.none(). }
