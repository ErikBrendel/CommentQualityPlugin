commented;modifiers;parameterAmount;loc;comment;code
true;private;1;16;/**  * Extract exception mappings from the {@code @ExceptionHandler} annotation first,  * and then as a fallback from the method signature itself.  */ ;/**  * Extract exception mappings from the {@code @ExceptionHandler} annotation first,  * and then as a fallback from the method signature itself.  */ @SuppressWarnings("unchecked") private List<Class<? extends Throwable>> detectExceptionMappings(Method method) {     List<Class<? extends Throwable>> result = new ArrayList<>().     detectAnnotationExceptionMappings(method, result).     if (result.isEmpty()) {         for (Class<?> paramType : method.getParameterTypes()) {             if (Throwable.class.isAssignableFrom(paramType)) {                 result.add((Class<? extends Throwable>) paramType).             }         }     }     if (result.isEmpty()) {         throw new IllegalStateException("No exception types mapped to " + method).     }     return result. }
false;private;2;5;;private void detectAnnotationExceptionMappings(Method method, List<Class<? extends Throwable>> result) {     ExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class).     Assert.state(ann != null, "No ExceptionHandler annotation").     result.addAll(Arrays.asList(ann.value())). }
false;private;2;7;;private void addExceptionMapping(Class<? extends Throwable> exceptionType, Method method) {     Method oldMethod = this.mappedMethods.put(exceptionType, method).     if (oldMethod != null && !oldMethod.equals(method)) {         throw new IllegalStateException("Ambiguous @ExceptionHandler method mapped for [" + exceptionType + "]: {" + oldMethod + ", " + method + "}").     } }
true;public;0;3;/**  * Whether the contained type has any exception mappings.  */ ;/**  * Whether the contained type has any exception mappings.  */ public boolean hasExceptionMappings() {     return !this.mappedMethods.isEmpty(). }
true;public;1;4;/**  * Find a {@link Method} to handle the given exception.  * Use {@link ExceptionDepthComparator} if more than one match is found.  * @param exception the exception  * @return a Method to handle the exception, or {@code null} if none found  */ ;/**  * Find a {@link Method} to handle the given exception.  * Use {@link ExceptionDepthComparator} if more than one match is found.  * @param exception the exception  * @return a Method to handle the exception, or {@code null} if none found  */ @Nullable public Method resolveMethod(Exception exception) {     return resolveMethodByThrowable(exception). }
true;public;1;11;/**  * Find a {@link Method} to handle the given Throwable.  * Use {@link ExceptionDepthComparator} if more than one match is found.  * @param exception the exception  * @return a Method to handle the exception, or {@code null} if none found  * @since 5.0  */ ;/**  * Find a {@link Method} to handle the given Throwable.  * Use {@link ExceptionDepthComparator} if more than one match is found.  * @param exception the exception  * @return a Method to handle the exception, or {@code null} if none found  * @since 5.0  */ @Nullable public Method resolveMethodByThrowable(Throwable exception) {     Method method = resolveMethodByExceptionType(exception.getClass()).     if (method == null) {         Throwable cause = exception.getCause().         if (cause != null) {             method = resolveMethodByExceptionType(cause.getClass()).         }     }     return method. }
true;public;1;9;/**  * Find a {@link Method} to handle the given exception type. This can be  * useful if an {@link Exception} instance is not available (e.g. for tools).  * @param exceptionType the exception type  * @return a Method to handle the exception, or {@code null} if none found  */ ;/**  * Find a {@link Method} to handle the given exception type. This can be  * useful if an {@link Exception} instance is not available (e.g. for tools).  * @param exceptionType the exception type  * @return a Method to handle the exception, or {@code null} if none found  */ @Nullable public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {     Method method = this.exceptionLookupCache.get(exceptionType).     if (method == null) {         method = getMappedMethod(exceptionType).         this.exceptionLookupCache.put(exceptionType, method).     }     return method. }
true;private;1;16;/**  * Return the {@link Method} mapped to the given exception type, or {@code null} if none.  */ ;/**  * Return the {@link Method} mapped to the given exception type, or {@code null} if none.  */ @Nullable private Method getMappedMethod(Class<? extends Throwable> exceptionType) {     List<Class<? extends Throwable>> matches = new ArrayList<>().     for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {         if (mappedException.isAssignableFrom(exceptionType)) {             matches.add(mappedException).         }     }     if (!matches.isEmpty()) {         matches.sort(new ExceptionDepthComparator(exceptionType)).         return this.mappedMethods.get(matches.get(0)).     } else {         return null.     } }
