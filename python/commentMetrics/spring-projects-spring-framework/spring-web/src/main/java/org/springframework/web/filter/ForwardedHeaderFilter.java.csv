commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Enables mode in which any "Forwarded" or "X-Forwarded-*" headers are  * removed only and the information in them ignored.  * @param removeOnly whether to discard and ignore forwarded headers  * @since 4.3.9  */ ;/**  * Enables mode in which any "Forwarded" or "X-Forwarded-*" headers are  * removed only and the information in them ignored.  * @param removeOnly whether to discard and ignore forwarded headers  * @since 4.3.9  */ public void setRemoveOnly(boolean removeOnly) {     this.removeOnly = removeOnly. }
true;public;1;3;/**  * Use this property to enable relative redirects as explained in  * {@link RelativeRedirectFilter}, and also using the same response wrapper  * as that filter does, or if both are configured, only one will wrap.  * <p>By default, if this property is set to false, in which case calls to  * {@link HttpServletResponse#sendRedirect(String)} are overridden in order  * to turn relative into absolute URLs, also taking into account forwarded  * headers.  * @param relativeRedirects whether to use relative redirects  * @since 4.3.10  */ ;/**  * Use this property to enable relative redirects as explained in  * {@link RelativeRedirectFilter}, and also using the same response wrapper  * as that filter does, or if both are configured, only one will wrap.  * <p>By default, if this property is set to false, in which case calls to  * {@link HttpServletResponse#sendRedirect(String)} are overridden in order  * to turn relative into absolute URLs, also taking into account forwarded  * headers.  * @param relativeRedirects whether to use relative redirects  * @since 4.3.10  */ public void setRelativeRedirects(boolean relativeRedirects) {     this.relativeRedirects = relativeRedirects. }
false;protected;1;9;;@Override protected boolean shouldNotFilter(HttpServletRequest request) {     for (String headerName : FORWARDED_HEADER_NAMES) {         if (request.getHeader(headerName) != null) {             return false.         }     }     return true. }
false;protected;0;4;;@Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
false;protected;0;4;;@Override protected boolean shouldNotFilterErrorDispatch() {     return false. }
false;protected;3;19;;@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     if (this.removeOnly) {         ForwardedHeaderRemovingRequest wrappedRequest = new ForwardedHeaderRemovingRequest(request).         filterChain.doFilter(wrappedRequest, response).     } else {         HttpServletRequest wrappedRequest = new ForwardedHeaderExtractingRequest(request, this.pathHelper).         HttpServletResponse wrappedResponse = this.relativeRedirects ? RelativeRedirectResponseWrapper.wrapIfNecessary(response, HttpStatus.SEE_OTHER) : new ForwardedHeaderExtractingResponse(response, wrappedRequest).         filterChain.doFilter(wrappedRequest, wrappedResponse).     } }
false;private,static;1;11;;private static Map<String, List<String>> initHeaders(HttpServletRequest request) {     Map<String, List<String>> headers = new LinkedCaseInsensitiveMap<>(Locale.ENGLISH).     Enumeration<String> names = request.getHeaderNames().     while (names.hasMoreElements()) {         String name = names.nextElement().         if (!FORWARDED_HEADER_NAMES.contains(name)) {             headers.put(name, Collections.list(request.getHeaders(name))).         }     }     return headers. }
false;public;1;6;;// Override header accessors to not expose forwarded headers @Override @Nullable public String getHeader(String name) {     List<String> value = this.headers.get(name).     return (CollectionUtils.isEmpty(value) ? null : value.get(0)). }
false;public;1;5;;@Override public Enumeration<String> getHeaders(String name) {     List<String> value = this.headers.get(name).     return (Collections.enumeration(value != null ? value : Collections.emptySet())). }
false;public;0;4;;@Override public Enumeration<String> getHeaderNames() {     return Collections.enumeration(this.headers.keySet()). }
false;public;0;5;;@Override @Nullable public String getScheme() {     return this.scheme. }
false;public;0;5;;@Override @Nullable public String getServerName() {     return this.host. }
false;public;0;4;;@Override public int getServerPort() {     return this.port. }
false;public;0;4;;@Override public boolean isSecure() {     return this.secure. }
false;public;0;4;;@Override public String getContextPath() {     return this.forwardedPrefixExtractor.getContextPath(). }
false;public;0;4;;@Override public String getRequestURI() {     return this.forwardedPrefixExtractor.getRequestUri(). }
false;public;0;4;;@Override public StringBuffer getRequestURL() {     return this.forwardedPrefixExtractor.getRequestUrl(). }
false;private,static;1;17;;@Nullable private static String initForwardedPrefix(HttpServletRequest request) {     String result = null.     Enumeration<String> names = request.getHeaderNames().     while (names.hasMoreElements()) {         String name = names.nextElement().         if ("X-Forwarded-Prefix".equalsIgnoreCase(name)) {             result = request.getHeader(name).         }     }     if (result != null) {         while (result.endsWith("/")) {             result = result.substring(0, result.length() - 1).         }     }     return result. }
false;private;0;7;;@Nullable private String initRequestUri() {     if (this.forwardedPrefix != null) {         return this.forwardedPrefix + this.pathHelper.getPathWithinApplication(this.delegate.get()).     }     return null. }
false;private;0;3;;private String initRequestUrl() {     return this.baseUrl + (this.requestUri != null ? this.requestUri : this.delegate.get().getRequestURI()). }
false;public;0;3;;public String getContextPath() {     return this.forwardedPrefix == null ? this.delegate.get().getContextPath() : this.forwardedPrefix. }
false;public;0;7;;public String getRequestUri() {     if (this.requestUri == null) {         return this.delegate.get().getRequestURI().     }     recalculatePathsIfNecessary().     return this.requestUri. }
false;public;0;4;;public StringBuffer getRequestUrl() {     recalculatePathsIfNecessary().     return new StringBuffer(this.requestUrl). }
false;private;0;8;;private void recalculatePathsIfNecessary() {     if (!this.actualRequestUri.equals(this.delegate.get().getRequestURI())) {         // Underlying path change (e.g. Servlet FORWARD).         this.actualRequestUri = this.delegate.get().getRequestURI().         this.requestUri = initRequestUri().         // Keep the order: depends on requestUri         this.requestUrl = initRequestUrl().     } }
false;public;1;35;;@Override public void sendRedirect(String location) throws IOException {     UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(location).     UriComponents uriComponents = builder.build().     // Absolute location     if (uriComponents.getScheme() != null) {         super.sendRedirect(location).         return.     }     // Network-path reference     if (location.startsWith("//")) {         String scheme = this.request.getScheme().         super.sendRedirect(builder.scheme(scheme).toUriString()).         return.     }     String path = uriComponents.getPath().     if (path != null) {         // Relative to Servlet container root or to current request         path = (path.startsWith(FOLDER_SEPARATOR) ? path : StringUtils.applyRelativePath(this.request.getRequestURI(), path)).     }     String result = UriComponentsBuilder.fromHttpRequest(new ServletServerHttpRequest(this.request)).replacePath(path).replaceQuery(uriComponents.getQuery()).fragment(uriComponents.getFragment()).build().normalize().toUriString().     super.sendRedirect(result). }
