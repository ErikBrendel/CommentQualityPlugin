# id;timestamp;commentText;codeText;commentWords;codeWords
Jaxb2XmlDecoder -> public Function<Unmarshaller, Unmarshaller> getUnmarshallerProcessor();1542146216;Return the configured processor for customizing Unmarshaller instances._@since 5.1.3;public Function<Unmarshaller, Unmarshaller> getUnmarshallerProcessor() {_		return this.unmarshallerProcessor__	};return,the,configured,processor,for,customizing,unmarshaller,instances,since,5,1,3;public,function,unmarshaller,unmarshaller,get,unmarshaller,processor,return,this,unmarshaller,processor
Jaxb2XmlDecoder -> public Function<Unmarshaller, Unmarshaller> getUnmarshallerProcessor();1543877580;Return the configured processor for customizing Unmarshaller instances._@since 5.1.3;public Function<Unmarshaller, Unmarshaller> getUnmarshallerProcessor() {_		return this.unmarshallerProcessor__	};return,the,configured,processor,for,customizing,unmarshaller,instances,since,5,1,3;public,function,unmarshaller,unmarshaller,get,unmarshaller,processor,return,this,unmarshaller,processor
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1469540372;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Outputclass [" + outputClass + "] is " +_					"neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null &&_					outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,outputclass,output,class,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1473671281;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Outputclass [" + outputClass + "] is " +_					"neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null &&_					outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,outputclass,output,class,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1474365351;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Outputclass [" + outputClass + "] is " +_					"neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null &&_					outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,outputclass,output,class,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1494008983;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Outputclass [" + outputClass + "] is " +_					"neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null &&_					outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,outputclass,output,class,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1494019141;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1496242568;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1496259743;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1496837955;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1500495740;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1522360217;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1525255846;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1529721864;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1530174524;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1530793695;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1536942003;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1536962806;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1542050977;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1542146216;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> QName toQName(Class<?> outputClass);1543877580;Returns the qualified name for the given class, according to the mapping rules_in the JAXB specification.;QName toQName(Class<?> outputClass) {_		String localPart__		String namespaceUri___		if (outputClass.isAnnotationPresent(XmlRootElement.class)) {_			XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else if (outputClass.isAnnotationPresent(XmlType.class)) {_			XmlType annotation = outputClass.getAnnotation(XmlType.class)__			localPart = annotation.name()__			namespaceUri = annotation.namespace()__		}_		else {_			throw new IllegalArgumentException("Output class [" + outputClass.getName() +_					"] is neither annotated with @XmlRootElement nor @XmlType")__		}__		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {_			localPart = ClassUtils.getShortNameAsProperty(outputClass)__		}_		if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {_			Package outputClassPackage = outputClass.getPackage()__			if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {_				XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class)__				namespaceUri = annotation.namespace()__			}_			else {_				namespaceUri = XMLConstants.NULL_NS_URI__			}_		}_		return new QName(namespaceUri, localPart)__	};returns,the,qualified,name,for,the,given,class,according,to,the,mapping,rules,in,the,jaxb,specification;qname,to,qname,class,output,class,string,local,part,string,namespace,uri,if,output,class,is,annotation,present,xml,root,element,class,xml,root,element,annotation,output,class,get,annotation,xml,root,element,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,if,output,class,is,annotation,present,xml,type,class,xml,type,annotation,output,class,get,annotation,xml,type,class,local,part,annotation,name,namespace,uri,annotation,namespace,else,throw,new,illegal,argument,exception,output,class,output,class,get,name,is,neither,annotated,with,xml,root,element,nor,xml,type,if,equals,local,part,local,part,class,utils,get,short,name,as,property,output,class,if,equals,namespace,uri,package,output,class,package,output,class,get,package,if,output,class,package,null,output,class,package,is,annotation,present,xml,schema,class,xml,schema,annotation,output,class,package,get,annotation,xml,schema,class,namespace,uri,annotation,namespace,else,namespace,uri,xmlconstants,return,new,qname,namespace,uri,local,part
Jaxb2XmlDecoder -> public void setUnmarshallerProcessor(Function<Unmarshaller, Unmarshaller> processor);1542146216;Configure a processor function to customize Unmarshaller instances._@param processor the function to use_@since 5.1.3;public void setUnmarshallerProcessor(Function<Unmarshaller, Unmarshaller> processor) {_		this.unmarshallerProcessor = this.unmarshallerProcessor.andThen(processor)__	};configure,a,processor,function,to,customize,unmarshaller,instances,param,processor,the,function,to,use,since,5,1,3;public,void,set,unmarshaller,processor,function,unmarshaller,unmarshaller,processor,this,unmarshaller,processor,this,unmarshaller,processor,and,then,processor
Jaxb2XmlDecoder -> public void setUnmarshallerProcessor(Function<Unmarshaller, Unmarshaller> processor);1543877580;Configure a processor function to customize Unmarshaller instances._@param processor the function to use_@since 5.1.3;public void setUnmarshallerProcessor(Function<Unmarshaller, Unmarshaller> processor) {_		this.unmarshallerProcessor = this.unmarshallerProcessor.andThen(processor)__	};configure,a,processor,function,to,customize,unmarshaller,instances,param,processor,the,function,to,use,since,5,1,3;public,void,set,unmarshaller,processor,function,unmarshaller,unmarshaller,processor,this,unmarshaller,processor,this,unmarshaller,processor,and,then,processor
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1469540372;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list for each_branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown_{@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method_returns a flux of two lists, each of which containing the events of a particular_branch of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux_				.flatMap(new Function<XMLEvent, Publisher<? extends List<XMLEvent>>>() {__					private List<XMLEvent> events = null___					private int elementDepth = 0___					private int barrier = Integer.MAX_VALUE___					@Override_					public Publisher<? extends List<XMLEvent>> apply(XMLEvent event) {_						if (event.isStartElement()) {_							if (this.barrier == Integer.MAX_VALUE) {_								QName startElementName = event.asStartElement().getName()__								if (desiredName.equals(startElementName)) {_									this.events = new ArrayList<XMLEvent>()__									this.barrier = this.elementDepth__								}_							}_							this.elementDepth++__						}_						if (this.elementDepth > this.barrier) {_							this.events.add(event)__						}_						if (event.isEndElement()) {_							this.elementDepth--__							if (this.elementDepth == this.barrier) {_								this.barrier = Integer.MAX_VALUE__								return Mono.just(this.events)__							}_						}_						return Mono.empty()__					}_				})__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,function,xmlevent,publisher,extends,list,xmlevent,private,list,xmlevent,events,null,private,int,element,depth,0,private,int,barrier,integer,override,public,publisher,extends,list,xmlevent,apply,xmlevent,event,if,event,is,start,element,if,this,barrier,integer,qname,start,element,name,event,as,start,element,get,name,if,desired,name,equals,start,element,name,this,events,new,array,list,xmlevent,this,barrier,this,element,depth,this,element,depth,if,this,element,depth,this,barrier,this,events,add,event,if,event,is,end,element,this,element,depth,if,this,element,depth,this,barrier,this,barrier,integer,return,mono,just,this,events,return,mono,empty
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1473671281;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list for each_branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown_{@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method_returns a flux of two lists, each of which containing the events of a particular_branch of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux_				.flatMap(new Function<XMLEvent, Publisher<? extends List<XMLEvent>>>() {__					private List<XMLEvent> events = null___					private int elementDepth = 0___					private int barrier = Integer.MAX_VALUE___					@Override_					public Publisher<? extends List<XMLEvent>> apply(XMLEvent event) {_						if (event.isStartElement()) {_							if (this.barrier == Integer.MAX_VALUE) {_								QName startElementName = event.asStartElement().getName()__								if (desiredName.equals(startElementName)) {_									this.events = new ArrayList<XMLEvent>()__									this.barrier = this.elementDepth__								}_							}_							this.elementDepth++__						}_						if (this.elementDepth > this.barrier) {_							this.events.add(event)__						}_						if (event.isEndElement()) {_							this.elementDepth--__							if (this.elementDepth == this.barrier) {_								this.barrier = Integer.MAX_VALUE__								return Mono.just(this.events)__							}_						}_						return Mono.empty()__					}_				})__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,function,xmlevent,publisher,extends,list,xmlevent,private,list,xmlevent,events,null,private,int,element,depth,0,private,int,barrier,integer,override,public,publisher,extends,list,xmlevent,apply,xmlevent,event,if,event,is,start,element,if,this,barrier,integer,qname,start,element,name,event,as,start,element,get,name,if,desired,name,equals,start,element,name,this,events,new,array,list,xmlevent,this,barrier,this,element,depth,this,element,depth,if,this,element,depth,this,barrier,this,events,add,event,if,event,is,end,element,this,element,depth,if,this,element,depth,this,barrier,this,barrier,integer,return,mono,just,this,events,return,mono,empty
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1474365351;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list for each_branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown_{@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method_returns a flux of two lists, each of which containing the events of a particular_branch of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux_				.flatMap(new Function<XMLEvent, Publisher<? extends List<XMLEvent>>>() {__					private List<XMLEvent> events = null___					private int elementDepth = 0___					private int barrier = Integer.MAX_VALUE___					@Override_					public Publisher<? extends List<XMLEvent>> apply(XMLEvent event) {_						if (event.isStartElement()) {_							if (this.barrier == Integer.MAX_VALUE) {_								QName startElementName = event.asStartElement().getName()__								if (desiredName.equals(startElementName)) {_									this.events = new ArrayList<XMLEvent>()__									this.barrier = this.elementDepth__								}_							}_							this.elementDepth++__						}_						if (this.elementDepth > this.barrier) {_							this.events.add(event)__						}_						if (event.isEndElement()) {_							this.elementDepth--__							if (this.elementDepth == this.barrier) {_								this.barrier = Integer.MAX_VALUE__								return Mono.just(this.events)__							}_						}_						return Mono.empty()__					}_				})__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,function,xmlevent,publisher,extends,list,xmlevent,private,list,xmlevent,events,null,private,int,element,depth,0,private,int,barrier,integer,override,public,publisher,extends,list,xmlevent,apply,xmlevent,event,if,event,is,start,element,if,this,barrier,integer,qname,start,element,name,event,as,start,element,get,name,if,desired,name,equals,start,element,name,this,events,new,array,list,xmlevent,this,barrier,this,element,depth,this,element,depth,if,this,element,depth,this,barrier,this,events,add,event,if,event,is,end,element,this,element,depth,if,this,element,depth,this,barrier,this,barrier,integer,return,mono,just,this,events,return,mono,empty
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1494008983;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list for each_branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown_{@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method_returns a flux of two lists, each of which containing the events of a particular_branch of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux_				.flatMap(new Function<XMLEvent, Publisher<? extends List<XMLEvent>>>() {__					private List<XMLEvent> events = null___					private int elementDepth = 0___					private int barrier = Integer.MAX_VALUE___					@Override_					public Publisher<? extends List<XMLEvent>> apply(XMLEvent event) {_						if (event.isStartElement()) {_							if (this.barrier == Integer.MAX_VALUE) {_								QName startElementName = event.asStartElement().getName()__								if (desiredName.equals(startElementName)) {_									this.events = new ArrayList<XMLEvent>()__									this.barrier = this.elementDepth__								}_							}_							this.elementDepth++__						}_						if (this.elementDepth > this.barrier) {_							this.events.add(event)__						}_						if (event.isEndElement()) {_							this.elementDepth--__							if (this.elementDepth == this.barrier) {_								this.barrier = Integer.MAX_VALUE__								return Mono.just(this.events)__							}_						}_						return Mono.empty()__					}_				})__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,function,xmlevent,publisher,extends,list,xmlevent,private,list,xmlevent,events,null,private,int,element,depth,0,private,int,barrier,integer,override,public,publisher,extends,list,xmlevent,apply,xmlevent,event,if,event,is,start,element,if,this,barrier,integer,qname,start,element,name,event,as,start,element,get,name,if,desired,name,equals,start,element,name,this,events,new,array,list,xmlevent,this,barrier,this,element,depth,this,element,depth,if,this,element,depth,this,barrier,this,events,add,event,if,event,is,end,element,this,element,depth,if,this,element,depth,this,barrier,this,barrier,integer,return,mono,just,this,events,return,mono,empty
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1494019141;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1496242568;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1496259743;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1496837955;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1500495740;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1522360217;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1525255846;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1529721864;Split a flux of {@link XMLEvent}s into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,s,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1530174524;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1530793695;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1536942003;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1536962806;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1542050977;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1542146216;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
Jaxb2XmlDecoder -> Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName);1543877580;Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list_for each branch of the tree that starts with the given qualified name._That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},_and the {@code desiredName} "{@code child}", this method returns a flux_of two lists, each of which containing the events of a particular branch_of the tree that starts with "{@code child}"._<ol>_<li>The first list, dealing with the first branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code foo}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_<li>The second list, dealing with the second branch of the tree:_<ol>_<li>{@link javax.xml.stream.events.StartElement} {@code child}</li>_<li>{@link javax.xml.stream.events.Characters} {@code bar}</li>_<li>{@link javax.xml.stream.events.EndElement} {@code child}</li>_</ol>_</li>_</ol>;Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {_		return xmlEventFlux.flatMap(new SplitFunction(desiredName))__	};split,a,flux,of,link,xmlevent,xmlevents,into,a,flux,of,xmlevent,lists,one,list,for,each,branch,of,the,tree,that,starts,with,the,given,qualified,name,that,is,given,the,xmlevents,shown,linkplain,xml,event,decoder,here,and,the,code,desired,name,code,child,this,method,returns,a,flux,of,two,lists,each,of,which,containing,the,events,of,a,particular,branch,of,the,tree,that,starts,with,code,child,ol,li,the,first,list,dealing,with,the,first,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,foo,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,the,second,list,dealing,with,the,second,branch,of,the,tree,ol,li,link,javax,xml,stream,events,start,element,code,child,li,li,link,javax,xml,stream,events,characters,code,bar,li,li,link,javax,xml,stream,events,end,element,code,child,li,ol,li,ol;flux,list,xmlevent,split,flux,xmlevent,xml,event,flux,qname,desired,name,return,xml,event,flux,flat,map,new,split,function,desired,name
