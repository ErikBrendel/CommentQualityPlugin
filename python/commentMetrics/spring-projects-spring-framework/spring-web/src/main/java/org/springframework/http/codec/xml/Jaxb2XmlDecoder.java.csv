commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Configure a processor function to customize Unmarshaller instances.  * @param processor the function to use  * @since 5.1.3  */ ;/**  * Configure a processor function to customize Unmarshaller instances.  * @param processor the function to use  * @since 5.1.3  */ public void setUnmarshallerProcessor(Function<Unmarshaller, Unmarshaller> processor) {     this.unmarshallerProcessor = this.unmarshallerProcessor.andThen(processor). }
true;public;0;3;/**  * Return the configured processor for customizing Unmarshaller instances.  * @since 5.1.3  */ ;/**  * Return the configured processor for customizing Unmarshaller instances.  * @since 5.1.3  */ public Function<Unmarshaller, Unmarshaller> getUnmarshallerProcessor() {     return this.unmarshallerProcessor. }
false;public;2;6;;@Override public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {     Class<?> outputClass = elementType.toClass().     return (outputClass.isAnnotationPresent(XmlRootElement.class) || outputClass.isAnnotationPresent(XmlType.class)) && super.canDecode(elementType, mimeType). }
false;public;4;20;;@Override public Flux<Object> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<XMLEvent> xmlEventFlux = this.xmlEventDecoder.decode(inputStream, ResolvableType.forClass(XMLEvent.class), mimeType, hints).     Class<?> outputClass = elementType.toClass().     QName typeName = toQName(outputClass).     Flux<List<XMLEvent>> splitEvents = split(xmlEventFlux, typeName).     return splitEvents.map(events -> {         Object value = unmarshal(events, outputClass).         LogFormatUtils.traceDebug(logger, traceOn -> {             String formatted = LogFormatUtils.formatValue(value, !traceOn).             return Hints.getLogPrefix(hints) + "Decoded [" + formatted + "]".         }).         return value.     }). }
false;public;4;6;;@Override public Mono<Object> decodeToMono(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     return decode(inputStream, elementType, mimeType, hints).singleOrEmpty(). }
false;private;2;19;;private Object unmarshal(List<XMLEvent> events, Class<?> outputClass) {     try {         Unmarshaller unmarshaller = initUnmarshaller(outputClass).         XMLEventReader eventReader = StaxUtils.createXMLEventReader(events).         if (outputClass.isAnnotationPresent(XmlRootElement.class)) {             return unmarshaller.unmarshal(eventReader).         } else {             JAXBElement<?> jaxbElement = unmarshaller.unmarshal(eventReader, outputClass).             return jaxbElement.getValue().         }     } catch (UnmarshalException ex) {         throw new DecodingException("Could not unmarshal XML to " + outputClass, ex).     } catch (JAXBException ex) {         throw new CodecException("Invalid JAXB configuration", ex).     } }
false;private;1;4;;private Unmarshaller initUnmarshaller(Class<?> outputClass) throws JAXBException {     Unmarshaller unmarshaller = this.jaxbContexts.createUnmarshaller(outputClass).     return this.unmarshallerProcessor.apply(unmarshaller). }
true;;1;34;/**  * Returns the qualified name for the given class, according to the mapping rules  * in the JAXB specification.  */ ;/**  * Returns the qualified name for the given class, according to the mapping rules  * in the JAXB specification.  */ QName toQName(Class<?> outputClass) {     String localPart.     String namespaceUri.     if (outputClass.isAnnotationPresent(XmlRootElement.class)) {         XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class).         localPart = annotation.name().         namespaceUri = annotation.namespace().     } else if (outputClass.isAnnotationPresent(XmlType.class)) {         XmlType annotation = outputClass.getAnnotation(XmlType.class).         localPart = annotation.name().         namespaceUri = annotation.namespace().     } else {         throw new IllegalArgumentException("Output class [" + outputClass.getName() + "] is neither annotated with @XmlRootElement nor @XmlType").     }     if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {         localPart = ClassUtils.getShortNameAsProperty(outputClass).     }     if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {         Package outputClassPackage = outputClass.getPackage().         if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {             XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class).             namespaceUri = annotation.namespace().         } else {             namespaceUri = XMLConstants.NULL_NS_URI.         }     }     return new QName(namespaceUri, localPart). }
true;;2;3;/**  * Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list  * for each branch of the tree that starts with the given qualified name.  * That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},  * and the {@code desiredName} "{@code child}", this method returns a flux  * of two lists, each of which containing the events of a particular branch  * of the tree that starts with "{@code child}".  * <ol>  * <li>The first list, dealing with the first branch of the tree:  * <ol>  * <li>{@link javax.xml.stream.events.StartElement} {@code child}</li>  * <li>{@link javax.xml.stream.events.Characters} {@code foo}</li>  * <li>{@link javax.xml.stream.events.EndElement} {@code child}</li>  * </ol>  * <li>The second list, dealing with the second branch of the tree:  * <ol>  * <li>{@link javax.xml.stream.events.StartElement} {@code child}</li>  * <li>{@link javax.xml.stream.events.Characters} {@code bar}</li>  * <li>{@link javax.xml.stream.events.EndElement} {@code child}</li>  * </ol>  * </li>  * </ol>  */ ;/**  * Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list  * for each branch of the tree that starts with the given qualified name.  * That is, given the XMLEvents shown {@linkplain XmlEventDecoder here},  * and the {@code desiredName} "{@code child}", this method returns a flux  * of two lists, each of which containing the events of a particular branch  * of the tree that starts with "{@code child}".  * <ol>  * <li>The first list, dealing with the first branch of the tree:  * <ol>  * <li>{@link javax.xml.stream.events.StartElement} {@code child}</li>  * <li>{@link javax.xml.stream.events.Characters} {@code foo}</li>  * <li>{@link javax.xml.stream.events.EndElement} {@code child}</li>  * </ol>  * <li>The second list, dealing with the second branch of the tree:  * <ol>  * <li>{@link javax.xml.stream.events.StartElement} {@code child}</li>  * <li>{@link javax.xml.stream.events.Characters} {@code bar}</li>  * <li>{@link javax.xml.stream.events.EndElement} {@code child}</li>  * </ol>  * </li>  * </ol>  */ Flux<List<XMLEvent>> split(Flux<XMLEvent> xmlEventFlux, QName desiredName) {     return xmlEventFlux.flatMap(new SplitFunction(desiredName)). }
false;public;1;26;;@Override public Publisher<? extends List<XMLEvent>> apply(XMLEvent event) {     if (event.isStartElement()) {         if (this.barrier == Integer.MAX_VALUE) {             QName startElementName = event.asStartElement().getName().             if (this.desiredName.equals(startElementName)) {                 this.events = new ArrayList<>().                 this.barrier = this.elementDepth.             }         }         this.elementDepth++.     }     if (this.elementDepth > this.barrier) {         Assert.state(this.events != null, "No XMLEvent List").         this.events.add(event).     }     if (event.isEndElement()) {         this.elementDepth--.         if (this.elementDepth == this.barrier) {             this.barrier = Integer.MAX_VALUE.             Assert.state(this.events != null, "No XMLEvent List").             return Mono.just(this.events).         }     }     return Mono.empty(). }
