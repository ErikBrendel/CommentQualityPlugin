commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured log message prefix.  * @since 5.1  */ ;/**  * Return the configured log message prefix.  * @since 5.1  */ public String getLogPrefix() {     return this.logPrefix. }
false;public;1;4;;// Publisher implementation... @Override public void subscribe(Subscriber<? super T> subscriber) {     this.state.get().subscribe(this, subscriber). }
true;public,final;0;4;/**  * Invoked when reading is possible, either in the same thread after a check  * via {@link #checkOnDataAvailable()}, or as a callback from the underlying  * container.  */ ;// Async I/O notification methods... /**  * Invoked when reading is possible, either in the same thread after a check  * via {@link #checkOnDataAvailable()}, or as a callback from the underlying  * container.  */ public final void onDataAvailable() {     rsReadLogger.trace(getLogPrefix() + "onDataAvailable").     this.state.get().onDataAvailable(this). }
true;public;0;4;/**  * Sub-classes can call this method to delegate a contain notification when  * all data has been read.  */ ;/**  * Sub-classes can call this method to delegate a contain notification when  * all data has been read.  */ public void onAllDataRead() {     rsReadLogger.trace(getLogPrefix() + "onAllDataRead").     this.state.get().onAllDataRead(this). }
true;public,final;1;6;/**  * Sub-classes can call this to delegate container error notifications.  */ ;/**  * Sub-classes can call this to delegate container error notifications.  */ public final void onError(Throwable ex) {     if (rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + "Connection error: " + ex).     }     this.state.get().onError(this, ex). }
true;protected,abstract;0;1;/**  * Check if data is available and either call {@link #onDataAvailable()}  * immediately or schedule a notification.  */ ;// Read API methods to be implemented or template methods to override... /**  * Check if data is available and either call {@link #onDataAvailable()}  * immediately or schedule a notification.  */ protected abstract void checkOnDataAvailable().
true;protected,abstract;0;2;/**  * Read once from the input, if possible.  * @return the item that was read. or {@code null}  */ ;/**  * Read once from the input, if possible.  * @return the item that was read. or {@code null}  */ @Nullable protected abstract T read() throws IOException.
true;protected,abstract;0;1;/**  * Invoked when reading is paused due to a lack of demand.  * <p><strong>Note:</strong> This method is guaranteed not to compete with  * {@link #checkOnDataAvailable()} so it can be used to safely suspend  * reading, if the underlying API supports it, i.e. without competing with  * an implicit call to resume via {@code checkOnDataAvailable()}.  * @since 5.0.2  */ ;/**  * Invoked when reading is paused due to a lack of demand.  * <p><strong>Note:</strong> This method is guaranteed not to compete with  * {@link #checkOnDataAvailable()} so it can be used to safely suspend  * reading, if the underlying API supports it, i.e. without competing with  * an implicit call to resume via {@code checkOnDataAvailable()}.  * @since 5.0.2  */ protected abstract void readingPaused().
true;protected,abstract;0;1;/**  * Invoked after an I/O read error from the underlying server or after a  * cancellation signal from the downstream consumer to allow sub-classes  * to discard any current cached data they might have.  * @since 5.0.11  */ ;/**  * Invoked after an I/O read error from the underlying server or after a  * cancellation signal from the downstream consumer to allow sub-classes  * to discard any current cached data they might have.  * @since 5.0.11  */ protected abstract void discardData().
true;private;0;24;/**  * Read and publish data one at a time until there is no more data, no more  * demand, or perhaps we completed in the mean time.  * @return {@code true} if there is more demand. {@code false} if there is  * no more demand or we have completed.  */ ;// Private methods for use in State... /**  * Read and publish data one at a time until there is no more data, no more  * demand, or perhaps we completed in the mean time.  * @return {@code true} if there is more demand. {@code false} if there is  * no more demand or we have completed.  */ private boolean readAndPublish() throws IOException {     long r.     while ((r = this.demand) > 0 && !this.state.get().equals(State.COMPLETED)) {         T data = read().         if (data != null) {             if (r != Long.MAX_VALUE) {                 DEMAND_FIELD_UPDATER.addAndGet(this, -1L).             }             Subscriber<? super T> subscriber = this.subscriber.             Assert.state(subscriber != null, "No subscriber").             if (rsReadLogger.isTraceEnabled()) {                 rsReadLogger.trace(getLogPrefix() + "Publishing data read").             }             subscriber.onNext(data).         } else {             if (rsReadLogger.isTraceEnabled()) {                 rsReadLogger.trace(getLogPrefix() + "No more data to read").             }             return true.         }     }     return false. }
false;private;2;7;;private boolean changeState(State oldState, State newState) {     boolean result = this.state.compareAndSet(oldState, newState).     if (result && rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + oldState + " -> " + newState).     }     return result. }
false;private;1;10;;private void changeToDemandState(State oldState) {     if (changeState(oldState, State.DEMAND)) {         // Generally, no need to check if we just came out of readAndPublish()...         if (!oldState.equals(State.READING)) {             checkOnDataAvailable().         }     } }
false;private;0;3;;private Subscription createSubscription() {     return new ReadSubscription(). }
false;public,final;1;7;;@Override public final void request(long n) {     if (rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + n + " requested").     }     state.get().request(AbstractListenerReadPublisher.this, n). }
false;public,final;0;7;;@Override public final void cancel() {     if (rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + "Cancellation").     }     state.get().cancel(AbstractListenerReadPublisher.this). }
false;;2;28;;@Override <T> void subscribe(AbstractListenerReadPublisher<T> publisher, Subscriber<? super T> subscriber) {     Assert.notNull(publisher, "Publisher must not be null").     Assert.notNull(subscriber, "Subscriber must not be null").     if (publisher.changeState(this, SUBSCRIBING)) {         Subscription subscription = publisher.createSubscription().         publisher.subscriber = subscriber.         subscriber.onSubscribe(subscription).         publisher.changeState(SUBSCRIBING, NO_DEMAND).         // Now safe to check "beforeDemand" flags, they won't change once in NO_DEMAND         String logPrefix = publisher.getLogPrefix().         if (publisher.completionBeforeDemand) {             rsReadLogger.trace(logPrefix + "Completed before demand").             publisher.state.get().onAllDataRead(publisher).         }         Throwable ex = publisher.errorBeforeDemand.         if (ex != null) {             if (rsReadLogger.isTraceEnabled()) {                 rsReadLogger.trace(logPrefix + "Completed with error before demand: " + ex).             }             publisher.state.get().onError(publisher, ex).         }     } else {         throw new IllegalStateException("Failed to transition to SUBSCRIBING, " + "subscriber: " + subscriber).     } }
false;;1;4;;@Override <T> void onAllDataRead(AbstractListenerReadPublisher<T> publisher) {     publisher.completionBeforeDemand = true. }
false;;2;4;;@Override <T> void onError(AbstractListenerReadPublisher<T> publisher, Throwable ex) {     publisher.errorBeforeDemand = ex. }
false;;2;7;;@Override <T> void request(AbstractListenerReadPublisher<T> publisher, long n) {     if (Operators.validate(n)) {         Operators.addCap(DEMAND_FIELD_UPDATER, publisher, n).         publisher.changeToDemandState(this).     } }
false;;1;4;;@Override <T> void onAllDataRead(AbstractListenerReadPublisher<T> publisher) {     publisher.completionBeforeDemand = true. }
false;;2;4;;@Override <T> void onError(AbstractListenerReadPublisher<T> publisher, Throwable ex) {     publisher.errorBeforeDemand = ex. }
false;;2;7;;@Override <T> void request(AbstractListenerReadPublisher<T> publisher, long n) {     if (Operators.validate(n)) {         Operators.addCap(DEMAND_FIELD_UPDATER, publisher, n).         publisher.changeToDemandState(this).     } }
false;;2;8;;@Override <T> void request(AbstractListenerReadPublisher<T> publisher, long n) {     if (Operators.validate(n)) {         Operators.addCap(DEMAND_FIELD_UPDATER, publisher, n).         // Did a concurrent read transition to NO_DEMAND just before us?         publisher.changeToDemandState(NO_DEMAND).     } }
false;;1;25;;@Override <T> void onDataAvailable(AbstractListenerReadPublisher<T> publisher) {     if (publisher.changeState(this, READING)) {         try {             boolean demandAvailable = publisher.readAndPublish().             if (demandAvailable) {                 publisher.changeToDemandState(READING).             } else {                 publisher.readingPaused().                 if (publisher.changeState(READING, NO_DEMAND)) {                     // Demand may have arrived since readAndPublish returned                     long r = publisher.demand.                     if (r > 0) {                         publisher.changeToDemandState(NO_DEMAND).                     }                 }             }         } catch (IOException ex) {             publisher.onError(ex).         }     } // Else, either competing onDataAvailable (request vs container), or concurrent completion }
false;;2;8;;@Override <T> void request(AbstractListenerReadPublisher<T> publisher, long n) {     if (Operators.validate(n)) {         Operators.addCap(DEMAND_FIELD_UPDATER, publisher, n).         // Did a concurrent read transition to NO_DEMAND just before us?         publisher.changeToDemandState(NO_DEMAND).     } }
false;;2;4;;@Override <T> void request(AbstractListenerReadPublisher<T> publisher, long n) { // ignore }
false;;1;4;;@Override <T> void cancel(AbstractListenerReadPublisher<T> publisher) { // ignore }
false;;1;4;;@Override <T> void onAllDataRead(AbstractListenerReadPublisher<T> publisher) { // ignore }
false;;2;4;;@Override <T> void onError(AbstractListenerReadPublisher<T> publisher, Throwable t) { // ignore }
false;;2;3;;<T> void subscribe(AbstractListenerReadPublisher<T> publisher, Subscriber<? super T> subscriber) {     throw new IllegalStateException(toString()). }
false;;2;3;;<T> void request(AbstractListenerReadPublisher<T> publisher, long n) {     throw new IllegalStateException(toString()). }
false;;1;8;;<T> void cancel(AbstractListenerReadPublisher<T> publisher) {     if (publisher.changeState(this, COMPLETED)) {         publisher.discardData().     } else {         publisher.state.get().cancel(publisher).     } }
false;;1;3;;<T> void onDataAvailable(AbstractListenerReadPublisher<T> publisher) { // ignore }
false;;1;11;;<T> void onAllDataRead(AbstractListenerReadPublisher<T> publisher) {     if (publisher.changeState(this, COMPLETED)) {         Subscriber<? super T> s = publisher.subscriber.         if (s != null) {             s.onComplete().         }     } else {         publisher.state.get().onAllDataRead(publisher).     } }
false;;2;12;;<T> void onError(AbstractListenerReadPublisher<T> publisher, Throwable t) {     if (publisher.changeState(this, COMPLETED)) {         publisher.discardData().         Subscriber<? super T> s = publisher.subscriber.         if (s != null) {             s.onError(t).         }     } else {         publisher.state.get().onError(publisher, t).     } }
