# id;timestamp;commentText;codeText;commentWords;codeWords
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1501676476;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1501679128;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1501684266;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1501690296;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1502700327;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1502717619;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1502726139;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1504818226;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1506416353;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1508532146;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1510948997;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1520528267;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1524865018;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1530174524;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1530174524;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> PathMatchInfo -> public Map<String, String> getUriVariables();1530174524;Return the extracted URI variables.;public Map<String, String> getUriVariables() {_			return this.uriVariables__		};return,the,extracted,uri,variables;public,map,string,string,get,uri,variables,return,this,uri,variables
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1501679128;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1501684266;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1501690296;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1502700327;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1502717619;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1502726139;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1504818226;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1506416353;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1508532146;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1510948997;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1520528267;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1524865018;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1530174524;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1530174524;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer);1530174524;Match the beginning of the given path and return the remaining portion_not covered by this pattern. This is useful for matching nested routes_where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,not,covered,by,this,pattern,this,is,useful,for,matching,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,match,start,of,path,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> public boolean matchStart(String path);1495035625;@param path the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,return,true,matching,context,matching,context,new,matching,context,path,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(String path);1495868221;@param path the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,return,true,matching,context,matching,context,new,matching,context,path,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(String path);1496259743;@param path the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,return,true,matching,context,matching,context,new,matching,context,path,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(String path);1496837955;@param path the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,return,true,matching,context,matching,context,new,matching,context,path,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(String path);1497970202;@param path the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(String path) {_		if (this.head == null) {_			return !StringUtils.hasLength(path)__		}_		else if (!StringUtils.hasLength(path)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,string,path,if,this,head,null,return,string,utils,has,length,path,else,if,string,utils,has,length,path,return,true,matching,context,matching,context,new,matching,context,path,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(String path);1498780456;@param path the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(String path) {_		if (this.head == null) {_			return !StringUtils.hasLength(path)__		}_		else if (!StringUtils.hasLength(path)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,string,path,if,this,head,null,return,string,utils,has,length,path,else,if,string,utils,has,length,path,return,true,matching,context,matching,context,new,matching,context,path,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1498861175;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1498861175;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1498861175;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1498953917;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1499081790;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1499448036;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1499763525;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1501237594;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1501531808;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1501619481;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> public boolean matchStart(PathContainer pathContainer);1501676476;@param pathContainer the path to check against the pattern_@return true if the pattern matches as much of the path as is supplied;public boolean matchStart(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return true__		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		matchingContext.setMatchStartMatching(true)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,path,to,check,against,the,pattern,return,true,if,the,pattern,matches,as,much,of,the,path,as,is,supplied;public,boolean,match,start,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,return,true,matching,context,matching,context,new,matching,context,path,container,false,matching,context,set,match,start,matching,true,return,this,head,matches,0,matching,context
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1498861175;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof Segment) {_				return ((Segment)element).valueDecoded()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,segment,return,segment,element,value,decoded,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1498861175;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof Segment) {_				return ((Segment)element).valueDecoded()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,segment,return,segment,element,value,decoded,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1498861175;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof Segment) {_				return ((Segment)element).valueDecoded()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,segment,return,segment,element,value,decoded,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1498953917;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof Segment) {_				return ((Segment)element).valueDecoded()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,segment,return,segment,element,value,decoded,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1499081790;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof Segment) {_				return ((Segment)element).valueDecoded()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,segment,return,segment,element,value,decoded,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1499448036;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof Segment) {_				return ((Segment)element).valueDecoded()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,segment,return,segment,element,value,decoded,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1499763525;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501237594;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501531808;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501619481;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501676476;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501679128;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501684266;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1501690296;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1502700327;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1502717619;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1502726139;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1504818226;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1506416353;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1508532146;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1510948997;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1520528267;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1524865018;@param pathIndex path element index_@return decoded value of the specified element;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};param,path,index,path,element,index,return,decoded,value,of,the,specified,element;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1530174524;Return the decoded value of the specified element._@param pathIndex path element index_@return the decoded value;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};return,the,decoded,value,of,the,specified,element,param,path,index,path,element,index,return,the,decoded,value;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1530174524;Return the decoded value of the specified element._@param pathIndex path element index_@return the decoded value;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < pathLength) ? pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};return,the,decoded,value,of,the,specified,element,param,path,index,path,element,index,return,the,decoded,value;string,path,element,value,int,path,index,element,element,path,index,path,length,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> MatchingContext -> String pathElementValue(int pathIndex);1530174524;Return the decoded value of the specified element._@param pathIndex path element index_@return the decoded value;String pathElementValue(int pathIndex) {_			Element element = (pathIndex < this.pathLength) ? this.pathElements.get(pathIndex) : null__			if (element instanceof PathContainer.PathSegment) {_				return ((PathContainer.PathSegment)element).valueToMatch()__			}_			return ""__		};return,the,decoded,value,of,the,specified,element,param,path,index,path,element,index,return,the,decoded,value;string,path,element,value,int,path,index,element,element,path,index,this,path,length,this,path,elements,get,path,index,null,if,element,instanceof,path,container,path,segment,return,path,container,path,segment,element,value,to,match,return
PathPattern -> public String combine(String pattern2string);1495035625;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public String combine(String pattern2string) {_		_		if (!hasLength(this.patternString)) {_			if (!hasLength(pattern2string)) {_				return ""__			}_			else {_				return pattern2string__			}_		}_		else if (!hasLength(pattern2string)) {_			return this.patternString__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string) &&this. capturedVariableCount == 0 && matches(pattern2string)) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string)__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return concat(this.patternString, pattern2string)__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		int dotPos2 = pattern2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2string : pattern2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : pattern2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return file2 + (firstExtensionWild ? secondExtension : firstExtension)__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,string,combine,string,pattern2string,if,has,length,this,pattern,string,if,has,length,pattern2string,return,else,return,pattern2string,else,if,has,length,pattern2string,return,this,pattern,string,if,this,pattern,string,equals,pattern2string,this,captured,variable,count,0,matches,pattern2string,return,pattern2string,if,this,ends,with,separator,wildcard,return,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,concat,this,pattern,string,pattern2string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,int,dot,pos2,pattern2string,index,of,string,file2,dot,pos2,1,pattern2string,pattern2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,pattern2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public String combine(String pattern2string);1495868221;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public String combine(String pattern2string) {_		_		if (!hasLength(this.patternString)) {_			if (!hasLength(pattern2string)) {_				return ""__			}_			else {_				return pattern2string__			}_		}_		else if (!hasLength(pattern2string)) {_			return this.patternString__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string) &&this. capturedVariableCount == 0 && matches(pattern2string)) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string)__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return concat(this.patternString, pattern2string)__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		int dotPos2 = pattern2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2string : pattern2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : pattern2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return file2 + (firstExtensionWild ? secondExtension : firstExtension)__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,string,combine,string,pattern2string,if,has,length,this,pattern,string,if,has,length,pattern2string,return,else,return,pattern2string,else,if,has,length,pattern2string,return,this,pattern,string,if,this,pattern,string,equals,pattern2string,this,captured,variable,count,0,matches,pattern2string,return,pattern2string,if,this,ends,with,separator,wildcard,return,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,concat,this,pattern,string,pattern2string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,int,dot,pos2,pattern2string,index,of,string,file2,dot,pos2,1,pattern2string,pattern2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,pattern2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public String combine(String pattern2string);1496259743;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public String combine(String pattern2string) {_		_		if (!hasLength(this.patternString)) {_			if (!hasLength(pattern2string)) {_				return ""__			}_			else {_				return pattern2string__			}_		}_		else if (!hasLength(pattern2string)) {_			return this.patternString__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string) &&this. capturedVariableCount == 0 && matches(pattern2string)) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string)__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return concat(this.patternString, pattern2string)__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		int dotPos2 = pattern2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2string : pattern2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : pattern2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return file2 + (firstExtensionWild ? secondExtension : firstExtension)__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,string,combine,string,pattern2string,if,has,length,this,pattern,string,if,has,length,pattern2string,return,else,return,pattern2string,else,if,has,length,pattern2string,return,this,pattern,string,if,this,pattern,string,equals,pattern2string,this,captured,variable,count,0,matches,pattern2string,return,pattern2string,if,this,ends,with,separator,wildcard,return,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,concat,this,pattern,string,pattern2string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,int,dot,pos2,pattern2string,index,of,string,file2,dot,pos2,1,pattern2string,pattern2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,pattern2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public String combine(String pattern2string);1496837955;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public String combine(String pattern2string) {_		_		if (!hasLength(this.patternString)) {_			if (!hasLength(pattern2string)) {_				return ""__			}_			else {_				return pattern2string__			}_		}_		else if (!hasLength(pattern2string)) {_			return this.patternString__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string) &&this. capturedVariableCount == 0 && matches(pattern2string)) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string)__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return concat(this.patternString, pattern2string)__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		int dotPos2 = pattern2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2string : pattern2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : pattern2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return file2 + (firstExtensionWild ? secondExtension : firstExtension)__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,string,combine,string,pattern2string,if,has,length,this,pattern,string,if,has,length,pattern2string,return,else,return,pattern2string,else,if,has,length,pattern2string,return,this,pattern,string,if,this,pattern,string,equals,pattern2string,this,captured,variable,count,0,matches,pattern2string,return,pattern2string,if,this,ends,with,separator,wildcard,return,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,concat,this,pattern,string,pattern2string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,int,dot,pos2,pattern2string,index,of,string,file2,dot,pos2,1,pattern2string,pattern2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,pattern2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public String combine(String pattern2string);1497970202;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public String combine(String pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string)) {_				return ""__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string)) {_			return this.patternString__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string) &&this. capturedVariableCount == 0 && matches(pattern2string)) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string)__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return concat(this.patternString, pattern2string)__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		int dotPos2 = pattern2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2string : pattern2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : pattern2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return file2 + (firstExtensionWild ? secondExtension : firstExtension)__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,string,combine,string,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,return,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,return,this,pattern,string,if,this,pattern,string,equals,pattern2string,this,captured,variable,count,0,matches,pattern2string,return,pattern2string,if,this,ends,with,separator,wildcard,return,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,concat,this,pattern,string,pattern2string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,int,dot,pos2,pattern2string,index,of,string,file2,dot,pos2,1,pattern2string,pattern2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,pattern2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public String combine(String pattern2string);1498780456;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public String combine(String pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string)) {_				return ""__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string)) {_			return this.patternString__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string) &&this. capturedVariableCount == 0 && matches(pattern2string)) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string)__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return concat(this.patternString, pattern2string)__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		int dotPos2 = pattern2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2string : pattern2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : pattern2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return file2 + (firstExtensionWild ? secondExtension : firstExtension)__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,string,combine,string,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,return,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,return,this,pattern,string,if,this,pattern,string,equals,pattern2string,this,captured,variable,count,0,matches,pattern2string,return,pattern2string,if,this,ends,with,separator,wildcard,return,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,concat,this,pattern,string,pattern2string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,int,dot,pos2,pattern2string,index,of,string,file2,dot,pos2,1,pattern2string,pattern2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,pattern2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,file2,first,extension,wild,second,extension,first,extension
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(@Nullable PathContainer pathContainer);1498861175;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(@Nullable PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getExtractedVariables())__			}_			else {_				info = new PathRemainingMatchInfo(PathContainer.subPath(pathContainer, matchingContext.remainingPathIndex),_						 matchingContext.getExtractedVariables())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,nullable,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,extracted,variables,else,info,new,path,remaining,match,info,path,container,sub,path,path,container,matching,context,remaining,path,index,matching,context,get,extracted,variables,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(@Nullable PathContainer pathContainer);1498861175;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(@Nullable PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(PathContainer.subPath(pathContainer, matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,nullable,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,path,container,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1498861175;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(PathContainer.subPath(pathContainer, matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,path,container,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1498953917;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(PathContainer.subPath(pathContainer, matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,path,container,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1499081790;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(PathContainer.subPath(pathContainer, matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,path,container,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1499448036;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(PathContainer.subPath(pathContainer, matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,path,container,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1499763525;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1501237594;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1501531808;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1501619481;For a given path return the remaining piece that is not covered by this PathPattern._@param pathContainer a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,container,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer);1501676476;Match the beginning of the given path and return the remaining portion of_the path not covered by this pattern. This is useful for matching through_nested routes where the path is matched incrementally at each level._@param pathContainer the candidate path to attempt to match against_@return info object with the match result or {@code null} for no match;@Nullable_	public PathRemainingMatchInfo getPathRemaining(PathContainer pathContainer) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {_				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult())__			}_			else {_				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),_						 matchingContext.getPathMatchResult())__			}_			return info__		}_	};match,the,beginning,of,the,given,path,and,return,the,remaining,portion,of,the,path,not,covered,by,this,pattern,this,is,useful,for,matching,through,nested,routes,where,the,path,is,matched,incrementally,at,each,level,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,match,result,or,code,null,for,no,match;nullable,public,path,remaining,match,info,get,path,remaining,path,container,path,container,if,this,head,null,return,new,path,remaining,match,info,path,container,else,if,has,length,path,container,return,null,matching,context,matching,context,new,matching,context,path,container,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,container,elements,size,info,new,path,remaining,match,info,matching,context,get,path,match,result,else,info,new,path,remaining,match,info,path,container,sub,path,matching,context,remaining,path,index,matching,context,get,path,match,result,return,info
PathPattern -> public boolean matches(PathContainer pathContainer);1498861175;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1498861175;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1498861175;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1498953917;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1499081790;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1499448036;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1499763525;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501237594;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501531808;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501619481;@param pathContainer the candidate path container to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};param,path,container,the,candidate,path,container,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501676476;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501679128;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501684266;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1501690296;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1502700327;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1502717619;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1502726139;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1504818226;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer)__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1506416353;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) || _				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1508532146;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) || _				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1510948997;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) || _				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1520528267;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) || _				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1524865018;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) || _				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1530174524;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) ||_				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1530174524;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) ||_				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(PathContainer pathContainer);1530174524;Whether this pattern matches the given path._@param pathContainer the candidate path to attempt to match against_@return {@code true} if the path matches this pattern;public boolean matches(PathContainer pathContainer) {_		if (this.head == null) {_			return !hasLength(pathContainer) ||_				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, false)__		return this.head.matches(0, matchingContext)__	};whether,this,pattern,matches,the,given,path,param,path,container,the,candidate,path,to,attempt,to,match,against,return,code,true,if,the,path,matches,this,pattern;public,boolean,matches,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,false,matching,context,matching,context,new,matching,context,path,container,false,return,this,head,matches,0,matching,context
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getMatchingVariables();1495035625;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getMatchingVariables() {_			return this.matchingVariables__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,matching,variables,return,this,matching,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getMatchingVariables();1495868221;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getMatchingVariables() {_			return this.matchingVariables__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,matching,variables,return,this,matching,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getMatchingVariables();1496259743;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getMatchingVariables() {_			return this.matchingVariables__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,matching,variables,return,this,matching,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getMatchingVariables();1496837955;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getMatchingVariables() {_			return this.matchingVariables__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,matching,variables,return,this,matching,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getMatchingVariables();1497970202;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getMatchingVariables() {_			return this.matchingVariables__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,matching,variables,return,this,matching,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getMatchingVariables();1498780456;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getMatchingVariables() {_			return this.matchingVariables__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,matching,variables,return,this,matching,variables
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(String path);1495868221;For a given path return the remaining piece that is not covered by this PathPattern._@param path a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result or null if_the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(String path) {_		if (this.head == null) {_			if (path == null) {_				return new PathRemainingMatchInfo(null)__			}_			else {_				return new PathRemainingMatchInfo(hasLength(path) ? path : "")__			}_		}_		else if (!hasLength(path)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(path, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == path.length()) {_				info = new PathRemainingMatchInfo("", matchingContext.getExtractedVariables())__			}_			else {_				info = new PathRemainingMatchInfo(path.substring(matchingContext.remainingPathIndex),_						 matchingContext.getExtractedVariables())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,string,path,if,this,head,null,if,path,null,return,new,path,remaining,match,info,null,else,return,new,path,remaining,match,info,has,length,path,path,else,if,has,length,path,return,null,matching,context,matching,context,new,matching,context,path,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,length,info,new,path,remaining,match,info,matching,context,get,extracted,variables,else,info,new,path,remaining,match,info,path,substring,matching,context,remaining,path,index,matching,context,get,extracted,variables,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(String path);1496259743;For a given path return the remaining piece that is not covered by this PathPattern._@param path a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result or null if_the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(String path) {_		if (this.head == null) {_			if (path == null) {_				return new PathRemainingMatchInfo(null)__			}_			else {_				return new PathRemainingMatchInfo(hasLength(path) ? path : "")__			}_		}_		else if (!hasLength(path)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(path, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == path.length()) {_				info = new PathRemainingMatchInfo("", matchingContext.getExtractedVariables())__			}_			else {_				info = new PathRemainingMatchInfo(path.substring(matchingContext.remainingPathIndex),_						 matchingContext.getExtractedVariables())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,string,path,if,this,head,null,if,path,null,return,new,path,remaining,match,info,null,else,return,new,path,remaining,match,info,has,length,path,path,else,if,has,length,path,return,null,matching,context,matching,context,new,matching,context,path,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,length,info,new,path,remaining,match,info,matching,context,get,extracted,variables,else,info,new,path,remaining,match,info,path,substring,matching,context,remaining,path,index,matching,context,get,extracted,variables,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(String path);1496837955;For a given path return the remaining piece that is not covered by this PathPattern._@param path a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(String path) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(path)__		}_		else if (!hasLength(path)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(path, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == path.length()) {_				info = new PathRemainingMatchInfo("", matchingContext.getExtractedVariables())__			}_			else {_				info = new PathRemainingMatchInfo(path.substring(matchingContext.remainingPathIndex),_						 matchingContext.getExtractedVariables())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,string,path,if,this,head,null,return,new,path,remaining,match,info,path,else,if,has,length,path,return,null,matching,context,matching,context,new,matching,context,path,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,length,info,new,path,remaining,match,info,matching,context,get,extracted,variables,else,info,new,path,remaining,match,info,path,substring,matching,context,remaining,path,index,matching,context,get,extracted,variables,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(String path);1497970202;For a given path return the remaining piece that is not covered by this PathPattern._@param path a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(String path) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(path)__		}_		else if (!StringUtils.hasLength(path)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(path, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == path.length()) {_				info = new PathRemainingMatchInfo("", matchingContext.getExtractedVariables())__			}_			else {_				info = new PathRemainingMatchInfo(path.substring(matchingContext.remainingPathIndex),_						 matchingContext.getExtractedVariables())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,string,path,if,this,head,null,return,new,path,remaining,match,info,path,else,if,string,utils,has,length,path,return,null,matching,context,matching,context,new,matching,context,path,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,length,info,new,path,remaining,match,info,matching,context,get,extracted,variables,else,info,new,path,remaining,match,info,path,substring,matching,context,remaining,path,index,matching,context,get,extracted,variables,return,info
PathPattern -> @Nullable 	public PathRemainingMatchInfo getPathRemaining(String path);1498780456;For a given path return the remaining piece that is not covered by this PathPattern._@param path a path that may or may not match this path pattern_@return a {@link PathRemainingMatchInfo} describing the match result,_or {@code null} if the path does not match this pattern;@Nullable_	public PathRemainingMatchInfo getPathRemaining(String path) {_		if (this.head == null) {_			return new PathRemainingMatchInfo(path)__		}_		else if (!StringUtils.hasLength(path)) {_			return null__		}__		MatchingContext matchingContext = new MatchingContext(path, true)__		matchingContext.setMatchAllowExtraPath()__		boolean matches = this.head.matches(0, matchingContext)__		if (!matches) {_			return null__		}_		else {_			PathRemainingMatchInfo info__			if (matchingContext.remainingPathIndex == path.length()) {_				info = new PathRemainingMatchInfo("", matchingContext.getExtractedVariables())__			}_			else {_				info = new PathRemainingMatchInfo(path.substring(matchingContext.remainingPathIndex),_						 matchingContext.getExtractedVariables())__			}_			return info__		}_	};for,a,given,path,return,the,remaining,piece,that,is,not,covered,by,this,path,pattern,param,path,a,path,that,may,or,may,not,match,this,path,pattern,return,a,link,path,remaining,match,info,describing,the,match,result,or,code,null,if,the,path,does,not,match,this,pattern;nullable,public,path,remaining,match,info,get,path,remaining,string,path,if,this,head,null,return,new,path,remaining,match,info,path,else,if,string,utils,has,length,path,return,null,matching,context,matching,context,new,matching,context,path,true,matching,context,set,match,allow,extra,path,boolean,matches,this,head,matches,0,matching,context,if,matches,return,null,else,path,remaining,match,info,info,if,matching,context,remaining,path,index,path,length,info,new,path,remaining,match,info,matching,context,get,extracted,variables,else,info,new,path,remaining,match,info,path,substring,matching,context,remaining,path,index,matching,context,get,extracted,variables,return,info
PathPattern -> public boolean matches(String path);1495035625;@param path the candidate path to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				path = ""_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		return this.head.matches(0, matchingContext)__	};param,path,the,candidate,path,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,else,return,false,matching,context,matching,context,new,matching,context,path,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(String path);1495868221;@param path the candidate path to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				path = ""_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		return this.head.matches(0, matchingContext)__	};param,path,the,candidate,path,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,else,return,false,matching,context,matching,context,new,matching,context,path,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(String path);1496259743;@param path the candidate path to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				path = ""_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		return this.head.matches(0, matchingContext)__	};param,path,the,candidate,path,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,else,return,false,matching,context,matching,context,new,matching,context,path,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(String path);1496837955;@param path the candidate path to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(String path) {_		if (this.head == null) {_			return !hasLength(path)__		}_		else if (!hasLength(path)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				path = ""_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		return this.head.matches(0, matchingContext)__	};param,path,the,candidate,path,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,string,path,if,this,head,null,return,has,length,path,else,if,has,length,path,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,else,return,false,matching,context,matching,context,new,matching,context,path,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(String path);1497970202;@param path the candidate path to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(String path) {_		if (this.head == null) {_			return !StringUtils.hasLength(path)__		}_		else if (!StringUtils.hasLength(path)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				path = ""_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		return this.head.matches(0, matchingContext)__	};param,path,the,candidate,path,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,string,path,if,this,head,null,return,string,utils,has,length,path,else,if,string,utils,has,length,path,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,else,return,false,matching,context,matching,context,new,matching,context,path,false,return,this,head,matches,0,matching,context
PathPattern -> public boolean matches(String path);1498780456;@param path the candidate path to attempt to match against this pattern_@return true if the path matches this pattern;public boolean matches(String path) {_		if (this.head == null) {_			return !StringUtils.hasLength(path)__		}_		else if (!StringUtils.hasLength(path)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				path = ""_ _			}_			else {_				return false__			}_		}_		MatchingContext matchingContext = new MatchingContext(path, false)__		return this.head.matches(0, matchingContext)__	};param,path,the,candidate,path,to,attempt,to,match,against,this,pattern,return,true,if,the,path,matches,this,pattern;public,boolean,matches,string,path,if,this,head,null,return,string,utils,has,length,path,else,if,string,utils,has,length,path,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,else,return,false,matching,context,matching,context,new,matching,context,path,false,return,this,head,matches,0,matching,context
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1498861175;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1498953917;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1499081790;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1499448036;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1499763525;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501237594;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501531808;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501619481;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501676476;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501679128;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501684266;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1501690296;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1502700327;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1502717619;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1502726139;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1504818226;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1506416353;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1508532146;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1510948997;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1520528267;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1524865018;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1530174524;Return if the container is not null and has more than zero elements._@param container a path container_@return {@code true} has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};return,if,the,container,is,not,null,and,has,more,than,zero,elements,param,container,a,path,container,return,code,true,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1530174524;Return if the container is not null and has more than zero elements._@param container a path container_@return {@code true} has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};return,if,the,container,is,not,null,and,has,more,than,zero,elements,param,container,a,path,container,return,code,true,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(@Nullable PathContainer container);1530174524;Return if the container is not null and has more than zero elements._@param container a path container_@return {@code true} has more than zero elements;private boolean hasLength(@Nullable PathContainer container) {_		return container != null && container.elements().size() > 0__	};return,if,the,container,is,not,null,and,has,more,than,zero,elements,param,container,a,path,container,return,code,true,has,more,than,zero,elements;private,boolean,has,length,nullable,path,container,container,return,container,null,container,elements,size,0
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1498861175;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1498861175;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1498953917;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1499081790;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1499448036;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1499763525;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501237594;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501531808;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501619481;Return variables that were bound in the part of the path that was successfully matched._Will be an empty map if no variables were bound;public Map<String, String> getUriVariables() {_			return this.pathMatchResult.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,will,be,an,empty,map,if,no,variables,were,bound;public,map,string,string,get,uri,variables,return,this,path,match,result,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501676476;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501679128;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501684266;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1501690296;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1502700327;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1502717619;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1502726139;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1504818226;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1506416353;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1508532146;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1510948997;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1520528267;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1524865018;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1530174524;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1530174524;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, String> getUriVariables();1530174524;Return variables that were bound in the part of the path that was_successfully matched or an empty map.;public Map<String, String> getUriVariables() {_			return this.pathMatchInfo.getUriVariables()__		};return,variables,that,were,bound,in,the,part,of,the,path,that,was,successfully,matched,or,an,empty,map;public,map,string,string,get,uri,variables,return,this,path,match,info,get,uri,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1498861175;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1498861175;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1498953917;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1499081790;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1499448036;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1499763525;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501237594;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501531808;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501619481;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchResult.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,result,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501676476;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501679128;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501684266;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501690296;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1502700327;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1502717619;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1502726139;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1504818226;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1506416353;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1508532146;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1510948997;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1520528267;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1524865018;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1530174524;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1530174524;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathRemainingMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1530174524;Return the path parameters for each bound variable.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.pathMatchInfo.getMatrixVariables()__		};return,the,path,parameters,for,each,bound,variable;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,path,match,info,get,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501676476;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501679128;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501684266;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1501690296;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1502700327;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1502717619;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1502726139;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1504818226;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1506416353;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1508532146;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1510948997;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1520528267;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1524865018;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1530174524;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1530174524;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> PathMatchInfo -> public Map<String, MultiValueMap<String, String>> getMatrixVariables();1530174524;Return maps of matrix variables per path segment, keyed off by URI_variable name.;public Map<String, MultiValueMap<String, String>> getMatrixVariables() {_			return this.matrixVariables__		};return,maps,of,matrix,variables,per,path,segment,keyed,off,by,uri,variable,name;public,map,string,multi,value,map,string,string,get,matrix,variables,return,this,matrix,variables
PathPattern -> int getNormalizedLength();1495035625;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1495868221;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1496259743;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1496837955;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1497970202;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1498780456;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1498861175;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1498861175;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1498861175;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1498953917;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1499081790;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1499448036;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1499763525;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501237594;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501531808;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501619481;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501676476;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501679128;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501684266;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1501690296;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1502700327;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1502717619;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1502726139;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1504818226;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1506416353;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1508532146;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1510948997;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1520528267;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1524865018;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1530174524;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1530174524;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> int getNormalizedLength();1530174524;The normalized length is trying to measure the 'active' part of the pattern. It is computed_by assuming all capture variables have a normalized length of 1. Effectively this means changing_your variable name lengths isn't going to change the length of the active part of the pattern._Useful when comparing two patterns.;int getNormalizedLength() {_		return this.normalizedLength__	};the,normalized,length,is,trying,to,measure,the,active,part,of,the,pattern,it,is,computed,by,assuming,all,capture,variables,have,a,normalized,length,of,1,effectively,this,means,changing,your,variable,name,lengths,isn,t,going,to,change,the,length,of,the,active,part,of,the,pattern,useful,when,comparing,two,patterns;int,get,normalized,length,return,this,normalized,length
PathPattern -> private boolean hasLength(PathContainer container);1498861175;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,path,container,container,return,container,null,container,elements,size,0
PathPattern -> private boolean hasLength(PathContainer container);1498861175;@param container a path container_@return true if the container is not null and has more than zero elements;private boolean hasLength(PathContainer container) {_		return container != null && container.elements().size() > 0__	};param,container,a,path,container,return,true,if,the,container,is,not,null,and,has,more,than,zero,elements;private,boolean,has,length,path,container,container,return,container,null,container,elements,size,0
PathPattern -> MatchingContext -> public int scanAhead(int pos);1495035625;Scan ahead from the specified position for either the next separator_character or the end of the candidate._@param pos the starting position for the scan_@return the position of the next separator or the end of the candidate;public int scanAhead(int pos) {_			while (pos < candidateLength) {_				if (candidate[pos] == separator) {_					return pos__				}_				pos++__			}_			return candidateLength__		};scan,ahead,from,the,specified,position,for,either,the,next,separator,character,or,the,end,of,the,candidate,param,pos,the,starting,position,for,the,scan,return,the,position,of,the,next,separator,or,the,end,of,the,candidate;public,int,scan,ahead,int,pos,while,pos,candidate,length,if,candidate,pos,separator,return,pos,pos,return,candidate,length
PathPattern -> MatchingContext -> public int scanAhead(int pos);1495868221;Scan ahead from the specified position for either the next separator_character or the end of the candidate._@param pos the starting position for the scan_@return the position of the next separator or the end of the candidate;public int scanAhead(int pos) {_			while (pos < candidateLength) {_				if (candidate[pos] == separator) {_					return pos__				}_				pos++__			}_			return candidateLength__		};scan,ahead,from,the,specified,position,for,either,the,next,separator,character,or,the,end,of,the,candidate,param,pos,the,starting,position,for,the,scan,return,the,position,of,the,next,separator,or,the,end,of,the,candidate;public,int,scan,ahead,int,pos,while,pos,candidate,length,if,candidate,pos,separator,return,pos,pos,return,candidate,length
PathPattern -> MatchingContext -> public int scanAhead(int pos);1496259743;Scan ahead from the specified position for either the next separator_character or the end of the candidate._@param pos the starting position for the scan_@return the position of the next separator or the end of the candidate;public int scanAhead(int pos) {_			while (pos < candidateLength) {_				if (candidate[pos] == separator) {_					return pos__				}_				pos++__			}_			return candidateLength__		};scan,ahead,from,the,specified,position,for,either,the,next,separator,character,or,the,end,of,the,candidate,param,pos,the,starting,position,for,the,scan,return,the,position,of,the,next,separator,or,the,end,of,the,candidate;public,int,scan,ahead,int,pos,while,pos,candidate,length,if,candidate,pos,separator,return,pos,pos,return,candidate,length
PathPattern -> MatchingContext -> public int scanAhead(int pos);1496837955;Scan ahead from the specified position for either the next separator_character or the end of the candidate._@param pos the starting position for the scan_@return the position of the next separator or the end of the candidate;public int scanAhead(int pos) {_			while (pos < candidateLength) {_				if (candidate[pos] == separator) {_					return pos__				}_				pos++__			}_			return candidateLength__		};scan,ahead,from,the,specified,position,for,either,the,next,separator,character,or,the,end,of,the,candidate,param,pos,the,starting,position,for,the,scan,return,the,position,of,the,next,separator,or,the,end,of,the,candidate;public,int,scan,ahead,int,pos,while,pos,candidate,length,if,candidate,pos,separator,return,pos,pos,return,candidate,length
PathPattern -> MatchingContext -> public int scanAhead(int pos);1497970202;Scan ahead from the specified position for either the next separator_character or the end of the candidate._@param pos the starting position for the scan_@return the position of the next separator or the end of the candidate;public int scanAhead(int pos) {_			while (pos < candidateLength) {_				if (candidate[pos] == separator) {_					return pos__				}_				pos++__			}_			return candidateLength__		};scan,ahead,from,the,specified,position,for,either,the,next,separator,character,or,the,end,of,the,candidate,param,pos,the,starting,position,for,the,scan,return,the,position,of,the,next,separator,or,the,end,of,the,candidate;public,int,scan,ahead,int,pos,while,pos,candidate,length,if,candidate,pos,separator,return,pos,pos,return,candidate,length
PathPattern -> MatchingContext -> public int scanAhead(int pos);1498780456;Scan ahead from the specified position for either the next separator_character or the end of the candidate._@param pos the starting position for the scan_@return the position of the next separator or the end of the candidate;public int scanAhead(int pos) {_			while (pos < candidateLength) {_				if (candidate[pos] == separator) {_					return pos__				}_				pos++__			}_			return candidateLength__		};scan,ahead,from,the,specified,position,for,either,the,next,separator,character,or,the,end,of,the,candidate,param,pos,the,starting,position,for,the,scan,return,the,position,of,the,next,separator,or,the,end,of,the,candidate;public,int,scan,ahead,int,pos,while,pos,candidate,length,if,candidate,pos,separator,return,pos,pos,return,candidate,length
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1495035625;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1495868221;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1496259743;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1496837955;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1497970202;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1498780456;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1498861175;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining == null ? null: this.pathRemaining.value()__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining,null,null,this,path,remaining,value
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1498861175;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining == null ? null: this.pathRemaining.value()__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining,null,null,this,path,remaining,value
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1498861175;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining.value()__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining,value
PathPattern -> PathRemainingMatchInfo -> public String getPathRemaining();1498953917;Return the part of a path that was not matched by a pattern.;public String getPathRemaining() {_			return this.pathRemaining.value()__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,string,get,path,remaining,return,this,path,remaining,value
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1499081790;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1499448036;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1499763525;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501237594;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501531808;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501619481;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501676476;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501679128;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501684266;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1501690296;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1502700327;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1502717619;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1502726139;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1504818226;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1506416353;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1508532146;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1510948997;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1520528267;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1524865018;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1530174524;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1530174524;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> PathRemainingMatchInfo -> public PathContainer getPathRemaining();1530174524;Return the part of a path that was not matched by a pattern.;public PathContainer getPathRemaining() {_			return this.pathRemaining__		};return,the,part,of,a,path,that,was,not,matched,by,a,pattern;public,path,container,get,path,remaining,return,this,path,remaining
PathPattern -> public Map<String, String> matchAndExtract(String path);1495035625;@param path a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public Map<String, String> matchAndExtract(String path) {_		MatchingContext matchingContext = new MatchingContext(path, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getExtractedVariables()__		}_		else {_			if (!hasLength(path)) {_				return Collections.emptyMap()__			}_			else {_				throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + path + "\"")__			}_		}_	};param,path,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,map,string,string,match,and,extract,string,path,matching,context,matching,context,new,matching,context,path,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,extracted,variables,else,if,has,length,path,return,collections,empty,map,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path
PathPattern -> public Map<String, String> matchAndExtract(String path);1495868221;@param path a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public Map<String, String> matchAndExtract(String path) {_		MatchingContext matchingContext = new MatchingContext(path, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getExtractedVariables()__		}_		else {_			if (!hasLength(path)) {_				return Collections.emptyMap()__			}_			else {_				throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + path + "\"")__			}_		}_	};param,path,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,map,string,string,match,and,extract,string,path,matching,context,matching,context,new,matching,context,path,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,extracted,variables,else,if,has,length,path,return,collections,empty,map,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path
PathPattern -> public Map<String, String> matchAndExtract(String path);1496259743;@param path a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public Map<String, String> matchAndExtract(String path) {_		MatchingContext matchingContext = new MatchingContext(path, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getExtractedVariables()__		}_		else {_			if (!hasLength(path)) {_				return Collections.emptyMap()__			}_			else {_				throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + path + "\"")__			}_		}_	};param,path,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,map,string,string,match,and,extract,string,path,matching,context,matching,context,new,matching,context,path,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,extracted,variables,else,if,has,length,path,return,collections,empty,map,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path
PathPattern -> public Map<String, String> matchAndExtract(String path);1496837955;@param path a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public Map<String, String> matchAndExtract(String path) {_		MatchingContext matchingContext = new MatchingContext(path, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getExtractedVariables()__		}_		else {_			if (!hasLength(path)) {_				return Collections.emptyMap()__			}_			else {_				throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + path + "\"")__			}_		}_	};param,path,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,map,string,string,match,and,extract,string,path,matching,context,matching,context,new,matching,context,path,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,extracted,variables,else,if,has,length,path,return,collections,empty,map,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path
PathPattern -> public Map<String, String> matchAndExtract(String path);1497970202;@param path a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public Map<String, String> matchAndExtract(String path) {_		MatchingContext matchingContext = new MatchingContext(path, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getExtractedVariables()__		}_		else if (!StringUtils.hasLength(path)) {_			return Collections.emptyMap()__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + path + "\"")__		}_	};param,path,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,map,string,string,match,and,extract,string,path,matching,context,matching,context,new,matching,context,path,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,extracted,variables,else,if,string,utils,has,length,path,return,collections,empty,map,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path
PathPattern -> public Map<String, String> matchAndExtract(String path);1498780456;@param path a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public Map<String, String> matchAndExtract(String path) {_		MatchingContext matchingContext = new MatchingContext(path, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getExtractedVariables()__		}_		else if (!StringUtils.hasLength(path)) {_			return Collections.emptyMap()__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + path + "\"")__		}_	};param,path,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,map,string,string,match,and,extract,string,path,matching,context,matching,context,new,matching,context,path,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,extracted,variables,else,if,string,utils,has,length,path,return,collections,empty,map,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1501684266;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) ? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1501690296;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) ? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1502700327;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) ? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1502717619;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) ? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1502726139;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) ? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1504818226;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) ? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1506416353;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1508532146;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1510948997;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1520528267;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1524865018;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1530174524;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1530174524;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> @Nullable 	public PathMatchInfo matchAndExtract(PathContainer pathContainer);1530174524;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables, or {@code null} for no match;@Nullable_	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		if (this.head == null) {_			return hasLength(pathContainer) &&_				!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer))_				? null : PathMatchInfo.EMPTY__		}_		else if (!hasLength(pathContainer)) {_			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {_				pathContainer = EMPTY_PATH_ _			}_			else {_				return null__			}_		}_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null__	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,or,code,null,for,no,match;nullable,public,path,match,info,match,and,extract,path,container,path,container,if,this,head,null,return,has,length,path,container,this,match,optional,trailing,separator,path,container,is,just,separator,path,container,null,path,match,info,empty,else,if,has,length,path,container,if,this,head,instanceof,wildcard,the,rest,path,element,this,head,instanceof,capture,the,rest,path,element,path,container,else,return,null,matching,context,matching,context,new,matching,context,path,container,true,return,this,head,matches,0,matching,context,matching,context,get,path,match,result,null
PathPattern -> public PathMatchInfo matchAndExtract(PathContainer pathContainer);1501676476;Match this pattern to the given URI path and extract URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables_@throws IllegalStateException if the path does not match the pattern;public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchInfo.EMPTY__		}_		else {_			throw new IllegalStateException(_					"Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};match,this,pattern,to,the,given,uri,path,and,extract,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,info,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,info,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchInfo matchAndExtract(PathContainer pathContainer);1501679128;Match this pattern to the given URI path and return extracted URI template_variables as well as path parameters (matrix variables)._@param pathContainer the candidate path to attempt to match against_@return info object with the extracted variables_@throws IllegalStateException if the path does not match the pattern;public PathMatchInfo matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchInfo.EMPTY__		}_		else {_			throw new IllegalStateException(_					"Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};match,this,pattern,to,the,given,uri,path,and,return,extracted,uri,template,variables,as,well,as,path,parameters,matrix,variables,param,path,container,the,candidate,path,to,attempt,to,match,against,return,info,object,with,the,extracted,variables,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,info,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,info,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public String getPatternString();1495035625;Return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1495868221;Return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1496259743;Return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1496837955;Return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1497970202;Return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1498780456;Return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1498861175;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1498861175;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1498861175;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1498953917;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1499081790;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1499448036;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1499763525;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501237594;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501531808;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501619481;@return the original pattern string that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,pattern,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501676476;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501679128;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501684266;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1501690296;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1502700327;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1502717619;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1502726139;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1504818226;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1506416353;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1508532146;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1510948997;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1520528267;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1524865018;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1530174524;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1530174524;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public String getPatternString();1530174524;Return the original String that was parsed to create this PathPattern.;public String getPatternString() {_		return this.patternString__	};return,the,original,string,that,was,parsed,to,create,this,path,pattern;public,string,get,pattern,string,return,this,pattern,string
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1498861175;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1498861175;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1498953917;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1499081790;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1499448036;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1499763525;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1501237594;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1501531808;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> public PathMatchResult matchAndExtract(PathContainer pathContainer);1501619481;@param pathContainer a path that matches this pattern from which to extract variables_@return a map of extracted variables - an empty map if no variables extracted._@throws IllegalStateException if the path does not match the pattern;public PathMatchResult matchAndExtract(PathContainer pathContainer) {_		MatchingContext matchingContext = new MatchingContext(pathContainer, true)__		if (this.head != null && this.head.matches(0, matchingContext)) {_			return matchingContext.getPathMatchResult()__		}_		else if (!hasLength(pathContainer)) {_			return PathMatchResult.EMPTY__		}_		else {_			throw new IllegalStateException("Pattern \"" + this + "\" is not a match for \"" + pathContainer.value() + "\"")__		}_	};param,path,container,a,path,that,matches,this,pattern,from,which,to,extract,variables,return,a,map,of,extracted,variables,an,empty,map,if,no,variables,extracted,throws,illegal,state,exception,if,the,path,does,not,match,the,pattern;public,path,match,result,match,and,extract,path,container,path,container,matching,context,matching,context,new,matching,context,path,container,true,if,this,head,null,this,head,matches,0,matching,context,return,matching,context,get,path,match,result,else,if,has,length,path,container,return,path,match,result,empty,else,throw,new,illegal,state,exception,pattern,this,is,not,a,match,for,path,container,value
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1498861175;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1498861175;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1498861175;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1498953917;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1499081790;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1499448036;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1499763525;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501237594;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501531808;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501619481;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501676476;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501679128;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501684266;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1501690296;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1502700327;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1502717619;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1502726139;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1504818226;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1506416353;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1508532146;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1510948997;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1520528267;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1524865018;@param pathIndex possible index of a separator_@return true if element at specified index is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};param,path,index,possible,index,of,a,separator,return,true,if,element,at,specified,index,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1530174524;Return if element at specified index is a separator._@param pathIndex possible index of a separator_@return {@code true} if element is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};return,if,element,at,specified,index,is,a,separator,param,path,index,possible,index,of,a,separator,return,code,true,if,element,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1530174524;Return if element at specified index is a separator._@param pathIndex possible index of a separator_@return {@code true} if element is a separator;boolean isSeparator(int pathIndex) {_			return pathElements.get(pathIndex) instanceof Separator__		};return,if,element,at,specified,index,is,a,separator,param,path,index,possible,index,of,a,separator,return,code,true,if,element,is,a,separator;boolean,is,separator,int,path,index,return,path,elements,get,path,index,instanceof,separator
PathPattern -> MatchingContext -> boolean isSeparator(int pathIndex);1530174524;Return if element at specified index is a separator._@param pathIndex possible index of a separator_@return {@code true} if element is a separator;boolean isSeparator(int pathIndex) {_			return this.pathElements.get(pathIndex) instanceof Separator__		};return,if,element,at,specified,index,is,a,separator,param,path,index,possible,index,of,a,separator,return,code,true,if,element,is,a,separator;boolean,is,separator,int,path,index,return,this,path,elements,get,path,index,instanceof,separator
PathPattern -> private String concat(String path1, String path2);1495035625;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1495868221;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1496259743;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1496837955;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1497970202;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1498780456;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1498861175;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1498861175;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1498861175;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1498953917;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1499081790;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1499448036;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1499763525;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501237594;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501531808;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501619481;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501676476;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501679128;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501684266;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1501690296;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1502700327;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1502717619;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1502726139;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1504818226;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1506416353;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1508532146;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1510948997;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1520528267;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1524865018;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1530174524;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1530174524;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> private String concat(String path1, String path2);1530174524;Join two paths together including a separator if necessary._Extraneous separators are removed (if the first path_ends with one and the second path starts with one)._@param path1 first path_@param path2 second path_@return joined path that may include separator if necessary;private String concat(String path1, String path2) {_		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator)__		boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator)__		if (path1EndsWithSeparator && path2StartsWithSeparator) {_			return path1 + path2.substring(1)__		}_		else if (path1EndsWithSeparator || path2StartsWithSeparator) {_			return path1 + path2__		}_		else {_			return path1 + this.separator + path2__		}_	};join,two,paths,together,including,a,separator,if,necessary,extraneous,separators,are,removed,if,the,first,path,ends,with,one,and,the,second,path,starts,with,one,param,path1,first,path,param,path2,second,path,return,joined,path,that,may,include,separator,if,necessary;private,string,concat,string,path1,string,path2,boolean,path1ends,with,separator,path1,char,at,path1,length,1,this,separator,boolean,path2starts,with,separator,path2,char,at,0,this,separator,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,substring,1,else,if,path1ends,with,separator,path2starts,with,separator,return,path1,path2,else,return,path1,this,separator,path2
PathPattern -> public PathPattern combine(PathPattern pattern2string);1498861175;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parse(pattern2string.patternString, StandardCharsets.UTF_8))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,pattern2string,pattern,string,standard,charsets,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1498861175;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parse(pattern2string.patternString, StandardCharsets.UTF_8))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,pattern2string,pattern,string,standard,charsets,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1498861175;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parse(pattern2string.patternString, StandardCharsets.UTF_8))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,pattern2string,pattern,string,standard,charsets,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1498953917;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parse(pattern2string.patternString, StandardCharsets.UTF_8))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,pattern2string,pattern,string,standard,charsets,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1499081790;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parse(pattern2string.patternString, StandardCharsets.UTF_8))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,pattern2string,pattern,string,standard,charsets,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1499448036;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parse(pattern2string.patternString, StandardCharsets.UTF_8))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,pattern2string,pattern,string,standard,charsets,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1499763525;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parseUrlPath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,url,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501237594;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parseUrlPath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,url,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501531808;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501619481;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501676476;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501679128;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501684266;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1501690296;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1502700327;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1502717619;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1502726139;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1504818226;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1506416353;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1508532146;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1510948997;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1520528267;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1524865018;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && _				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1530174524;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 &&_				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1530174524;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 &&_				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> public PathPattern combine(PathPattern pattern2string);1530174524;Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.;public PathPattern combine(PathPattern pattern2string) {_		_		if (!StringUtils.hasLength(this.patternString)) {_			if (!StringUtils.hasLength(pattern2string.patternString)) {_				return this.parser.parse("")__			}_			else {_				return pattern2string__			}_		}_		else if (!StringUtils.hasLength(pattern2string.patternString)) {_			return this__		}__		_		_		_		_		_		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 &&_				matches(PathContainer.parsePath(pattern2string.patternString))) {_			return pattern2string__		}__		_		_		if (this.endsWithSeparatorWildcard) {_			return this.parser.parse(concat(_					this.patternString.substring(0, this.patternString.length() - 2),_					pattern2string.patternString))__		}__		_		_		int starDotPos1 = this.patternString.indexOf("*.")_  _		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {_			return this.parser.parse(concat(this.patternString, pattern2string.patternString))__		}__		_		_		String firstExtension = this.patternString.substring(starDotPos1 + 1)_  _		String p2string = pattern2string.patternString__		int dotPos2 = p2string.indexOf('.')__		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2))__		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2))__		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals(""))__		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals(""))__		if (!firstExtensionWild && !secondExtensionWild) {_			throw new IllegalArgumentException(_					"Cannot combine patterns: " + this.patternString + " and " + pattern2string)__		}_		return this.parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension))__	};combine,this,pattern,with,another,currently,does,not,produce,a,new,path,pattern,just,produces,a,new,string;public,path,pattern,combine,path,pattern,pattern2string,if,string,utils,has,length,this,pattern,string,if,string,utils,has,length,pattern2string,pattern,string,return,this,parser,parse,else,return,pattern2string,else,if,string,utils,has,length,pattern2string,pattern,string,return,this,if,this,pattern,string,equals,pattern2string,pattern,string,this,captured,variable,count,0,matches,path,container,parse,path,pattern2string,pattern,string,return,pattern2string,if,this,ends,with,separator,wildcard,return,this,parser,parse,concat,this,pattern,string,substring,0,this,pattern,string,length,2,pattern2string,pattern,string,int,star,dot,pos1,this,pattern,string,index,of,if,this,captured,variable,count,0,star,dot,pos1,1,this,separator,return,this,parser,parse,concat,this,pattern,string,pattern2string,pattern,string,string,first,extension,this,pattern,string,substring,star,dot,pos1,1,string,p2string,pattern2string,pattern,string,int,dot,pos2,p2string,index,of,string,file2,dot,pos2,1,p2string,p2string,substring,0,dot,pos2,string,second,extension,dot,pos2,1,p2string,substring,dot,pos2,boolean,first,extension,wild,first,extension,equals,first,extension,equals,boolean,second,extension,wild,second,extension,equals,second,extension,equals,if,first,extension,wild,second,extension,wild,throw,new,illegal,argument,exception,cannot,combine,patterns,this,pattern,string,and,pattern2string,return,this,parser,parse,file2,first,extension,wild,second,extension,first,extension
PathPattern -> String computePatternString();1498861175;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1498861175;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1498861175;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1498953917;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1499081790;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1499448036;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1499763525;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501237594;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501531808;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501619481;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501676476;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501679128;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501684266;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1501690296;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1502700327;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1502717619;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1502726139;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1504818226;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1506416353;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1508532146;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1510948997;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1520528267;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1524865018;@return string form of the pattern built from walking the path element chain;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,string,form,of,the,pattern,built,from,walking,the,path,element,chain;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1530174524;Return the string form of the pattern built from walking the path element chain._@return the string form of the pattern;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,the,string,form,of,the,pattern,built,from,walking,the,path,element,chain,return,the,string,form,of,the,pattern;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1530174524;Return the string form of the pattern built from walking the path element chain._@return the string form of the pattern;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,the,string,form,of,the,pattern,built,from,walking,the,path,element,chain,return,the,string,form,of,the,pattern;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> String computePatternString();1530174524;Return the string form of the pattern built from walking the path element chain._@return the string form of the pattern;String computePatternString() {_		StringBuilder buf = new StringBuilder()__		PathElement pe = this.head__		while (pe != null) {_			buf.append(pe.getChars())__			pe = pe.next__		}_		return buf.toString()__	};return,the,string,form,of,the,pattern,built,from,walking,the,path,element,chain,return,the,string,form,of,the,pattern;string,compute,pattern,string,string,builder,buf,new,string,builder,path,element,pe,this,head,while,pe,null,buf,append,pe,get,chars,pe,pe,next,return,buf,to,string
PathPattern -> public String extractPathWithinPattern(String path);1495035625;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1495868221;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1496259743;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1496837955;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1497970202;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1498780456;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1498861175;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1498861175;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1498861175;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1498953917;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> public String extractPathWithinPattern(String path);1499081790;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public String extractPathWithinPattern(String path) {_		_		PathElement elem = head__		int separatorCount = 0__		boolean matchTheRest = false___		_		while (elem != null) {_			if (elem instanceof SeparatorPathElement || elem instanceof CaptureTheRestPathElement ||_					elem instanceof WildcardTheRestPathElement) {_				separatorCount++__				if (elem instanceof WildcardTheRestPathElement || elem instanceof CaptureTheRestPathElement) {_					matchTheRest = true__				}_			}_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__		}__		if (elem == null) {_			return ""_  _		}__		_		char[] pathChars = path.toCharArray()__		int len = pathChars.length__		int pos = 0__		while (separatorCount > 0 && pos < len) {_			if (path.charAt(pos++) == separator) {_				separatorCount--__			}_		}_		int end = len__		_		if (!matchTheRest) {_			while (end > 0 && path.charAt(end - 1) == separator) {_				end--__			}_		}__		_		_		_		int c = pos__		StringBuilder stringWithDuplicateSeparatorsRemoved = null__		while (c < end) {_			char ch = path.charAt(c)__			if (ch == separator) {_				if ((c + 1) < end && path.charAt(c + 1) == separator) {_					_					if (stringWithDuplicateSeparatorsRemoved == null) {_						_						stringWithDuplicateSeparatorsRemoved = new StringBuilder()__						stringWithDuplicateSeparatorsRemoved.append(path.substring(pos, c))__					}_					do {_						c++__					} while ((c + 1) < end && path.charAt(c + 1) == separator)__				}_			}_			if (stringWithDuplicateSeparatorsRemoved != null) {_				stringWithDuplicateSeparatorsRemoved.append(ch)__			}_			c++__		}__		if (stringWithDuplicateSeparatorsRemoved != null) {_			return stringWithDuplicateSeparatorsRemoved.toString()__		}_		return (pos == len ? "" : path.substring(pos, end))__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,string,extract,path,within,pattern,string,path,path,element,elem,head,int,separator,count,0,boolean,match,the,rest,false,while,elem,null,if,elem,instanceof,separator,path,element,elem,instanceof,capture,the,rest,path,element,elem,instanceof,wildcard,the,rest,path,element,separator,count,if,elem,instanceof,wildcard,the,rest,path,element,elem,instanceof,capture,the,rest,path,element,match,the,rest,true,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,if,elem,null,return,char,path,chars,path,to,char,array,int,len,path,chars,length,int,pos,0,while,separator,count,0,pos,len,if,path,char,at,pos,separator,separator,count,int,end,len,if,match,the,rest,while,end,0,path,char,at,end,1,separator,end,int,c,pos,string,builder,string,with,duplicate,separators,removed,null,while,c,end,char,ch,path,char,at,c,if,ch,separator,if,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,new,string,builder,string,with,duplicate,separators,removed,append,path,substring,pos,c,do,c,while,c,1,end,path,char,at,c,1,separator,if,string,with,duplicate,separators,removed,null,string,with,duplicate,separators,removed,append,ch,c,if,string,with,duplicate,separators,removed,null,return,string,with,duplicate,separators,removed,to,string,return,pos,len,path,substring,pos,end
PathPattern -> @Override 	public int compareTo(PathPattern otherPattern);1495035625;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(PathPattern otherPattern);1495868221;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(PathPattern otherPattern);1496259743;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1496837955;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1497970202;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1498780456;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1498861175;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1498861175;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1498861175;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1498953917;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1499081790;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1499448036;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1499763525;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501237594;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501531808;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501619481;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501676476;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501679128;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501684266;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		_		if (otherPattern == null) {_			return -1__		}__		_		_		if (isCatchAll()) {_			if (otherPattern.isCatchAll()) {_				int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__				if (lenDifference != 0) {_					return (lenDifference < 0) ? +1 : -1__				}_			}_			else {_				return +1__			}_		}_		else if (otherPattern.isCatchAll()) {_			return -1__		}__		_		_		int score = getScore() - otherPattern.getScore()__		if (score != 0) {_			return (score < 0) ? -1 : +1__		}__		_		int lenDifference = getNormalizedLength() - otherPattern.getNormalizedLength()__		return (lenDifference < 0) ? +1 : (lenDifference == 0 ? 0 : -1)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,if,other,pattern,null,return,1,if,is,catch,all,if,other,pattern,is,catch,all,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,if,len,difference,0,return,len,difference,0,1,1,else,return,1,else,if,other,pattern,is,catch,all,return,1,int,score,get,score,other,pattern,get,score,if,score,0,return,score,0,1,1,int,len,difference,get,normalized,length,other,pattern,get,normalized,length,return,len,difference,0,1,len,difference,0,0,1
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1501690296;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1502700327;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1502717619;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1502726139;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1504818226;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1506416353;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1508532146;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1510948997;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1520528267;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1524865018;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1530174524;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1530174524;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> @Override 	public int compareTo(@Nullable PathPattern otherPattern);1530174524;Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern_is more specific, the same or less specific than the supplied pattern._The aim is to sort more specific patterns first.;@Override_	public int compareTo(@Nullable PathPattern otherPattern) {_		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern)__		return (result == 0 && otherPattern != null ?_				this.patternString.compareTo(otherPattern.patternString) : result)__	};compare,this,pattern,with,a,supplied,pattern,return,1,0,1,if,this,pattern,is,more,specific,the,same,or,less,specific,than,the,supplied,pattern,the,aim,is,to,sort,more,specific,patterns,first;override,public,int,compare,to,nullable,path,pattern,other,pattern,int,result,compare,this,other,pattern,return,result,0,other,pattern,null,this,pattern,string,compare,to,other,pattern,pattern,string,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1499448036;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		String result = extractPathWithinPattern(path.value())__		return PathContainer.parse(result, StandardCharsets.UTF_8)__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,result,standard,charsets
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1499763525;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		_		String result = extractPathWithinPattern(path.value())__		return PathContainer.parseUrlPath(result)__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,url,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501237594;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		_		String result = extractPathWithinPattern(path.value())__		return PathContainer.parseUrlPath(result)__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,url,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501531808;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		_		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501619481;Given a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this. As per the contract on {@link PathMatcher}, this_method will trim leading/trailing separators. It will also remove duplicate separators in_the returned path._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		_		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};given,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this,as,per,the,contract,on,link,path,matcher,this,method,will,trim,leading,trailing,separators,it,will,also,remove,duplicate,separators,in,the,returned,path,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501676476;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501679128;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501684266;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1501690296;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1502700327;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1502717619;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1502726139;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1504818226;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1506416353;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1508532146;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Note:</b> Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {__		__		_		_		__		String result = extractPathWithinPattern(path.value())__		return PathContainer.parsePath(result)__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,note,b,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,string,result,extract,path,within,pattern,path,value,return,path,container,parse,path,result
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1510948997;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Notes:</b>_<ul>_<li>Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._<li>Duplicate occurrences of separators within the returned result are removed_<li>Leading and trailing separators are removed from the returned result_</ul>_@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		List<Element> pathElements = path.elements()__		int pathElementsCount = pathElements.size()___		int startIndex = 0__		_		PathElement elem = head__		while (elem != null) {_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__			startIndex++__		}_		if (elem == null) {_			_			return PathContainer.parsePath("")__		}_		_		_		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {_			startIndex++__		}_		_		int endIndex = pathElements.size()__		_		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {_			endIndex--__		}_		_		boolean multipleAdjacentSeparators = false__		for (int i = startIndex_ i < (endIndex - 1)_ i++) {_			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {_				multipleAdjacentSeparators=true__				break__			}_		}_		_		PathContainer resultPath = null__		if (multipleAdjacentSeparators) {_			_			StringBuilder buf = new StringBuilder()__			int i = startIndex__			while (i < endIndex) {_				Element e = pathElements.get(i++)__				buf.append(e.value())__				if (e instanceof Separator) {_					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {_						i++__					} _				}_			}_			resultPath = PathContainer.parsePath(buf.toString())__		} else if (startIndex >= endIndex) {_			resultPath = PathContainer.parsePath("")__		}_		else {_			resultPath = path.subPath(startIndex, endIndex)__		}_		return resultPath__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,notes,b,ul,li,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,li,duplicate,occurrences,of,separators,within,the,returned,result,are,removed,li,leading,and,trailing,separators,are,removed,from,the,returned,result,ul,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,list,element,path,elements,path,elements,int,path,elements,count,path,elements,size,int,start,index,0,path,element,elem,head,while,elem,null,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,start,index,if,elem,null,return,path,container,parse,path,while,start,index,path,elements,count,path,elements,get,start,index,instanceof,separator,start,index,int,end,index,path,elements,size,while,end,index,0,path,elements,get,end,index,1,instanceof,separator,end,index,boolean,multiple,adjacent,separators,false,for,int,i,start,index,i,end,index,1,i,if,path,elements,get,i,instanceof,separator,path,elements,get,i,1,instanceof,separator,multiple,adjacent,separators,true,break,path,container,result,path,null,if,multiple,adjacent,separators,string,builder,buf,new,string,builder,int,i,start,index,while,i,end,index,element,e,path,elements,get,i,buf,append,e,value,if,e,instanceof,separator,while,i,end,index,path,elements,get,i,instanceof,separator,i,result,path,path,container,parse,path,buf,to,string,else,if,start,index,end,index,result,path,path,container,parse,path,else,result,path,path,sub,path,start,index,end,index,return,result,path
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1520528267;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Notes:</b>_<ul>_<li>Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._<li>Duplicate occurrences of separators within the returned result are removed_<li>Leading and trailing separators are removed from the returned result_</ul>_@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		List<Element> pathElements = path.elements()__		int pathElementsCount = pathElements.size()___		int startIndex = 0__		_		PathElement elem = head__		while (elem != null) {_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__			startIndex++__		}_		if (elem == null) {_			_			return PathContainer.parsePath("")__		}_		_		_		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {_			startIndex++__		}_		_		int endIndex = pathElements.size()__		_		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {_			endIndex--__		}_		_		boolean multipleAdjacentSeparators = false__		for (int i = startIndex_ i < (endIndex - 1)_ i++) {_			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {_				multipleAdjacentSeparators=true__				break__			}_		}_		_		PathContainer resultPath = null__		if (multipleAdjacentSeparators) {_			_			StringBuilder buf = new StringBuilder()__			int i = startIndex__			while (i < endIndex) {_				Element e = pathElements.get(i++)__				buf.append(e.value())__				if (e instanceof Separator) {_					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {_						i++__					} _				}_			}_			resultPath = PathContainer.parsePath(buf.toString())__		} else if (startIndex >= endIndex) {_			resultPath = PathContainer.parsePath("")__		}_		else {_			resultPath = path.subPath(startIndex, endIndex)__		}_		return resultPath__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,notes,b,ul,li,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,li,duplicate,occurrences,of,separators,within,the,returned,result,are,removed,li,leading,and,trailing,separators,are,removed,from,the,returned,result,ul,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,list,element,path,elements,path,elements,int,path,elements,count,path,elements,size,int,start,index,0,path,element,elem,head,while,elem,null,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,start,index,if,elem,null,return,path,container,parse,path,while,start,index,path,elements,count,path,elements,get,start,index,instanceof,separator,start,index,int,end,index,path,elements,size,while,end,index,0,path,elements,get,end,index,1,instanceof,separator,end,index,boolean,multiple,adjacent,separators,false,for,int,i,start,index,i,end,index,1,i,if,path,elements,get,i,instanceof,separator,path,elements,get,i,1,instanceof,separator,multiple,adjacent,separators,true,break,path,container,result,path,null,if,multiple,adjacent,separators,string,builder,buf,new,string,builder,int,i,start,index,while,i,end,index,element,e,path,elements,get,i,buf,append,e,value,if,e,instanceof,separator,while,i,end,index,path,elements,get,i,instanceof,separator,i,result,path,path,container,parse,path,buf,to,string,else,if,start,index,end,index,result,path,path,container,parse,path,else,result,path,path,sub,path,start,index,end,index,return,result,path
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1524865018;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Notes:</b>_<ul>_<li>Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._<li>Duplicate occurrences of separators within the returned result are removed_<li>Leading and trailing separators are removed from the returned result_</ul>_@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		List<Element> pathElements = path.elements()__		int pathElementsCount = pathElements.size()___		int startIndex = 0__		_		PathElement elem = head__		while (elem != null) {_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__			startIndex++__		}_		if (elem == null) {_			_			return PathContainer.parsePath("")__		}_		_		_		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {_			startIndex++__		}_		_		int endIndex = pathElements.size()__		_		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {_			endIndex--__		}_		_		boolean multipleAdjacentSeparators = false__		for (int i = startIndex_ i < (endIndex - 1)_ i++) {_			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {_				multipleAdjacentSeparators=true__				break__			}_		}_		_		PathContainer resultPath = null__		if (multipleAdjacentSeparators) {_			_			StringBuilder buf = new StringBuilder()__			int i = startIndex__			while (i < endIndex) {_				Element e = pathElements.get(i++)__				buf.append(e.value())__				if (e instanceof Separator) {_					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {_						i++__					} _				}_			}_			resultPath = PathContainer.parsePath(buf.toString())__		}_		else if (startIndex >= endIndex) {_			resultPath = PathContainer.parsePath("")__		}_		else {_			resultPath = path.subPath(startIndex, endIndex)__		}_		return resultPath__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,notes,b,ul,li,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,li,duplicate,occurrences,of,separators,within,the,returned,result,are,removed,li,leading,and,trailing,separators,are,removed,from,the,returned,result,ul,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,list,element,path,elements,path,elements,int,path,elements,count,path,elements,size,int,start,index,0,path,element,elem,head,while,elem,null,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,start,index,if,elem,null,return,path,container,parse,path,while,start,index,path,elements,count,path,elements,get,start,index,instanceof,separator,start,index,int,end,index,path,elements,size,while,end,index,0,path,elements,get,end,index,1,instanceof,separator,end,index,boolean,multiple,adjacent,separators,false,for,int,i,start,index,i,end,index,1,i,if,path,elements,get,i,instanceof,separator,path,elements,get,i,1,instanceof,separator,multiple,adjacent,separators,true,break,path,container,result,path,null,if,multiple,adjacent,separators,string,builder,buf,new,string,builder,int,i,start,index,while,i,end,index,element,e,path,elements,get,i,buf,append,e,value,if,e,instanceof,separator,while,i,end,index,path,elements,get,i,instanceof,separator,i,result,path,path,container,parse,path,buf,to,string,else,if,start,index,end,index,result,path,path,container,parse,path,else,result,path,path,sub,path,start,index,end,index,return,result,path
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1530174524;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Notes:</b>_<ul>_<li>Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._<li>Duplicate occurrences of separators within the returned result are removed_<li>Leading and trailing separators are removed from the returned result_</ul>_@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		List<Element> pathElements = path.elements()__		int pathElementsCount = pathElements.size()___		int startIndex = 0__		_		PathElement elem = head__		while (elem != null) {_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__			startIndex++__		}_		if (elem == null) {_			_			return PathContainer.parsePath("")__		}__		_		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {_			startIndex++__		}__		int endIndex = pathElements.size()__		_		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {_			endIndex--__		}__		boolean multipleAdjacentSeparators = false__		for (int i = startIndex_ i < (endIndex - 1)_ i++) {_			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {_				multipleAdjacentSeparators=true__				break__			}_		}__		PathContainer resultPath = null__		if (multipleAdjacentSeparators) {_			_			StringBuilder buf = new StringBuilder()__			int i = startIndex__			while (i < endIndex) {_				Element e = pathElements.get(i++)__				buf.append(e.value())__				if (e instanceof Separator) {_					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {_						i++__					}_				}_			}_			resultPath = PathContainer.parsePath(buf.toString())__		}_		else if (startIndex >= endIndex) {_			resultPath = PathContainer.parsePath("")__		}_		else {_			resultPath = path.subPath(startIndex, endIndex)__		}_		return resultPath__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,notes,b,ul,li,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,li,duplicate,occurrences,of,separators,within,the,returned,result,are,removed,li,leading,and,trailing,separators,are,removed,from,the,returned,result,ul,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,list,element,path,elements,path,elements,int,path,elements,count,path,elements,size,int,start,index,0,path,element,elem,head,while,elem,null,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,start,index,if,elem,null,return,path,container,parse,path,while,start,index,path,elements,count,path,elements,get,start,index,instanceof,separator,start,index,int,end,index,path,elements,size,while,end,index,0,path,elements,get,end,index,1,instanceof,separator,end,index,boolean,multiple,adjacent,separators,false,for,int,i,start,index,i,end,index,1,i,if,path,elements,get,i,instanceof,separator,path,elements,get,i,1,instanceof,separator,multiple,adjacent,separators,true,break,path,container,result,path,null,if,multiple,adjacent,separators,string,builder,buf,new,string,builder,int,i,start,index,while,i,end,index,element,e,path,elements,get,i,buf,append,e,value,if,e,instanceof,separator,while,i,end,index,path,elements,get,i,instanceof,separator,i,result,path,path,container,parse,path,buf,to,string,else,if,start,index,end,index,result,path,path,container,parse,path,else,result,path,path,sub,path,start,index,end,index,return,result,path
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1530174524;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Notes:</b>_<ul>_<li>Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._<li>Duplicate occurrences of separators within the returned result are removed_<li>Leading and trailing separators are removed from the returned result_</ul>_@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		List<Element> pathElements = path.elements()__		int pathElementsCount = pathElements.size()___		int startIndex = 0__		_		PathElement elem = head__		while (elem != null) {_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__			startIndex++__		}_		if (elem == null) {_			_			return PathContainer.parsePath("")__		}__		_		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {_			startIndex++__		}__		int endIndex = pathElements.size()__		_		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {_			endIndex--__		}__		boolean multipleAdjacentSeparators = false__		for (int i = startIndex_ i < (endIndex - 1)_ i++) {_			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {_				multipleAdjacentSeparators=true__				break__			}_		}__		PathContainer resultPath = null__		if (multipleAdjacentSeparators) {_			_			StringBuilder buf = new StringBuilder()__			int i = startIndex__			while (i < endIndex) {_				Element e = pathElements.get(i++)__				buf.append(e.value())__				if (e instanceof Separator) {_					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {_						i++__					}_				}_			}_			resultPath = PathContainer.parsePath(buf.toString())__		}_		else if (startIndex >= endIndex) {_			resultPath = PathContainer.parsePath("")__		}_		else {_			resultPath = path.subPath(startIndex, endIndex)__		}_		return resultPath__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,notes,b,ul,li,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,li,duplicate,occurrences,of,separators,within,the,returned,result,are,removed,li,leading,and,trailing,separators,are,removed,from,the,returned,result,ul,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,list,element,path,elements,path,elements,int,path,elements,count,path,elements,size,int,start,index,0,path,element,elem,head,while,elem,null,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,start,index,if,elem,null,return,path,container,parse,path,while,start,index,path,elements,count,path,elements,get,start,index,instanceof,separator,start,index,int,end,index,path,elements,size,while,end,index,0,path,elements,get,end,index,1,instanceof,separator,end,index,boolean,multiple,adjacent,separators,false,for,int,i,start,index,i,end,index,1,i,if,path,elements,get,i,instanceof,separator,path,elements,get,i,1,instanceof,separator,multiple,adjacent,separators,true,break,path,container,result,path,null,if,multiple,adjacent,separators,string,builder,buf,new,string,builder,int,i,start,index,while,i,end,index,element,e,path,elements,get,i,buf,append,e,value,if,e,instanceof,separator,while,i,end,index,path,elements,get,i,instanceof,separator,i,result,path,path,container,parse,path,buf,to,string,else,if,start,index,end,index,result,path,path,container,parse,path,else,result,path,path,sub,path,start,index,end,index,return,result,path
PathPattern -> public PathContainer extractPathWithinPattern(PathContainer path);1530174524;Determine the pattern-mapped part for the given path._<p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_</ul>_<p><b>Notes:</b>_<ul>_<li>Assumes that {@link #matches} returns {@code true} for_the same path but does <strong>not</strong> enforce this._<li>Duplicate occurrences of separators within the returned result are removed_<li>Leading and trailing separators are removed from the returned result_</ul>_@param path a path that matches this pattern_@return the subset of the path that is matched by pattern or "" if none_of it is matched by pattern elements;public PathContainer extractPathWithinPattern(PathContainer path) {_		List<Element> pathElements = path.elements()__		int pathElementsCount = pathElements.size()___		int startIndex = 0__		_		PathElement elem = this.head__		while (elem != null) {_			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {_				break__			}_			elem = elem.next__			startIndex++__		}_		if (elem == null) {_			_			return PathContainer.parsePath("")__		}__		_		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {_			startIndex++__		}__		int endIndex = pathElements.size()__		_		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {_			endIndex--__		}__		boolean multipleAdjacentSeparators = false__		for (int i = startIndex_ i < (endIndex - 1)_ i++) {_			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {_				multipleAdjacentSeparators=true__				break__			}_		}__		PathContainer resultPath = null__		if (multipleAdjacentSeparators) {_			_			StringBuilder buf = new StringBuilder()__			int i = startIndex__			while (i < endIndex) {_				Element e = pathElements.get(i++)__				buf.append(e.value())__				if (e instanceof Separator) {_					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {_						i++__					}_				}_			}_			resultPath = PathContainer.parsePath(buf.toString())__		}_		else if (startIndex >= endIndex) {_			resultPath = PathContainer.parsePath("")__		}_		else {_			resultPath = path.subPath(startIndex, endIndex)__		}_		return resultPath__	};determine,the,pattern,mapped,part,for,the,given,path,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,ul,p,b,notes,b,ul,li,assumes,that,link,matches,returns,code,true,for,the,same,path,but,does,strong,not,strong,enforce,this,li,duplicate,occurrences,of,separators,within,the,returned,result,are,removed,li,leading,and,trailing,separators,are,removed,from,the,returned,result,ul,param,path,a,path,that,matches,this,pattern,return,the,subset,of,the,path,that,is,matched,by,pattern,or,if,none,of,it,is,matched,by,pattern,elements;public,path,container,extract,path,within,pattern,path,container,path,list,element,path,elements,path,elements,int,path,elements,count,path,elements,size,int,start,index,0,path,element,elem,this,head,while,elem,null,if,elem,get,wildcard,count,0,elem,get,capture,count,0,break,elem,elem,next,start,index,if,elem,null,return,path,container,parse,path,while,start,index,path,elements,count,path,elements,get,start,index,instanceof,separator,start,index,int,end,index,path,elements,size,while,end,index,0,path,elements,get,end,index,1,instanceof,separator,end,index,boolean,multiple,adjacent,separators,false,for,int,i,start,index,i,end,index,1,i,if,path,elements,get,i,instanceof,separator,path,elements,get,i,1,instanceof,separator,multiple,adjacent,separators,true,break,path,container,result,path,null,if,multiple,adjacent,separators,string,builder,buf,new,string,builder,int,i,start,index,while,i,end,index,element,e,path,elements,get,i,buf,append,e,value,if,e,instanceof,separator,while,i,end,index,path,elements,get,i,instanceof,separator,i,result,path,path,container,parse,path,buf,to,string,else,if,start,index,end,index,result,path,path,container,parse,path,else,result,path,path,sub,path,start,index,end,index,return,result,path
