commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the original String that was parsed to create this PathPattern.  */ ;/**  * Return the original String that was parsed to create this PathPattern.  */ public String getPatternString() {     return this.patternString. }
true;public;1;16;/**  * Whether this pattern matches the given path.  * @param pathContainer the candidate path to attempt to match against  * @return {@code true} if the path matches this pattern  */ ;/**  * Whether this pattern matches the given path.  * @param pathContainer the candidate path to attempt to match against  * @return {@code true} if the path matches this pattern  */ public boolean matches(PathContainer pathContainer) {     if (this.head == null) {         return !hasLength(pathContainer) || (this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer)).     } else if (!hasLength(pathContainer)) {         if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {             // Will allow CaptureTheRest to bind the variable to empty             pathContainer = EMPTY_PATH.         } else {             return false.         }     }     MatchingContext matchingContext = new MatchingContext(pathContainer, false).     return this.head.matches(0, matchingContext). }
true;public;1;18;/**  * Match this pattern to the given URI path and return extracted URI template  * variables as well as path parameters (matrix variables).  * @param pathContainer the candidate path to attempt to match against  * @return info object with the extracted variables, or {@code null} for no match  */ ;/**  * Match this pattern to the given URI path and return extracted URI template  * variables as well as path parameters (matrix variables).  * @param pathContainer the candidate path to attempt to match against  * @return info object with the extracted variables, or {@code null} for no match  */ @Nullable public PathMatchInfo matchAndExtract(PathContainer pathContainer) {     if (this.head == null) {         return hasLength(pathContainer) && !(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer)) ? null : PathMatchInfo.EMPTY.     } else if (!hasLength(pathContainer)) {         if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {             // Will allow CaptureTheRest to bind the variable to empty             pathContainer = EMPTY_PATH.         } else {             return null.         }     }     MatchingContext matchingContext = new MatchingContext(pathContainer, true).     return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null. }
true;public;1;27;/**  * Match the beginning of the given path and return the remaining portion  * not covered by this pattern. This is useful for matching nested routes  * where the path is matched incrementally at each level.  * @param pathContainer the candidate path to attempt to match against  * @return info object with the match result or {@code null} for no match  */ ;/**  * Match the beginning of the given path and return the remaining portion  * not covered by this pattern. This is useful for matching nested routes  * where the path is matched incrementally at each level.  * @param pathContainer the candidate path to attempt to match against  * @return info object with the match result or {@code null} for no match  */ @Nullable public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {     if (this.head == null) {         return new PathRemainingMatchInfo(pathContainer).     } else if (!hasLength(pathContainer)) {         return null.     }     MatchingContext matchingContext = new MatchingContext(pathContainer, true).     matchingContext.setMatchAllowExtraPath().     boolean matches = this.head.matches(0, matchingContext).     if (!matches) {         return null.     } else {         PathRemainingMatchInfo info.         if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {             info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult()).         } else {             info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex), matchingContext.getPathMatchResult()).         }         return info.     } }
true;public;1;62;/**  * Determine the pattern-mapped part for the given path.  * <p>For example: <ul>  * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>  * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>  * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>  * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>  * </ul>  * <p><b>Notes:</b>  * <ul>  * <li>Assumes that {@link #matches} returns {@code true} for  * the same path but does <strong>not</strong> enforce this.  * <li>Duplicate occurrences of separators within the returned result are removed  * <li>Leading and trailing separators are removed from the returned result  * </ul>  * @param path a path that matches this pattern  * @return the subset of the path that is matched by pattern or "" if none  * of it is matched by pattern elements  */ ;/**  * Determine the pattern-mapped part for the given path.  * <p>For example: <ul>  * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>  * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' -> '{@code cvs/commit}'</li>  * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>  * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>  * </ul>  * <p><b>Notes:</b>  * <ul>  * <li>Assumes that {@link #matches} returns {@code true} for  * the same path but does <strong>not</strong> enforce this.  * <li>Duplicate occurrences of separators within the returned result are removed  * <li>Leading and trailing separators are removed from the returned result  * </ul>  * @param path a path that matches this pattern  * @return the subset of the path that is matched by pattern or "" if none  * of it is matched by pattern elements  */ public PathContainer extractPathWithinPattern(PathContainer path) {     List<Element> pathElements = path.elements().     int pathElementsCount = pathElements.size().     int startIndex = 0.     // Find first path element that is not a separator or a literal (i.e. the first pattern based element)     PathElement elem = this.head.     while (elem != null) {         if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {             break.         }         elem = elem.next.         startIndex++.     }     if (elem == null) {         // There is no pattern piece         return PathContainer.parsePath("").     }     // Skip leading separators that would be in the result     while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {         startIndex++.     }     int endIndex = pathElements.size().     // Skip trailing separators that would be in the result     while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {         endIndex--.     }     boolean multipleAdjacentSeparators = false.     for (int i = startIndex. i < (endIndex - 1). i++) {         if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i + 1) instanceof Separator)) {             multipleAdjacentSeparators = true.             break.         }     }     PathContainer resultPath = null.     if (multipleAdjacentSeparators) {         // Need to rebuild the path without the duplicate adjacent separators         StringBuilder buf = new StringBuilder().         int i = startIndex.         while (i < endIndex) {             Element e = pathElements.get(i++).             buf.append(e.value()).             if (e instanceof Separator) {                 while (i < endIndex && (pathElements.get(i) instanceof Separator)) {                     i++.                 }             }         }         resultPath = PathContainer.parsePath(buf.toString()).     } else if (startIndex >= endIndex) {         resultPath = PathContainer.parsePath("").     } else {         resultPath = path.subPath(startIndex, endIndex).     }     return resultPath. }
true;public;1;6;/**  * Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern  * is more specific, the same or less specific than the supplied pattern.  * The aim is to sort more specific patterns first.  */ ;/**  * Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern  * is more specific, the same or less specific than the supplied pattern.  * The aim is to sort more specific patterns first.  */ @Override public int compareTo(@Nullable PathPattern otherPattern) {     int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern).     return (result == 0 && otherPattern != null ? this.patternString.compareTo(otherPattern.patternString) : result). }
true;public;1;54;/**  * Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.  */ ;/**  * Combine this pattern with another. Currently does not produce a new PathPattern, just produces a new string.  */ public PathPattern combine(PathPattern pattern2string) {     // If one of them is empty the result is the other. If both empty the result is ""     if (!StringUtils.hasLength(this.patternString)) {         if (!StringUtils.hasLength(pattern2string.patternString)) {             return this.parser.parse("").         } else {             return pattern2string.         }     } else if (!StringUtils.hasLength(pattern2string.patternString)) {         return this.     }     // /{foo} + /bar => /{foo}/bar     if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 && matches(PathContainer.parsePath(pattern2string.patternString))) {         return pattern2string.     }     // /hotels/* + booking => /hotels/booking     if (this.endsWithSeparatorWildcard) {         return this.parser.parse(concat(this.patternString.substring(0, this.patternString.length() - 2), pattern2string.patternString)).     }     // /hotels + /booking => /hotels/booking     // /hotels + booking => /hotels/booking     // Are there any file prefix/suffix things to consider?     int starDotPos1 = this.patternString.indexOf("*.").     if (this.capturedVariableCount != 0 || starDotPos1 == -1 || this.separator == '.') {         return this.parser.parse(concat(this.patternString, pattern2string.patternString)).     }     // /*.html + /hotel => /hotel.html     // /*.html + /hotel.* => /hotel.html     // looking for the first extension     String firstExtension = this.patternString.substring(starDotPos1 + 1).     String p2string = pattern2string.patternString.     int dotPos2 = p2string.indexOf('.').     String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2)).     String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2)).     boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.equals("")).     boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.equals("")).     if (!firstExtensionWild && !secondExtensionWild) {         throw new IllegalArgumentException("Cannot combine patterns: " + this.patternString + " and " + pattern2string).     }     return this.parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension)). }
false;public;1;9;;public boolean equals(Object other) {     if (!(other instanceof PathPattern)) {         return false.     }     PathPattern otherPattern = (PathPattern) other.     return (this.patternString.equals(otherPattern.getPatternString()) && this.separator == otherPattern.getSeparator() && this.caseSensitive == otherPattern.caseSensitive). }
false;public;0;3;;public int hashCode() {     return (this.patternString.hashCode() + this.separator) * 17 + (this.caseSensitive ? 1 : 0). }
false;public;0;3;;public String toString() {     return this.patternString. }
false;;0;3;;int getScore() {     return this.score. }
false;;0;3;;boolean isCatchAll() {     return this.catchAll. }
true;;0;3;/**  * The normalized length is trying to measure the 'active' part of the pattern. It is computed  * by assuming all capture variables have a normalized length of 1. Effectively this means changing  * your variable name lengths isn't going to change the length of the active part of the pattern.  * Useful when comparing two patterns.  */ ;/**  * The normalized length is trying to measure the 'active' part of the pattern. It is computed  * by assuming all capture variables have a normalized length of 1. Effectively this means changing  * your variable name lengths isn't going to change the length of the active part of the pattern.  * Useful when comparing two patterns.  */ int getNormalizedLength() {     return this.normalizedLength. }
false;;0;3;;char getSeparator() {     return this.separator. }
false;;0;3;;int getCapturedVariableCount() {     return this.capturedVariableCount. }
false;;0;9;;String toChainString() {     StringBuilder buf = new StringBuilder().     PathElement pe = this.head.     while (pe != null) {         buf.append(pe.toString()).append(" ").         pe = pe.next.     }     return buf.toString().trim(). }
true;;0;9;/**  * Return the string form of the pattern built from walking the path element chain.  * @return the string form of the pattern  */ ;/**  * Return the string form of the pattern built from walking the path element chain.  * @return the string form of the pattern  */ String computePatternString() {     StringBuilder buf = new StringBuilder().     PathElement pe = this.head.     while (pe != null) {         buf.append(pe.getChars()).         pe = pe.next.     }     return buf.toString(). }
false;;0;4;;@Nullable PathElement getHeadSection() {     return this.head. }
true;private;2;13;/**  * Join two paths together including a separator if necessary.  * Extraneous separators are removed (if the first path  * ends with one and the second path starts with one).  * @param path1 first path  * @param path2 second path  * @return joined path that may include separator if necessary  */ ;/**  * Join two paths together including a separator if necessary.  * Extraneous separators are removed (if the first path  * ends with one and the second path starts with one).  * @param path1 first path  * @param path2 second path  * @return joined path that may include separator if necessary  */ private String concat(String path1, String path2) {     boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == this.separator).     boolean path2StartsWithSeparator = (path2.charAt(0) == this.separator).     if (path1EndsWithSeparator && path2StartsWithSeparator) {         return path1 + path2.substring(1).     } else if (path1EndsWithSeparator || path2StartsWithSeparator) {         return path1 + path2.     } else {         return path1 + this.separator + path2.     } }
true;private;1;3;/**  * Return if the container is not null and has more than zero elements.  * @param container a path container  * @return {@code true} has more than zero elements  */ ;/**  * Return if the container is not null and has more than zero elements.  * @param container a path container  * @return {@code true} has more than zero elements  */ private boolean hasLength(@Nullable PathContainer container) {     return container != null && container.elements().size() > 0. }
false;private,static;1;3;;private static int scoreByNormalizedLength(PathPattern pattern) {     return -pattern.getNormalizedLength(). }
false;private;1;4;;private boolean pathContainerIsJustSeparator(PathContainer pathContainer) {     return pathContainer.value().length() == 1 && pathContainer.value().charAt(0) == this.separator. }
true;public;0;3;/**  * Return the extracted URI variables.  */ ;/**  * Return the extracted URI variables.  */ public Map<String, String> getUriVariables() {     return this.uriVariables. }
true;public;0;3;/**  * Return maps of matrix variables per path segment, keyed off by URI  * variable name.  */ ;/**  * Return maps of matrix variables per path segment, keyed off by URI  * variable name.  */ public Map<String, MultiValueMap<String, String>> getMatrixVariables() {     return this.matrixVariables. }
false;public;0;5;;@Override public String toString() {     return "PathMatchInfo[uriVariables=" + this.uriVariables + ", " + "matrixVariables=" + this.matrixVariables + "]". }
true;public;0;3;/**  * Return the part of a path that was not matched by a pattern.  */ ;/**  * Return the part of a path that was not matched by a pattern.  */ public PathContainer getPathRemaining() {     return this.pathRemaining. }
true;public;0;3;/**  * Return variables that were bound in the part of the path that was  * successfully matched or an empty map.  */ ;/**  * Return variables that were bound in the part of the path that was  * successfully matched or an empty map.  */ public Map<String, String> getUriVariables() {     return this.pathMatchInfo.getUriVariables(). }
true;public;0;3;/**  * Return the path parameters for each bound variable.  */ ;/**  * Return the path parameters for each bound variable.  */ public Map<String, MultiValueMap<String, String>> getMatrixVariables() {     return this.pathMatchInfo.getMatrixVariables(). }
false;public;0;3;;public void setMatchAllowExtraPath() {     this.determineRemainingPath = true. }
false;public;0;3;;public boolean isMatchOptionalTrailingSeparator() {     return matchOptionalTrailingSeparator. }
false;public;3;13;;public void set(String key, String value, MultiValueMap<String, String> parameters) {     if (this.extractedUriVariables == null) {         this.extractedUriVariables = new HashMap<>().     }     this.extractedUriVariables.put(key, value).     if (!parameters.isEmpty()) {         if (this.extractedMatrixVariables == null) {             this.extractedMatrixVariables = new HashMap<>().         }         this.extractedMatrixVariables.put(key, CollectionUtils.unmodifiableMultiValueMap(parameters)).     } }
false;public;0;8;;public PathMatchInfo getPathMatchResult() {     if (this.extractedUriVariables == null) {         return PathMatchInfo.EMPTY.     } else {         return new PathMatchInfo(this.extractedUriVariables, this.extractedMatrixVariables).     } }
true;;1;3;/**  * Return if element at specified index is a separator.  * @param pathIndex possible index of a separator  * @return {@code true} if element is a separator  */ ;/**  * Return if element at specified index is a separator.  * @param pathIndex possible index of a separator  * @return {@code true} if element is a separator  */ boolean isSeparator(int pathIndex) {     return this.pathElements.get(pathIndex) instanceof Separator. }
true;;1;7;/**  * Return the decoded value of the specified element.  * @param pathIndex path element index  * @return the decoded value  */ ;/**  * Return the decoded value of the specified element.  * @param pathIndex path element index  * @return the decoded value  */ String pathElementValue(int pathIndex) {     Element element = (pathIndex < this.pathLength) ? this.pathElements.get(pathIndex) : null.     if (element instanceof PathContainer.PathSegment) {         return ((PathContainer.PathSegment) element).valueToMatch().     }     return "". }
