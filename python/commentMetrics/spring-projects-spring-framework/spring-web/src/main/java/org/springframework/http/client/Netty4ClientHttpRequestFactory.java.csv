commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the default maximum response size.  * <p>By default this is set to {@link #DEFAULT_MAX_RESPONSE_SIZE}.  * @since 4.1.5  * @see HttpObjectAggregator#HttpObjectAggregator(int)  */ ;/**  * Set the default maximum response size.  * <p>By default this is set to {@link #DEFAULT_MAX_RESPONSE_SIZE}.  * @since 4.1.5  * @see HttpObjectAggregator#HttpObjectAggregator(int)  */ public void setMaxResponseSize(int maxResponseSize) {     this.maxResponseSize = maxResponseSize. }
true;public;1;3;/**  * Set the SSL context. When configured it is used to create and insert an  * {@link io.netty.handler.ssl.SslHandler} in the channel pipeline.  * <p>A default client SslContext is configured if none has been provided.  */ ;/**  * Set the SSL context. When configured it is used to create and insert an  * {@link io.netty.handler.ssl.SslHandler} in the channel pipeline.  * <p>A default client SslContext is configured if none has been provided.  */ public void setSslContext(SslContext sslContext) {     this.sslContext = sslContext. }
true;public;1;3;/**  * Set the underlying connect timeout (in milliseconds).  * A timeout value of 0 specifies an infinite timeout.  * @see ChannelConfig#setConnectTimeoutMillis(int)  */ ;/**  * Set the underlying connect timeout (in milliseconds).  * A timeout value of 0 specifies an infinite timeout.  * @see ChannelConfig#setConnectTimeoutMillis(int)  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
true;public;1;3;/**  * Set the underlying URLConnection's read timeout (in milliseconds).  * A timeout value of 0 specifies an infinite timeout.  * @see ReadTimeoutHandler  */ ;/**  * Set the underlying URLConnection's read timeout (in milliseconds).  * A timeout value of 0 specifies an infinite timeout.  * @see ReadTimeoutHandler  */ public void setReadTimeout(int readTimeout) {     this.readTimeout = readTimeout. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (this.sslContext == null) {         this.sslContext = getDefaultClientSslContext().     } }
false;private;0;8;;private SslContext getDefaultClientSslContext() {     try {         return SslContextBuilder.forClient().build().     } catch (SSLException ex) {         throw new IllegalStateException("Could not create default client SslContext", ex).     } }
false;public;2;4;;@Override public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {     return createRequestInternal(uri, httpMethod). }
false;public;2;4;;@Override public AsyncClientHttpRequest createAsyncRequest(URI uri, HttpMethod httpMethod) throws IOException {     return createRequestInternal(uri, httpMethod). }
false;private;2;3;;private Netty4ClientHttpRequest createRequestInternal(URI uri, HttpMethod httpMethod) {     return new Netty4ClientHttpRequest(getBootstrap(uri), uri, httpMethod). }
false;private;1;14;;private Bootstrap getBootstrap(URI uri) {     boolean isSecure = (uri.getPort() == 443 || "https".equalsIgnoreCase(uri.getScheme())).     if (isSecure) {         return buildBootstrap(uri, true).     } else {         Bootstrap bootstrap = this.bootstrap.         if (bootstrap == null) {             bootstrap = buildBootstrap(uri, false).             this.bootstrap = bootstrap.         }         return bootstrap.     } }
false;protected;1;15;;@Override protected void initChannel(SocketChannel channel) throws Exception {     configureChannel(channel.config()).     ChannelPipeline pipeline = channel.pipeline().     if (isSecure) {         Assert.notNull(sslContext, "sslContext should not be null").         pipeline.addLast(sslContext.newHandler(channel.alloc(), uri.getHost(), uri.getPort())).     }     pipeline.addLast(new HttpClientCodec()).     pipeline.addLast(new HttpObjectAggregator(maxResponseSize)).     if (readTimeout > 0) {         pipeline.addLast(new ReadTimeoutHandler(readTimeout, TimeUnit.MILLISECONDS)).     } }
false;private;2;22;;private Bootstrap buildBootstrap(URI uri, boolean isSecure) {     Bootstrap bootstrap = new Bootstrap().     bootstrap.group(this.eventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {          @Override         protected void initChannel(SocketChannel channel) throws Exception {             configureChannel(channel.config()).             ChannelPipeline pipeline = channel.pipeline().             if (isSecure) {                 Assert.notNull(sslContext, "sslContext should not be null").                 pipeline.addLast(sslContext.newHandler(channel.alloc(), uri.getHost(), uri.getPort())).             }             pipeline.addLast(new HttpClientCodec()).             pipeline.addLast(new HttpObjectAggregator(maxResponseSize)).             if (readTimeout > 0) {                 pipeline.addLast(new ReadTimeoutHandler(readTimeout, TimeUnit.MILLISECONDS)).             }         }     }).     return bootstrap. }
true;protected;1;5;/**  * Template method for changing properties on the given {@link SocketChannelConfig}.  * <p>The default implementation sets the connect timeout based on the set property.  * @param config the channel configuration  */ ;/**  * Template method for changing properties on the given {@link SocketChannelConfig}.  * <p>The default implementation sets the connect timeout based on the set property.  * @param config the channel configuration  */ protected void configureChannel(SocketChannelConfig config) {     if (this.connectTimeout >= 0) {         config.setConnectTimeoutMillis(this.connectTimeout).     } }
false;public;0;7;;@Override public void destroy() throws InterruptedException {     if (this.defaultEventLoopGroup) {         // Clean up the EventLoopGroup if we created it in the constructor         this.eventLoopGroup.shutdownGracefully().sync().     } }
