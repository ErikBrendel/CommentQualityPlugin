commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify a prefix that can be used for parameters that mark potentially  * empty fields, having "prefix + field" as name. Such a marker parameter is  * checked by existence: You can send any value for it, for example "visible".  * This is particularly useful for HTML checkboxes and select options.  * <p>Default is "_", for "_FIELD" parameters (e.g. "_subscribeToNewsletter").  * Set this to null if you want to turn off the empty field check completely.  * <p>HTML checkboxes only send a value when they're checked, so it is not  * possible to detect that a formerly checked box has just been unchecked,  * at least not with standard HTML means.  * <p>One way to address this is to look for a checkbox parameter value if  * you know that the checkbox has been visible in the form, resetting the  * checkbox if no value found. In Spring web MVC, this typically happens  * in a custom {@code onBind} implementation.  * <p>This auto-reset mechanism addresses this deficiency, provided  * that a marker parameter is sent for each checkbox field, like  * "_subscribeToNewsletter" for a "subscribeToNewsletter" field.  * As the marker parameter is sent in any case, the data binder can  * detect an empty field and automatically reset its value.  * @see #DEFAULT_FIELD_MARKER_PREFIX  */ ;/**  * Specify a prefix that can be used for parameters that mark potentially  * empty fields, having "prefix + field" as name. Such a marker parameter is  * checked by existence: You can send any value for it, for example "visible".  * This is particularly useful for HTML checkboxes and select options.  * <p>Default is "_", for "_FIELD" parameters (e.g. "_subscribeToNewsletter").  * Set this to null if you want to turn off the empty field check completely.  * <p>HTML checkboxes only send a value when they're checked, so it is not  * possible to detect that a formerly checked box has just been unchecked,  * at least not with standard HTML means.  * <p>One way to address this is to look for a checkbox parameter value if  * you know that the checkbox has been visible in the form, resetting the  * checkbox if no value found. In Spring web MVC, this typically happens  * in a custom {@code onBind} implementation.  * <p>This auto-reset mechanism addresses this deficiency, provided  * that a marker parameter is sent for each checkbox field, like  * "_subscribeToNewsletter" for a "subscribeToNewsletter" field.  * As the marker parameter is sent in any case, the data binder can  * detect an empty field and automatically reset its value.  * @see #DEFAULT_FIELD_MARKER_PREFIX  */ public void setFieldMarkerPrefix(@Nullable String fieldMarkerPrefix) {     this.fieldMarkerPrefix = fieldMarkerPrefix. }
true;public;0;4;/**  * Return the prefix for parameters that mark potentially empty fields.  */ ;/**  * Return the prefix for parameters that mark potentially empty fields.  */ @Nullable public String getFieldMarkerPrefix() {     return this.fieldMarkerPrefix. }
true;public;1;3;/**  * Specify a prefix that can be used for parameters that indicate default  * value fields, having "prefix + field" as name. The value of the default  * field is used when the field is not provided.  * <p>Default is "!", for "!FIELD" parameters (e.g. "!subscribeToNewsletter").  * Set this to null if you want to turn off the field defaults completely.  * <p>HTML checkboxes only send a value when they're checked, so it is not  * possible to detect that a formerly checked box has just been unchecked,  * at least not with standard HTML means.  A default field is especially  * useful when a checkbox represents a non-boolean value.  * <p>The presence of a default parameter preempts the behavior of a field  * marker for the given field.  * @see #DEFAULT_FIELD_DEFAULT_PREFIX  */ ;/**  * Specify a prefix that can be used for parameters that indicate default  * value fields, having "prefix + field" as name. The value of the default  * field is used when the field is not provided.  * <p>Default is "!", for "!FIELD" parameters (e.g. "!subscribeToNewsletter").  * Set this to null if you want to turn off the field defaults completely.  * <p>HTML checkboxes only send a value when they're checked, so it is not  * possible to detect that a formerly checked box has just been unchecked,  * at least not with standard HTML means.  A default field is especially  * useful when a checkbox represents a non-boolean value.  * <p>The presence of a default parameter preempts the behavior of a field  * marker for the given field.  * @see #DEFAULT_FIELD_DEFAULT_PREFIX  */ public void setFieldDefaultPrefix(@Nullable String fieldDefaultPrefix) {     this.fieldDefaultPrefix = fieldDefaultPrefix. }
true;public;0;4;/**  * Return the prefix for parameters that mark default fields.  */ ;/**  * Return the prefix for parameters that mark default fields.  */ @Nullable public String getFieldDefaultPrefix() {     return this.fieldDefaultPrefix. }
true;public;1;3;/**  * Set whether to bind empty MultipartFile parameters. Default is "true".  * <p>Turn this off if you want to keep an already bound MultipartFile  * when the user resubmits the form without choosing a different file.  * Else, the already bound MultipartFile will be replaced by an empty  * MultipartFile holder.  * @see org.springframework.web.multipart.MultipartFile  */ ;/**  * Set whether to bind empty MultipartFile parameters. Default is "true".  * <p>Turn this off if you want to keep an already bound MultipartFile  * when the user resubmits the form without choosing a different file.  * Else, the already bound MultipartFile will be replaced by an empty  * MultipartFile holder.  * @see org.springframework.web.multipart.MultipartFile  */ public void setBindEmptyMultipartFiles(boolean bindEmptyMultipartFiles) {     this.bindEmptyMultipartFiles = bindEmptyMultipartFiles. }
true;public;0;3;/**  * Return whether to bind empty MultipartFile parameters.  */ ;/**  * Return whether to bind empty MultipartFile parameters.  */ public boolean isBindEmptyMultipartFiles() {     return this.bindEmptyMultipartFiles. }
true;protected;1;6;/**  * This implementation performs a field default and marker check  * before delegating to the superclass binding process.  * @see #checkFieldDefaults  * @see #checkFieldMarkers  */ ;/**  * This implementation performs a field default and marker check  * before delegating to the superclass binding process.  * @see #checkFieldDefaults  * @see #checkFieldMarkers  */ @Override protected void doBind(MutablePropertyValues mpvs) {     checkFieldDefaults(mpvs).     checkFieldMarkers(mpvs).     super.doBind(mpvs). }
true;protected;1;15;/**  * Check the given property values for field defaults,  * i.e. for fields that start with the field default prefix.  * <p>The existence of a field defaults indicates that the specified  * value should be used if the field is otherwise not present.  * @param mpvs the property values to be bound (can be modified)  * @see #getFieldDefaultPrefix  */ ;/**  * Check the given property values for field defaults,  * i.e. for fields that start with the field default prefix.  * <p>The existence of a field defaults indicates that the specified  * value should be used if the field is otherwise not present.  * @param mpvs the property values to be bound (can be modified)  * @see #getFieldDefaultPrefix  */ protected void checkFieldDefaults(MutablePropertyValues mpvs) {     String fieldDefaultPrefix = getFieldDefaultPrefix().     if (fieldDefaultPrefix != null) {         PropertyValue[] pvArray = mpvs.getPropertyValues().         for (PropertyValue pv : pvArray) {             if (pv.getName().startsWith(fieldDefaultPrefix)) {                 String field = pv.getName().substring(fieldDefaultPrefix.length()).                 if (getPropertyAccessor().isWritableProperty(field) && !mpvs.contains(field)) {                     mpvs.add(field, pv.getValue()).                 }                 mpvs.removePropertyValue(pv).             }         }     } }
true;protected;1;16;/**  * Check the given property values for field markers,  * i.e. for fields that start with the field marker prefix.  * <p>The existence of a field marker indicates that the specified  * field existed in the form. If the property values do not contain  * a corresponding field value, the field will be considered as empty  * and will be reset appropriately.  * @param mpvs the property values to be bound (can be modified)  * @see #getFieldMarkerPrefix  * @see #getEmptyValue(String, Class)  */ ;/**  * Check the given property values for field markers,  * i.e. for fields that start with the field marker prefix.  * <p>The existence of a field marker indicates that the specified  * field existed in the form. If the property values do not contain  * a corresponding field value, the field will be considered as empty  * and will be reset appropriately.  * @param mpvs the property values to be bound (can be modified)  * @see #getFieldMarkerPrefix  * @see #getEmptyValue(String, Class)  */ protected void checkFieldMarkers(MutablePropertyValues mpvs) {     String fieldMarkerPrefix = getFieldMarkerPrefix().     if (fieldMarkerPrefix != null) {         PropertyValue[] pvArray = mpvs.getPropertyValues().         for (PropertyValue pv : pvArray) {             if (pv.getName().startsWith(fieldMarkerPrefix)) {                 String field = pv.getName().substring(fieldMarkerPrefix.length()).                 if (getPropertyAccessor().isWritableProperty(field) && !mpvs.contains(field)) {                     Class<?> fieldType = getPropertyAccessor().getPropertyType(field).                     mpvs.add(field, getEmptyValue(field, fieldType)).                 }                 mpvs.removePropertyValue(pv).             }         }     } }
true;protected;2;4;/**  * Determine an empty value for the specified field.  * <p>The default implementation delegates to {@link #getEmptyValue(Class)}  * if the field type is known, otherwise falls back to {@code null}.  * @param field the name of the field  * @param fieldType the type of the field  * @return the empty value (for most fields: {@code null})  */ ;/**  * Determine an empty value for the specified field.  * <p>The default implementation delegates to {@link #getEmptyValue(Class)}  * if the field type is known, otherwise falls back to {@code null}.  * @param field the name of the field  * @param fieldType the type of the field  * @return the empty value (for most fields: {@code null})  */ @Nullable protected Object getEmptyValue(String field, @Nullable Class<?> fieldType) {     return (fieldType != null ? getEmptyValue(fieldType) : null). }
true;public;1;26;/**  * Determine an empty value for the specified field.  * <p>The default implementation returns:  * <ul>  * <li>{@code Boolean.FALSE} for boolean fields  * <li>an empty array for array types  * <li>Collection implementations for Collection types  * <li>Map implementations for Map types  * <li>else, {@code null} is used as default  * </ul>  * @param fieldType the type of the field  * @return the empty value (for most fields: {@code null})  * @since 5.0  */ ;/**  * Determine an empty value for the specified field.  * <p>The default implementation returns:  * <ul>  * <li>{@code Boolean.FALSE} for boolean fields  * <li>an empty array for array types  * <li>Collection implementations for Collection types  * <li>Map implementations for Map types  * <li>else, {@code null} is used as default  * </ul>  * @param fieldType the type of the field  * @return the empty value (for most fields: {@code null})  * @since 5.0  */ @Nullable public Object getEmptyValue(Class<?> fieldType) {     try {         if (boolean.class == fieldType || Boolean.class == fieldType) {             // Special handling of boolean property.             return Boolean.FALSE.         } else if (fieldType.isArray()) {             // Special handling of array property.             return Array.newInstance(fieldType.getComponentType(), 0).         } else if (Collection.class.isAssignableFrom(fieldType)) {             return CollectionFactory.createCollection(fieldType, 0).         } else if (Map.class.isAssignableFrom(fieldType)) {             return CollectionFactory.createMap(fieldType, 0).         }     } catch (IllegalArgumentException ex) {         if (logger.isDebugEnabled()) {             logger.debug("Failed to create default value - falling back to null: " + ex.getMessage()).         }     }     // Default value: null.     return null. }
true;protected;2;13;/**  * Bind all multipart files contained in the given request, if any  * (in case of a multipart request). To be called by subclasses.  * <p>Multipart files will only be added to the property values if they  * are not empty or if we're configured to bind empty multipart files too.  * @param multipartFiles a Map of field name String to MultipartFile object  * @param mpvs the property values to be bound (can be modified)  * @see org.springframework.web.multipart.MultipartFile  * @see #setBindEmptyMultipartFiles  */ ;/**  * Bind all multipart files contained in the given request, if any  * (in case of a multipart request). To be called by subclasses.  * <p>Multipart files will only be added to the property values if they  * are not empty or if we're configured to bind empty multipart files too.  * @param multipartFiles a Map of field name String to MultipartFile object  * @param mpvs the property values to be bound (can be modified)  * @see org.springframework.web.multipart.MultipartFile  * @see #setBindEmptyMultipartFiles  */ protected void bindMultipart(Map<String, List<MultipartFile>> multipartFiles, MutablePropertyValues mpvs) {     multipartFiles.forEach((key, values) -> {         if (values.size() == 1) {             MultipartFile value = values.get(0).             if (isBindEmptyMultipartFiles() || !value.isEmpty()) {                 mpvs.add(key, value).             }         } else {             mpvs.add(key, values).         }     }). }
