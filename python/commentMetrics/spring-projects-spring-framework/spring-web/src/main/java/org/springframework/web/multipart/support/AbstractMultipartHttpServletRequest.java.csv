commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public HttpServletRequest getRequest() {     return (HttpServletRequest) super.getRequest(). }
false;public;0;4;;@Override public HttpMethod getRequestMethod() {     return HttpMethod.resolve(getRequest().getMethod()). }
false;public;0;10;;@Override public HttpHeaders getRequestHeaders() {     HttpHeaders headers = new HttpHeaders().     Enumeration<String> headerNames = getHeaderNames().     while (headerNames.hasMoreElements()) {         String headerName = headerNames.nextElement().         headers.put(headerName, Collections.list(getHeaders(headerName))).     }     return headers. }
false;public;0;4;;@Override public Iterator<String> getFileNames() {     return getMultipartFiles().keySet().iterator(). }
false;public;1;4;;@Override public MultipartFile getFile(String name) {     return getMultipartFiles().getFirst(name). }
false;public;1;10;;@Override public List<MultipartFile> getFiles(String name) {     List<MultipartFile> multipartFiles = getMultipartFiles().get(name).     if (multipartFiles != null) {         return multipartFiles.     } else {         return Collections.emptyList().     } }
false;public;0;4;;@Override public Map<String, MultipartFile> getFileMap() {     return getMultipartFiles().toSingleValueMap(). }
false;public;0;4;;@Override public MultiValueMap<String, MultipartFile> getMultiFileMap() {     return getMultipartFiles(). }
true;public;0;3;/**  * Determine whether the underlying multipart request has been resolved.  * @return {@code true} when eagerly initialized or lazily triggered,  * {@code false} in case of a lazy-resolution request that got aborted  * before any parameters or multipart files have been accessed  * @since 4.3.15  * @see #getMultipartFiles()  */ ;/**  * Determine whether the underlying multipart request has been resolved.  * @return {@code true} when eagerly initialized or lazily triggered,  * {@code false} in case of a lazy-resolution request that got aborted  * before any parameters or multipart files have been accessed  * @since 4.3.15  * @see #getMultipartFiles()  */ public boolean isResolved() {     return (this.multipartFiles != null). }
true;protected,final;1;4;/**  * Set a Map with parameter names as keys and list of MultipartFile objects as values.  * To be invoked by subclasses on initialization.  */ ;/**  * Set a Map with parameter names as keys and list of MultipartFile objects as values.  * To be invoked by subclasses on initialization.  */ protected final void setMultipartFiles(MultiValueMap<String, MultipartFile> multipartFiles) {     this.multipartFiles = new LinkedMultiValueMap<>(Collections.unmodifiableMap(multipartFiles)). }
true;protected;0;6;/**  * Obtain the MultipartFile Map for retrieval,  * lazily initializing it if necessary.  * @see #initializeMultipart()  */ ;/**  * Obtain the MultipartFile Map for retrieval,  * lazily initializing it if necessary.  * @see #initializeMultipart()  */ protected MultiValueMap<String, MultipartFile> getMultipartFiles() {     if (this.multipartFiles == null) {         initializeMultipart().     }     return this.multipartFiles. }
true;protected;0;3;/**  * Lazily initialize the multipart request, if possible.  * Only called if not already eagerly initialized.  */ ;/**  * Lazily initialize the multipart request, if possible.  * Only called if not already eagerly initialized.  */ protected void initializeMultipart() {     throw new IllegalStateException("Multipart request not initialized"). }
