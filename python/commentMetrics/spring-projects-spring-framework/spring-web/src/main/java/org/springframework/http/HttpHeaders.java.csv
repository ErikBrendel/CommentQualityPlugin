commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the list of acceptable {@linkplain MediaType media types},  * as specified by the {@code Accept} header.  */ ;/**  * Set the list of acceptable {@linkplain MediaType media types},  * as specified by the {@code Accept} header.  */ public void setAccept(List<MediaType> acceptableMediaTypes) {     set(ACCEPT, MediaType.toString(acceptableMediaTypes)). }
true;public;0;3;/**  * Return the list of acceptable {@linkplain MediaType media types},  * as specified by the {@code Accept} header.  * <p>Returns an empty list when the acceptable media types are unspecified.  */ ;/**  * Return the list of acceptable {@linkplain MediaType media types},  * as specified by the {@code Accept} header.  * <p>Returns an empty list when the acceptable media types are unspecified.  */ public List<MediaType> getAccept() {     return MediaType.parseMediaTypes(get(ACCEPT)). }
true;public;1;11;/**  * Set the acceptable language ranges, as specified by the  * {@literal Accept-Language} header.  * @since 5.0  */ ;/**  * Set the acceptable language ranges, as specified by the  * {@literal Accept-Language} header.  * @since 5.0  */ public void setAcceptLanguage(List<Locale.LanguageRange> languages) {     Assert.notNull(languages, "LanguageRange List must not be null").     DecimalFormat decimal = new DecimalFormat("0.0", DECIMAL_FORMAT_SYMBOLS).     List<String> values = languages.stream().map(range -> range.getWeight() == Locale.LanguageRange.MAX_WEIGHT ? range.getRange() : range.getRange() + ".q=" + decimal.format(range.getWeight())).collect(Collectors.toList()).     set(ACCEPT_LANGUAGE, toCommaDelimitedString(values)). }
true;public;0;4;/**  * Return the language ranges from the {@literal "Accept-Language"} header.  * <p>If you only need sorted, preferred locales only use  * {@link #getAcceptLanguageAsLocales()} or if you need to filter based on  * a list of supported locales you can pass the returned list to  * {@link Locale#filter(List, Collection)}.  * @throws IllegalArgumentException if the value cannot be converted to a language range  * @since 5.0  */ ;/**  * Return the language ranges from the {@literal "Accept-Language"} header.  * <p>If you only need sorted, preferred locales only use  * {@link #getAcceptLanguageAsLocales()} or if you need to filter based on  * a list of supported locales you can pass the returned list to  * {@link Locale#filter(List, Collection)}.  * @throws IllegalArgumentException if the value cannot be converted to a language range  * @since 5.0  */ public List<Locale.LanguageRange> getAcceptLanguage() {     String value = getFirst(ACCEPT_LANGUAGE).     return (StringUtils.hasText(value) ? Locale.LanguageRange.parse(value) : Collections.emptyList()). }
true;public;1;5;/**  * Variant of {@link #setAcceptLanguage(List)} using {@link Locale}'s.  * @since 5.0  */ ;/**  * Variant of {@link #setAcceptLanguage(List)} using {@link Locale}'s.  * @since 5.0  */ public void setAcceptLanguageAsLocales(List<Locale> locales) {     setAcceptLanguage(locales.stream().map(locale -> new Locale.LanguageRange(locale.toLanguageTag())).collect(Collectors.toList())). }
true;public;0;10;/**  * A variant of {@link #getAcceptLanguage()} that converts each  * {@link java.util.Locale.LanguageRange} to a {@link Locale}.  * @return the locales or an empty list  * @throws IllegalArgumentException if the value cannot be converted to a locale  * @since 5.0  */ ;/**  * A variant of {@link #getAcceptLanguage()} that converts each  * {@link java.util.Locale.LanguageRange} to a {@link Locale}.  * @return the locales or an empty list  * @throws IllegalArgumentException if the value cannot be converted to a locale  * @since 5.0  */ public List<Locale> getAcceptLanguageAsLocales() {     List<Locale.LanguageRange> ranges = getAcceptLanguage().     if (ranges.isEmpty()) {         return Collections.emptyList().     }     return ranges.stream().map(range -> Locale.forLanguageTag(range.getRange())).filter(locale -> StringUtils.hasText(locale.getDisplayName())).collect(Collectors.toList()). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Allow-Credentials} response header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Allow-Credentials} response header.  */ public void setAccessControlAllowCredentials(boolean allowCredentials) {     set(ACCESS_CONTROL_ALLOW_CREDENTIALS, Boolean.toString(allowCredentials)). }
true;public;0;3;/**  * Return the value of the {@code Access-Control-Allow-Credentials} response header.  */ ;/**  * Return the value of the {@code Access-Control-Allow-Credentials} response header.  */ public boolean getAccessControlAllowCredentials() {     return Boolean.parseBoolean(getFirst(ACCESS_CONTROL_ALLOW_CREDENTIALS)). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Allow-Headers} response header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Allow-Headers} response header.  */ public void setAccessControlAllowHeaders(List<String> allowedHeaders) {     set(ACCESS_CONTROL_ALLOW_HEADERS, toCommaDelimitedString(allowedHeaders)). }
true;public;0;3;/**  * Return the value of the {@code Access-Control-Allow-Headers} response header.  */ ;/**  * Return the value of the {@code Access-Control-Allow-Headers} response header.  */ public List<String> getAccessControlAllowHeaders() {     return getValuesAsList(ACCESS_CONTROL_ALLOW_HEADERS). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Allow-Methods} response header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Allow-Methods} response header.  */ public void setAccessControlAllowMethods(List<HttpMethod> allowedMethods) {     set(ACCESS_CONTROL_ALLOW_METHODS, StringUtils.collectionToCommaDelimitedString(allowedMethods)). }
true;public;0;14;/**  * Return the value of the {@code Access-Control-Allow-Methods} response header.  */ ;/**  * Return the value of the {@code Access-Control-Allow-Methods} response header.  */ public List<HttpMethod> getAccessControlAllowMethods() {     List<HttpMethod> result = new ArrayList<>().     String value = getFirst(ACCESS_CONTROL_ALLOW_METHODS).     if (value != null) {         String[] tokens = StringUtils.tokenizeToStringArray(value, ",").         for (String token : tokens) {             HttpMethod resolved = HttpMethod.resolve(token).             if (resolved != null) {                 result.add(resolved).             }         }     }     return result. }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Allow-Origin} response header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Allow-Origin} response header.  */ public void setAccessControlAllowOrigin(@Nullable String allowedOrigin) {     setOrRemove(ACCESS_CONTROL_ALLOW_ORIGIN, allowedOrigin). }
true;public;0;4;/**  * Return the value of the {@code Access-Control-Allow-Origin} response header.  */ ;/**  * Return the value of the {@code Access-Control-Allow-Origin} response header.  */ @Nullable public String getAccessControlAllowOrigin() {     return getFieldValues(ACCESS_CONTROL_ALLOW_ORIGIN). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Expose-Headers} response header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Expose-Headers} response header.  */ public void setAccessControlExposeHeaders(List<String> exposedHeaders) {     set(ACCESS_CONTROL_EXPOSE_HEADERS, toCommaDelimitedString(exposedHeaders)). }
true;public;0;3;/**  * Return the value of the {@code Access-Control-Expose-Headers} response header.  */ ;/**  * Return the value of the {@code Access-Control-Expose-Headers} response header.  */ public List<String> getAccessControlExposeHeaders() {     return getValuesAsList(ACCESS_CONTROL_EXPOSE_HEADERS). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Max-Age} response header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Max-Age} response header.  */ public void setAccessControlMaxAge(long maxAge) {     set(ACCESS_CONTROL_MAX_AGE, Long.toString(maxAge)). }
true;public;0;4;/**  * Return the value of the {@code Access-Control-Max-Age} response header.  * <p>Returns -1 when the max age is unknown.  */ ;/**  * Return the value of the {@code Access-Control-Max-Age} response header.  * <p>Returns -1 when the max age is unknown.  */ public long getAccessControlMaxAge() {     String value = getFirst(ACCESS_CONTROL_MAX_AGE).     return (value != null ? Long.parseLong(value) : -1). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Request-Headers} request header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Request-Headers} request header.  */ public void setAccessControlRequestHeaders(List<String> requestHeaders) {     set(ACCESS_CONTROL_REQUEST_HEADERS, toCommaDelimitedString(requestHeaders)). }
true;public;0;3;/**  * Return the value of the {@code Access-Control-Request-Headers} request header.  */ ;/**  * Return the value of the {@code Access-Control-Request-Headers} request header.  */ public List<String> getAccessControlRequestHeaders() {     return getValuesAsList(ACCESS_CONTROL_REQUEST_HEADERS). }
true;public;1;3;/**  * Set the (new) value of the {@code Access-Control-Request-Method} request header.  */ ;/**  * Set the (new) value of the {@code Access-Control-Request-Method} request header.  */ public void setAccessControlRequestMethod(@Nullable HttpMethod requestMethod) {     setOrRemove(ACCESS_CONTROL_REQUEST_METHOD, (requestMethod != null ? requestMethod.name() : null)). }
true;public;0;4;/**  * Return the value of the {@code Access-Control-Request-Method} request header.  */ ;/**  * Return the value of the {@code Access-Control-Request-Method} request header.  */ @Nullable public HttpMethod getAccessControlRequestMethod() {     return HttpMethod.resolve(getFirst(ACCESS_CONTROL_REQUEST_METHOD)). }
true;public;1;11;/**  * Set the list of acceptable {@linkplain Charset charsets},  * as specified by the {@code Accept-Charset} header.  */ ;/**  * Set the list of acceptable {@linkplain Charset charsets},  * as specified by the {@code Accept-Charset} header.  */ public void setAcceptCharset(List<Charset> acceptableCharsets) {     StringBuilder builder = new StringBuilder().     for (Iterator<Charset> iterator = acceptableCharsets.iterator(). iterator.hasNext(). ) {         Charset charset = iterator.next().         builder.append(charset.name().toLowerCase(Locale.ENGLISH)).         if (iterator.hasNext()) {             builder.append(", ").         }     }     set(ACCEPT_CHARSET, builder.toString()). }
true;public;0;24;/**  * Return the list of acceptable {@linkplain Charset charsets},  * as specified by the {@code Accept-Charset} header.  */ ;/**  * Return the list of acceptable {@linkplain Charset charsets},  * as specified by the {@code Accept-Charset} header.  */ public List<Charset> getAcceptCharset() {     String value = getFirst(ACCEPT_CHARSET).     if (value != null) {         String[] tokens = StringUtils.tokenizeToStringArray(value, ",").         List<Charset> result = new ArrayList<>(tokens.length).         for (String token : tokens) {             int paramIdx = token.indexOf('.').             String charsetName.             if (paramIdx == -1) {                 charsetName = token.             } else {                 charsetName = token.substring(0, paramIdx).             }             if (!charsetName.equals("*")) {                 result.add(Charset.forName(charsetName)).             }         }         return result.     } else {         return Collections.emptyList().     } }
true;public;1;3;/**  * Set the set of allowed {@link HttpMethod HTTP methods},  * as specified by the {@code Allow} header.  */ ;/**  * Set the set of allowed {@link HttpMethod HTTP methods},  * as specified by the {@code Allow} header.  */ public void setAllow(Set<HttpMethod> allowedMethods) {     set(ALLOW, StringUtils.collectionToCommaDelimitedString(allowedMethods)). }
true;public;0;17;/**  * Return the set of allowed {@link HttpMethod HTTP methods},  * as specified by the {@code Allow} header.  * <p>Returns an empty set when the allowed methods are unspecified.  */ ;/**  * Return the set of allowed {@link HttpMethod HTTP methods},  * as specified by the {@code Allow} header.  * <p>Returns an empty set when the allowed methods are unspecified.  */ public Set<HttpMethod> getAllow() {     String value = getFirst(ALLOW).     if (!StringUtils.isEmpty(value)) {         String[] tokens = StringUtils.tokenizeToStringArray(value, ",").         List<HttpMethod> result = new ArrayList<>(tokens.length).         for (String token : tokens) {             HttpMethod resolved = HttpMethod.resolve(token).             if (resolved != null) {                 result.add(resolved).             }         }         return EnumSet.copyOf(result).     } else {         return EnumSet.noneOf(HttpMethod.class).     } }
true;public;2;3;/**  * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to  * Basic Authentication based on the given username and password.  * <p>Note that this method only supports characters in the  * {@link StandardCharsets#ISO_8859_1 ISO-8859-1} character set.  * @param username the username  * @param password the password  * @throws IllegalArgumentException if either {@code user} or  * {@code password} contain characters that cannot be encoded to ISO-8859-1  * @since 5.1  * @see #setBasicAuth(String, String, Charset)  * @see <a href="https://tools.ietf.org/html/rfc7617">RFC 7617</a>  */ ;/**  * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to  * Basic Authentication based on the given username and password.  * <p>Note that this method only supports characters in the  * {@link StandardCharsets#ISO_8859_1 ISO-8859-1} character set.  * @param username the username  * @param password the password  * @throws IllegalArgumentException if either {@code user} or  * {@code password} contain characters that cannot be encoded to ISO-8859-1  * @since 5.1  * @see #setBasicAuth(String, String, Charset)  * @see <a href="https://tools.ietf.org/html/rfc7617">RFC 7617</a>  */ public void setBasicAuth(String username, String password) {     setBasicAuth(username, password, null). }
true;public;3;18;/**  * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to  * Basic Authentication based on the given username and password.  * @param username the username  * @param password the password  * @param charset the charset to use to convert the credentials into an octet  * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.  * @throws IllegalArgumentException if {@code username} or {@code password}  * contains characters that cannot be encoded to the given charset  * @since 5.1  * @see <a href="https://tools.ietf.org/html/rfc7617">RFC 7617</a>  */ ;/**  * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to  * Basic Authentication based on the given username and password.  * @param username the username  * @param password the password  * @param charset the charset to use to convert the credentials into an octet  * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.  * @throws IllegalArgumentException if {@code username} or {@code password}  * contains characters that cannot be encoded to the given charset  * @since 5.1  * @see <a href="https://tools.ietf.org/html/rfc7617">RFC 7617</a>  */ public void setBasicAuth(String username, String password, @Nullable Charset charset) {     Assert.notNull(username, "Username must not be null").     Assert.notNull(password, "Password must not be null").     if (charset == null) {         charset = StandardCharsets.ISO_8859_1.     }     CharsetEncoder encoder = charset.newEncoder().     if (!encoder.canEncode(username) || !encoder.canEncode(password)) {         throw new IllegalArgumentException("Username or password contains characters that cannot be encoded to " + charset.displayName()).     }     String credentialsString = username + ":" + password.     byte[] encodedBytes = Base64.getEncoder().encode(credentialsString.getBytes(charset)).     String encodedCredentials = new String(encodedBytes, charset).     set(AUTHORIZATION, "Basic " + encodedCredentials). }
true;public;1;3;/**  * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to  * the given Bearer token.  * @param token the Base64 encoded token  * @since 5.1  * @see <a href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>  */ ;/**  * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to  * the given Bearer token.  * @param token the Base64 encoded token  * @since 5.1  * @see <a href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>  */ public void setBearerAuth(String token) {     set(AUTHORIZATION, "Bearer " + token). }
true;public;1;3;/**  * Set a configured {@link CacheControl} instance as the  * new value of the {@code Cache-Control} header.  * @since 5.0.5  */ ;/**  * Set a configured {@link CacheControl} instance as the  * new value of the {@code Cache-Control} header.  * @since 5.0.5  */ public void setCacheControl(CacheControl cacheControl) {     setOrRemove(CACHE_CONTROL, cacheControl.getHeaderValue()). }
true;public;1;3;/**  * Set the (new) value of the {@code Cache-Control} header.  */ ;/**  * Set the (new) value of the {@code Cache-Control} header.  */ public void setCacheControl(@Nullable String cacheControl) {     setOrRemove(CACHE_CONTROL, cacheControl). }
true;public;0;4;/**  * Return the value of the {@code Cache-Control} header.  */ ;/**  * Return the value of the {@code Cache-Control} header.  */ @Nullable public String getCacheControl() {     return getFieldValues(CACHE_CONTROL). }
true;public;1;3;/**  * Set the (new) value of the {@code Connection} header.  */ ;/**  * Set the (new) value of the {@code Connection} header.  */ public void setConnection(String connection) {     set(CONNECTION, connection). }
true;public;1;3;/**  * Set the (new) value of the {@code Connection} header.  */ ;/**  * Set the (new) value of the {@code Connection} header.  */ public void setConnection(List<String> connection) {     set(CONNECTION, toCommaDelimitedString(connection)). }
true;public;0;3;/**  * Return the value of the {@code Connection} header.  */ ;/**  * Return the value of the {@code Connection} header.  */ public List<String> getConnection() {     return getValuesAsList(CONNECTION). }
true;public;2;8;/**  * Set the {@code Content-Disposition} header when creating a  * {@code "multipart/form-data"} request.  * <p>Applications typically would not set this header directly but  * rather prepare a {@code MultiValueMap<String, Object>}, containing an  * Object or a {@link org.springframework.core.io.Resource} for each part,  * and then pass that to the {@code RestTemplate} or {@code WebClient}.  * @param name the control name  * @param filename the filename (may be {@code null})  * @see #getContentDisposition()  */ ;/**  * Set the {@code Content-Disposition} header when creating a  * {@code "multipart/form-data"} request.  * <p>Applications typically would not set this header directly but  * rather prepare a {@code MultiValueMap<String, Object>}, containing an  * Object or a {@link org.springframework.core.io.Resource} for each part,  * and then pass that to the {@code RestTemplate} or {@code WebClient}.  * @param name the control name  * @param filename the filename (may be {@code null})  * @see #getContentDisposition()  */ public void setContentDispositionFormData(String name, @Nullable String filename) {     Assert.notNull(name, "Name must not be null").     ContentDisposition.Builder disposition = ContentDisposition.builder("form-data").name(name).     if (filename != null) {         disposition.filename(filename).     }     setContentDisposition(disposition.build()). }
true;public;1;3;/**  * Set the {@literal Content-Disposition} header.  * <p>This could be used on a response to indicate if the content is  * expected to be displayed inline in the browser or as an attachment to be  * saved locally.  * <p>It can also be used for a {@code "multipart/form-data"} request.  * For more details see notes on {@link #setContentDispositionFormData}.  * @since 5.0  * @see #getContentDisposition()  */ ;/**  * Set the {@literal Content-Disposition} header.  * <p>This could be used on a response to indicate if the content is  * expected to be displayed inline in the browser or as an attachment to be  * saved locally.  * <p>It can also be used for a {@code "multipart/form-data"} request.  * For more details see notes on {@link #setContentDispositionFormData}.  * @since 5.0  * @see #getContentDisposition()  */ public void setContentDisposition(ContentDisposition contentDisposition) {     set(CONTENT_DISPOSITION, contentDisposition.toString()). }
true;public;0;7;/**  * Return a parsed representation of the {@literal Content-Disposition} header.  * @since 5.0  * @see #setContentDisposition(ContentDisposition)  */ ;/**  * Return a parsed representation of the {@literal Content-Disposition} header.  * @since 5.0  * @see #setContentDisposition(ContentDisposition)  */ public ContentDisposition getContentDisposition() {     String contentDisposition = getFirst(CONTENT_DISPOSITION).     if (contentDisposition != null) {         return ContentDisposition.parse(contentDisposition).     }     return ContentDisposition.empty(). }
true;public;1;3;/**  * Set the {@link Locale} of the content language,  * as specified by the {@literal Content-Language} header.  * <p>Use {@code set(CONTENT_LANGUAGE, ...)} if you need  * to set multiple content languages.</p>  * @since 5.0  */ ;/**  * Set the {@link Locale} of the content language,  * as specified by the {@literal Content-Language} header.  * <p>Use {@code set(CONTENT_LANGUAGE, ...)} if you need  * to set multiple content languages.</p>  * @since 5.0  */ public void setContentLanguage(@Nullable Locale locale) {     setOrRemove(CONTENT_LANGUAGE, (locale != null ? locale.toLanguageTag() : null)). }
true;public;0;8;/**  * Return the first {@link Locale} of the content languages,  * as specified by the {@literal Content-Language} header.  * <p>Returns {@code null} when the content language is unknown.  * <p>Use {@code getValuesAsList(CONTENT_LANGUAGE)} if you need  * to get multiple content languages.</p>  * @since 5.0  */ ;/**  * Return the first {@link Locale} of the content languages,  * as specified by the {@literal Content-Language} header.  * <p>Returns {@code null} when the content language is unknown.  * <p>Use {@code getValuesAsList(CONTENT_LANGUAGE)} if you need  * to get multiple content languages.</p>  * @since 5.0  */ @Nullable public Locale getContentLanguage() {     return getValuesAsList(CONTENT_LANGUAGE).stream().findFirst().map(Locale::forLanguageTag).orElse(null). }
true;public;1;3;/**  * Set the length of the body in bytes, as specified by the  * {@code Content-Length} header.  */ ;/**  * Set the length of the body in bytes, as specified by the  * {@code Content-Length} header.  */ public void setContentLength(long contentLength) {     set(CONTENT_LENGTH, Long.toString(contentLength)). }
true;public;0;4;/**  * Return the length of the body in bytes, as specified by the  * {@code Content-Length} header.  * <p>Returns -1 when the content-length is unknown.  */ ;/**  * Return the length of the body in bytes, as specified by the  * {@code Content-Length} header.  * <p>Returns -1 when the content-length is unknown.  */ public long getContentLength() {     String value = getFirst(CONTENT_LENGTH).     return (value != null ? Long.parseLong(value) : -1). }
true;public;1;10;/**  * Set the {@linkplain MediaType media type} of the body,  * as specified by the {@code Content-Type} header.  */ ;/**  * Set the {@linkplain MediaType media type} of the body,  * as specified by the {@code Content-Type} header.  */ public void setContentType(@Nullable MediaType mediaType) {     if (mediaType != null) {         Assert.isTrue(!mediaType.isWildcardType(), "Content-Type cannot contain wildcard type '*'").         Assert.isTrue(!mediaType.isWildcardSubtype(), "Content-Type cannot contain wildcard subtype '*'").         set(CONTENT_TYPE, mediaType.toString()).     } else {         remove(CONTENT_TYPE).     } }
true;public;0;5;/**  * Return the {@linkplain MediaType media type} of the body, as specified  * by the {@code Content-Type} header.  * <p>Returns {@code null} when the content-type is unknown.  */ ;/**  * Return the {@linkplain MediaType media type} of the body, as specified  * by the {@code Content-Type} header.  * <p>Returns {@code null} when the content-type is unknown.  */ @Nullable public MediaType getContentType() {     String value = getFirst(CONTENT_TYPE).     return (StringUtils.hasLength(value) ? MediaType.parseMediaType(value) : null). }
true;public;1;3;/**  * Set the date and time at which the message was created, as specified  * by the {@code Date} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ ;/**  * Set the date and time at which the message was created, as specified  * by the {@code Date} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ public void setDate(long date) {     setDate(DATE, date). }
true;public;0;3;/**  * Return the date and time at which the message was created, as specified  * by the {@code Date} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @throws IllegalArgumentException if the value cannot be converted to a date  */ ;/**  * Return the date and time at which the message was created, as specified  * by the {@code Date} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @throws IllegalArgumentException if the value cannot be converted to a date  */ public long getDate() {     return getFirstDate(DATE). }
true;public;1;11;/**  * Set the (new) entity tag of the body, as specified by the {@code ETag} header.  */ ;/**  * Set the (new) entity tag of the body, as specified by the {@code ETag} header.  */ public void setETag(@Nullable String etag) {     if (etag != null) {         Assert.isTrue(etag.startsWith("\"") || etag.startsWith("W/"), "Invalid ETag: does not start with W/ or \"").         Assert.isTrue(etag.endsWith("\""), "Invalid ETag: does not end with \"").         set(ETAG, etag).     } else {         remove(ETAG).     } }
true;public;0;4;/**  * Return the entity tag of the body, as specified by the {@code ETag} header.  */ ;/**  * Return the entity tag of the body, as specified by the {@code ETag} header.  */ @Nullable public String getETag() {     return getFirst(ETAG). }
true;public;1;3;/**  * Set the duration after which the message is no longer valid,  * as specified by the {@code Expires} header.  * @since 5.0.5  */ ;/**  * Set the duration after which the message is no longer valid,  * as specified by the {@code Expires} header.  * @since 5.0.5  */ public void setExpires(ZonedDateTime expires) {     setZonedDateTime(EXPIRES, expires). }
true;public;1;3;/**  * Set the date and time at which the message is no longer valid,  * as specified by the {@code Expires} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ ;/**  * Set the date and time at which the message is no longer valid,  * as specified by the {@code Expires} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ public void setExpires(long expires) {     setDate(EXPIRES, expires). }
true;public;0;3;/**  * Return the date and time at which the message is no longer valid,  * as specified by the {@code Expires} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @see #getFirstZonedDateTime(String)  */ ;/**  * Return the date and time at which the message is no longer valid,  * as specified by the {@code Expires} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @see #getFirstZonedDateTime(String)  */ public long getExpires() {     return getFirstDate(EXPIRES, false). }
true;public;1;13;/**  * Set the (new) value of the {@code Host} header.  * <p>If the given {@linkplain InetSocketAddress#getPort() port} is {@code 0},  * the host header will only contain the  * {@linkplain InetSocketAddress#getHostString() host name}.  * @since 5.0  */ ;/**  * Set the (new) value of the {@code Host} header.  * <p>If the given {@linkplain InetSocketAddress#getPort() port} is {@code 0},  * the host header will only contain the  * {@linkplain InetSocketAddress#getHostString() host name}.  * @since 5.0  */ public void setHost(@Nullable InetSocketAddress host) {     if (host != null) {         String value = host.getHostString().         int port = host.getPort().         if (port != 0) {             value = value + ":" + port.         }         set(HOST, value).     } else {         remove(HOST, null).     } }
true;public;0;26;/**  * Return the value of the {@code Host} header, if available.  * <p>If the header value does not contain a port, the  * {@linkplain InetSocketAddress#getPort() port} in the returned address will  * be {@code 0}.  * @since 5.0  */ ;/**  * Return the value of the {@code Host} header, if available.  * <p>If the header value does not contain a port, the  * {@linkplain InetSocketAddress#getPort() port} in the returned address will  * be {@code 0}.  * @since 5.0  */ @Nullable public InetSocketAddress getHost() {     String value = getFirst(HOST).     if (value == null) {         return null.     }     String host = null.     int port = 0.     int separator = (value.startsWith("[") ? value.indexOf(':', value.indexOf(']')) : value.lastIndexOf(':')).     if (separator != -1) {         host = value.substring(0, separator).         String portString = value.substring(separator + 1).         try {             port = Integer.parseInt(portString).         } catch (NumberFormatException ex) {         // ignore         }     }     if (host == null) {         host = value.     }     return InetSocketAddress.createUnresolved(host, port). }
true;public;1;3;/**  * Set the (new) value of the {@code If-Match} header.  * @since 4.3  */ ;/**  * Set the (new) value of the {@code If-Match} header.  * @since 4.3  */ public void setIfMatch(String ifMatch) {     set(IF_MATCH, ifMatch). }
true;public;1;3;/**  * Set the (new) value of the {@code If-Match} header.  * @since 4.3  */ ;/**  * Set the (new) value of the {@code If-Match} header.  * @since 4.3  */ public void setIfMatch(List<String> ifMatchList) {     set(IF_MATCH, toCommaDelimitedString(ifMatchList)). }
true;public;0;3;/**  * Return the value of the {@code If-Match} header.  * @since 4.3  */ ;/**  * Return the value of the {@code If-Match} header.  * @since 4.3  */ public List<String> getIfMatch() {     return getETagValuesAsList(IF_MATCH). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ public void setIfModifiedSince(ZonedDateTime ifModifiedSince) {     setZonedDateTime(IF_MODIFIED_SINCE, ifModifiedSince.withZoneSameInstant(GMT)). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ public void setIfModifiedSince(Instant ifModifiedSince) {     setInstant(IF_MODIFIED_SINCE, ifModifiedSince). }
true;public;1;3;/**  * Set the (new) value of the {@code If-Modified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ ;/**  * Set the (new) value of the {@code If-Modified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ public void setIfModifiedSince(long ifModifiedSince) {     setDate(IF_MODIFIED_SINCE, ifModifiedSince). }
true;public;0;3;/**  * Return the value of the {@code If-Modified-Since} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @see #getFirstZonedDateTime(String)  */ ;/**  * Return the value of the {@code If-Modified-Since} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @see #getFirstZonedDateTime(String)  */ public long getIfModifiedSince() {     return getFirstDate(IF_MODIFIED_SINCE, false). }
true;public;1;3;/**  * Set the (new) value of the {@code If-None-Match} header.  */ ;/**  * Set the (new) value of the {@code If-None-Match} header.  */ public void setIfNoneMatch(String ifNoneMatch) {     set(IF_NONE_MATCH, ifNoneMatch). }
true;public;1;3;/**  * Set the (new) values of the {@code If-None-Match} header.  */ ;/**  * Set the (new) values of the {@code If-None-Match} header.  */ public void setIfNoneMatch(List<String> ifNoneMatchList) {     set(IF_NONE_MATCH, toCommaDelimitedString(ifNoneMatchList)). }
true;public;0;3;/**  * Return the value of the {@code If-None-Match} header.  */ ;/**  * Return the value of the {@code If-None-Match} header.  */ public List<String> getIfNoneMatch() {     return getETagValuesAsList(IF_NONE_MATCH). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ public void setIfUnmodifiedSince(ZonedDateTime ifUnmodifiedSince) {     setZonedDateTime(IF_UNMODIFIED_SINCE, ifUnmodifiedSince.withZoneSameInstant(GMT)). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ public void setIfUnmodifiedSince(Instant ifUnmodifiedSince) {     setInstant(IF_UNMODIFIED_SINCE, ifUnmodifiedSince). }
true;public;1;3;/**  * Set the (new) value of the {@code If-Unmodified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  * @since 4.3  */ ;/**  * Set the (new) value of the {@code If-Unmodified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  * @since 4.3  */ public void setIfUnmodifiedSince(long ifUnmodifiedSince) {     setDate(IF_UNMODIFIED_SINCE, ifUnmodifiedSince). }
true;public;0;3;/**  * Return the value of the {@code If-Unmodified-Since} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @since 4.3  * @see #getFirstZonedDateTime(String)  */ ;/**  * Return the value of the {@code If-Unmodified-Since} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @since 4.3  * @see #getFirstZonedDateTime(String)  */ public long getIfUnmodifiedSince() {     return getFirstDate(IF_UNMODIFIED_SINCE, false). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ public void setLastModified(ZonedDateTime lastModified) {     setZonedDateTime(LAST_MODIFIED, lastModified.withZoneSameInstant(GMT)). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * @since 5.1.4  */ public void setLastModified(Instant lastModified) {     setInstant(LAST_MODIFIED, lastModified). }
true;public;1;3;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ ;/**  * Set the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  */ public void setLastModified(long lastModified) {     setDate(LAST_MODIFIED, lastModified). }
true;public;0;3;/**  * Return the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @see #getFirstZonedDateTime(String)  */ ;/**  * Return the time the resource was last changed, as specified by the  * {@code Last-Modified} header.  * <p>The date is returned as the number of milliseconds since  * January 1, 1970 GMT. Returns -1 when the date is unknown.  * @see #getFirstZonedDateTime(String)  */ public long getLastModified() {     return getFirstDate(LAST_MODIFIED, false). }
true;public;1;3;/**  * Set the (new) location of a resource,  * as specified by the {@code Location} header.  */ ;/**  * Set the (new) location of a resource,  * as specified by the {@code Location} header.  */ public void setLocation(@Nullable URI location) {     setOrRemove(LOCATION, (location != null ? location.toASCIIString() : null)). }
true;public;0;5;/**  * Return the (new) location of a resource  * as specified by the {@code Location} header.  * <p>Returns {@code null} when the location is unknown.  */ ;/**  * Return the (new) location of a resource  * as specified by the {@code Location} header.  * <p>Returns {@code null} when the location is unknown.  */ @Nullable public URI getLocation() {     String value = getFirst(LOCATION).     return (value != null ? URI.create(value) : null). }
true;public;1;3;/**  * Set the (new) value of the {@code Origin} header.  */ ;/**  * Set the (new) value of the {@code Origin} header.  */ public void setOrigin(@Nullable String origin) {     setOrRemove(ORIGIN, origin). }
true;public;0;4;/**  * Return the value of the {@code Origin} header.  */ ;/**  * Return the value of the {@code Origin} header.  */ @Nullable public String getOrigin() {     return getFirst(ORIGIN). }
true;public;1;3;/**  * Set the (new) value of the {@code Pragma} header.  */ ;/**  * Set the (new) value of the {@code Pragma} header.  */ public void setPragma(@Nullable String pragma) {     setOrRemove(PRAGMA, pragma). }
true;public;0;4;/**  * Return the value of the {@code Pragma} header.  */ ;/**  * Return the value of the {@code Pragma} header.  */ @Nullable public String getPragma() {     return getFirst(PRAGMA). }
true;public;1;4;/**  * Sets the (new) value of the {@code Range} header.  */ ;/**  * Sets the (new) value of the {@code Range} header.  */ public void setRange(List<HttpRange> ranges) {     String value = HttpRange.toString(ranges).     set(RANGE, value). }
true;public;0;4;/**  * Return the value of the {@code Range} header.  * <p>Returns an empty list when the range is unknown.  */ ;/**  * Return the value of the {@code Range} header.  * <p>Returns an empty list when the range is unknown.  */ public List<HttpRange> getRange() {     String value = getFirst(RANGE).     return HttpRange.parseRanges(value). }
true;public;1;3;/**  * Set the (new) value of the {@code Upgrade} header.  */ ;/**  * Set the (new) value of the {@code Upgrade} header.  */ public void setUpgrade(@Nullable String upgrade) {     setOrRemove(UPGRADE, upgrade). }
true;public;0;4;/**  * Return the value of the {@code Upgrade} header.  */ ;/**  * Return the value of the {@code Upgrade} header.  */ @Nullable public String getUpgrade() {     return getFirst(UPGRADE). }
true;public;1;3;/**  * Set the request header names (e.g. "Accept-Language") for which the  * response is subject to content negotiation and variances based on the  * value of those request headers.  * @param requestHeaders the request header names  * @since 4.3  */ ;/**  * Set the request header names (e.g. "Accept-Language") for which the  * response is subject to content negotiation and variances based on the  * value of those request headers.  * @param requestHeaders the request header names  * @since 4.3  */ public void setVary(List<String> requestHeaders) {     set(VARY, toCommaDelimitedString(requestHeaders)). }
true;public;0;3;/**  * Return the request header names subject to content negotiation.  * @since 4.3  */ ;/**  * Return the request header names subject to content negotiation.  * @since 4.3  */ public List<String> getVary() {     return getValuesAsList(VARY). }
true;public;2;3;/**  * Set the given date under the given header name after formatting it as a string  * using the RFC-1123 date-time formatter. The equivalent of  * {@link #set(String, String)} but for date headers.  * @since 5.0  */ ;/**  * Set the given date under the given header name after formatting it as a string  * using the RFC-1123 date-time formatter. The equivalent of  * {@link #set(String, String)} but for date headers.  * @since 5.0  */ public void setZonedDateTime(String headerName, ZonedDateTime date) {     set(headerName, DATE_FORMATTERS[0].format(date)). }
true;public;2;3;/**  * Set the given date under the given header name after formatting it as a string  * using the RFC-1123 date-time formatter. The equivalent of  * {@link #set(String, String)} but for date headers.  * @since 5.1.4  */ ;/**  * Set the given date under the given header name after formatting it as a string  * using the RFC-1123 date-time formatter. The equivalent of  * {@link #set(String, String)} but for date headers.  * @since 5.1.4  */ public void setInstant(String headerName, Instant date) {     setZonedDateTime(headerName, ZonedDateTime.ofInstant(date, GMT)). }
true;public;2;3;/**  * Set the given date under the given header name after formatting it as a string  * using the RFC-1123 date-time formatter. The equivalent of  * {@link #set(String, String)} but for date headers.  * @since 3.2.4  * @see #setZonedDateTime(String, ZonedDateTime)  */ ;/**  * Set the given date under the given header name after formatting it as a string  * using the RFC-1123 date-time formatter. The equivalent of  * {@link #set(String, String)} but for date headers.  * @since 3.2.4  * @see #setZonedDateTime(String, ZonedDateTime)  */ public void setDate(String headerName, long date) {     setInstant(headerName, Instant.ofEpochMilli(date)). }
true;public;1;3;/**  * Parse the first header value for the given header name as a date,  * return -1 if there is no value, or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @return the parsed date header, or -1 if none  * @since 3.2.4  * @see #getFirstZonedDateTime(String)  */ ;/**  * Parse the first header value for the given header name as a date,  * return -1 if there is no value, or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @return the parsed date header, or -1 if none  * @since 3.2.4  * @see #getFirstZonedDateTime(String)  */ public long getFirstDate(String headerName) {     return getFirstDate(headerName, true). }
true;private;2;4;/**  * Parse the first header value for the given header name as a date,  * return -1 if there is no value or also in case of an invalid value  * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @param rejectInvalid whether to reject invalid values with an  * {@link IllegalArgumentException} ({@code true}) or rather return -1  * in that case ({@code false})  * @return the parsed date header, or -1 if none (or invalid)  * @see #getFirstZonedDateTime(String, boolean)  */ ;/**  * Parse the first header value for the given header name as a date,  * return -1 if there is no value or also in case of an invalid value  * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @param rejectInvalid whether to reject invalid values with an  * {@link IllegalArgumentException} ({@code true}) or rather return -1  * in that case ({@code false})  * @return the parsed date header, or -1 if none (or invalid)  * @see #getFirstZonedDateTime(String, boolean)  */ private long getFirstDate(String headerName, boolean rejectInvalid) {     ZonedDateTime zonedDateTime = getFirstZonedDateTime(headerName, rejectInvalid).     return (zonedDateTime != null ? zonedDateTime.toInstant().toEpochMilli() : -1). }
true;public;1;4;/**  * Parse the first header value for the given header name as a date,  * return {@code null} if there is no value, or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @return the parsed date header, or {@code null} if none  * @since 5.0  */ ;/**  * Parse the first header value for the given header name as a date,  * return {@code null} if there is no value, or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @return the parsed date header, or {@code null} if none  * @since 5.0  */ @Nullable public ZonedDateTime getFirstZonedDateTime(String headerName) {     return getFirstZonedDateTime(headerName, true). }
true;private;2;33;/**  * Parse the first header value for the given header name as a date,  * return {@code null} if there is no value or also in case of an invalid value  * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @param rejectInvalid whether to reject invalid values with an  * {@link IllegalArgumentException} ({@code true}) or rather return {@code null}  * in that case ({@code false})  * @return the parsed date header, or {@code null} if none (or invalid)  */ ;/**  * Parse the first header value for the given header name as a date,  * return {@code null} if there is no value or also in case of an invalid value  * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}  * if the value cannot be parsed as a date.  * @param headerName the header name  * @param rejectInvalid whether to reject invalid values with an  * {@link IllegalArgumentException} ({@code true}) or rather return {@code null}  * in that case ({@code false})  * @return the parsed date header, or {@code null} if none (or invalid)  */ @Nullable private ZonedDateTime getFirstZonedDateTime(String headerName, boolean rejectInvalid) {     String headerValue = getFirst(headerName).     if (headerValue == null) {         // No header value sent at all         return null.     }     if (headerValue.length() >= 3) {         // Short "0" or "-1" like values are never valid HTTP date headers...         // Let's only bother with DateTimeFormatter parsing for long enough values.         // See https://stackoverflow.com/questions/12626699/if-modified-since-http-header-passed-by-ie9-includes-length         int parametersIndex = headerValue.indexOf('.').         if (parametersIndex != -1) {             headerValue = headerValue.substring(0, parametersIndex).         }         for (DateTimeFormatter dateFormatter : DATE_FORMATTERS) {             try {                 return ZonedDateTime.parse(headerValue, dateFormatter).             } catch (DateTimeParseException ex) {             // ignore             }         }     }     if (rejectInvalid) {         throw new IllegalArgumentException("Cannot parse date value \"" + headerValue + "\" for \"" + headerName + "\" header").     }     return null. }
true;public;1;13;/**  * Return all values of a given header name,  * even if this header is set multiple times.  * @param headerName the header name  * @return all associated values  * @since 4.3  */ ;/**  * Return all values of a given header name,  * even if this header is set multiple times.  * @param headerName the header name  * @return all associated values  * @since 4.3  */ public List<String> getValuesAsList(String headerName) {     List<String> values = get(headerName).     if (values != null) {         List<String> result = new ArrayList<>().         for (String value : values) {             if (value != null) {                 Collections.addAll(result, StringUtils.tokenizeToStringArray(value, ",")).             }         }         return result.     }     return Collections.emptyList(). }
true;protected;1;25;/**  * Retrieve a combined result from the field values of the ETag header.  * @param headerName the header name  * @return the combined result  * @since 4.3  */ ;/**  * Retrieve a combined result from the field values of the ETag header.  * @param headerName the header name  * @return the combined result  * @since 4.3  */ protected List<String> getETagValuesAsList(String headerName) {     List<String> values = get(headerName).     if (values != null) {         List<String> result = new ArrayList<>().         for (String value : values) {             if (value != null) {                 Matcher matcher = ETAG_HEADER_VALUE_PATTERN.matcher(value).                 while (matcher.find()) {                     if ("*".equals(matcher.group())) {                         result.add(matcher.group()).                     } else {                         result.add(matcher.group(1)).                     }                 }                 if (result.isEmpty()) {                     throw new IllegalArgumentException("Could not parse header '" + headerName + "' with value '" + value + "'").                 }             }         }         return result.     }     return Collections.emptyList(). }
true;protected;1;5;/**  * Retrieve a combined result from the field values of multi-valued headers.  * @param headerName the header name  * @return the combined result  * @since 4.3  */ ;/**  * Retrieve a combined result from the field values of multi-valued headers.  * @param headerName the header name  * @return the combined result  * @since 4.3  */ @Nullable protected String getFieldValues(String headerName) {     List<String> headerValues = get(headerName).     return (headerValues != null ? toCommaDelimitedString(headerValues) : null). }
true;protected;1;9;/**  * Turn the given list of header values into a comma-delimited result.  * @param headerValues the list of header values  * @return a combined result with comma delimitation  */ ;/**  * Turn the given list of header values into a comma-delimited result.  * @param headerValues the list of header values  * @return a combined result with comma delimitation  */ protected String toCommaDelimitedString(List<String> headerValues) {     StringJoiner joiner = new StringJoiner(", ").     for (String val : headerValues) {         if (val != null) {             joiner.add(val).         }     }     return joiner.toString(). }
true;private;2;8;/**  * Set the given header value, or remove the header if {@code null}.  * @param headerName the header name  * @param headerValue the header value, or {@code null} for none  */ ;/**  * Set the given header value, or remove the header if {@code null}.  * @param headerName the header name  * @param headerValue the header value, or {@code null} for none  */ private void setOrRemove(String headerName, @Nullable String headerValue) {     if (headerValue != null) {         set(headerName, headerValue).     } else {         remove(headerName).     } }
true;public;1;5;/**  * Return the first header value for the given header name, if any.  * @param headerName the header name  * @return the first header value, or {@code null} if none  */ ;// MultiValueMap implementation /**  * Return the first header value for the given header name, if any.  * @param headerName the header name  * @return the first header value, or {@code null} if none  */ @Override @Nullable public String getFirst(String headerName) {     return this.headers.getFirst(headerName). }
true;public;2;4;/**  * Add the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #set(String, String)  */ ;/**  * Add the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #set(String, String)  */ @Override public void add(String headerName, @Nullable String headerValue) {     this.headers.add(headerName, headerValue). }
false;public;2;4;;@Override public void addAll(String key, List<? extends String> values) {     this.headers.addAll(key, values). }
false;public;1;4;;@Override public void addAll(MultiValueMap<String, String> values) {     this.headers.addAll(values). }
true;public;2;4;/**  * Set the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #add(String, String)  */ ;/**  * Set the given, single header value under the given name.  * @param headerName the header name  * @param headerValue the header value  * @throws UnsupportedOperationException if adding headers is not supported  * @see #put(String, List)  * @see #add(String, String)  */ @Override public void set(String headerName, @Nullable String headerValue) {     this.headers.set(headerName, headerValue). }
false;public;1;4;;@Override public void setAll(Map<String, String> values) {     this.headers.setAll(values). }
false;public;0;4;;@Override public Map<String, String> toSingleValueMap() {     return this.headers.toSingleValueMap(). }
false;public;0;4;;// Map implementation @Override public int size() {     return this.headers.size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return this.headers.isEmpty(). }
false;public;1;4;;@Override public boolean containsKey(Object key) {     return this.headers.containsKey(key). }
false;public;1;4;;@Override public boolean containsValue(Object value) {     return this.headers.containsValue(value). }
false;public;1;5;;@Override @Nullable public List<String> get(Object key) {     return this.headers.get(key). }
false;public;2;4;;@Override public List<String> put(String key, List<String> value) {     return this.headers.put(key, value). }
false;public;1;4;;@Override public List<String> remove(Object key) {     return this.headers.remove(key). }
false;public;1;4;;@Override public void putAll(Map<? extends String, ? extends List<String>> map) {     this.headers.putAll(map). }
false;public;0;4;;@Override public void clear() {     this.headers.clear(). }
false;public;0;4;;@Override public Set<String> keySet() {     return this.headers.keySet(). }
false;public;0;4;;@Override public Collection<List<String>> values() {     return this.headers.values(). }
false;public;0;4;;@Override public Set<Entry<String, List<String>>> entrySet() {     return this.headers.entrySet(). }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof HttpHeaders)) {         return false.     }     HttpHeaders otherHeaders = (HttpHeaders) other.     return this.headers.equals(otherHeaders.headers). }
false;public;0;4;;@Override public int hashCode() {     return this.headers.hashCode(). }
false;public;0;4;;@Override public String toString() {     return formatHeaders(this.headers). }
true;public,static;1;9;/**  * Return an {@code HttpHeaders} object that can only be read, not written to.  */ ;/**  * Return an {@code HttpHeaders} object that can only be read, not written to.  */ public static HttpHeaders readOnlyHttpHeaders(HttpHeaders headers) {     Assert.notNull(headers, "HttpHeaders must not be null").     if (headers instanceof ReadOnlyHttpHeaders) {         return headers.     } else {         return new ReadOnlyHttpHeaders(headers).     } }
true;public,static;1;12;/**  * Return an {@code HttpHeaders} object that can be read and written to.  * @since 5.1.1  */ ;/**  * Return an {@code HttpHeaders} object that can be read and written to.  * @since 5.1.1  */ public static HttpHeaders writableHttpHeaders(HttpHeaders headers) {     Assert.notNull(headers, "HttpHeaders must not be null").     if (headers == EMPTY) {         return new HttpHeaders().     } else if (headers instanceof ReadOnlyHttpHeaders) {         return new HttpHeaders(headers.headers).     } else {         return headers.     } }
true;public,static;1;10;/**  * Helps to format HTTP header values, as HTTP header values themselves can  * contain comma-separated values, can become confusing with regular  * {@link Map} formatting that also uses commas between entries.  * @param headers the headers to format  * @return the headers to a String  * @since 5.1.4  */ ;/**  * Helps to format HTTP header values, as HTTP header values themselves can  * contain comma-separated values, can become confusing with regular  * {@link Map} formatting that also uses commas between entries.  * @param headers the headers to format  * @return the headers to a String  * @since 5.1.4  */ public static String formatHeaders(MultiValueMap<String, String> headers) {     return headers.entrySet().stream().map(entry -> {         List<String> values = entry.getValue().         return entry.getKey() + ":" + (values.size() == 1 ? "\"" + values.get(0) + "\"" : values.stream().map(s -> "\"" + s + "\"").collect(Collectors.joining(", "))).     }).collect(Collectors.joining(", ", "[", "]")). }
true;static;1;5;// Package-private: used in ResponseCookie ;// Package-private: used in ResponseCookie static String formatDate(long date) {     Instant instant = Instant.ofEpochMilli(date).     ZonedDateTime time = ZonedDateTime.ofInstant(instant, GMT).     return DATE_FORMATTERS[0].format(time). }
