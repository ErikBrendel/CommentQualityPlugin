commented;modifiers;parameterAmount;loc;comment;code
false;public;1;24;;@Override public boolean test(Class<?> controllerType) {     if (!hasSelectors()) {         return true.     } else if (controllerType != null) {         for (String basePackage : this.basePackages) {             if (controllerType.getName().startsWith(basePackage)) {                 return true.             }         }         for (Class<?> clazz : this.assignableTypes) {             if (ClassUtils.isAssignable(clazz, controllerType)) {                 return true.             }         }         for (Class<? extends Annotation> annotationClass : this.annotations) {             if (AnnotationUtils.findAnnotation(controllerType, annotationClass) != null) {                 return true.             }         }     }     return false. }
false;private;0;3;;private boolean hasSelectors() {     return (!this.basePackages.isEmpty() || !this.assignableTypes.isEmpty() || !this.annotations.isEmpty()). }
true;public,static;0;4;/**  * {@code Predicate} that applies to any handlers.  */ ;// Static factory methods /**  * {@code Predicate} that applies to any handlers.  */ public static HandlerTypePredicate forAnyHandlerType() {     return new HandlerTypePredicate(Collections.emptySet(), Collections.emptyList(), Collections.emptyList()). }
true;public,static;1;3;/**  * Match handlers declared under a base package, e.g. "org.example".  * @param packages one or more base package names  */ ;/**  * Match handlers declared under a base package, e.g. "org.example".  * @param packages one or more base package names  */ public static HandlerTypePredicate forBasePackage(String... packages) {     return new Builder().basePackage(packages).build(). }
true;public,static;1;3;/**  * Type-safe alternative to {@link #forBasePackage(String...)} to specify a  * base package through a class.  * @param packageClasses one or more base package classes  */ ;/**  * Type-safe alternative to {@link #forBasePackage(String...)} to specify a  * base package through a class.  * @param packageClasses one or more base package classes  */ public static HandlerTypePredicate forBasePackageClass(Class<?>... packageClasses) {     return new Builder().basePackageClass(packageClasses).build(). }
true;public,static;1;3;/**  * Match handlers that are assignable to a given type.  * @param types one or more handler super types  */ ;/**  * Match handlers that are assignable to a given type.  * @param types one or more handler super types  */ public static HandlerTypePredicate forAssignableType(Class<?>... types) {     return new Builder().assignableType(types).build(). }
true;public,static;1;4;/**  * Match handlers annotated with a specific annotation.  * @param annotations one or more annotations to check for  */ ;/**  * Match handlers annotated with a specific annotation.  * @param annotations one or more annotations to check for  */ @SafeVarargs public static HandlerTypePredicate forAnnotation(Class<? extends Annotation>... annotations) {     return new Builder().annotation(annotations).build(). }
true;public,static;0;3;/**  * Return a builder for a {@code HandlerTypePredicate}.  */ ;/**  * Return a builder for a {@code HandlerTypePredicate}.  */ public static Builder builder() {     return new Builder(). }
true;public;1;4;/**  * Match handlers declared under a base package, e.g. "org.example".  * @param packages one or more base package classes  */ ;/**  * Match handlers declared under a base package, e.g. "org.example".  * @param packages one or more base package classes  */ public Builder basePackage(String... packages) {     Arrays.stream(packages).filter(StringUtils::hasText).forEach(this::addBasePackage).     return this. }
true;public;1;4;/**  * Type-safe alternative to {@link #forBasePackage(String...)} to specify a  * base package through a class.  * @param packageClasses one or more base package names  */ ;/**  * Type-safe alternative to {@link #forBasePackage(String...)} to specify a  * base package through a class.  * @param packageClasses one or more base package names  */ public Builder basePackageClass(Class<?>... packageClasses) {     Arrays.stream(packageClasses).forEach(clazz -> addBasePackage(ClassUtils.getPackageName(clazz))).     return this. }
false;private;1;3;;private void addBasePackage(String basePackage) {     this.basePackages.add(basePackage.endsWith(".") ? basePackage : basePackage + "."). }
true;public;1;4;/**  * Match handlers that are assignable to a given type.  * @param types one or more handler super types  */ ;/**  * Match handlers that are assignable to a given type.  * @param types one or more handler super types  */ public Builder assignableType(Class<?>... types) {     this.assignableTypes.addAll(Arrays.asList(types)).     return this. }
true;public,final;1;5;/**  * Match types that are annotated with one of the given annotations.  * @param annotations one or more annotations to check for  */ ;/**  * Match types that are annotated with one of the given annotations.  * @param annotations one or more annotations to check for  */ @SuppressWarnings("unchecked") public final Builder annotation(Class<? extends Annotation>... annotations) {     this.annotations.addAll(Arrays.asList(annotations)).     return this. }
false;public;0;3;;public HandlerTypePredicate build() {     return new HandlerTypePredicate(this.basePackages, this.assignableTypes, this.annotations). }
