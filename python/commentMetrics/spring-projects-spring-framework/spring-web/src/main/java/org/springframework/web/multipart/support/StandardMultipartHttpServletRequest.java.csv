commented;modifiers;parameterAmount;loc;comment;code
false;private;1;25;;private void parseRequest(HttpServletRequest request) {     try {         Collection<Part> parts = request.getParts().         this.multipartParameterNames = new LinkedHashSet<>(parts.size()).         MultiValueMap<String, MultipartFile> files = new LinkedMultiValueMap<>(parts.size()).         for (Part part : parts) {             String headerValue = part.getHeader(HttpHeaders.CONTENT_DISPOSITION).             ContentDisposition disposition = ContentDisposition.parse(headerValue).             String filename = disposition.getFilename().             if (filename != null) {                 if (filename.startsWith("=?") && filename.endsWith("?=")) {                     filename = MimeDelegate.decode(filename).                 }                 files.add(part.getName(), new StandardMultipartFile(part, filename)).             } else {                 this.multipartParameterNames.add(part.getName()).             }         }         setMultipartFiles(files).     } catch (Throwable ex) {         handleParseFailure(ex).     } }
false;protected;1;7;;protected void handleParseFailure(Throwable ex) {     String msg = ex.getMessage().     if (msg != null && msg.contains("size") && msg.contains("exceed")) {         throw new MaxUploadSizeExceededException(-1, ex).     }     throw new MultipartException("Failed to parse multipart servlet request", ex). }
false;protected;0;4;;@Override protected void initializeMultipart() {     parseRequest(getRequest()). }
false;public;0;19;;@Override public Enumeration<String> getParameterNames() {     if (this.multipartParameterNames == null) {         initializeMultipart().     }     if (this.multipartParameterNames.isEmpty()) {         return super.getParameterNames().     }     // Servlet 3.0 getParameterNames() not guaranteed to include multipart form items     // (e.g. on WebLogic 12) -> need to merge them here to be on the safe side     Set<String> paramNames = new LinkedHashSet<>().     Enumeration<String> paramEnum = super.getParameterNames().     while (paramEnum.hasMoreElements()) {         paramNames.add(paramEnum.nextElement()).     }     paramNames.addAll(this.multipartParameterNames).     return Collections.enumeration(paramNames). }
false;public;0;19;;@Override public Map<String, String[]> getParameterMap() {     if (this.multipartParameterNames == null) {         initializeMultipart().     }     if (this.multipartParameterNames.isEmpty()) {         return super.getParameterMap().     }     // Servlet 3.0 getParameterMap() not guaranteed to include multipart form items     // (e.g. on WebLogic 12) -> need to merge them here to be on the safe side     Map<String, String[]> paramMap = new LinkedHashMap<>(super.getParameterMap()).     for (String paramName : this.multipartParameterNames) {         if (!paramMap.containsKey(paramName)) {             paramMap.put(paramName, getParameterValues(paramName)).         }     }     return paramMap. }
false;public;1;10;;@Override public String getMultipartContentType(String paramOrFileName) {     try {         Part part = getPart(paramOrFileName).         return (part != null ? part.getContentType() : null).     } catch (Throwable ex) {         throw new MultipartException("Could not access multipart servlet request", ex).     } }
false;public;1;19;;@Override public HttpHeaders getMultipartHeaders(String paramOrFileName) {     try {         Part part = getPart(paramOrFileName).         if (part != null) {             HttpHeaders headers = new HttpHeaders().             for (String headerName : part.getHeaderNames()) {                 headers.put(headerName, new ArrayList<>(part.getHeaders(headerName))).             }             return headers.         } else {             return null.         }     } catch (Throwable ex) {         throw new MultipartException("Could not access multipart servlet request", ex).     } }
false;public;0;4;;@Override public String getName() {     return this.part.getName(). }
false;public;0;4;;@Override public String getOriginalFilename() {     return this.filename. }
false;public;0;4;;@Override public String getContentType() {     return this.part.getContentType(). }
false;public;0;4;;@Override public boolean isEmpty() {     return (this.part.getSize() == 0). }
false;public;0;4;;@Override public long getSize() {     return this.part.getSize(). }
false;public;0;4;;@Override public byte[] getBytes() throws IOException {     return FileCopyUtils.copyToByteArray(this.part.getInputStream()). }
false;public;0;4;;@Override public InputStream getInputStream() throws IOException {     return this.part.getInputStream(). }
false;public;1;13;;@Override public void transferTo(File dest) throws IOException, IllegalStateException {     this.part.write(dest.getPath()).     if (dest.isAbsolute() && !dest.exists()) {         // Servlet 3.0 Part.write is not guaranteed to support absolute file paths:         // may translate the given path to a relative location within a temp dir         // (e.g. on Jetty whereas Tomcat and Undertow detect absolute paths).         // At least we offloaded the file from memory storage. it'll get deleted         // from the temp dir eventually in any case. And for our user's purposes,         // we can manually copy it to the requested location as a fallback.         FileCopyUtils.copy(this.part.getInputStream(), Files.newOutputStream(dest.toPath())).     } }
false;public;1;4;;@Override public void transferTo(Path dest) throws IOException, IllegalStateException {     FileCopyUtils.copy(this.part.getInputStream(), Files.newOutputStream(dest)). }
false;public,static;1;8;;public static String decode(String value) {     try {         return MimeUtility.decodeText(value).     } catch (UnsupportedEncodingException ex) {         throw new IllegalStateException(ex).     } }
