commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;4;;@Override public final HttpHeaders getHeaders() {     return (this.executed ? HttpHeaders.readOnlyHttpHeaders(this.headers) : this.headers). }
false;public,final;0;5;;@Override public final OutputStream getBody() throws IOException {     assertNotExecuted().     return getBodyInternal(this.headers). }
false;public;0;7;;@Override public ListenableFuture<ClientHttpResponse> executeAsync() throws IOException {     assertNotExecuted().     ListenableFuture<ClientHttpResponse> result = executeInternal(this.headers).     this.executed = true.     return result. }
true;protected;0;3;/**  * Asserts that this request has not been {@linkplain #executeAsync() executed} yet.  * @throws IllegalStateException if this request has been executed  */ ;/**  * Asserts that this request has not been {@linkplain #executeAsync() executed} yet.  * @throws IllegalStateException if this request has been executed  */ protected void assertNotExecuted() {     Assert.state(!this.executed, "ClientHttpRequest already executed"). }
true;protected,abstract;1;1;/**  * Abstract template method that returns the body.  * @param headers the HTTP headers  * @return the body output stream  */ ;/**  * Abstract template method that returns the body.  * @param headers the HTTP headers  * @return the body output stream  */ protected abstract OutputStream getBodyInternal(HttpHeaders headers) throws IOException.
true;protected,abstract;1;2;/**  * Abstract template method that writes the given headers and content to the HTTP request.  * @param headers the HTTP headers  * @return the response object for the executed request  */ ;/**  * Abstract template method that writes the given headers and content to the HTTP request.  * @param headers the HTTP headers  * @return the response object for the executed request  */ protected abstract ListenableFuture<ClientHttpResponse> executeInternal(HttpHeaders headers) throws IOException.
