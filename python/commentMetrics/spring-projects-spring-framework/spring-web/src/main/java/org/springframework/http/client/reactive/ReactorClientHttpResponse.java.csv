commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;@Override public Flux<DataBuffer> getBody() {     return this.inbound.receive().doOnSubscribe(s -> {         if (this.rejectSubscribers.get()) {             throw new IllegalStateException("The client response body can only be consumed once.").         }     }).doOnCancel(() -> {         // https://github.com/reactor/reactor-netty/issues/503         // FluxReceive rejects multiple subscribers, but not after a cancel().         // Subsequent subscribers after cancel() will not be rejected, but will hang instead.         // So we need to intercept and reject them in that case.         this.rejectSubscribers.set(true).     }).map(byteBuf -> {         byteBuf.retain().         return this.bufferFactory.wrap(byteBuf).     }). }
false;public;0;6;;@Override public HttpHeaders getHeaders() {     HttpHeaders headers = new HttpHeaders().     this.response.responseHeaders().entries().forEach(e -> headers.add(e.getKey(), e.getValue())).     return headers. }
false;public;0;4;;@Override public HttpStatus getStatusCode() {     return HttpStatus.valueOf(getRawStatusCode()). }
false;public;0;4;;@Override public int getRawStatusCode() {     return this.response.status().code(). }
false;public;0;14;;@Override public MultiValueMap<String, ResponseCookie> getCookies() {     MultiValueMap<String, ResponseCookie> result = new LinkedMultiValueMap<>().     this.response.cookies().values().stream().flatMap(Collection::stream).forEach(cookie -> result.add(cookie.name(), ResponseCookie.from(cookie.name(), cookie.value()).domain(cookie.domain()).path(cookie.path()).maxAge(cookie.maxAge()).secure(cookie.isSecure()).httpOnly(cookie.isHttpOnly()).build())).     return CollectionUtils.unmodifiableMultiValueMap(result). }
false;public;0;6;;@Override public String toString() {     return "ReactorClientHttpResponse{" + "request=[" + this.response.method().name() + " " + this.response.uri() + "]," + "status=" + getRawStatusCode() + '}'. }
