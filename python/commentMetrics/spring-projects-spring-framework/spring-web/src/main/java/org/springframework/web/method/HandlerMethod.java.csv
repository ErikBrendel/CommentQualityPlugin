commented;modifiers;parameterAmount;loc;comment;code
false;private;0;10;;private MethodParameter[] initMethodParameters() {     int count = this.bridgedMethod.getParameterCount().     MethodParameter[] result = new MethodParameter[count].     for (int i = 0. i < count. i++) {         HandlerMethodParameter parameter = new HandlerMethodParameter(i).         GenericTypeResolver.resolveParameterType(parameter, this.beanType).         result[i] = parameter.     }     return result. }
false;private;0;10;;private void evaluateResponseStatus() {     ResponseStatus annotation = getMethodAnnotation(ResponseStatus.class).     if (annotation == null) {         annotation = AnnotatedElementUtils.findMergedAnnotation(getBeanType(), ResponseStatus.class).     }     if (annotation != null) {         this.responseStatus = annotation.code().         this.responseStatusReason = annotation.reason().     } }
true;public;0;3;/**  * Return the bean for this handler method.  */ ;/**  * Return the bean for this handler method.  */ public Object getBean() {     return this.bean. }
true;public;0;3;/**  * Return the method for this handler method.  */ ;/**  * Return the method for this handler method.  */ public Method getMethod() {     return this.method. }
true;public;0;3;/**  * This method returns the type of the handler for this handler method.  * <p>Note that if the bean type is a CGLIB-generated class, the original  * user-defined class is returned.  */ ;/**  * This method returns the type of the handler for this handler method.  * <p>Note that if the bean type is a CGLIB-generated class, the original  * user-defined class is returned.  */ public Class<?> getBeanType() {     return this.beanType. }
true;protected;0;3;/**  * If the bean method is a bridge method, this method returns the bridged  * (user-defined) method. Otherwise it returns the same method as {@link #getMethod()}.  */ ;/**  * If the bean method is a bridge method, this method returns the bridged  * (user-defined) method. Otherwise it returns the same method as {@link #getMethod()}.  */ protected Method getBridgedMethod() {     return this.bridgedMethod. }
true;public;0;3;/**  * Return the method parameters for this handler method.  */ ;/**  * Return the method parameters for this handler method.  */ public MethodParameter[] getMethodParameters() {     return this.parameters. }
true;protected;0;4;/**  * Return the specified response status, if any.  * @since 4.3.8  * @see ResponseStatus#code()  */ ;/**  * Return the specified response status, if any.  * @since 4.3.8  * @see ResponseStatus#code()  */ @Nullable protected HttpStatus getResponseStatus() {     return this.responseStatus. }
true;protected;0;4;/**  * Return the associated response status reason, if any.  * @since 4.3.8  * @see ResponseStatus#reason()  */ ;/**  * Return the associated response status reason, if any.  * @since 4.3.8  * @see ResponseStatus#reason()  */ @Nullable protected String getResponseStatusReason() {     return this.responseStatusReason. }
true;public;0;3;/**  * Return the HandlerMethod return type.  */ ;/**  * Return the HandlerMethod return type.  */ public MethodParameter getReturnType() {     return new HandlerMethodParameter(-1). }
true;public;1;3;/**  * Return the actual return value type.  */ ;/**  * Return the actual return value type.  */ public MethodParameter getReturnValueType(@Nullable Object returnValue) {     return new ReturnValueMethodParameter(returnValue). }
true;public;0;3;/**  * Return {@code true} if the method return type is void, {@code false} otherwise.  */ ;/**  * Return {@code true} if the method return type is void, {@code false} otherwise.  */ public boolean isVoid() {     return Void.TYPE.equals(getReturnType().getParameterType()). }
true;public;1;4;/**  * Return a single annotation on the underlying method traversing its super methods  * if no annotation can be found on the given method itself.  * <p>Also supports <em>merged</em> composed annotations with attribute  * overrides as of Spring Framework 4.2.2.  * @param annotationType the type of annotation to introspect the method for  * @return the annotation, or {@code null} if none found  * @see AnnotatedElementUtils#findMergedAnnotation  */ ;/**  * Return a single annotation on the underlying method traversing its super methods  * if no annotation can be found on the given method itself.  * <p>Also supports <em>merged</em> composed annotations with attribute  * overrides as of Spring Framework 4.2.2.  * @param annotationType the type of annotation to introspect the method for  * @return the annotation, or {@code null} if none found  * @see AnnotatedElementUtils#findMergedAnnotation  */ @Nullable public <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {     return AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType). }
true;public;1;3;/**  * Return whether the parameter is declared with the given annotation type.  * @param annotationType the annotation type to look for  * @since 4.3  * @see AnnotatedElementUtils#hasAnnotation  */ ;/**  * Return whether the parameter is declared with the given annotation type.  * @param annotationType the annotation type to look for  * @since 4.3  * @see AnnotatedElementUtils#hasAnnotation  */ public <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {     return AnnotatedElementUtils.hasAnnotation(this.method, annotationType). }
true;public;0;4;/**  * Return the HandlerMethod from which this HandlerMethod instance was  * resolved via {@link #createWithResolvedBean()}.  */ ;/**  * Return the HandlerMethod from which this HandlerMethod instance was  * resolved via {@link #createWithResolvedBean()}.  */ @Nullable public HandlerMethod getResolvedFromHandlerMethod() {     return this.resolvedFromHandlerMethod. }
true;public;0;9;/**  * If the provided instance contains a bean name rather than an object instance,  * the bean name is resolved before a {@link HandlerMethod} is created and returned.  */ ;/**  * If the provided instance contains a bean name rather than an object instance,  * the bean name is resolved before a {@link HandlerMethod} is created and returned.  */ public HandlerMethod createWithResolvedBean() {     Object handler = this.bean.     if (this.bean instanceof String) {         Assert.state(this.beanFactory != null, "Cannot resolve bean name without BeanFactory").         String beanName = (String) this.bean.         handler = this.beanFactory.getBean(beanName).     }     return new HandlerMethod(this, handler). }
true;public;0;4;/**  * Return a short representation of this handler method for log message purposes.  * @since 4.3  */ ;/**  * Return a short representation of this handler method for log message purposes.  * @since 4.3  */ public String getShortLogMessage() {     return getBeanType().getName() + "#" + this.method.getName() + "[" + this.method.getParameterCount() + " args]". }
false;private;0;15;;private List<Annotation[][]> getInterfaceParameterAnnotations() {     List<Annotation[][]> parameterAnnotations = this.interfaceParameterAnnotations.     if (parameterAnnotations == null) {         parameterAnnotations = new ArrayList<>().         for (Class<?> ifc : this.method.getDeclaringClass().getInterfaces()) {             for (Method candidate : ifc.getMethods()) {                 if (isOverrideFor(candidate)) {                     parameterAnnotations.add(candidate.getParameterAnnotations()).                 }             }         }         this.interfaceParameterAnnotations = parameterAnnotations.     }     return parameterAnnotations. }
false;private;1;17;;private boolean isOverrideFor(Method candidate) {     if (!candidate.getName().equals(this.method.getName()) || candidate.getParameterCount() != this.method.getParameterCount()) {         return false.     }     Class<?>[] paramTypes = this.method.getParameterTypes().     if (Arrays.equals(candidate.getParameterTypes(), paramTypes)) {         return true.     }     for (int i = 0. i < paramTypes.length. i++) {         if (paramTypes[i] != ResolvableType.forMethodParameter(candidate, i, this.method.getDeclaringClass()).resolve()) {             return false.         }     }     return true. }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof HandlerMethod)) {         return false.     }     HandlerMethod otherMethod = (HandlerMethod) other.     return (this.bean.equals(otherMethod.bean) && this.method.equals(otherMethod.method)). }
false;public;0;4;;@Override public int hashCode() {     return (this.bean.hashCode() * 31 + this.method.hashCode()). }
false;public;0;4;;@Override public String toString() {     return this.method.toGenericString(). }
false;protected,static;2;11;;// Support methods for use in "InvocableHandlerMethod" sub-class variants.. @Nullable protected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {     if (!ObjectUtils.isEmpty(providedArgs)) {         for (Object providedArg : providedArgs) {             if (parameter.getParameterType().isInstance(providedArg)) {                 return providedArg.             }         }     }     return null. }
false;protected,static;2;4;;protected static String formatArgumentError(MethodParameter param, String message) {     return "Could not resolve parameter [" + param.getParameterIndex() + "] in " + param.getExecutable().toGenericString() + (StringUtils.hasText(message) ? ": " + message : ""). }
true;protected;3;11;/**  * Assert that the target bean class is an instance of the class where the given  * method is declared. In some cases the actual controller instance at request-  * processing time may be a JDK dynamic proxy (lazy initialization, prototype  * beans, and others). {@code @Controller}'s that require proxying should prefer  * class-based proxy mechanisms.  */ ;/**  * Assert that the target bean class is an instance of the class where the given  * method is declared. In some cases the actual controller instance at request-  * processing time may be a JDK dynamic proxy (lazy initialization, prototype  * beans, and others). {@code @Controller}'s that require proxying should prefer  * class-based proxy mechanisms.  */ protected void assertTargetBean(Method method, Object targetBean, Object[] args) {     Class<?> methodDeclaringClass = method.getDeclaringClass().     Class<?> targetBeanClass = targetBean.getClass().     if (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {         String text = "The mapped handler method class '" + methodDeclaringClass.getName() + "' is not an instance of the actual controller bean class '" + targetBeanClass.getName() + "'. If the controller requires proxying " + "(e.g. due to @Transactional), please use class-based proxying.".         throw new IllegalStateException(formatInvokeError(text, args)).     } }
false;protected;2;11;;protected String formatInvokeError(String text, Object[] args) {     String formattedArgs = IntStream.range(0, args.length).mapToObj(i -> (args[i] != null ? "[" + i + "] [type=" + args[i].getClass().getName() + "] [value=" + args[i] + "]" : "[" + i + "] [null]")).collect(Collectors.joining(",\n", " ", " ")).     return text + "\n" + "Controller [" + getBeanType().getName() + "]\n" + "Method [" + getBridgedMethod().toGenericString() + "] " + "with argument values:\n" + formattedArgs. }
false;public;0;4;;@Override public Class<?> getContainingClass() {     return HandlerMethod.this.getBeanType(). }
false;public;1;4;;@Override public <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {     return HandlerMethod.this.getMethodAnnotation(annotationType). }
false;public;1;4;;@Override public <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {     return HandlerMethod.this.hasMethodAnnotation(annotationType). }
false;public;0;34;;@Override public Annotation[] getParameterAnnotations() {     Annotation[] anns = this.combinedAnnotations.     if (anns == null) {         anns = super.getParameterAnnotations().         int index = getParameterIndex().         if (index >= 0) {             for (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {                 if (index < ifcAnns.length) {                     Annotation[] paramAnns = ifcAnns[index].                     if (paramAnns.length > 0) {                         List<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length).                         merged.addAll(Arrays.asList(anns)).                         for (Annotation paramAnn : paramAnns) {                             boolean existingType = false.                             for (Annotation ann : anns) {                                 if (ann.annotationType() == paramAnn.annotationType()) {                                     existingType = true.                                     break.                                 }                             }                             if (!existingType) {                                 merged.add(adaptAnnotation(paramAnn)).                             }                         }                         anns = merged.toArray(new Annotation[0]).                     }                 }             }         }         this.combinedAnnotations = anns.     }     return anns. }
false;public;0;4;;@Override public HandlerMethodParameter clone() {     return new HandlerMethodParameter(this). }
false;public;0;4;;@Override public Class<?> getParameterType() {     return (this.returnValue != null ? this.returnValue.getClass() : super.getParameterType()). }
false;public;0;4;;@Override public ReturnValueMethodParameter clone() {     return new ReturnValueMethodParameter(this). }
