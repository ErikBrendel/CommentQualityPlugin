commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Indicates whether DTD parsing should be supported.  * <p>Default is {@code false} meaning that DTD is disabled.  */ ;/**  * Indicates whether DTD parsing should be supported.  * <p>Default is {@code false} meaning that DTD is disabled.  */ public void setSupportDtd(boolean supportDtd) {     this.supportDtd = supportDtd. }
true;public;0;3;/**  * Whether DTD parsing is supported.  */ ;/**  * Whether DTD parsing is supported.  */ public boolean isSupportDtd() {     return this.supportDtd. }
true;public;1;6;/**  * Indicates whether external XML entities are processed when converting to a Source.  * <p>Default is {@code false}, meaning that external entities are not resolved.  * <p><strong>Note:</strong> setting this option to {@code true} also  * automatically sets {@link #setSupportDtd} to {@code true}.  */ ;/**  * Indicates whether external XML entities are processed when converting to a Source.  * <p>Default is {@code false}, meaning that external entities are not resolved.  * <p><strong>Note:</strong> setting this option to {@code true} also  * automatically sets {@link #setSupportDtd} to {@code true}.  */ public void setProcessExternalEntities(boolean processExternalEntities) {     this.processExternalEntities = processExternalEntities.     if (processExternalEntities) {         setSupportDtd(true).     } }
true;public;0;3;/**  * Returns the configured value for whether XML external entities are allowed.  */ ;/**  * Returns the configured value for whether XML external entities are allowed.  */ public boolean isProcessExternalEntities() {     return this.processExternalEntities. }
false;public;1;4;;@Override public boolean supports(Class<?> clazz) {     return SUPPORTED_CLASSES.contains(clazz). }
false;protected;2;23;;@Override @SuppressWarnings("unchecked") protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {     InputStream body = inputMessage.getBody().     if (DOMSource.class == clazz) {         return (T) readDOMSource(body, inputMessage).     } else if (SAXSource.class == clazz) {         return (T) readSAXSource(body, inputMessage).     } else if (StAXSource.class == clazz) {         return (T) readStAXSource(body, inputMessage).     } else if (StreamSource.class == clazz || Source.class == clazz) {         return (T) readStreamSource(body).     } else {         throw new HttpMessageNotReadableException("Could not read class [" + clazz + "]. Only DOMSource, SAXSource, StAXSource, and StreamSource are supported.", inputMessage).     } }
false;private;2;31;;private DOMSource readDOMSource(InputStream body, HttpInputMessage inputMessage) throws IOException {     try {         DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance().         documentBuilderFactory.setNamespaceAware(true).         documentBuilderFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", !isSupportDtd()).         documentBuilderFactory.setFeature("http://xml.org/sax/features/external-general-entities", isProcessExternalEntities()).         DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder().         if (!isProcessExternalEntities()) {             documentBuilder.setEntityResolver(NO_OP_ENTITY_RESOLVER).         }         Document document = documentBuilder.parse(body).         return new DOMSource(document).     } catch (NullPointerException ex) {         if (!isSupportDtd()) {             throw new HttpMessageNotReadableException("NPE while unmarshalling: This can happen " + "due to the presence of DTD declarations which are disabled.", ex, inputMessage).         }         throw ex.     } catch (ParserConfigurationException ex) {         throw new HttpMessageNotReadableException("Could not set feature: " + ex.getMessage(), ex, inputMessage).     } catch (SAXException ex) {         throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex, inputMessage).     } }
false;private;2;17;;// on JDK 9 @SuppressWarnings("deprecation") private SAXSource readSAXSource(InputStream body, HttpInputMessage inputMessage) throws IOException {     try {         XMLReader xmlReader = org.xml.sax.helpers.XMLReaderFactory.createXMLReader().         xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", !isSupportDtd()).         xmlReader.setFeature("http://xml.org/sax/features/external-general-entities", isProcessExternalEntities()).         if (!isProcessExternalEntities()) {             xmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER).         }         byte[] bytes = StreamUtils.copyToByteArray(body).         return new SAXSource(xmlReader, new InputSource(new ByteArrayInputStream(bytes))).     } catch (SAXException ex) {         throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex, inputMessage).     } }
false;private;2;16;;private Source readStAXSource(InputStream body, HttpInputMessage inputMessage) {     try {         XMLInputFactory inputFactory = XMLInputFactory.newInstance().         inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, isSupportDtd()).         inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, isProcessExternalEntities()).         if (!isProcessExternalEntities()) {             inputFactory.setXMLResolver(NO_OP_XML_RESOLVER).         }         XMLStreamReader streamReader = inputFactory.createXMLStreamReader(body).         return new StAXSource(streamReader).     } catch (XMLStreamException ex) {         throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex, inputMessage).     } }
false;private;1;4;;private StreamSource readStreamSource(InputStream body) throws IOException {     byte[] bytes = StreamUtils.copyToByteArray(body).     return new StreamSource(new ByteArrayInputStream(bytes)). }
false;protected;2;15;;@Override @Nullable protected Long getContentLength(T t, @Nullable MediaType contentType) {     if (t instanceof DOMSource) {         try {             CountingOutputStream os = new CountingOutputStream().             transform(t, new StreamResult(os)).             return os.count.         } catch (TransformerException ex) {         // ignore         }     }     return null. }
false;protected;2;11;;@Override protected void writeInternal(T t, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {     try {         Result result = new StreamResult(outputMessage.getBody()).         transform(t, result).     } catch (TransformerException ex) {         throw new HttpMessageNotWritableException("Could not transform [" + t + "] to output message", ex).     } }
false;private;2;3;;private void transform(Source source, Result result) throws TransformerException {     this.transformerFactory.newTransformer().transform(source, result). }
false;public;1;4;;@Override public void write(int b) throws IOException {     this.count++. }
false;public;1;4;;@Override public void write(byte[] b) throws IOException {     this.count += b.length. }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     this.count += len. }
