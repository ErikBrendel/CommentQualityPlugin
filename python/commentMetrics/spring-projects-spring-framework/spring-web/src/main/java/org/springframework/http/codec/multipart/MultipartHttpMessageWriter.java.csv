commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;8;;private static List<MediaType> initMediaTypes(@Nullable HttpMessageWriter<?> formWriter) {     List<MediaType> result = new ArrayList<>().     result.add(MediaType.MULTIPART_FORM_DATA).     if (formWriter != null) {         result.addAll(formWriter.getWritableMediaTypes()).     }     return Collections.unmodifiableList(result). }
true;public;0;3;/**  * Return the configured part writers.  * @since 5.0.7  */ ;/**  * Return the configured part writers.  * @since 5.0.7  */ public List<HttpMessageWriter<?>> getPartWriters() {     return Collections.unmodifiableList(this.partWriters). }
true;public;1;4;/**  * Set the character set to use for part headers such as  * "Content-Disposition" (and its filename parameter).  * <p>By default this is set to "UTF-8".  */ ;/**  * Set the character set to use for part headers such as  * "Content-Disposition" (and its filename parameter).  * <p>By default this is set to "UTF-8".  */ public void setCharset(Charset charset) {     Assert.notNull(charset, "Charset must not be null").     this.charset = charset. }
true;public;0;3;/**  * Return the configured charset for part headers.  */ ;/**  * Return the configured charset for part headers.  */ public Charset getCharset() {     return this.charset. }
false;public;0;4;;@Override public List<MediaType> getWritableMediaTypes() {     return this.supportedMediaTypes. }
false;public;2;6;;@Override public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {     return (MultiValueMap.class.isAssignableFrom(elementType.toClass()) && (mediaType == null || this.supportedMediaTypes.stream().anyMatch(element -> element.isCompatibleWith(mediaType)))). }
false;public;5;17;;@Override public Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream, ResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage, Map<String, Object> hints) {     return Mono.from(inputStream).flatMap(map -> {         if (this.formWriter == null || isMultipart(map, mediaType)) {             return writeMultipart(map, outputMessage, hints).         } else {             @SuppressWarnings("unchecked")             MultiValueMap<String, String> formData = (MultiValueMap<String, String>) map.             return this.formWriter.write(Mono.just(formData), elementType, mediaType, outputMessage, hints).         }     }). }
false;private;2;13;;private boolean isMultipart(MultiValueMap<String, ?> map, @Nullable MediaType contentType) {     if (contentType != null) {         return MediaType.MULTIPART_FORM_DATA.includes(contentType).     }     for (String name : map.keySet()) {         for (Object value : map.get(name)) {             if (value != null && !(value instanceof String)) {                 return true.             }         }     }     return false. }
false;private;3;22;;private Mono<Void> writeMultipart(MultiValueMap<String, ?> map, ReactiveHttpOutputMessage outputMessage, Map<String, Object> hints) {     byte[] boundary = generateMultipartBoundary().     Map<String, String> params = new HashMap<>(2).     params.put("boundary", new String(boundary, StandardCharsets.US_ASCII)).     params.put("charset", getCharset().name()).     outputMessage.getHeaders().setContentType(new MediaType(MediaType.MULTIPART_FORM_DATA, params)).     LogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + "Encoding " + (isEnableLoggingRequestDetails() ? LogFormatUtils.formatValue(map, !traceOn) : "parts " + map.keySet() + " (content masked)")).     Flux<DataBuffer> body = Flux.fromIterable(map.entrySet()).concatMap(entry -> encodePartValues(boundary, entry.getKey(), entry.getValue())).concatWith(Mono.just(generateLastLine(boundary))).     return outputMessage.writeWith(body). }
true;protected;0;3;/**  * Generate a multipart boundary.  * <p>By default delegates to {@link MimeTypeUtils#generateMultipartBoundary()}.  */ ;/**  * Generate a multipart boundary.  * <p>By default delegates to {@link MimeTypeUtils#generateMultipartBoundary()}.  */ protected byte[] generateMultipartBoundary() {     return MimeTypeUtils.generateMultipartBoundary(). }
false;private;3;4;;private Flux<DataBuffer> encodePartValues(byte[] boundary, String name, List<?> values) {     return Flux.concat(values.stream().map(v -> encodePart(boundary, name, v)).collect(Collectors.toList())). }
false;private;3;66;;@SuppressWarnings("unchecked") private <T> Flux<DataBuffer> encodePart(byte[] boundary, String name, T value) {     MultipartHttpOutputMessage outputMessage = new MultipartHttpOutputMessage(this.bufferFactory, getCharset()).     HttpHeaders outputHeaders = outputMessage.getHeaders().     T body.     ResolvableType resolvableType = null.     if (value instanceof HttpEntity) {         HttpEntity<T> httpEntity = (HttpEntity<T>) value.         outputHeaders.putAll(httpEntity.getHeaders()).         body = httpEntity.getBody().         Assert.state(body != null, "MultipartHttpMessageWriter only supports HttpEntity with body").         if (httpEntity instanceof MultipartBodyBuilder.PublisherEntity<?, ?>) {             MultipartBodyBuilder.PublisherEntity<?, ?> publisherEntity = (MultipartBodyBuilder.PublisherEntity<?, ?>) httpEntity.             resolvableType = publisherEntity.getResolvableType().         }     } else {         body = value.     }     if (resolvableType == null) {         resolvableType = ResolvableType.forClass(body.getClass()).     }     if (!outputHeaders.containsKey(HttpHeaders.CONTENT_DISPOSITION)) {         if (body instanceof Resource) {             outputHeaders.setContentDispositionFormData(name, ((Resource) body).getFilename()).         } else if (resolvableType.resolve() == Resource.class) {             body = (T) Mono.from((Publisher<?>) body).doOnNext(o -> outputHeaders.setContentDispositionFormData(name, ((Resource) o).getFilename())).         } else {             outputHeaders.setContentDispositionFormData(name, null).         }     }     MediaType contentType = outputHeaders.getContentType().     final ResolvableType finalBodyType = resolvableType.     Optional<HttpMessageWriter<?>> writer = this.partWriters.stream().filter(partWriter -> partWriter.canWrite(finalBodyType, contentType)).findFirst().     if (!writer.isPresent()) {         return Flux.error(new CodecException("No suitable writer found for part: " + name)).     }     Publisher<T> bodyPublisher = body instanceof Publisher ? (Publisher<T>) body : Mono.just(body).     // The writer will call MultipartHttpOutputMessage#write which doesn't actually write     // but only stores the body Flux and returns Mono.empty().     Mono<Void> partContentReady = ((HttpMessageWriter<T>) writer.get()).write(bodyPublisher, resolvableType, contentType, outputMessage, DEFAULT_HINTS).     // After partContentReady, we can access the part content from MultipartHttpOutputMessage     // and use it for writing to the actual request body     Flux<DataBuffer> partContent = partContentReady.thenMany(Flux.defer(outputMessage::getBody)).     return Flux.concat(Mono.just(generateBoundaryLine(boundary)), partContent, Mono.just(generateNewLine())). }
false;private;1;9;;private DataBuffer generateBoundaryLine(byte[] boundary) {     DataBuffer buffer = this.bufferFactory.allocateBuffer(boundary.length + 4).     buffer.write((byte) '-').     buffer.write((byte) '-').     buffer.write(boundary).     buffer.write((byte) '\r').     buffer.write((byte) '\n').     return buffer. }
false;private;0;6;;private DataBuffer generateNewLine() {     DataBuffer buffer = this.bufferFactory.allocateBuffer(2).     buffer.write((byte) '\r').     buffer.write((byte) '\n').     return buffer. }
false;private;1;11;;private DataBuffer generateLastLine(byte[] boundary) {     DataBuffer buffer = this.bufferFactory.allocateBuffer(boundary.length + 6).     buffer.write((byte) '-').     buffer.write((byte) '-').     buffer.write(boundary).     buffer.write((byte) '-').     buffer.write((byte) '-').     buffer.write((byte) '\r').     buffer.write((byte) '\n').     return buffer. }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return (this.body != null ? HttpHeaders.readOnlyHttpHeaders(this.headers) : this.headers). }
false;public;0;4;;@Override public DataBufferFactory bufferFactory() {     return this.bufferFactory. }
false;public;1;4;;@Override public void beforeCommit(Supplier<? extends Mono<Void>> action) {     this.committed.set(true). }
false;public;0;4;;@Override public boolean isCommitted() {     return this.committed.get(). }
false;public;1;10;;@Override public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {     if (this.body != null) {         return Mono.error(new IllegalStateException("Multiple calls to writeWith() not supported")).     }     this.body = Flux.just(generateHeaders()).concatWith(body).     // We don't actually want to write (just save the body Flux)     return Mono.empty(). }
false;private;0;18;;private DataBuffer generateHeaders() {     DataBuffer buffer = this.bufferFactory.allocateBuffer().     for (Map.Entry<String, List<String>> entry : this.headers.entrySet()) {         byte[] headerName = entry.getKey().getBytes(this.charset).         for (String headerValueString : entry.getValue()) {             byte[] headerValue = headerValueString.getBytes(this.charset).             buffer.write(headerName).             buffer.write((byte) ':').             buffer.write((byte) ' ').             buffer.write(headerValue).             buffer.write((byte) '\r').             buffer.write((byte) '\n').         }     }     buffer.write((byte) '\r').     buffer.write((byte) '\n').     return buffer. }
false;public;1;4;;@Override public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {     return Mono.error(new UnsupportedOperationException()). }
false;public;0;4;;public Flux<DataBuffer> getBody() {     return (this.body != null ? this.body : Flux.error(new IllegalStateException("Body has not been written yet"))). }
false;public;0;4;;@Override public Mono<Void> setComplete() {     return Mono.error(new UnsupportedOperationException()). }
