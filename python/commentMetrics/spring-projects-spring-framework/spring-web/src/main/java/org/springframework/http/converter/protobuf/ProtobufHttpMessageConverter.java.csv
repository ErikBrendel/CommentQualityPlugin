commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean supports(Class<?> clazz) {     return Message.class.isAssignableFrom(clazz). }
false;protected;1;4;;@Override protected MediaType getDefaultContentType(Message message) {     return PROTOBUF. }
false;protected;2;27;;@Override protected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {     MediaType contentType = inputMessage.getHeaders().getContentType().     if (contentType == null) {         contentType = PROTOBUF.     }     Charset charset = contentType.getCharset().     if (charset == null) {         charset = DEFAULT_CHARSET.     }     Message.Builder builder = getMessageBuilder(clazz).     if (PROTOBUF.isCompatibleWith(contentType)) {         builder.mergeFrom(inputMessage.getBody(), this.extensionRegistry).     } else if (TEXT_PLAIN.isCompatibleWith(contentType)) {         InputStreamReader reader = new InputStreamReader(inputMessage.getBody(), charset).         TextFormat.merge(reader, this.extensionRegistry, builder).     } else if (this.protobufFormatSupport != null) {         this.protobufFormatSupport.merge(inputMessage.getBody(), charset, contentType, this.extensionRegistry, builder).     }     return builder.build(). }
true;private;1;14;/**  * Create a new {@code Message.Builder} instance for the given class.  * <p>This method uses a ConcurrentReferenceHashMap for caching method lookups.  */ ;/**  * Create a new {@code Message.Builder} instance for the given class.  * <p>This method uses a ConcurrentReferenceHashMap for caching method lookups.  */ private Message.Builder getMessageBuilder(Class<? extends Message> clazz) {     try {         Method method = methodCache.get(clazz).         if (method == null) {             method = clazz.getMethod("newBuilder").             methodCache.put(clazz, method).         }         return (Message.Builder) method.invoke(clazz).     } catch (Exception ex) {         throw new HttpMessageConversionException("Invalid Protobuf Message type: no invocable newBuilder() method on " + clazz, ex).     } }
false;protected;1;5;;@Override protected boolean canWrite(@Nullable MediaType mediaType) {     return (super.canWrite(mediaType) || (this.protobufFormatSupport != null && this.protobufFormatSupport.supportsWriteOnly(mediaType))). }
false;protected;2;31;;@Override protected void writeInternal(Message message, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {     MediaType contentType = outputMessage.getHeaders().getContentType().     if (contentType == null) {         contentType = getDefaultContentType(message).         Assert.state(contentType != null, "No content type").     }     Charset charset = contentType.getCharset().     if (charset == null) {         charset = DEFAULT_CHARSET.     }     if (PROTOBUF.isCompatibleWith(contentType)) {         setProtoHeader(outputMessage, message).         CodedOutputStream codedOutputStream = CodedOutputStream.newInstance(outputMessage.getBody()).         message.writeTo(codedOutputStream).         codedOutputStream.flush().     } else if (TEXT_PLAIN.isCompatibleWith(contentType)) {         OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset).         TextFormat.print(message, outputStreamWriter).         outputStreamWriter.flush().         outputMessage.getBody().flush().     } else if (this.protobufFormatSupport != null) {         this.protobufFormatSupport.print(message, outputMessage.getBody(), contentType, charset).         outputMessage.getBody().flush().     } }
true;private;2;4;/**  * Set the "X-Protobuf-*" HTTP headers when responding with a message of  * content type "application/x-protobuf"  * <p><b>Note:</b> <code>outputMessage.getBody()</code> should not have been called  * before because it writes HTTP headers (making them read only).</p>  */ ;/**  * Set the "X-Protobuf-*" HTTP headers when responding with a message of  * content type "application/x-protobuf"  * <p><b>Note:</b> <code>outputMessage.getBody()</code> should not have been called  * before because it writes HTTP headers (making them read only).</p>  */ private void setProtoHeader(HttpOutputMessage response, Message message) {     response.getHeaders().set(X_PROTOBUF_SCHEMA_HEADER, message.getDescriptorForType().getFile().getName()).     response.getHeaders().set(X_PROTOBUF_MESSAGE_HEADER, message.getDescriptorForType().getFullName()). }
false;;0;1;;MediaType[] supportedMediaTypes().
false;;1;1;;boolean supportsWriteOnly(@Nullable MediaType mediaType).
false;;5;3;;void merge(InputStream input, Charset charset, MediaType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder) throws IOException, HttpMessageConversionException.
false;;4;2;;void print(Message message, OutputStream output, MediaType contentType, Charset charset) throws IOException, HttpMessageConversionException.
false;public;0;4;;@Override public MediaType[] supportedMediaTypes() {     return new MediaType[] { PROTOBUF, TEXT_PLAIN, APPLICATION_XML, APPLICATION_JSON }. }
false;public;1;4;;@Override public boolean supportsWriteOnly(@Nullable MediaType mediaType) {     return TEXT_HTML.isCompatibleWith(mediaType). }
false;public;5;16;;@Override public void merge(InputStream input, Charset charset, MediaType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder) throws IOException, HttpMessageConversionException {     if (contentType.isCompatibleWith(APPLICATION_JSON)) {         this.jsonFormatter.merge(input, charset, extensionRegistry, builder).     } else if (contentType.isCompatibleWith(APPLICATION_XML)) {         this.xmlFormatter.merge(input, charset, extensionRegistry, builder).     } else {         throw new HttpMessageConversionException("protobuf-java-format does not support parsing " + contentType).     } }
false;public;4;18;;@Override public void print(Message message, OutputStream output, MediaType contentType, Charset charset) throws IOException, HttpMessageConversionException {     if (contentType.isCompatibleWith(APPLICATION_JSON)) {         this.jsonFormatter.print(message, output, charset).     } else if (contentType.isCompatibleWith(APPLICATION_XML)) {         this.xmlFormatter.print(message, output, charset).     } else if (contentType.isCompatibleWith(TEXT_HTML)) {         this.htmlFormatter.print(message, output, charset).     } else {         throw new HttpMessageConversionException("protobuf-java-format does not support printing " + contentType).     } }
false;public;0;4;;@Override public MediaType[] supportedMediaTypes() {     return new MediaType[] { PROTOBUF, TEXT_PLAIN, APPLICATION_JSON }. }
false;public;1;4;;@Override public boolean supportsWriteOnly(@Nullable MediaType mediaType) {     return false. }
false;public;5;14;;@Override public void merge(InputStream input, Charset charset, MediaType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder) throws IOException, HttpMessageConversionException {     if (contentType.isCompatibleWith(APPLICATION_JSON)) {         InputStreamReader reader = new InputStreamReader(input, charset).         this.parser.merge(reader, builder).     } else {         throw new HttpMessageConversionException("protobuf-java-util does not support parsing " + contentType).     } }
false;public;4;14;;@Override public void print(Message message, OutputStream output, MediaType contentType, Charset charset) throws IOException, HttpMessageConversionException {     if (contentType.isCompatibleWith(APPLICATION_JSON)) {         OutputStreamWriter writer = new OutputStreamWriter(output, charset).         this.printer.appendTo(message, writer).         writer.flush().     } else {         throw new HttpMessageConversionException("protobuf-java-util does not support printing " + contentType).     } }
