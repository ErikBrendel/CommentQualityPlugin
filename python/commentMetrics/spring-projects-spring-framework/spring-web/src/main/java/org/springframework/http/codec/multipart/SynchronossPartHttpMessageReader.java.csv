commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<MediaType> getReadableMediaTypes() {     return Collections.singletonList(MediaType.MULTIPART_FORM_DATA). }
false;public;2;5;;@Override public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {     return Part.class.equals(elementType.toClass()) && (mediaType == null || MediaType.MULTIPART_FORM_DATA.isCompatibleWith(mediaType)). }
false;public;3;12;;@Override public Flux<Part> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     return Flux.create(new SynchronossPartGenerator(message, this.bufferFactory, this.streamStorageFactory)).doOnNext(part -> {         if (!Hints.isLoggingSuppressed(hints)) {             LogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + "Parsed " + (isEnableLoggingRequestDetails() ? LogFormatUtils.formatValue(part, !traceOn) : "parts '" + part.name() + "' (content masked)")).         }     }). }
false;public;3;4;;@Override public Mono<Part> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     return Mono.error(new UnsupportedOperationException("Cannot read multipart request body into single Part")). }
false;public;1;45;;@Override public void accept(FluxSink<Part> emitter) {     HttpHeaders headers = this.inputMessage.getHeaders().     MediaType mediaType = headers.getContentType().     Assert.state(mediaType != null, "No content type set").     int length = getContentLength(headers).     Charset charset = Optional.ofNullable(mediaType.getCharset()).orElse(StandardCharsets.UTF_8).     MultipartContext context = new MultipartContext(mediaType.toString(), length, charset.name()).     NioMultipartParserListener listener = new FluxSinkAdapterListener(emitter, this.bufferFactory, context).     NioMultipartParser parser = Multipart.multipart(context).usePartBodyStreamStorageFactory(this.streamStorageFactory).forNIO(listener).     this.inputMessage.getBody().subscribe(buffer -> {         byte[] resultBytes = new byte[buffer.readableByteCount()].         buffer.read(resultBytes).         try {             parser.write(resultBytes).         } catch (IOException ex) {             listener.onError("Exception thrown providing input to the parser", ex).         } finally {             DataBufferUtils.release(buffer).         }     }, ex -> {         try {             listener.onError("Request body input error", ex).             parser.close().         } catch (IOException ex2) {             listener.onError("Exception thrown while closing the parser", ex2).         }     }, () -> {         try {             parser.close().         } catch (IOException ex) {             listener.onError("Exception thrown while closing the parser", ex).         }     }). }
false;private;1;5;;private int getContentLength(HttpHeaders headers) {     // Until this is fixed https://github.com/synchronoss/nio-multipart/issues/10     long length = headers.getContentLength().     return (int) length == length ? (int) length : -1. }
false;public;2;6;;@Override public void onPartFinished(StreamStorage storage, Map<String, List<String>> headers) {     HttpHeaders httpHeaders = new HttpHeaders().     httpHeaders.putAll(headers).     this.sink.next(createPart(storage, httpHeaders)). }
false;private;2;13;;private Part createPart(StreamStorage storage, HttpHeaders httpHeaders) {     String filename = MultipartUtils.getFileName(httpHeaders).     if (filename != null) {         return new SynchronossFilePart(httpHeaders, filename, storage, this.bufferFactory).     } else if (MultipartUtils.isFormField(httpHeaders, this.context)) {         String value = MultipartUtils.readFormParameterValue(storage, httpHeaders).         return new SynchronossFormFieldPart(httpHeaders, this.bufferFactory, value).     } else {         return new SynchronossPart(httpHeaders, storage, this.bufferFactory).     } }
false;public;2;6;;@Override public void onError(String message, Throwable cause) {     if (this.terminated.getAndIncrement() == 0) {         this.sink.error(new RuntimeException(message, cause)).     } }
false;public;0;6;;@Override public void onAllPartsFinished() {     if (this.terminated.getAndIncrement() == 0) {         this.sink.complete().     } }
false;public;1;3;;@Override public void onNestedPartStarted(Map<String, List<String>> headersFromParentPart) { }
false;public;0;3;;@Override public void onNestedPartFinished() { }
false;public;0;4;;@Override public String name() {     return this.name. }
false;public;0;4;;@Override public HttpHeaders headers() {     return this.headers. }
false;;0;3;;DataBufferFactory getBufferFactory() {     return this.bufferFactory. }
false;public;0;4;;@Override public String toString() {     return "Part '" + this.name + "', headers=" + this.headers. }
false;public;0;4;;@Override public Flux<DataBuffer> content() {     return DataBufferUtils.readInputStream(getStorage()::getInputStream, getBufferFactory(), 4096). }
false;protected;0;3;;protected StreamStorage getStorage() {     return this.storage. }
false;public;0;4;;@Override public String filename() {     return this.filename. }
false;public;1;38;;@Override public Mono<Void> transferTo(Path dest) {     ReadableByteChannel input = null.     FileChannel output = null.     try {         input = Channels.newChannel(getStorage().getInputStream()).         output = FileChannel.open(dest, FILE_CHANNEL_OPTIONS).         long size = (input instanceof FileChannel ? ((FileChannel) input).size() : Long.MAX_VALUE).         long totalWritten = 0.         while (totalWritten < size) {             long written = output.transferFrom(input, totalWritten, size - totalWritten).             if (written <= 0) {                 break.             }             totalWritten += written.         }     } catch (IOException ex) {         return Mono.error(ex).     } finally {         if (input != null) {             try {                 input.close().             } catch (IOException ignored) {             }         }         if (output != null) {             try {                 output.close().             } catch (IOException ignored) {             }         }     }     return Mono.empty(). }
false;public;0;4;;@Override public String toString() {     return "Part '" + name() + "', filename='" + this.filename + "'". }
false;public;0;4;;@Override public String value() {     return this.content. }
false;public;0;7;;@Override public Flux<DataBuffer> content() {     byte[] bytes = this.content.getBytes(getCharset()).     DataBuffer buffer = getBufferFactory().allocateBuffer(bytes.length).     buffer.write(bytes).     return Flux.just(buffer). }
false;private;0;4;;private Charset getCharset() {     String name = MultipartUtils.getCharEncoding(headers()).     return (name != null ? Charset.forName(name) : StandardCharsets.UTF_8). }
false;public;0;4;;@Override public String toString() {     return "Part '" + name() + "=" + this.content + "'". }
