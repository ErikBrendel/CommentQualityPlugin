commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Create an instance with the given log prefix.  * @since 5.1  */ ;/**  * Create an instance with the given log prefix.  * @since 5.1  */ public String getLogPrefix() {     return this.logPrefix. }
false;public,final;1;4;;// Subscriber methods and async I/O notification methods... @Override public final void onSubscribe(Subscription subscription) {     this.state.get().onSubscribe(this, subscription). }
false;public,final;1;7;;@Override public final void onNext(T data) {     if (rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "Item to write").     }     this.state.get().onNext(this, data). }
true;public,final;1;7;/**  * Error signal from the upstream, write Publisher. This is also used by  * sub-classes to delegate error notifications from the container.  */ ;/**  * Error signal from the upstream, write Publisher. This is also used by  * sub-classes to delegate error notifications from the container.  */ @Override public final void onError(Throwable ex) {     if (rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "Write source error: " + ex).     }     this.state.get().onError(this, ex). }
true;public,final;0;7;/**  * Completion signal from the upstream, write Publisher. This is also used  * by sub-classes to delegate completion notifications from the container.  */ ;/**  * Completion signal from the upstream, write Publisher. This is also used  * by sub-classes to delegate completion notifications from the container.  */ @Override public final void onComplete() {     if (rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "No more items to write").     }     this.state.get().onComplete(this). }
true;public,final;0;6;/**  * Invoked when writing is possible, either in the same thread after a check  * via {@link #isWritePossible()}, or as a callback from the underlying  * container.  */ ;/**  * Invoked when writing is possible, either in the same thread after a check  * via {@link #isWritePossible()}, or as a callback from the underlying  * container.  */ public final void onWritePossible() {     if (rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "onWritePossible").     }     this.state.get().onWritePossible(this). }
true;public;0;6;/**  * Invoked during an error or completion callback from the underlying  * container to cancel the upstream subscription.  */ ;/**  * Invoked during an error or completion callback from the underlying  * container to cancel the upstream subscription.  */ public void cancel() {     rsWriteLogger.trace(getLogPrefix() + "Cancellation").     if (this.subscription != null) {         this.subscription.cancel().     } }
false;public,final;1;7;;// Publisher implementation for result notifications... @Override public final void subscribe(Subscriber<? super Void> subscriber) {     // Technically, cancellation from the result subscriber should be propagated     // to the upstream subscription. In practice, HttpHandler server adapters     // don't have a reason to cancel the result subscription.     this.resultPublisher.subscribe(subscriber). }
true;protected,abstract;1;1;/**  * Whether the given data item has any content to write.  * If false the item is not written.  */ ;// Write API methods to be implemented or template methods to override... /**  * Whether the given data item has any content to write.  * If false the item is not written.  */ protected abstract boolean isDataEmpty(T data).
true;protected;1;12;/**  * Template method invoked after a data item to write is received via  * {@link Subscriber#onNext(Object)}. The default implementation saves the  * data item for writing once that is possible.  */ ;/**  * Template method invoked after a data item to write is received via  * {@link Subscriber#onNext(Object)}. The default implementation saves the  * data item for writing once that is possible.  */ protected void dataReceived(T data) {     T prev = this.currentData.     if (prev != null) {         // This shouldn't happen:         // 1. dataReceived can only be called from REQUESTED state         // 2. currentData is cleared before requesting         discardData(data).         cancel().         onError(new IllegalStateException("Received new data while current not processed yet.")).     }     this.currentData = data. }
true;protected,abstract;0;1;/**  * Whether writing is possible.  */ ;/**  * Whether writing is possible.  */ protected abstract boolean isWritePossible().
true;protected,abstract;1;1;/**  * Write the given item.  * <p><strong>Note:</strong> Sub-classes are responsible for releasing any  * data buffer associated with the item, once fully written, if pooled  * buffers apply to the underlying container.  * @param data the item to write  * @return whether the current data item was written and another one  * requested ({@code true}), or or otherwise if more writes are required.  */ ;/**  * Write the given item.  * <p><strong>Note:</strong> Sub-classes are responsible for releasing any  * data buffer associated with the item, once fully written, if pooled  * buffers apply to the underlying container.  * @param data the item to write  * @return whether the current data item was written and another one  * requested ({@code true}), or or otherwise if more writes are required.  */ protected abstract boolean write(T data) throws IOException.
true;protected;0;3;/**  * Invoked after the current data has been written and before requesting  * the next item from the upstream, write Publisher.  * <p>The default implementation is a no-op.  * @deprecated originally introduced for Undertow to stop write notifications  * when no data is available, but deprecated as of as of 5.0.6 since constant  * switching on every requested item causes a significant slowdown.  */ ;/**  * Invoked after the current data has been written and before requesting  * the next item from the upstream, write Publisher.  * <p>The default implementation is a no-op.  * @deprecated originally introduced for Undertow to stop write notifications  * when no data is available, but deprecated as of as of 5.0.6 since constant  * switching on every requested item causes a significant slowdown.  */ @Deprecated protected void writingPaused() { }
true;protected;0;2;/**  * Invoked after onComplete or onError notification.  * <p>The default implementation is a no-op.  */ ;/**  * Invoked after onComplete or onError notification.  * <p>The default implementation is a no-op.  */ protected void writingComplete() { }
true;protected;1;2;/**  * Invoked when an I/O error occurs during a write. Sub-classes may choose  * to ignore this if they know the underlying API will provide an error  * notification in a container thread.  * <p>Defaults to no-op.  */ ;/**  * Invoked when an I/O error occurs during a write. Sub-classes may choose  * to ignore this if they know the underlying API will provide an error  * notification in a container thread.  * <p>Defaults to no-op.  */ protected void writingFailed(Throwable ex) { }
true;protected,abstract;1;1;/**  * Invoked after any error (either from the upstream write Publisher, or  * from I/O operations to the underlying server) and cancellation  * to discard in-flight data that was in  * the process of being written when the error took place.  * @param data the data to be released  * @since 5.0.11  */ ;/**  * Invoked after any error (either from the upstream write Publisher, or  * from I/O operations to the underlying server) and cancellation  * to discard in-flight data that was in  * the process of being written when the error took place.  * @param data the data to be released  * @since 5.0.11  */ protected abstract void discardData(T data).
false;private;2;7;;// Private methods for use from State's... private boolean changeState(State oldState, State newState) {     boolean result = this.state.compareAndSet(oldState, newState).     if (result && rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + oldState + " -> " + newState).     }     return result. }
false;private;1;5;;private void changeStateToReceived(State oldState) {     if (changeState(oldState, State.RECEIVED)) {         writeIfPossible().     } }
false;private;1;10;;private void changeStateToComplete(State oldState) {     if (changeState(oldState, State.COMPLETED)) {         discardCurrentData().         writingComplete().         this.resultPublisher.publishComplete().     } else {         this.state.get().onComplete(this).     } }
false;private;0;9;;private void writeIfPossible() {     boolean result = isWritePossible().     if (!result && rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "isWritePossible: false").     }     if (result) {         onWritePossible().     } }
false;private;0;7;;private void discardCurrentData() {     T data = this.currentData.     this.currentData = null.     if (data != null) {         discardData(data).     } }
false;public;2;11;;@Override public <T> void onSubscribe(AbstractListenerWriteProcessor<T> processor, Subscription subscription) {     Assert.notNull(subscription, "Subscription must not be null").     if (processor.changeState(this, REQUESTED)) {         processor.subscription = subscription.         subscription.request(1).     } else {         super.onSubscribe(processor, subscription).     } }
false;public;2;11;;@Override public <T> void onNext(AbstractListenerWriteProcessor<T> processor, T data) {     if (processor.isDataEmpty(data)) {         Assert.state(processor.subscription != null, "No subscription").         processor.subscription.request(1).     } else {         processor.dataReceived(data).         processor.changeStateToReceived(this).     } }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteProcessor<T> processor) {     processor.changeStateToComplete(this). }
false;public;1;29;;@SuppressWarnings("deprecation") @Override public <T> void onWritePossible(AbstractListenerWriteProcessor<T> processor) {     if (processor.changeState(this, WRITING)) {         T data = processor.currentData.         Assert.state(data != null, "No data").         try {             if (processor.write(data)) {                 if (processor.changeState(WRITING, REQUESTED)) {                     processor.currentData = null.                     if (processor.subscriberCompleted) {                         processor.changeStateToComplete(REQUESTED).                     } else {                         processor.writingPaused().                         Assert.state(processor.subscription != null, "No subscription").                         processor.subscription.request(1).                     }                 }             } else {                 processor.changeStateToReceived(WRITING).             }         } catch (IOException ex) {             processor.writingFailed(ex).         }     } }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteProcessor<T> processor) {     processor.subscriberCompleted = true. }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteProcessor<T> processor) {     processor.subscriberCompleted = true. }
false;public;2;4;;@Override public <T> void onNext(AbstractListenerWriteProcessor<T> processor, T data) { // ignore }
false;public;2;4;;@Override public <T> void onError(AbstractListenerWriteProcessor<T> processor, Throwable ex) { // ignore }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteProcessor<T> processor) { // ignore }
false;public;2;3;;public <T> void onSubscribe(AbstractListenerWriteProcessor<T> processor, Subscription subscription) {     subscription.cancel(). }
false;public;2;5;;public <T> void onNext(AbstractListenerWriteProcessor<T> processor, T data) {     processor.discardData(data).     processor.cancel().     processor.onError(new IllegalStateException("Illegal onNext without demand")). }
false;public;2;10;;public <T> void onError(AbstractListenerWriteProcessor<T> processor, Throwable ex) {     if (processor.changeState(this, COMPLETED)) {         processor.discardCurrentData().         processor.writingComplete().         processor.resultPublisher.publishError(ex).     } else {         processor.state.get().onError(processor, ex).     } }
false;public;1;3;;public <T> void onComplete(AbstractListenerWriteProcessor<T> processor) {     throw new IllegalStateException(toString()). }
false;public;1;3;;public <T> void onWritePossible(AbstractListenerWriteProcessor<T> processor) { // ignore }
