commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the name of the ServletContext attribute which should be used to retrieve the  * {@link WebApplicationContext} from which to load the delegate {@link Filter} bean.  */ ;/**  * Set the name of the ServletContext attribute which should be used to retrieve the  * {@link WebApplicationContext} from which to load the delegate {@link Filter} bean.  */ public void setContextAttribute(@Nullable String contextAttribute) {     this.contextAttribute = contextAttribute. }
true;public;0;4;/**  * Return the name of the ServletContext attribute which should be used to retrieve the  * {@link WebApplicationContext} from which to load the delegate {@link Filter} bean.  */ ;/**  * Return the name of the ServletContext attribute which should be used to retrieve the  * {@link WebApplicationContext} from which to load the delegate {@link Filter} bean.  */ @Nullable public String getContextAttribute() {     return this.contextAttribute. }
true;public;1;3;/**  * Set the name of the target bean in the Spring application context.  * The target bean must implement the standard Servlet Filter interface.  * <p>By default, the {@code filter-name} as specified for the  * DelegatingFilterProxy in {@code web.xml} will be used.  */ ;/**  * Set the name of the target bean in the Spring application context.  * The target bean must implement the standard Servlet Filter interface.  * <p>By default, the {@code filter-name} as specified for the  * DelegatingFilterProxy in {@code web.xml} will be used.  */ public void setTargetBeanName(@Nullable String targetBeanName) {     this.targetBeanName = targetBeanName. }
true;protected;0;4;/**  * Return the name of the target bean in the Spring application context.  */ ;/**  * Return the name of the target bean in the Spring application context.  */ @Nullable protected String getTargetBeanName() {     return this.targetBeanName. }
true;public;1;3;/**  * Set whether to invoke the {@code Filter.init} and  * {@code Filter.destroy} lifecycle methods on the target bean.  * <p>Default is "false". target beans usually rely on the Spring application  * context for managing their lifecycle. Setting this flag to "true" means  * that the servlet container will control the lifecycle of the target  * Filter, with this proxy delegating the corresponding calls.  */ ;/**  * Set whether to invoke the {@code Filter.init} and  * {@code Filter.destroy} lifecycle methods on the target bean.  * <p>Default is "false". target beans usually rely on the Spring application  * context for managing their lifecycle. Setting this flag to "true" means  * that the servlet container will control the lifecycle of the target  * Filter, with this proxy delegating the corresponding calls.  */ public void setTargetFilterLifecycle(boolean targetFilterLifecycle) {     this.targetFilterLifecycle = targetFilterLifecycle. }
true;protected;0;3;/**  * Return whether to invoke the {@code Filter.init} and  * {@code Filter.destroy} lifecycle methods on the target bean.  */ ;/**  * Return whether to invoke the {@code Filter.init} and  * {@code Filter.destroy} lifecycle methods on the target bean.  */ protected boolean isTargetFilterLifecycle() {     return this.targetFilterLifecycle. }
false;protected;0;18;;@Override protected void initFilterBean() throws ServletException {     synchronized (this.delegateMonitor) {         if (this.delegate == null) {             // If no target bean name specified, use filter name.             if (this.targetBeanName == null) {                 this.targetBeanName = getFilterName().             }             // Fetch Spring root application context and initialize the delegate early,             // if possible. If the root application context will be started after this             // filter proxy, we'll have to resort to lazy initialization.             WebApplicationContext wac = findWebApplicationContext().             if (wac != null) {                 this.delegate = initDelegate(wac).             }         }     } }
false;public;3;24;;@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {     // Lazily initialize the delegate if necessary.     Filter delegateToUse = this.delegate.     if (delegateToUse == null) {         synchronized (this.delegateMonitor) {             delegateToUse = this.delegate.             if (delegateToUse == null) {                 WebApplicationContext wac = findWebApplicationContext().                 if (wac == null) {                     throw new IllegalStateException("No WebApplicationContext found: " + "no ContextLoaderListener or DispatcherServlet registered?").                 }                 delegateToUse = initDelegate(wac).             }             this.delegate = delegateToUse.         }     }     // Let the delegate perform the actual doFilter operation.     invokeDelegate(delegateToUse, request, response, filterChain). }
false;public;0;7;;@Override public void destroy() {     Filter delegateToUse = this.delegate.     if (delegateToUse != null) {         destroyDelegate(delegateToUse).     } }
true;protected;0;21;/**  * Return the {@code WebApplicationContext} passed in at construction time, if available.  * Otherwise, attempt to retrieve a {@code WebApplicationContext} from the  * {@code ServletContext} attribute with the {@linkplain #setContextAttribute  * configured name} if set. Otherwise look up a {@code WebApplicationContext} under  * the well-known "root" application context attribute. The  * {@code WebApplicationContext} must have already been loaded and stored in the  * {@code ServletContext} before this filter gets initialized (or invoked).  * <p>Subclasses may override this method to provide a different  * {@code WebApplicationContext} retrieval strategy.  * @return the {@code WebApplicationContext} for this proxy, or {@code null} if not found  * @see #DelegatingFilterProxy(String, WebApplicationContext)  * @see #getContextAttribute()  * @see WebApplicationContextUtils#getWebApplicationContext(javax.servlet.ServletContext)  * @see WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE  */ ;/**  * Return the {@code WebApplicationContext} passed in at construction time, if available.  * Otherwise, attempt to retrieve a {@code WebApplicationContext} from the  * {@code ServletContext} attribute with the {@linkplain #setContextAttribute  * configured name} if set. Otherwise look up a {@code WebApplicationContext} under  * the well-known "root" application context attribute. The  * {@code WebApplicationContext} must have already been loaded and stored in the  * {@code ServletContext} before this filter gets initialized (or invoked).  * <p>Subclasses may override this method to provide a different  * {@code WebApplicationContext} retrieval strategy.  * @return the {@code WebApplicationContext} for this proxy, or {@code null} if not found  * @see #DelegatingFilterProxy(String, WebApplicationContext)  * @see #getContextAttribute()  * @see WebApplicationContextUtils#getWebApplicationContext(javax.servlet.ServletContext)  * @see WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE  */ @Nullable protected WebApplicationContext findWebApplicationContext() {     if (this.webApplicationContext != null) {         // The user has injected a context at construction time -> use it...         if (this.webApplicationContext instanceof ConfigurableApplicationContext) {             ConfigurableApplicationContext cac = (ConfigurableApplicationContext) this.webApplicationContext.             if (!cac.isActive()) {                 // The context has not yet been refreshed -> do so before returning it...                 cac.refresh().             }         }         return this.webApplicationContext.     }     String attrName = getContextAttribute().     if (attrName != null) {         return WebApplicationContextUtils.getWebApplicationContext(getServletContext(), attrName).     } else {         return WebApplicationContextUtils.findWebApplicationContext(getServletContext()).     } }
true;protected;1;9;/**  * Initialize the Filter delegate, defined as bean the given Spring  * application context.  * <p>The default implementation fetches the bean from the application context  * and calls the standard {@code Filter.init} method on it, passing  * in the FilterConfig of this Filter proxy.  * @param wac the root application context  * @return the initialized delegate Filter  * @throws ServletException if thrown by the Filter  * @see #getTargetBeanName()  * @see #isTargetFilterLifecycle()  * @see #getFilterConfig()  * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)  */ ;/**  * Initialize the Filter delegate, defined as bean the given Spring  * application context.  * <p>The default implementation fetches the bean from the application context  * and calls the standard {@code Filter.init} method on it, passing  * in the FilterConfig of this Filter proxy.  * @param wac the root application context  * @return the initialized delegate Filter  * @throws ServletException if thrown by the Filter  * @see #getTargetBeanName()  * @see #isTargetFilterLifecycle()  * @see #getFilterConfig()  * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)  */ protected Filter initDelegate(WebApplicationContext wac) throws ServletException {     String targetBeanName = getTargetBeanName().     Assert.state(targetBeanName != null, "No target bean name set").     Filter delegate = wac.getBean(targetBeanName, Filter.class).     if (isTargetFilterLifecycle()) {         delegate.init(getFilterConfig()).     }     return delegate. }
true;protected;4;6;/**  * Actually invoke the delegate Filter with the given request and response.  * @param delegate the delegate Filter  * @param request the current HTTP request  * @param response the current HTTP response  * @param filterChain the current FilterChain  * @throws ServletException if thrown by the Filter  * @throws IOException if thrown by the Filter  */ ;/**  * Actually invoke the delegate Filter with the given request and response.  * @param delegate the delegate Filter  * @param request the current HTTP request  * @param response the current HTTP response  * @param filterChain the current FilterChain  * @throws ServletException if thrown by the Filter  * @throws IOException if thrown by the Filter  */ protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {     delegate.doFilter(request, response, filterChain). }
true;protected;1;5;/**  * Destroy the Filter delegate.  * Default implementation simply calls {@code Filter.destroy} on it.  * @param delegate the Filter delegate (never {@code null})  * @see #isTargetFilterLifecycle()  * @see javax.servlet.Filter#destroy()  */ ;/**  * Destroy the Filter delegate.  * Default implementation simply calls {@code Filter.destroy} on it.  * @param delegate the Filter delegate (never {@code null})  * @see #isTargetFilterLifecycle()  * @see javax.servlet.Filter#destroy()  */ protected void destroyDelegate(Filter delegate) {     if (isTargetFilterLifecycle()) {         delegate.destroy().     } }
