commented;modifiers;parameterAmount;loc;comment;code
false;public;4;27;;@Override // on JDK 9 where XMLEventReader is Iterator<Object> @SuppressWarnings({ "rawtypes", "unchecked" }) public Flux<XMLEvent> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<DataBuffer> flux = Flux.from(inputStream).     if (this.useAalto) {         AaltoDataBufferToXmlEvent aaltoMapper = new AaltoDataBufferToXmlEvent().         return flux.flatMap(aaltoMapper).doFinally(signalType -> aaltoMapper.endOfInput()).     } else {         Mono<DataBuffer> singleBuffer = DataBufferUtils.join(flux).         return singleBuffer.flatMapMany(dataBuffer -> {             try {                 InputStream is = dataBuffer.asInputStream().                 Iterator eventReader = inputFactory.createXMLEventReader(is).                 return Flux.fromIterable((Iterable<XMLEvent>) () -> eventReader).doFinally(t -> DataBufferUtils.release(dataBuffer)).             } catch (XMLStreamException ex) {                 return Mono.error(ex).             }         }).     } }
false;public;1;27;;@Override public Publisher<? extends XMLEvent> apply(DataBuffer dataBuffer) {     try {         this.streamReader.getInputFeeder().feedInput(dataBuffer.asByteBuffer()).         List<XMLEvent> events = new ArrayList<>().         while (true) {             if (this.streamReader.next() == AsyncXMLStreamReader.EVENT_INCOMPLETE) {                 // no more events with what currently has been fed to the reader                 break.             } else {                 XMLEvent event = this.eventAllocator.allocate(this.streamReader).                 events.add(event).                 if (event.isEndDocument()) {                     break.                 }             }         }         return Flux.fromIterable(events).     } catch (XMLStreamException ex) {         return Mono.error(ex).     } finally {         DataBufferUtils.release(dataBuffer).     } }
false;public;0;3;;public void endOfInput() {     this.streamReader.getInputFeeder().endOfInput(). }
