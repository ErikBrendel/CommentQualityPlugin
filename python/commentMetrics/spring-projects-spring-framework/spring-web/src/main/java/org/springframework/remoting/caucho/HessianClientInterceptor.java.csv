commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the HessianProxyFactory instance to use.  * If not specified, a default HessianProxyFactory will be created.  * <p>Allows to use an externally configured factory instance,  * in particular a custom HessianProxyFactory subclass.  */ ;/**  * Set the HessianProxyFactory instance to use.  * If not specified, a default HessianProxyFactory will be created.  * <p>Allows to use an externally configured factory instance,  * in particular a custom HessianProxyFactory subclass.  */ public void setProxyFactory(@Nullable HessianProxyFactory proxyFactory) {     this.proxyFactory = (proxyFactory != null ? proxyFactory : new HessianProxyFactory()). }
true;public;1;3;/**  * Specify the Hessian SerializerFactory to use.  * <p>This will typically be passed in as an inner bean definition  * of type {@code com.caucho.hessian.io.SerializerFactory},  * with custom bean property values applied.  */ ;/**  * Specify the Hessian SerializerFactory to use.  * <p>This will typically be passed in as an inner bean definition  * of type {@code com.caucho.hessian.io.SerializerFactory},  * with custom bean property values applied.  */ public void setSerializerFactory(SerializerFactory serializerFactory) {     this.proxyFactory.setSerializerFactory(serializerFactory). }
true;public;1;3;/**  * Set whether to send the Java collection type for each serialized  * collection. Default is "true".  */ ;/**  * Set whether to send the Java collection type for each serialized  * collection. Default is "true".  */ public void setSendCollectionType(boolean sendCollectionType) {     this.proxyFactory.getSerializerFactory().setSendCollectionType(sendCollectionType). }
true;public;1;3;/**  * Set whether to allow non-serializable types as Hessian arguments  * and return values. Default is "true".  */ ;/**  * Set whether to allow non-serializable types as Hessian arguments  * and return values. Default is "true".  */ public void setAllowNonSerializable(boolean allowNonSerializable) {     this.proxyFactory.getSerializerFactory().setAllowNonSerializable(allowNonSerializable). }
true;public;1;3;/**  * Set whether overloaded methods should be enabled for remote invocations.  * Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setOverloadEnabled  */ ;/**  * Set whether overloaded methods should be enabled for remote invocations.  * Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setOverloadEnabled  */ public void setOverloadEnabled(boolean overloadEnabled) {     this.proxyFactory.setOverloadEnabled(overloadEnabled). }
true;public;1;3;/**  * Set the username that this factory should use to access the remote service.  * Default is none.  * <p>The username will be sent by Hessian via HTTP Basic Authentication.  * @see com.caucho.hessian.client.HessianProxyFactory#setUser  */ ;/**  * Set the username that this factory should use to access the remote service.  * Default is none.  * <p>The username will be sent by Hessian via HTTP Basic Authentication.  * @see com.caucho.hessian.client.HessianProxyFactory#setUser  */ public void setUsername(String username) {     this.proxyFactory.setUser(username). }
true;public;1;3;/**  * Set the password that this factory should use to access the remote service.  * Default is none.  * <p>The password will be sent by Hessian via HTTP Basic Authentication.  * @see com.caucho.hessian.client.HessianProxyFactory#setPassword  */ ;/**  * Set the password that this factory should use to access the remote service.  * Default is none.  * <p>The password will be sent by Hessian via HTTP Basic Authentication.  * @see com.caucho.hessian.client.HessianProxyFactory#setPassword  */ public void setPassword(String password) {     this.proxyFactory.setPassword(password). }
true;public;1;3;/**  * Set whether Hessian's debug mode should be enabled.  * Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setDebug  */ ;/**  * Set whether Hessian's debug mode should be enabled.  * Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setDebug  */ public void setDebug(boolean debug) {     this.proxyFactory.setDebug(debug). }
true;public;1;3;/**  * Set whether to use a chunked post for sending a Hessian request.  * @see com.caucho.hessian.client.HessianProxyFactory#setChunkedPost  */ ;/**  * Set whether to use a chunked post for sending a Hessian request.  * @see com.caucho.hessian.client.HessianProxyFactory#setChunkedPost  */ public void setChunkedPost(boolean chunkedPost) {     this.proxyFactory.setChunkedPost(chunkedPost). }
true;public;1;3;/**  * Specify a custom HessianConnectionFactory to use for the Hessian client.  */ ;/**  * Specify a custom HessianConnectionFactory to use for the Hessian client.  */ public void setConnectionFactory(HessianConnectionFactory connectionFactory) {     this.proxyFactory.setConnectionFactory(connectionFactory). }
true;public;1;3;/**  * Set the socket connect timeout to use for the Hessian client.  * @see com.caucho.hessian.client.HessianProxyFactory#setConnectTimeout  */ ;/**  * Set the socket connect timeout to use for the Hessian client.  * @see com.caucho.hessian.client.HessianProxyFactory#setConnectTimeout  */ public void setConnectTimeout(long timeout) {     this.proxyFactory.setConnectTimeout(timeout). }
true;public;1;3;/**  * Set the timeout to use when waiting for a reply from the Hessian service.  * @see com.caucho.hessian.client.HessianProxyFactory#setReadTimeout  */ ;/**  * Set the timeout to use when waiting for a reply from the Hessian service.  * @see com.caucho.hessian.client.HessianProxyFactory#setReadTimeout  */ public void setReadTimeout(long timeout) {     this.proxyFactory.setReadTimeout(timeout). }
true;public;1;4;/**  * Set whether version 2 of the Hessian protocol should be used for  * parsing requests and replies. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setHessian2Request  */ ;/**  * Set whether version 2 of the Hessian protocol should be used for  * parsing requests and replies. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setHessian2Request  */ public void setHessian2(boolean hessian2) {     this.proxyFactory.setHessian2Request(hessian2).     this.proxyFactory.setHessian2Reply(hessian2). }
true;public;1;3;/**  * Set whether version 2 of the Hessian protocol should be used for  * parsing requests. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setHessian2Request  */ ;/**  * Set whether version 2 of the Hessian protocol should be used for  * parsing requests. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setHessian2Request  */ public void setHessian2Request(boolean hessian2) {     this.proxyFactory.setHessian2Request(hessian2). }
true;public;1;3;/**  * Set whether version 2 of the Hessian protocol should be used for  * parsing replies. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setHessian2Reply  */ ;/**  * Set whether version 2 of the Hessian protocol should be used for  * parsing replies. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setHessian2Reply  */ public void setHessian2Reply(boolean hessian2) {     this.proxyFactory.setHessian2Reply(hessian2). }
false;public;0;5;;@Override public void afterPropertiesSet() {     super.afterPropertiesSet().     prepare(). }
true;public;0;8;/**  * Initialize the Hessian proxy for this interceptor.  * @throws RemoteLookupFailureException if the service URL is invalid  */ ;/**  * Initialize the Hessian proxy for this interceptor.  * @throws RemoteLookupFailureException if the service URL is invalid  */ public void prepare() throws RemoteLookupFailureException {     try {         this.hessianProxy = createHessianProxy(this.proxyFactory).     } catch (MalformedURLException ex) {         throw new RemoteLookupFailureException("Service URL [" + getServiceUrl() + "] is invalid", ex).     } }
true;protected;1;4;/**  * Create the Hessian proxy that is wrapped by this interceptor.  * @param proxyFactory the proxy factory to use  * @return the Hessian proxy  * @throws MalformedURLException if thrown by the proxy factory  * @see com.caucho.hessian.client.HessianProxyFactory#create  */ ;/**  * Create the Hessian proxy that is wrapped by this interceptor.  * @param proxyFactory the proxy factory to use  * @return the Hessian proxy  * @throws MalformedURLException if thrown by the proxy factory  * @see com.caucho.hessian.client.HessianProxyFactory#create  */ protected Object createHessianProxy(HessianProxyFactory proxyFactory) throws MalformedURLException {     Assert.notNull(getServiceInterface(), "'serviceInterface' is required").     return proxyFactory.create(getServiceInterface(), getServiceUrl(), getBeanClassLoader()). }
false;public;1;41;;@Override @Nullable public Object invoke(MethodInvocation invocation) throws Throwable {     if (this.hessianProxy == null) {         throw new IllegalStateException("HessianClientInterceptor is not properly initialized - " + "invoke 'prepare' before attempting any operations").     }     ClassLoader originalClassLoader = overrideThreadContextClassLoader().     try {         return invocation.getMethod().invoke(this.hessianProxy, invocation.getArguments()).     } catch (InvocationTargetException ex) {         Throwable targetEx = ex.getTargetException().         // Hessian 4.0 check: another layer of InvocationTargetException.         if (targetEx instanceof InvocationTargetException) {             targetEx = ((InvocationTargetException) targetEx).getTargetException().         }         if (targetEx instanceof HessianConnectionException) {             throw convertHessianAccessException(targetEx).         } else if (targetEx instanceof HessianException || targetEx instanceof HessianRuntimeException) {             Throwable cause = targetEx.getCause().             throw convertHessianAccessException(cause != null ? cause : targetEx).         } else if (targetEx instanceof UndeclaredThrowableException) {             UndeclaredThrowableException utex = (UndeclaredThrowableException) targetEx.             throw convertHessianAccessException(utex.getUndeclaredThrowable()).         } else {             throw targetEx.         }     } catch (Throwable ex) {         throw new RemoteProxyFailureException("Failed to invoke Hessian proxy for remote service [" + getServiceUrl() + "]", ex).     } finally {         resetThreadContextClassLoader(originalClassLoader).     } }
true;protected;1;10;/**  * Convert the given Hessian access exception to an appropriate  * Spring RemoteAccessException.  * @param ex the exception to convert  * @return the RemoteAccessException to throw  */ ;/**  * Convert the given Hessian access exception to an appropriate  * Spring RemoteAccessException.  * @param ex the exception to convert  * @return the RemoteAccessException to throw  */ protected RemoteAccessException convertHessianAccessException(Throwable ex) {     if (ex instanceof HessianConnectionException || ex instanceof ConnectException) {         return new RemoteConnectFailureException("Cannot connect to Hessian remote service at [" + getServiceUrl() + "]", ex).     } else {         return new RemoteAccessException("Cannot access Hessian remote service at [" + getServiceUrl() + "]", ex).     } }
