commented;modifiers;parameterAmount;loc;comment;code
false;public;5;26;;@SuppressWarnings("unchecked") @Override public Mono<Void> write(Publisher<? extends Message> inputStream, ResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {     try {         Message.Builder builder = getMessageBuilder(elementType.toClass()).         Descriptors.Descriptor descriptor = builder.getDescriptorForType().         message.getHeaders().add(X_PROTOBUF_SCHEMA_HEADER, descriptor.getFile().getName()).         message.getHeaders().add(X_PROTOBUF_MESSAGE_HEADER, descriptor.getFullName()).         if (inputStream instanceof Flux) {             if (mediaType == null) {                 message.getHeaders().setContentType(((HttpMessageEncoder<?>) getEncoder()).getStreamingMediaTypes().get(0)).             } else if (!ProtobufEncoder.DELIMITED_VALUE.equals(mediaType.getParameters().get(ProtobufEncoder.DELIMITED_KEY))) {                 Map<String, String> parameters = new HashMap<>(mediaType.getParameters()).                 parameters.put(ProtobufEncoder.DELIMITED_KEY, ProtobufEncoder.DELIMITED_VALUE).                 message.getHeaders().setContentType(new MediaType(mediaType.getType(), mediaType.getSubtype(), parameters)).             }         }         return super.write(inputStream, elementType, mediaType, message, hints).     } catch (Exception ex) {         return Mono.error(new DecodingException("Could not read Protobuf message: " + ex.getMessage(), ex)).     } }
true;private,static;1;8;/**  * Create a new {@code Message.Builder} instance for the given class.  * <p>This method uses a ConcurrentHashMap for caching method lookups.  */ ;/**  * Create a new {@code Message.Builder} instance for the given class.  * <p>This method uses a ConcurrentHashMap for caching method lookups.  */ private static Message.Builder getMessageBuilder(Class<?> clazz) throws Exception {     Method method = methodCache.get(clazz).     if (method == null) {         method = clazz.getMethod("newBuilder").         methodCache.put(clazz, method).     }     return (Message.Builder) method.invoke(clazz). }
