commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the size of the input buffer used for reading in bytes.  * <p>By default this is set to 8192.  */ ;/**  * Set the size of the input buffer used for reading in bytes.  * <p>By default this is set to 8192.  */ public void setBufferSize(int bufferSize) {     Assert.isTrue(bufferSize > 0, "Buffer size must be larger than zero").     this.bufferSize = bufferSize. }
true;public;0;3;/**  * Return the configured input buffer size.  */ ;/**  * Return the configured input buffer size.  */ public int getBufferSize() {     return this.bufferSize. }
true;public;0;4;/**  * Return the Servlet path under which the Servlet is deployed by checking  * the Servlet registration from {@link #init(ServletConfig)}.  * @return the path, or an empty string if the Servlet is deployed without  * a prefix (i.e. "/" or "/*"), or {@code null} if this method is invoked  * before the {@link #init(ServletConfig)} Servlet container callback.  */ ;/**  * Return the Servlet path under which the Servlet is deployed by checking  * the Servlet registration from {@link #init(ServletConfig)}.  * @return the path, or an empty string if the Servlet is deployed without  * a prefix (i.e. "/" or "/*"), or {@code null} if this method is invoked  * before the {@link #init(ServletConfig)} Servlet container callback.  */ @Nullable public String getServletPath() {     return this.servletPath. }
false;public;1;4;;public void setDataBufferFactory(DataBufferFactory dataBufferFactory) {     Assert.notNull(dataBufferFactory, "DataBufferFactory must not be null").     this.dataBufferFactory = dataBufferFactory. }
false;public;0;3;;public DataBufferFactory getDataBufferFactory() {     return this.dataBufferFactory. }
false;public;1;4;;// Servlet methods... @Override public void init(ServletConfig config) {     this.servletPath = getServletPath(config). }
false;private;1;27;;private String getServletPath(ServletConfig config) {     String name = config.getServletName().     ServletRegistration registration = config.getServletContext().getServletRegistration(name).     if (registration == null) {         throw new IllegalStateException("ServletRegistration not found for Servlet '" + name + "'").     }     Collection<String> mappings = registration.getMappings().     if (mappings.size() == 1) {         String mapping = mappings.iterator().next().         if (mapping.equals("/")) {             return "".         }         if (mapping.endsWith("/*")) {             String path = mapping.substring(0, mapping.length() - 2).             if (!path.isEmpty() && logger.isDebugEnabled()) {                 logger.debug("Found servlet mapping prefix '" + path + "' for '" + name + "'").             }             return path.         }     }     throw new IllegalArgumentException("Expected a single Servlet mapping: " + "either the default Servlet mapping (i.e. '/'), " + "or a path based mapping (e.g. '/*', '/foo/*'). " + "Actual mappings: " + mappings + " for Servlet '" + name + "'"). }
false;public;2;37;;@Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {     // Check for existing error attribute first     if (DispatcherType.ASYNC.equals(request.getDispatcherType())) {         Throwable ex = (Throwable) request.getAttribute(WRITE_ERROR_ATTRIBUTE_NAME).         throw new ServletException("Failed to create response content", ex).     }     // Start async before Read/WriteListener registration     AsyncContext asyncContext = request.startAsync().     asyncContext.setTimeout(-1).     ServletServerHttpRequest httpRequest.     try {         httpRequest = createRequest(((HttpServletRequest) request), asyncContext).     } catch (URISyntaxException ex) {         if (logger.isDebugEnabled()) {             logger.debug("Failed to get request  URL: " + ex.getMessage()).         }         ((HttpServletResponse) response).setStatus(400).         asyncContext.complete().         return.     }     ServerHttpResponse httpResponse = createResponse(((HttpServletResponse) response), asyncContext, httpRequest).     if (httpRequest.getMethod() == HttpMethod.HEAD) {         httpResponse = new HttpHeadResponseDecorator(httpResponse).     }     AtomicBoolean isCompleted = new AtomicBoolean().     HandlerResultAsyncListener listener = new HandlerResultAsyncListener(isCompleted, httpRequest).     asyncContext.addListener(listener).     HandlerResultSubscriber subscriber = new HandlerResultSubscriber(asyncContext, isCompleted, httpRequest).     this.httpHandler.handle(httpRequest, httpResponse).subscribe(subscriber). }
false;protected;2;7;;protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context) throws IOException, URISyntaxException {     Assert.notNull(this.servletPath, "Servlet path is not initialized").     return new ServletServerHttpRequest(request, context, this.servletPath, getDataBufferFactory(), getBufferSize()). }
false;protected;3;5;;protected ServletServerHttpResponse createResponse(HttpServletResponse response, AsyncContext context, ServletServerHttpRequest request) throws IOException {     return new ServletServerHttpResponse(response, context, getDataBufferFactory(), getBufferSize(), request). }
false;public;0;4;;@Override public String getServletInfo() {     return "". }
false;public;0;5;;@Override @Nullable public ServletConfig getServletConfig() {     return null. }
false;public;0;3;;@Override public void destroy() { }
true;private,static;3;11;/**  * We cannot combine ERROR_LISTENER and HandlerResultSubscriber due to:  * https://issues.jboss.org/browse/WFLY-8515.  */ ;/**  * We cannot combine ERROR_LISTENER and HandlerResultSubscriber due to:  * https://issues.jboss.org/browse/WFLY-8515.  */ private static void runIfAsyncNotComplete(AsyncContext asyncContext, AtomicBoolean isCompleted, Runnable task) {     try {         if (asyncContext.getRequest().isAsyncStarted() && isCompleted.compareAndSet(false, true)) {             task.run().         }     } catch (IllegalStateException ex) {     // Ignore: AsyncContext recycled and should not be used     // e.g. TIMEOUT_LISTENER (above) may have completed the AsyncContext     } }
false;public;1;6;;@Override public void onTimeout(AsyncEvent event) {     logger.debug(this.logPrefix + "Timeout notification").     AsyncContext context = event.getAsyncContext().     runIfAsyncNotComplete(context, this.isCompleted, context::complete). }
false;public;1;7;;@Override public void onError(AsyncEvent event) {     Throwable ex = event.getThrowable().     logger.debug(this.logPrefix + "Error notification: " + (ex != null ? ex : "<no Throwable>")).     AsyncContext context = event.getAsyncContext().     runIfAsyncNotComplete(context, this.isCompleted, context::complete). }
false;public;1;4;;@Override public void onStartAsync(AsyncEvent event) { // no-op }
false;public;1;4;;@Override public void onComplete(AsyncEvent event) { // no-op }
false;public;1;4;;@Override public void onSubscribe(Subscription subscription) {     subscription.request(Long.MAX_VALUE). }
false;public;1;4;;@Override public void onNext(Void aVoid) { // no-op }
false;public;1;21;;@Override public void onError(Throwable ex) {     logger.trace(this.logPrefix + "Failed to complete: " + ex.getMessage()).     runIfAsyncNotComplete(this.asyncContext, this.isCompleted, () -> {         if (this.asyncContext.getResponse().isCommitted()) {             logger.trace(this.logPrefix + "Dispatch to container, to raise the error on servlet thread").             this.asyncContext.getRequest().setAttribute(WRITE_ERROR_ATTRIBUTE_NAME, ex).             this.asyncContext.dispatch().         } else {             try {                 logger.trace(this.logPrefix + "Setting ServletResponse status to 500 Server Error").                 this.asyncContext.getResponse().resetBuffer().                 ((HttpServletResponse) this.asyncContext.getResponse()).setStatus(500).             } finally {                 this.asyncContext.complete().             }         }     }). }
false;public;0;5;;@Override public void onComplete() {     logger.trace(this.logPrefix + "Handling completed").     runIfAsyncNotComplete(this.asyncContext, this.isCompleted, this.asyncContext::complete). }
