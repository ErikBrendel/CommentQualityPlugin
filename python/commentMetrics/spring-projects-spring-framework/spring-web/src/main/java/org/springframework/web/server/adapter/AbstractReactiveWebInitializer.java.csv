commented;modifiers;parameterAmount;loc;comment;code
false;public;1;24;;@Override public void onStartup(ServletContext servletContext) throws ServletException {     String servletName = getServletName().     Assert.hasLength(servletName, "getServletName() must not return null or empty").     ApplicationContext applicationContext = createApplicationContext().     Assert.notNull(applicationContext, "createApplicationContext() must not return null").     refreshApplicationContext(applicationContext).     registerCloseListener(servletContext, applicationContext).     HttpHandler httpHandler = WebHttpHandlerBuilder.applicationContext(applicationContext).build().     ServletHttpHandlerAdapter servlet = new ServletHttpHandlerAdapter(httpHandler).     ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, servlet).     if (registration == null) {         throw new IllegalStateException("Failed to register servlet with name '" + servletName + "'. " + "Check if there is another servlet registered under the same name.").     }     registration.setLoadOnStartup(1).     registration.addMapping(getServletMapping()).     registration.setAsyncSupported(true). }
true;protected;0;3;/**  * Return the name to use to register the {@link ServletHttpHandlerAdapter}.  * <p>By default this is {@link #DEFAULT_SERVLET_NAME}.  */ ;/**  * Return the name to use to register the {@link ServletHttpHandlerAdapter}.  * <p>By default this is {@link #DEFAULT_SERVLET_NAME}.  */ protected String getServletName() {     return DEFAULT_SERVLET_NAME. }
true;protected;0;7;/**  * Return the Spring configuration that contains application beans including  * the ones detected by {@link WebHttpHandlerBuilder#applicationContext}.  */ ;/**  * Return the Spring configuration that contains application beans including  * the ones detected by {@link WebHttpHandlerBuilder#applicationContext}.  */ protected ApplicationContext createApplicationContext() {     AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext().     Class<?>[] configClasses = getConfigClasses().     Assert.notEmpty(configClasses, "No Spring configuration provided through getConfigClasses()").     context.register(configClasses).     return context. }
true;protected,abstract;0;1;/**  * Specify {@link org.springframework.context.annotation.Configuration @Configuration}  * and/or {@link org.springframework.stereotype.Component @Component}  * classes that make up the application configuration. The config classes  * are given to {@linkplain #createApplicationContext()}.  */ ;/**  * Specify {@link org.springframework.context.annotation.Configuration @Configuration}  * and/or {@link org.springframework.stereotype.Component @Component}  * classes that make up the application configuration. The config classes  * are given to {@linkplain #createApplicationContext()}.  */ protected abstract Class<?>[] getConfigClasses().
true;protected;1;8;/**  * Refresh the given application context, if necessary.  */ ;/**  * Refresh the given application context, if necessary.  */ protected void refreshApplicationContext(ApplicationContext context) {     if (context instanceof ConfigurableApplicationContext) {         ConfigurableApplicationContext cac = (ConfigurableApplicationContext) context.         if (!cac.isActive()) {             cac.refresh().         }     } }
true;protected;2;7;/**  * Register a {@link ServletContextListener} that closes the given  * application context when the servlet context is destroyed.  * @param servletContext the servlet context to listen to  * @param applicationContext the application context that is to be  * closed when {@code servletContext} is destroyed  */ ;/**  * Register a {@link ServletContextListener} that closes the given  * application context when the servlet context is destroyed.  * @param servletContext the servlet context to listen to  * @param applicationContext the application context that is to be  * closed when {@code servletContext} is destroyed  */ protected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext) {     if (applicationContext instanceof ConfigurableApplicationContext) {         ConfigurableApplicationContext cac = (ConfigurableApplicationContext) applicationContext.         ServletContextDestroyedListener listener = new ServletContextDestroyedListener(cac).         servletContext.addListener(listener).     } }
true;protected;0;3;/**  * Return the Servlet mapping to use. Only the default Servlet mapping '/'  * and path-based Servlet mappings such as '/api/*' are supported.  * <p>By default this is set to '/'.  */ ;/**  * Return the Servlet mapping to use. Only the default Servlet mapping '/'  * and path-based Servlet mappings such as '/api/*' are supported.  * <p>By default this is set to '/'.  */ protected String getServletMapping() {     return "/". }
false;public;1;3;;@Override public void contextInitialized(ServletContextEvent sce) { }
false;public;1;4;;@Override public void contextDestroyed(ServletContextEvent sce) {     this.applicationContext.close(). }
