commented;modifiers;parameterAmount;loc;comment;code
true;private,static;0;22;/**  * Parse the {@code mime.types} file found in the resources. Format is:  * <code>  * # comments begin with a '#'<br>  * # the format is &lt.mime type> &lt.space separated file extensions><br>  * # for example:<br>  * text/plain    txt text<br>  * # this would map file.txt and file.text to<br>  * # the mime type "text/plain"<br>  * </code>  * @return a multi-value map, mapping media types to file extensions.  */ ;/**  * Parse the {@code mime.types} file found in the resources. Format is:  * <code>  * # comments begin with a '#'<br>  * # the format is &lt.mime type> &lt.space separated file extensions><br>  * # for example:<br>  * text/plain    txt text<br>  * # this would map file.txt and file.text to<br>  * # the mime type "text/plain"<br>  * </code>  * @return a multi-value map, mapping media types to file extensions.  */ private static MultiValueMap<String, MediaType> parseMimeTypes() {     try (InputStream is = MediaTypeFactory.class.getResourceAsStream(MIME_TYPES_FILE_NAME)) {         BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.US_ASCII)).         MultiValueMap<String, MediaType> result = new LinkedMultiValueMap<>().         String line.         while ((line = reader.readLine()) != null) {             if (line.isEmpty() || line.charAt(0) == '#') {                 continue.             }             String[] tokens = StringUtils.tokenizeToStringArray(line, " \t\n\r\f").             MediaType mediaType = MediaType.parseMediaType(tokens[0]).             for (int i = 1. i < tokens.length. i++) {                 String fileExtension = tokens[i].toLowerCase(Locale.ENGLISH).                 result.add(fileExtension, mediaType).             }         }         return result.     } catch (IOException ex) {         throw new IllegalStateException("Could not load '" + MIME_TYPES_FILE_NAME + "'", ex).     } }
true;public,static;1;5;/**  * Determine a media type for the given resource, if possible.  * @param resource the resource to introspect  * @return the corresponding media type, or {@code null} if none found  */ ;/**  * Determine a media type for the given resource, if possible.  * @param resource the resource to introspect  * @return the corresponding media type, or {@code null} if none found  */ public static Optional<MediaType> getMediaType(@Nullable Resource resource) {     return Optional.ofNullable(resource).map(Resource::getFilename).flatMap(MediaTypeFactory::getMediaType). }
true;public,static;1;3;/**  * Determine a media type for the given file name, if possible.  * @param filename the file name plus extension  * @return the corresponding media type, or {@code null} if none found  */ ;/**  * Determine a media type for the given file name, if possible.  * @param filename the file name plus extension  * @return the corresponding media type, or {@code null} if none found  */ public static Optional<MediaType> getMediaType(@Nullable String filename) {     return getMediaTypes(filename).stream().findFirst(). }
true;public,static;1;6;/**  * Determine the media types for the given file name, if possible.  * @param filename the file name plus extension  * @return the corresponding media types, or an empty list if none found  */ ;/**  * Determine the media types for the given file name, if possible.  * @param filename the file name plus extension  * @return the corresponding media types, or an empty list if none found  */ public static List<MediaType> getMediaTypes(@Nullable String filename) {     return Optional.ofNullable(StringUtils.getFilenameExtension(filename)).map(s -> s.toLowerCase(Locale.ENGLISH)).map(fileExtensionToMediaTypes::get).orElse(Collections.emptyList()). }
