commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;12;/**  * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}.  * @param dataBuffers the source data buffers  * @param jsonFactory the factory to use  * @param tokenizeArrayElements if {@code true} and the "top level" JSON  * object is an array, each element is returned individually, immediately  * after it is received.  * @return the result token buffers  */ ;/**  * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}.  * @param dataBuffers the source data buffers  * @param jsonFactory the factory to use  * @param tokenizeArrayElements if {@code true} and the "top level" JSON  * object is an array, each element is returned individually, immediately  * after it is received.  * @return the result token buffers  */ public static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory, boolean tokenizeArrayElements) {     try {         JsonParser parser = jsonFactory.createNonBlockingByteArrayParser().         Jackson2Tokenizer tokenizer = new Jackson2Tokenizer(parser, tokenizeArrayElements).         return dataBuffers.flatMap(tokenizer::tokenize, Flux::error, tokenizer::endOfInput).     } catch (IOException ex) {         return Flux.error(ex).     } }
false;private;1;17;;private Flux<TokenBuffer> tokenize(DataBuffer dataBuffer) {     byte[] bytes = new byte[dataBuffer.readableByteCount()].     dataBuffer.read(bytes).     DataBufferUtils.release(dataBuffer).     try {         this.inputFeeder.feedInput(bytes, 0, bytes.length).         return parseTokenBufferFlux().     } catch (JsonProcessingException ex) {         return Flux.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex)).     } catch (IOException ex) {         return Flux.error(ex).     } }
false;private;0;13;;private Flux<TokenBuffer> endOfInput() {     this.inputFeeder.endOfInput().     try {         return parseTokenBufferFlux().     } catch (JsonProcessingException ex) {         return Flux.error(new DecodingException("JSON decoding error: " + ex.getOriginalMessage(), ex)).     } catch (IOException ex) {         return Flux.error(ex).     } }
false;private;0;21;;private Flux<TokenBuffer> parseTokenBufferFlux() throws IOException {     List<TokenBuffer> result = new ArrayList<>().     while (true) {         JsonToken token = this.parser.nextToken().         // SPR-16151: Smile data format uses null to separate documents         if ((token == JsonToken.NOT_AVAILABLE) || (token == null && (token = this.parser.nextToken()) == null)) {             break.         }         updateDepth(token).         if (!this.tokenizeArrayElements) {             processTokenNormal(token, result).         } else {             processTokenArray(token, result).         }     }     return Flux.fromIterable(result). }
false;private;1;16;;private void updateDepth(JsonToken token) {     switch(token) {         case START_OBJECT:             this.objectDepth++.             break.         case END_OBJECT:             this.objectDepth--.             break.         case START_ARRAY:             this.arrayDepth++.             break.         case END_ARRAY:             this.arrayDepth--.             break.     } }
false;private;2;10;;private void processTokenNormal(JsonToken token, List<TokenBuffer> result) throws IOException {     this.tokenBuffer.copyCurrentEvent(this.parser).     if ((token.isStructEnd() || token.isScalarValue()) && this.objectDepth == 0 && this.arrayDepth == 0) {         result.add(this.tokenBuffer).         this.tokenBuffer = new TokenBuffer(this.parser).     } }
false;private;2;12;;private void processTokenArray(JsonToken token, List<TokenBuffer> result) throws IOException {     if (!isTopLevelArrayToken(token)) {         this.tokenBuffer.copyCurrentEvent(this.parser).     }     if (this.objectDepth == 0 && (this.arrayDepth == 0 || this.arrayDepth == 1) && (token == JsonToken.END_OBJECT || token.isScalarValue())) {         result.add(this.tokenBuffer).         this.tokenBuffer = new TokenBuffer(this.parser).     } }
false;private;1;4;;private boolean isTopLevelArrayToken(JsonToken token) {     return this.objectDepth == 0 && ((token == JsonToken.START_ARRAY && this.arrayDepth == 1) || (token == JsonToken.END_ARRAY && this.arrayDepth == 0)). }
