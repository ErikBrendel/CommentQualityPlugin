# id;timestamp;commentText;codeText;commentWords;codeWords
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1498861175;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof Segment)) {_				_				return false__			}_			segmentData = ((Segment)element).valueDecoded()__			pathIndex++__		}_		_		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isAllowOptionalTrailingSlash() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else { _			if (matchingContext.isMatchStartMatching && pathIndex == matchingContext.pathLength) {_				return true_ _			}_			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return this.next.matches(pathIndex, matchingContext)__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,segment,return,false,segment,data,segment,element,value,decoded,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,allow,optional,trailing,slash,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,matching,context,is,match,start,matching,path,index,matching,context,path,length,return,true,if,segment,data,null,segment,data,length,0,return,false,return,this,next,matches,path,index,matching,context
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1499445979;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof Segment)) {_				_				return false__			}_			segmentData = ((Segment)element).valueDecoded()__			pathIndex++__		}_		_		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isAllowOptionalTrailingSlash() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else { _			if (matchingContext.isMatchStartMatching && pathIndex == matchingContext.pathLength) {_				return true_ _			}_			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return (this.next != null && this.next.matches(pathIndex, matchingContext))__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,segment,return,false,segment,data,segment,element,value,decoded,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,allow,optional,trailing,slash,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,matching,context,is,match,start,matching,path,index,matching,context,path,length,return,true,if,segment,data,null,segment,data,length,0,return,false,return,this,next,null,this,next,matches,path,index,matching,context
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1499763525;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof PathContainer.PathSegment)) {_				_				return false__			}_			segmentData = ((PathContainer.PathSegment)element).valueToMatch()__			pathIndex++__		}_		_		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isAllowOptionalTrailingSlash() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else { _			if (matchingContext.isMatchStartMatching && pathIndex == matchingContext.pathLength) {_				return true_ _			}_			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return (this.next != null && this.next.matches(pathIndex, matchingContext))__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,path,container,path,segment,return,false,segment,data,path,container,path,segment,element,value,to,match,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,allow,optional,trailing,slash,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,matching,context,is,match,start,matching,path,index,matching,context,path,length,return,true,if,segment,data,null,segment,data,length,0,return,false,return,this,next,null,this,next,matches,path,index,matching,context
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1501237594;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof PathContainer.PathSegment)) {_				_				return false__			}_			segmentData = ((PathContainer.PathSegment)element).valueToMatch()__			pathIndex++__		}_		_		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isAllowOptionalTrailingSlash() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else { _			if (matchingContext.isMatchStartMatching && pathIndex == matchingContext.pathLength) {_				return true_ _			}_			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return (this.next != null && this.next.matches(pathIndex, matchingContext))__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,path,container,path,segment,return,false,segment,data,path,container,path,segment,element,value,to,match,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,allow,optional,trailing,slash,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,matching,context,is,match,start,matching,path,index,matching,context,path,length,return,true,if,segment,data,null,segment,data,length,0,return,false,return,this,next,null,this,next,matches,path,index,matching,context
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1501676476;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof PathContainer.PathSegment)) {_				_				return false__			}_			segmentData = ((PathContainer.PathSegment)element).valueToMatch()__			pathIndex++__		}_		_		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isMatchOptionalTrailingSeparator() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else { _			if (matchingContext.isMatchStartMatching && pathIndex == matchingContext.pathLength) {_				return true_ _			}_			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return (this.next != null && this.next.matches(pathIndex, matchingContext))__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,path,container,path,segment,return,false,segment,data,path,container,path,segment,element,value,to,match,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,match,optional,trailing,separator,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,matching,context,is,match,start,matching,path,index,matching,context,path,length,return,true,if,segment,data,null,segment,data,length,0,return,false,return,this,next,null,this,next,matches,path,index,matching,context
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1504818226;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof PathContainer.PathSegment)) {_				_				return false__			}_			segmentData = ((PathContainer.PathSegment)element).valueToMatch()__			pathIndex++__		}_		_		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isMatchOptionalTrailingSeparator() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else { _			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return (this.next != null && this.next.matches(pathIndex, matchingContext))__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,path,container,path,segment,return,false,segment,data,path,container,path,segment,element,value,to,match,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,match,optional,trailing,separator,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,segment,data,null,segment,data,length,0,return,false,return,this,next,null,this,next,matches,path,index,matching,context
WildcardPathElement -> @Override 	public boolean matches(int pathIndex, MatchingContext matchingContext);1530174524;Matching on a WildcardPathElement is quite straight forward. Scan the_candidate from the candidateIndex onwards for the next separator or the end of the_candidate.;@Override_	public boolean matches(int pathIndex, MatchingContext matchingContext) {_		String segmentData = null__		_		if (pathIndex < matchingContext.pathLength) {_			Element element = matchingContext.pathElements.get(pathIndex)__			if (!(element instanceof PathContainer.PathSegment)) {_				_				return false__			}_			segmentData = ((PathContainer.PathSegment)element).valueToMatch()__			pathIndex++__		}__		if (isNoMorePattern()) {_			if (matchingContext.determineRemainingPath) {_				matchingContext.remainingPathIndex = pathIndex__				return true__			}_			else {_				if (pathIndex == matchingContext.pathLength) {_					_					return true__				}_				else {_					return (matchingContext.isMatchOptionalTrailingSeparator() &&  _							segmentData != null && segmentData.length() > 0 &&  _							(pathIndex + 1) == matchingContext.pathLength &&   _							matchingContext.isSeparator(pathIndex))_  _				}_			}_		}_		else {_			_			if (segmentData == null || segmentData.length() == 0) {_				return false__			}_			return (this.next != null && this.next.matches(pathIndex, matchingContext))__		}_	};matching,on,a,wildcard,path,element,is,quite,straight,forward,scan,the,candidate,from,the,candidate,index,onwards,for,the,next,separator,or,the,end,of,the,candidate;override,public,boolean,matches,int,path,index,matching,context,matching,context,string,segment,data,null,if,path,index,matching,context,path,length,element,element,matching,context,path,elements,get,path,index,if,element,instanceof,path,container,path,segment,return,false,segment,data,path,container,path,segment,element,value,to,match,path,index,if,is,no,more,pattern,if,matching,context,determine,remaining,path,matching,context,remaining,path,index,path,index,return,true,else,if,path,index,matching,context,path,length,return,true,else,return,matching,context,is,match,optional,trailing,separator,segment,data,null,segment,data,length,0,path,index,1,matching,context,path,length,matching,context,is,separator,path,index,else,if,segment,data,null,segment,data,length,0,return,false,return,this,next,null,this,next,matches,path,index,matching,context
