commented;modifiers;parameterAmount;loc;comment;code
true;public;2;40;/**  * Matching on a WildcardPathElement is quite straight forward. Scan the  * candidate from the candidateIndex onwards for the next separator or the end of the  * candidate.  */ ;/**  * Matching on a WildcardPathElement is quite straight forward. Scan the  * candidate from the candidateIndex onwards for the next separator or the end of the  * candidate.  */ @Override public boolean matches(int pathIndex, MatchingContext matchingContext) {     String segmentData = null.     // Assert if it exists it is a segment     if (pathIndex < matchingContext.pathLength) {         Element element = matchingContext.pathElements.get(pathIndex).         if (!(element instanceof PathContainer.PathSegment)) {             // Should not match a separator             return false.         }         segmentData = ((PathContainer.PathSegment) element).valueToMatch().         pathIndex++.     }     if (isNoMorePattern()) {         if (matchingContext.determineRemainingPath) {             matchingContext.remainingPathIndex = pathIndex.             return true.         } else {             if (pathIndex == matchingContext.pathLength) {                 // and the path data has run out too                 return true.             } else {                 return (// if optional slash is on...                 matchingContext.isMatchOptionalTrailingSeparator() && segmentData != null && // and there is at least one character to match the *...                 segmentData.length() > 0 && // and the next path element is the end of the candidate...                 (pathIndex + 1) == matchingContext.pathLength && // and the final element is a separator                 matchingContext.isSeparator(pathIndex)).             }         }     } else {         // Within a path (e.g. /aa/*/bb) there must be at least one character to match the wildcard         if (segmentData == null || segmentData.length() == 0) {             return false.         }         return (this.next != null && this.next.matches(pathIndex, matchingContext)).     } }
false;public;0;4;;@Override public int getNormalizedLength() {     return 1. }
false;public;0;4;;@Override public int getWildcardCount() {     return 1. }
false;public;0;4;;@Override public int getScore() {     return WILDCARD_WEIGHT. }
false;public;0;3;;public String toString() {     return "Wildcard(*)". }
false;public;0;4;;@Override public char[] getChars() {     return new char[] { '*' }. }
