commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the Hessian SerializerFactory to use.  * <p>This will typically be passed in as an inner bean definition  * of type {@code com.caucho.hessian.io.SerializerFactory},  * with custom bean property values applied.  */ ;/**  * Specify the Hessian SerializerFactory to use.  * <p>This will typically be passed in as an inner bean definition  * of type {@code com.caucho.hessian.io.SerializerFactory},  * with custom bean property values applied.  */ public void setSerializerFactory(@Nullable SerializerFactory serializerFactory) {     this.serializerFactory = (serializerFactory != null ? serializerFactory : new SerializerFactory()). }
true;public;1;3;/**  * Set whether to send the Java collection type for each serialized  * collection. Default is "true".  */ ;/**  * Set whether to send the Java collection type for each serialized  * collection. Default is "true".  */ public void setSendCollectionType(boolean sendCollectionType) {     this.serializerFactory.setSendCollectionType(sendCollectionType). }
true;public;1;3;/**  * Set whether to allow non-serializable types as Hessian arguments  * and return values. Default is "true".  */ ;/**  * Set whether to allow non-serializable types as Hessian arguments  * and return values. Default is "true".  */ public void setAllowNonSerializable(boolean allowNonSerializable) {     this.serializerFactory.setAllowNonSerializable(allowNonSerializable). }
true;public;1;3;/**  * Specify a custom HessianRemoteResolver to use for resolving remote  * object references.  */ ;/**  * Specify a custom HessianRemoteResolver to use for resolving remote  * object references.  */ public void setRemoteResolver(HessianRemoteResolver remoteResolver) {     this.remoteResolver = remoteResolver. }
true;public;1;3;/**  * Set whether Hessian's debug mode should be enabled, logging to  * this exporter's Commons Logging log. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setDebug  */ ;/**  * Set whether Hessian's debug mode should be enabled, logging to  * this exporter's Commons Logging log. Default is "false".  * @see com.caucho.hessian.client.HessianProxyFactory#setDebug  */ public void setDebug(boolean debug) {     this.debugLogger = (debug ? logger : null). }
false;public;0;4;;@Override public void afterPropertiesSet() {     prepare(). }
true;public;0;5;/**  * Initialize this exporter.  */ ;/**  * Initialize this exporter.  */ public void prepare() {     checkService().     checkServiceInterface().     this.skeleton = new HessianSkeleton(getProxyForService(), getServiceInterface()). }
true;public;2;4;/**  * Perform an invocation on the exported object.  * @param inputStream the request stream  * @param outputStream the response stream  * @throws Throwable if invocation failed  */ ;/**  * Perform an invocation on the exported object.  * @param inputStream the request stream  * @param outputStream the response stream  * @throws Throwable if invocation failed  */ public void invoke(InputStream inputStream, OutputStream outputStream) throws Throwable {     Assert.notNull(this.skeleton, "Hessian exporter has not been initialized").     doInvoke(this.skeleton, inputStream, outputStream). }
true;protected;3;97;/**  * Actually invoke the skeleton with the given streams.  * @param skeleton the skeleton to invoke  * @param inputStream the request stream  * @param outputStream the response stream  * @throws Throwable if invocation failed  */ ;/**  * Actually invoke the skeleton with the given streams.  * @param skeleton the skeleton to invoke  * @param inputStream the request stream  * @param outputStream the response stream  * @throws Throwable if invocation failed  */ protected void doInvoke(HessianSkeleton skeleton, InputStream inputStream, OutputStream outputStream) throws Throwable {     ClassLoader originalClassLoader = overrideThreadContextClassLoader().     try {         InputStream isToUse = inputStream.         OutputStream osToUse = outputStream.         if (this.debugLogger != null && this.debugLogger.isDebugEnabled()) {             try (PrintWriter debugWriter = new PrintWriter(new CommonsLogWriter(this.debugLogger))) {                 @SuppressWarnings("resource")                 HessianDebugInputStream dis = new HessianDebugInputStream(inputStream, debugWriter).                 @SuppressWarnings("resource")                 HessianDebugOutputStream dos = new HessianDebugOutputStream(outputStream, debugWriter).                 dis.startTop2().                 dos.startTop2().                 isToUse = dis.                 osToUse = dos.             }         }         if (!isToUse.markSupported()) {             isToUse = new BufferedInputStream(isToUse).             isToUse.mark(1).         }         int code = isToUse.read().         int major.         int minor.         AbstractHessianInput in.         AbstractHessianOutput out.         if (code == 'H') {             // Hessian 2.0 stream             major = isToUse.read().             minor = isToUse.read().             if (major != 0x02) {                 throw new IOException("Version " + major + '.' + minor + " is not understood").             }             in = new Hessian2Input(isToUse).             out = new Hessian2Output(osToUse).             in.readCall().         } else if (code == 'C') {             // Hessian 2.0 call... for some reason not handled in HessianServlet!             isToUse.reset().             in = new Hessian2Input(isToUse).             out = new Hessian2Output(osToUse).             in.readCall().         } else if (code == 'c') {             // Hessian 1.0 call             major = isToUse.read().             minor = isToUse.read().             in = new HessianInput(isToUse).             if (major >= 2) {                 out = new Hessian2Output(osToUse).             } else {                 out = new HessianOutput(osToUse).             }         } else {             throw new IOException("Expected 'H'/'C' (Hessian 2.0) or 'c' (Hessian 1.0) in hessian input at " + code).         }         in.setSerializerFactory(this.serializerFactory).         out.setSerializerFactory(this.serializerFactory).         if (this.remoteResolver != null) {             in.setRemoteResolver(this.remoteResolver).         }         try {             skeleton.invoke(in, out).         } finally {             try {                 in.close().                 isToUse.close().             } catch (IOException ex) {             // ignore             }             try {                 out.close().                 osToUse.close().             } catch (IOException ex) {             // ignore             }         }     } finally {         resetThreadContextClassLoader(originalClassLoader).     } }
