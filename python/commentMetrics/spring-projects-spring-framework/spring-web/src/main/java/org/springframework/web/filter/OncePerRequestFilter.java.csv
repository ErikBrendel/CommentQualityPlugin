commented;modifiers;parameterAmount;loc;comment;code
true;public,final;3;30;/**  * This {@code doFilter} implementation stores a request attribute for  * "already filtered", proceeding without filtering again if the  * attribute is already there.  * @see #getAlreadyFilteredAttributeName  * @see #shouldNotFilter  * @see #doFilterInternal  */ ;/**  * This {@code doFilter} implementation stores a request attribute for  * "already filtered", proceeding without filtering again if the  * attribute is already there.  * @see #getAlreadyFilteredAttributeName  * @see #shouldNotFilter  * @see #doFilterInternal  */ @Override public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {     if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)) {         throw new ServletException("OncePerRequestFilter just supports HTTP requests").     }     HttpServletRequest httpRequest = (HttpServletRequest) request.     HttpServletResponse httpResponse = (HttpServletResponse) response.     String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName().     boolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null.     if (hasAlreadyFilteredAttribute || skipDispatch(httpRequest) || shouldNotFilter(httpRequest)) {         // Proceed without invoking this filter...         filterChain.doFilter(request, response).     } else {         // Do invoke this filter...         request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE).         try {             doFilterInternal(httpRequest, httpResponse, filterChain).         } finally {             // Remove the "already filtered" request attribute for this request.             request.removeAttribute(alreadyFilteredAttributeName).         }     } }
false;private;1;9;;private boolean skipDispatch(HttpServletRequest request) {     if (isAsyncDispatch(request) && shouldNotFilterAsyncDispatch()) {         return true.     }     if (request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE) != null && shouldNotFilterErrorDispatch()) {         return true.     }     return false. }
true;protected;1;3;/**  * The dispatcher type {@code javax.servlet.DispatcherType.ASYNC} introduced  * in Servlet 3.0 means a filter can be invoked in more than one thread over  * the course of a single request. This method returns {@code true} if the  * filter is currently executing within an asynchronous dispatch.  * @param request the current request  * @since 3.2  * @see WebAsyncManager#hasConcurrentResult()  */ ;/**  * The dispatcher type {@code javax.servlet.DispatcherType.ASYNC} introduced  * in Servlet 3.0 means a filter can be invoked in more than one thread over  * the course of a single request. This method returns {@code true} if the  * filter is currently executing within an asynchronous dispatch.  * @param request the current request  * @since 3.2  * @see WebAsyncManager#hasConcurrentResult()  */ protected boolean isAsyncDispatch(HttpServletRequest request) {     return WebAsyncUtils.getAsyncManager(request).hasConcurrentResult(). }
true;protected;1;3;/**  * Whether request processing is in asynchronous mode meaning that the  * response will not be committed after the current thread is exited.  * @param request the current request  * @since 3.2  * @see WebAsyncManager#isConcurrentHandlingStarted()  */ ;/**  * Whether request processing is in asynchronous mode meaning that the  * response will not be committed after the current thread is exited.  * @param request the current request  * @since 3.2  * @see WebAsyncManager#isConcurrentHandlingStarted()  */ protected boolean isAsyncStarted(HttpServletRequest request) {     return WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted(). }
true;protected;0;7;/**  * Return the name of the request attribute that identifies that a request  * is already filtered.  * <p>The default implementation takes the configured name of the concrete filter  * instance and appends ".FILTERED". If the filter is not fully initialized,  * it falls back to its class name.  * @see #getFilterName  * @see #ALREADY_FILTERED_SUFFIX  */ ;/**  * Return the name of the request attribute that identifies that a request  * is already filtered.  * <p>The default implementation takes the configured name of the concrete filter  * instance and appends ".FILTERED". If the filter is not fully initialized,  * it falls back to its class name.  * @see #getFilterName  * @see #ALREADY_FILTERED_SUFFIX  */ protected String getAlreadyFilteredAttributeName() {     String name = getFilterName().     if (name == null) {         name = getClass().getName().     }     return name + ALREADY_FILTERED_SUFFIX. }
true;protected;1;3;/**  * Can be overridden in subclasses for custom filtering control,  * returning {@code true} to avoid filtering of the given request.  * <p>The default implementation always returns {@code false}.  * @param request current HTTP request  * @return whether the given request should <i>not</i> be filtered  * @throws ServletException in case of errors  */ ;/**  * Can be overridden in subclasses for custom filtering control,  * returning {@code true} to avoid filtering of the given request.  * <p>The default implementation always returns {@code false}.  * @param request current HTTP request  * @return whether the given request should <i>not</i> be filtered  * @throws ServletException in case of errors  */ protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {     return false. }
true;protected;0;3;/**  * The dispatcher type {@code javax.servlet.DispatcherType.ASYNC} introduced  * in Servlet 3.0 means a filter can be invoked in more than one thread  * over the course of a single request. Some filters only need to filter  * the initial thread (e.g. request wrapping) while others may need  * to be invoked at least once in each additional thread for example for  * setting up thread locals or to perform final processing at the very end.  * <p>Note that although a filter can be mapped to handle specific dispatcher  * types via {@code web.xml} or in Java through the {@code ServletContext},  * servlet containers may enforce different defaults with regards to  * dispatcher types. This flag enforces the design intent of the filter.  * <p>The default return value is "true", which means the filter will not be  * invoked during subsequent async dispatches. If "false", the filter will  * be invoked during async dispatches with the same guarantees of being  * invoked only once during a request within a single thread.  * @since 3.2  */ ;/**  * The dispatcher type {@code javax.servlet.DispatcherType.ASYNC} introduced  * in Servlet 3.0 means a filter can be invoked in more than one thread  * over the course of a single request. Some filters only need to filter  * the initial thread (e.g. request wrapping) while others may need  * to be invoked at least once in each additional thread for example for  * setting up thread locals or to perform final processing at the very end.  * <p>Note that although a filter can be mapped to handle specific dispatcher  * types via {@code web.xml} or in Java through the {@code ServletContext},  * servlet containers may enforce different defaults with regards to  * dispatcher types. This flag enforces the design intent of the filter.  * <p>The default return value is "true", which means the filter will not be  * invoked during subsequent async dispatches. If "false", the filter will  * be invoked during async dispatches with the same guarantees of being  * invoked only once during a request within a single thread.  * @since 3.2  */ protected boolean shouldNotFilterAsyncDispatch() {     return true. }
true;protected;0;3;/**  * Whether to filter error dispatches such as when the servlet container  * processes and error mapped in {@code web.xml}. The default return value  * is "true", which means the filter will not be invoked in case of an error  * dispatch.  * @since 3.2  */ ;/**  * Whether to filter error dispatches such as when the servlet container  * processes and error mapped in {@code web.xml}. The default return value  * is "true", which means the filter will not be invoked in case of an error  * dispatch.  * @since 3.2  */ protected boolean shouldNotFilterErrorDispatch() {     return true. }
true;protected,abstract;3;3;/**  * Same contract as for {@code doFilter}, but guaranteed to be  * just invoked once per request within a single request thread.  * See {@link #shouldNotFilterAsyncDispatch()} for details.  * <p>Provides HttpServletRequest and HttpServletResponse arguments instead of the  * default ServletRequest and ServletResponse ones.  */ ;/**  * Same contract as for {@code doFilter}, but guaranteed to be  * just invoked once per request within a single request thread.  * See {@link #shouldNotFilterAsyncDispatch()} for details.  * <p>Provides HttpServletRequest and HttpServletResponse arguments instead of the  * default ServletRequest and ServletResponse ones.  */ protected abstract void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException.
