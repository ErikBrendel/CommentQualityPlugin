commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setMaxMessageSize(int maxMessageSize) {     this.maxMessageSize = maxMessageSize. }
false;public;2;4;;@Override public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {     return Message.class.isAssignableFrom(elementType.toClass()) && supportsMimeType(mimeType). }
false;public;4;7;;@Override public Flux<Message> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     return Flux.from(inputStream).flatMapIterable(new MessageDecoderFunction(elementType, this.maxMessageSize)). }
false;public;4;23;;@Override public Mono<Message> decodeToMono(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     return DataBufferUtils.join(inputStream).map(dataBuffer -> {         try {             Message.Builder builder = getMessageBuilder(elementType.toClass()).             ByteBuffer buffer = dataBuffer.asByteBuffer().             builder.mergeFrom(CodedInputStream.newInstance(buffer), this.extensionRegistry).             return builder.build().         } catch (IOException ex) {             throw new DecodingException("I/O error while parsing input stream", ex).         } catch (Exception ex) {             throw new DecodingException("Could not read Protobuf message: " + ex.getMessage(), ex).         } finally {             DataBufferUtils.release(dataBuffer).         }     }). }
true;private,static;1;8;/**  * Create a new {@code Message.Builder} instance for the given class.  * <p>This method uses a ConcurrentHashMap for caching method lookups.  */ ;/**  * Create a new {@code Message.Builder} instance for the given class.  * <p>This method uses a ConcurrentHashMap for caching method lookups.  */ private static Message.Builder getMessageBuilder(Class<?> clazz) throws Exception {     Method method = methodCache.get(clazz).     if (method == null) {         method = clazz.getMethod("newBuilder").         methodCache.put(clazz, method).     }     return (Message.Builder) method.invoke(clazz). }
false;public;0;4;;@Override public List<MimeType> getDecodableMimeTypes() {     return getMimeTypes(). }
false;public;1;54;;@Override public Iterable<? extends Message> apply(DataBuffer input) {     try {         List<Message> messages = new ArrayList<>().         int remainingBytesToRead.         int chunkBytesToRead.         do {             if (this.output == null) {                 if (!readMessageSize(input)) {                     return messages.                 }                 if (this.messageBytesToRead > this.maxMessageSize) {                     throw new DecodingException("The number of bytes to read from the incoming stream " + "(" + this.messageBytesToRead + ") exceeds " + "the configured limit (" + this.maxMessageSize + ")").                 }                 this.output = input.factory().allocateBuffer(this.messageBytesToRead).             }             chunkBytesToRead = this.messageBytesToRead >= input.readableByteCount() ? input.readableByteCount() : this.messageBytesToRead.             remainingBytesToRead = input.readableByteCount() - chunkBytesToRead.             byte[] bytesToWrite = new byte[chunkBytesToRead].             input.read(bytesToWrite, 0, chunkBytesToRead).             this.output.write(bytesToWrite).             this.messageBytesToRead -= chunkBytesToRead.             if (this.messageBytesToRead == 0) {                 Message.Builder builder = getMessageBuilder(this.elementType.toClass()).                 ByteBuffer buffer = this.output.asByteBuffer().                 builder.mergeFrom(CodedInputStream.newInstance(buffer), extensionRegistry).                 messages.add(builder.build()).                 DataBufferUtils.release(this.output).                 this.output = null.             }         } while (remainingBytesToRead > 0).         return messages.     } catch (DecodingException ex) {         throw ex.     } catch (IOException ex) {         throw new DecodingException("I/O error while parsing input stream", ex).     } catch (Exception ex) {         throw new DecodingException("Could not read Protobuf message: " + ex.getMessage(), ex).     } finally {         DataBufferUtils.release(input).     } }
true;private;1;41;/**  * Parse message size as a varint from the input stream, updating {@code messageBytesToRead} and  * {@code offset} fields if needed to allow processing of upcoming chunks.  * Inspired from {@link CodedInputStream#readRawVarint32(int, java.io.InputStream)}  *  * @return {code true} when the message size is parsed successfully, {code false} when the message size is  * truncated  * @see <a href ="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a>  */ ;/**  * Parse message size as a varint from the input stream, updating {@code messageBytesToRead} and  * {@code offset} fields if needed to allow processing of upcoming chunks.  * Inspired from {@link CodedInputStream#readRawVarint32(int, java.io.InputStream)}  *  * @return {code true} when the message size is parsed successfully, {code false} when the message size is  * truncated  * @see <a href ="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a>  */ private boolean readMessageSize(DataBuffer input) {     if (this.offset == 0) {         if (input.readableByteCount() == 0) {             return false.         }         int firstByte = input.read().         if ((firstByte & 0x80) == 0) {             this.messageBytesToRead = firstByte.             return true.         }         this.messageBytesToRead = firstByte & 0x7f.         this.offset = 7.     }     if (this.offset < 32) {         for (. this.offset < 32. this.offset += 7) {             if (input.readableByteCount() == 0) {                 return false.             }             final int b = input.read().             this.messageBytesToRead |= (b & 0x7f) << offset.             if ((b & 0x80) == 0) {                 this.offset = 0.                 return true.             }         }     }     // Keep reading up to 64 bits.     for (. this.offset < 64. this.offset += 7) {         if (input.readableByteCount() == 0) {             return false.         }         final int b = input.read().         if ((b & 0x80) == 0) {             this.offset = 0.             return true.         }     }     this.offset = 0.     throw new DecodingException("Cannot parse message size: malformed varint"). }
