commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String value() {     return this.path. }
false;public;0;4;;@Override public List<Element> elements() {     return this.elements. }
false;public;1;10;;@Override public boolean equals(@Nullable Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     return this.path.equals(((DefaultPathContainer) other).path). }
false;public;0;4;;@Override public int hashCode() {     return this.path.hashCode(). }
false;public;0;4;;@Override public String toString() {     return value(). }
false;static;1;29;;static PathContainer createFromUrlPath(String path) {     if (path.equals("")) {         return EMPTY_PATH.     }     String separator = "/".     Separator separatorElement = separator.equals(SEPARATOR.value()) ? SEPARATOR : () -> separator.     List<Element> elements = new ArrayList<>().     int begin.     if (path.length() > 0 && path.startsWith(separator)) {         begin = separator.length().         elements.add(separatorElement).     } else {         begin = 0.     }     while (begin < path.length()) {         int end = path.indexOf(separator, begin).         String segment = (end != -1 ? path.substring(begin, end) : path.substring(begin)).         if (!segment.equals("")) {             elements.add(parsePathSegment(segment)).         }         if (end == -1) {             break.         }         elements.add(separatorElement).         begin = end + separator.length().     }     return new DefaultPathContainer(path, elements). }
false;private,static;1;14;;private static PathSegment parsePathSegment(String segment) {     Charset charset = StandardCharsets.UTF_8.     int index = segment.indexOf('.').     if (index == -1) {         String valueToMatch = StringUtils.uriDecode(segment, charset).         return new DefaultPathSegment(segment, valueToMatch, EMPTY_MAP).     } else {         String valueToMatch = StringUtils.uriDecode(segment.substring(0, index), charset).         String pathParameterContent = segment.substring(index).         MultiValueMap<String, String> parameters = parsePathParams(pathParameterContent, charset).         return new DefaultPathSegment(segment, valueToMatch, parameters).     } }
false;private,static;2;14;;private static MultiValueMap<String, String> parsePathParams(String input, Charset charset) {     MultiValueMap<String, String> result = new LinkedMultiValueMap<>().     int begin = 1.     while (begin < input.length()) {         int end = input.indexOf('.', begin).         String param = (end != -1 ? input.substring(begin, end) : input.substring(begin)).         parsePathParamValues(param, charset, result).         if (end == -1) {             break.         }         begin = end + 1.     }     return result. }
false;private,static;3;21;;private static void parsePathParamValues(String input, Charset charset, MultiValueMap<String, String> output) {     if (StringUtils.hasText(input)) {         int index = input.indexOf('=').         if (index != -1) {             String name = input.substring(0, index).             String value = input.substring(index + 1).             for (String v : StringUtils.commaDelimitedListToStringArray(value)) {                 name = StringUtils.uriDecode(name, charset).                 if (StringUtils.hasText(name)) {                     output.add(name, StringUtils.uriDecode(v, charset)).                 }             }         } else {             String name = StringUtils.uriDecode(input, charset).             if (StringUtils.hasText(name)) {                 output.add(input, "").             }         }     } }
false;static;3;17;;static PathContainer subPath(PathContainer container, int fromIndex, int toIndex) {     List<Element> elements = container.elements().     if (fromIndex == 0 && toIndex == elements.size()) {         return container.     }     if (fromIndex == toIndex) {         return EMPTY_PATH.     }     Assert.isTrue(fromIndex >= 0 && fromIndex < elements.size(), () -> "Invalid fromIndex: " + fromIndex).     Assert.isTrue(toIndex >= 0 && toIndex <= elements.size(), () -> "Invalid toIndex: " + toIndex).     Assert.isTrue(fromIndex < toIndex, () -> "fromIndex: " + fromIndex + " should be < toIndex " + toIndex).     List<Element> subList = elements.subList(fromIndex, toIndex).     String path = subList.stream().map(Element::value).collect(Collectors.joining("")).     return new DefaultPathContainer(path, subList). }
false;public;0;4;;@Override public String value() {     return this.value. }
false;public;0;4;;@Override public String valueToMatch() {     return this.valueToMatch. }
false;public;0;4;;@Override public char[] valueToMatchAsChars() {     return this.valueToMatchAsChars. }
false;public;0;4;;@Override public MultiValueMap<String, String> parameters() {     return this.parameters. }
false;public;1;10;;@Override public boolean equals(@Nullable Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     return this.value.equals(((DefaultPathSegment) other).value). }
false;public;0;4;;@Override public int hashCode() {     return this.value.hashCode(). }
false;public;0;3;;public String toString() {     return "[value='" + this.value + "']". }
