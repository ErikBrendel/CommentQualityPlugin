commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;4;;@Override public final DataBufferFactory bufferFactory() {     return this.dataBufferFactory. }
false;public;1;10;;@Override public boolean setStatusCode(@Nullable HttpStatus status) {     if (this.state.get() == State.COMMITTED) {         return false.     } else {         this.statusCode = (status != null ? status.value() : null).         return true.     } }
false;public;0;5;;@Override @Nullable public HttpStatus getStatusCode() {     return this.statusCode != null ? HttpStatus.resolve(this.statusCode) : null. }
true;public;1;3;/**  * Set the HTTP status code of the response.  * @param statusCode the HTTP status as an integer value  * @since 5.0.1  */ ;/**  * Set the HTTP status code of the response.  * @param statusCode the HTTP status as an integer value  * @since 5.0.1  */ public void setStatusCodeValue(@Nullable Integer statusCode) {     this.statusCode = statusCode. }
true;public;0;4;/**  * Return the HTTP status code of the response.  * @return the HTTP status as an integer value  * @since 5.0.1  */ ;/**  * Return the HTTP status code of the response.  * @return the HTTP status as an integer value  * @since 5.0.1  */ @Nullable public Integer getStatusCodeValue() {     return this.statusCode. }
false;public;0;5;;@Override public HttpHeaders getHeaders() {     return (this.state.get() == State.COMMITTED ? HttpHeaders.readOnlyHttpHeaders(this.headers) : this.headers). }
false;public;0;5;;@Override public MultiValueMap<String, ResponseCookie> getCookies() {     return (this.state.get() == State.COMMITTED ? CollectionUtils.unmodifiableMultiValueMap(this.cookies) : this.cookies). }
false;public;1;12;;@Override public void addCookie(ResponseCookie cookie) {     Assert.notNull(cookie, "ResponseCookie must not be null").     if (this.state.get() == State.COMMITTED) {         throw new IllegalStateException("Can't add the cookie " + cookie + "because the HTTP response has already been committed").     } else {         getCookies().add(cookie.getName(), cookie).     } }
true;public,abstract;0;1;/**  * Return the underlying server response.  * <p><strong>Note:</strong> This is exposed mainly for internal framework  * use such as WebSocket upgrades in the spring-webflux module.  */ ;/**  * Return the underlying server response.  * <p><strong>Note:</strong> This is exposed mainly for internal framework  * use such as WebSocket upgrades in the spring-webflux module.  */ public abstract <T> T getNativeResponse().
false;public;1;4;;@Override public void beforeCommit(Supplier<? extends Mono<Void>> action) {     this.commitActions.add(action). }
false;public;0;4;;@Override public boolean isCommitted() {     return this.state.get() != State.NEW. }
false;public,final;1;6;;@Override public final Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {     return new ChannelSendOperator<>(body, writePublisher -> doCommit(() -> writeWithInternal(writePublisher))).doOnError(t -> removeContentLength()). }
false;public,final;1;6;;@Override public final Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {     return new ChannelSendOperator<>(body, writePublisher -> doCommit(() -> writeAndFlushWithInternal(writePublisher))).doOnError(t -> removeContentLength()). }
false;private;0;5;;private void removeContentLength() {     if (!this.isCommitted()) {         this.getHeaders().remove(HttpHeaders.CONTENT_LENGTH).     } }
false;public;0;4;;@Override public Mono<Void> setComplete() {     return !isCommitted() ? doCommit(null) : Mono.empty(). }
true;protected;0;3;/**  * A variant of {@link #doCommit(Supplier)} for a response without no body.  * @return a completion publisher  */ ;/**  * A variant of {@link #doCommit(Supplier)} for a response without no body.  * @return a completion publisher  */ protected Mono<Void> doCommit() {     return doCommit(null). }
true;protected;1;20;/**  * Apply {@link #beforeCommit(Supplier) beforeCommit} actions, apply the  * response status and headers/cookies, and write the response body.  * @param writeAction the action to write the response body (may be {@code null})  * @return a completion publisher  */ ;/**  * Apply {@link #beforeCommit(Supplier) beforeCommit} actions, apply the  * response status and headers/cookies, and write the response body.  * @param writeAction the action to write the response body (may be {@code null})  * @return a completion publisher  */ protected Mono<Void> doCommit(@Nullable Supplier<? extends Mono<Void>> writeAction) {     if (!this.state.compareAndSet(State.NEW, State.COMMITTING)) {         return Mono.empty().     }     this.commitActions.add(() -> Mono.fromRunnable(() -> {         applyStatusCode().         applyHeaders().         applyCookies().         this.state.set(State.COMMITTED).     })).     if (writeAction != null) {         this.commitActions.add(writeAction).     }     Flux<Void> commit = Flux.empty().     for (Supplier<? extends Mono<Void>> action : this.commitActions) {         commit = commit.concatWith(action.get()).     }     return commit.then(). }
true;protected,abstract;1;1;/**  * Write to the underlying the response.  * @param body the publisher to write with  */ ;/**  * Write to the underlying the response.  * @param body the publisher to write with  */ protected abstract Mono<Void> writeWithInternal(Publisher<? extends DataBuffer> body).
true;protected,abstract;1;1;/**  * Write to the underlying the response, and flush after each {@code Publisher<DataBuffer>}.  * @param body the publisher to write and flush with  */ ;/**  * Write to the underlying the response, and flush after each {@code Publisher<DataBuffer>}.  * @param body the publisher to write and flush with  */ protected abstract Mono<Void> writeAndFlushWithInternal(Publisher<? extends Publisher<? extends DataBuffer>> body).
true;protected,abstract;0;1;/**  * Write the status code to the underlying response.  * This method is called once only.  */ ;/**  * Write the status code to the underlying response.  * This method is called once only.  */ protected abstract void applyStatusCode().
true;protected,abstract;0;1;/**  * Apply header changes from {@link #getHeaders()} to the underlying response.  * This method is called once only.  */ ;/**  * Apply header changes from {@link #getHeaders()} to the underlying response.  * This method is called once only.  */ protected abstract void applyHeaders().
true;protected,abstract;0;1;/**  * Add cookies from {@link #getHeaders()} to the underlying response.  * This method is called once only.  */ ;/**  * Add cookies from {@link #getHeaders()} to the underlying response.  * This method is called once only.  */ protected abstract void applyCookies().
