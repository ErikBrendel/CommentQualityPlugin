commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Specify which {@link ApplicationContextInitializer} instances should be used  * to initialize the application context used by this {@code ContextLoader}.  * @since 4.2  * @see #configureAndRefreshWebApplicationContext  * @see #customizeContext  */ ;/**  * Specify which {@link ApplicationContextInitializer} instances should be used  * to initialize the application context used by this {@code ContextLoader}.  * @since 4.2  * @see #configureAndRefreshWebApplicationContext  * @see #customizeContext  */ @SuppressWarnings("unchecked") public void setContextInitializers(@Nullable ApplicationContextInitializer<?>... initializers) {     if (initializers != null) {         for (ApplicationContextInitializer<?> initializer : initializers) {             this.contextInitializers.add((ApplicationContextInitializer<ConfigurableApplicationContext>) initializer).         }     } }
true;public;1;57;/**  * Initialize Spring's web application context for the given servlet context,  * using the application context provided at construction time, or creating a new one  * according to the "{@link #CONTEXT_CLASS_PARAM contextClass}" and  * "{@link #CONFIG_LOCATION_PARAM contextConfigLocation}" context-params.  * @param servletContext current servlet context  * @return the new WebApplicationContext  * @see #ContextLoader(WebApplicationContext)  * @see #CONTEXT_CLASS_PARAM  * @see #CONFIG_LOCATION_PARAM  */ ;/**  * Initialize Spring's web application context for the given servlet context,  * using the application context provided at construction time, or creating a new one  * according to the "{@link #CONTEXT_CLASS_PARAM contextClass}" and  * "{@link #CONFIG_LOCATION_PARAM contextConfigLocation}" context-params.  * @param servletContext current servlet context  * @return the new WebApplicationContext  * @see #ContextLoader(WebApplicationContext)  * @see #CONTEXT_CLASS_PARAM  * @see #CONFIG_LOCATION_PARAM  */ public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {     if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {         throw new IllegalStateException("Cannot initialize context because there is already a root application context present - " + "check whether you have multiple ContextLoader* definitions in your web.xml!").     }     servletContext.log("Initializing Spring root WebApplicationContext").     Log logger = LogFactory.getLog(ContextLoader.class).     if (logger.isInfoEnabled()) {         logger.info("Root WebApplicationContext: initialization started").     }     long startTime = System.currentTimeMillis().     try {         // it is available on ServletContext shutdown.         if (this.context == null) {             this.context = createWebApplicationContext(servletContext).         }         if (this.context instanceof ConfigurableWebApplicationContext) {             ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context.             if (!cwac.isActive()) {                 // setting the parent context, setting the application context id, etc                 if (cwac.getParent() == null) {                     // The context instance was injected without an explicit parent ->                     // determine parent for root web application context, if any.                     ApplicationContext parent = loadParentContext(servletContext).                     cwac.setParent(parent).                 }                 configureAndRefreshWebApplicationContext(cwac, servletContext).             }         }         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context).         ClassLoader ccl = Thread.currentThread().getContextClassLoader().         if (ccl == ContextLoader.class.getClassLoader()) {             currentContext = this.context.         } else if (ccl != null) {             currentContextPerThread.put(ccl, this.context).         }         if (logger.isInfoEnabled()) {             long elapsedTime = System.currentTimeMillis() - startTime.             logger.info("Root WebApplicationContext initialized in " + elapsedTime + " ms").         }         return this.context.     } catch (RuntimeException | Error ex) {         logger.error("Context initialization failed", ex).         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex).         throw ex.     } }
true;protected;1;8;/**  * Instantiate the root WebApplicationContext for this loader, either the  * default context class or a custom context class if specified.  * <p>This implementation expects custom contexts to implement the  * {@link ConfigurableWebApplicationContext} interface.  * Can be overridden in subclasses.  * <p>In addition, {@link #customizeContext} gets called prior to refreshing the  * context, allowing subclasses to perform custom modifications to the context.  * @param sc current servlet context  * @return the root WebApplicationContext  * @see ConfigurableWebApplicationContext  */ ;/**  * Instantiate the root WebApplicationContext for this loader, either the  * default context class or a custom context class if specified.  * <p>This implementation expects custom contexts to implement the  * {@link ConfigurableWebApplicationContext} interface.  * Can be overridden in subclasses.  * <p>In addition, {@link #customizeContext} gets called prior to refreshing the  * context, allowing subclasses to perform custom modifications to the context.  * @param sc current servlet context  * @return the root WebApplicationContext  * @see ConfigurableWebApplicationContext  */ protected WebApplicationContext createWebApplicationContext(ServletContext sc) {     Class<?> contextClass = determineContextClass(sc).     if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {         throw new ApplicationContextException("Custom context class [" + contextClass.getName() + "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]").     }     return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass). }
true;protected;1;22;/**  * Return the WebApplicationContext implementation class to use, either the  * default XmlWebApplicationContext or a custom context class if specified.  * @param servletContext current servlet context  * @return the WebApplicationContext implementation class to use  * @see #CONTEXT_CLASS_PARAM  * @see org.springframework.web.context.support.XmlWebApplicationContext  */ ;/**  * Return the WebApplicationContext implementation class to use, either the  * default XmlWebApplicationContext or a custom context class if specified.  * @param servletContext current servlet context  * @return the WebApplicationContext implementation class to use  * @see #CONTEXT_CLASS_PARAM  * @see org.springframework.web.context.support.XmlWebApplicationContext  */ protected Class<?> determineContextClass(ServletContext servletContext) {     String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM).     if (contextClassName != null) {         try {             return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader()).         } catch (ClassNotFoundException ex) {             throw new ApplicationContextException("Failed to load custom context class [" + contextClassName + "]", ex).         }     } else {         contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName()).         try {             return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader()).         } catch (ClassNotFoundException ex) {             throw new ApplicationContextException("Failed to load default context class [" + contextClassName + "]", ex).         }     } }
false;protected;2;32;;protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {     if (ObjectUtils.identityToString(wac).equals(wac.getId())) {         // The application context id is still set to its original default value         // -> assign a more useful id based on available information         String idParam = sc.getInitParameter(CONTEXT_ID_PARAM).         if (idParam != null) {             wac.setId(idParam).         } else {             // Generate default id...             wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath())).         }     }     wac.setServletContext(sc).     String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM).     if (configLocationParam != null) {         wac.setConfigLocation(configLocationParam).     }     // The wac environment's #initPropertySources will be called in any case when the context     // is refreshed. do it eagerly here to ensure servlet property sources are in place for     // use in any post-processing or initialization that occurs below prior to #refresh     ConfigurableEnvironment env = wac.getEnvironment().     if (env instanceof ConfigurableWebEnvironment) {         ((ConfigurableWebEnvironment) env).initPropertySources(sc, null).     }     customizeContext(sc, wac).     wac.refresh(). }
true;protected;2;22;/**  * Customize the {@link ConfigurableWebApplicationContext} created by this  * ContextLoader after config locations have been supplied to the context  * but before the context is <em>refreshed</em>.  * <p>The default implementation {@linkplain #determineContextInitializerClasses(ServletContext)  * determines} what (if any) context initializer classes have been specified through  * {@linkplain #CONTEXT_INITIALIZER_CLASSES_PARAM context init parameters} and  * {@linkplain ApplicationContextInitializer#initialize invokes each} with the  * given web application context.  * <p>Any {@code ApplicationContextInitializers} implementing  * {@link org.springframework.core.Ordered Ordered} or marked with @{@link  * org.springframework.core.annotation.Order Order} will be sorted appropriately.  * @param sc the current servlet context  * @param wac the newly created application context  * @see #CONTEXT_INITIALIZER_CLASSES_PARAM  * @see ApplicationContextInitializer#initialize(ConfigurableApplicationContext)  */ ;/**  * Customize the {@link ConfigurableWebApplicationContext} created by this  * ContextLoader after config locations have been supplied to the context  * but before the context is <em>refreshed</em>.  * <p>The default implementation {@linkplain #determineContextInitializerClasses(ServletContext)  * determines} what (if any) context initializer classes have been specified through  * {@linkplain #CONTEXT_INITIALIZER_CLASSES_PARAM context init parameters} and  * {@linkplain ApplicationContextInitializer#initialize invokes each} with the  * given web application context.  * <p>Any {@code ApplicationContextInitializers} implementing  * {@link org.springframework.core.Ordered Ordered} or marked with @{@link  * org.springframework.core.annotation.Order Order} will be sorted appropriately.  * @param sc the current servlet context  * @param wac the newly created application context  * @see #CONTEXT_INITIALIZER_CLASSES_PARAM  * @see ApplicationContextInitializer#initialize(ConfigurableApplicationContext)  */ protected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {     List<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> initializerClasses = determineContextInitializerClasses(sc).     for (Class<ApplicationContextInitializer<ConfigurableApplicationContext>> initializerClass : initializerClasses) {         Class<?> initializerContextClass = GenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class).         if (initializerContextClass != null && !initializerContextClass.isInstance(wac)) {             throw new ApplicationContextException(String.format("Could not apply context initializer [%s] since its generic parameter [%s] " + "is not assignable from the type of application context used by this " + "context loader: [%s]", initializerClass.getName(), initializerContextClass.getName(), wac.getClass().getName())).         }         this.contextInitializers.add(BeanUtils.instantiateClass(initializerClass)).     }     AnnotationAwareOrderComparator.sort(this.contextInitializers).     for (ApplicationContextInitializer<ConfigurableApplicationContext> initializer : this.contextInitializers) {         initializer.initialize(wac).     } }
true;protected;1;22;/**  * Return the {@link ApplicationContextInitializer} implementation classes to use  * if any have been specified by {@link #CONTEXT_INITIALIZER_CLASSES_PARAM}.  * @param servletContext current servlet context  * @see #CONTEXT_INITIALIZER_CLASSES_PARAM  */ ;/**  * Return the {@link ApplicationContextInitializer} implementation classes to use  * if any have been specified by {@link #CONTEXT_INITIALIZER_CLASSES_PARAM}.  * @param servletContext current servlet context  * @see #CONTEXT_INITIALIZER_CLASSES_PARAM  */ protected List<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> determineContextInitializerClasses(ServletContext servletContext) {     List<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> classes = new ArrayList<>().     String globalClassNames = servletContext.getInitParameter(GLOBAL_INITIALIZER_CLASSES_PARAM).     if (globalClassNames != null) {         for (String className : StringUtils.tokenizeToStringArray(globalClassNames, INIT_PARAM_DELIMITERS)) {             classes.add(loadInitializerClass(className)).         }     }     String localClassNames = servletContext.getInitParameter(CONTEXT_INITIALIZER_CLASSES_PARAM).     if (localClassNames != null) {         for (String className : StringUtils.tokenizeToStringArray(localClassNames, INIT_PARAM_DELIMITERS)) {             classes.add(loadInitializerClass(className)).         }     }     return classes. }
false;private;1;14;;@SuppressWarnings("unchecked") private Class<ApplicationContextInitializer<ConfigurableApplicationContext>> loadInitializerClass(String className) {     try {         Class<?> clazz = ClassUtils.forName(className, ClassUtils.getDefaultClassLoader()).         if (!ApplicationContextInitializer.class.isAssignableFrom(clazz)) {             throw new ApplicationContextException("Initializer class does not implement ApplicationContextInitializer interface: " + clazz).         }         return (Class<ApplicationContextInitializer<ConfigurableApplicationContext>>) clazz.     } catch (ClassNotFoundException ex) {         throw new ApplicationContextException("Failed to load context initializer class [" + className + "]", ex).     } }
true;protected;1;4;/**  * Template method with default implementation (which may be overridden by a  * subclass), to load or obtain an ApplicationContext instance which will be  * used as the parent context of the root WebApplicationContext. If the  * return value from the method is null, no parent context is set.  * <p>The main reason to load a parent context here is to allow multiple root  * web application contexts to all be children of a shared EAR context, or  * alternately to also share the same parent context that is visible to  * EJBs. For pure web applications, there is usually no need to worry about  * having a parent context to the root web application context.  * <p>The default implementation simply returns {@code null}, as of 5.0.  * @param servletContext current servlet context  * @return the parent application context, or {@code null} if none  */ ;/**  * Template method with default implementation (which may be overridden by a  * subclass), to load or obtain an ApplicationContext instance which will be  * used as the parent context of the root WebApplicationContext. If the  * return value from the method is null, no parent context is set.  * <p>The main reason to load a parent context here is to allow multiple root  * web application contexts to all be children of a shared EAR context, or  * alternately to also share the same parent context that is visible to  * EJBs. For pure web applications, there is usually no need to worry about  * having a parent context to the root web application context.  * <p>The default implementation simply returns {@code null}, as of 5.0.  * @param servletContext current servlet context  * @return the parent application context, or {@code null} if none  */ @Nullable protected ApplicationContext loadParentContext(ServletContext servletContext) {     return null. }
true;public;1;18;/**  * Close Spring's web application context for the given servlet context.  * <p>If overriding {@link #loadParentContext(ServletContext)}, you may have  * to override this method as well.  * @param servletContext the ServletContext that the WebApplicationContext runs in  */ ;/**  * Close Spring's web application context for the given servlet context.  * <p>If overriding {@link #loadParentContext(ServletContext)}, you may have  * to override this method as well.  * @param servletContext the ServletContext that the WebApplicationContext runs in  */ public void closeWebApplicationContext(ServletContext servletContext) {     servletContext.log("Closing Spring root WebApplicationContext").     try {         if (this.context instanceof ConfigurableWebApplicationContext) {             ((ConfigurableWebApplicationContext) this.context).close().         }     } finally {         ClassLoader ccl = Thread.currentThread().getContextClassLoader().         if (ccl == ContextLoader.class.getClassLoader()) {             currentContext = null.         } else if (ccl != null) {             currentContextPerThread.remove(ccl).         }         servletContext.removeAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE).     } }
true;public,static;0;11;/**  * Obtain the Spring root web application context for the current thread  * (i.e. for the current thread's context ClassLoader, which needs to be  * the web application's ClassLoader).  * @return the current root web application context, or {@code null}  * if none found  * @see org.springframework.web.context.support.SpringBeanAutowiringSupport  */ ;/**  * Obtain the Spring root web application context for the current thread  * (i.e. for the current thread's context ClassLoader, which needs to be  * the web application's ClassLoader).  * @return the current root web application context, or {@code null}  * if none found  * @see org.springframework.web.context.support.SpringBeanAutowiringSupport  */ @Nullable public static WebApplicationContext getCurrentWebApplicationContext() {     ClassLoader ccl = Thread.currentThread().getContextClassLoader().     if (ccl != null) {         WebApplicationContext ccpt = currentContextPerThread.get(ccl).         if (ccpt != null) {             return ccpt.         }     }     return currentContext. }
