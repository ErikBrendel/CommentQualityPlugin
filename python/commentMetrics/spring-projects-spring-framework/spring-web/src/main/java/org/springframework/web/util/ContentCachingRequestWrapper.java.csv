commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public ServletInputStream getInputStream() throws IOException {     if (this.inputStream == null) {         this.inputStream = new ContentCachingInputStream(getRequest().getInputStream()).     }     return this.inputStream. }
false;public;0;5;;@Override public String getCharacterEncoding() {     String enc = super.getCharacterEncoding().     return (enc != null ? enc : WebUtils.DEFAULT_CHARACTER_ENCODING). }
false;public;0;7;;@Override public BufferedReader getReader() throws IOException {     if (this.reader == null) {         this.reader = new BufferedReader(new InputStreamReader(getInputStream(), getCharacterEncoding())).     }     return this.reader. }
false;public;1;7;;@Override public String getParameter(String name) {     if (this.cachedContent.size() == 0 && isFormPost()) {         writeRequestParametersToCachedContent().     }     return super.getParameter(name). }
false;public;0;7;;@Override public Map<String, String[]> getParameterMap() {     if (this.cachedContent.size() == 0 && isFormPost()) {         writeRequestParametersToCachedContent().     }     return super.getParameterMap(). }
false;public;0;7;;@Override public Enumeration<String> getParameterNames() {     if (this.cachedContent.size() == 0 && isFormPost()) {         writeRequestParametersToCachedContent().     }     return super.getParameterNames(). }
false;public;1;7;;@Override public String[] getParameterValues(String name) {     if (this.cachedContent.size() == 0 && isFormPost()) {         writeRequestParametersToCachedContent().     }     return super.getParameterValues(name). }
false;private;0;5;;private boolean isFormPost() {     String contentType = getContentType().     return (contentType != null && contentType.contains(FORM_CONTENT_TYPE) && HttpMethod.POST.matches(getMethod())). }
false;private;0;29;;private void writeRequestParametersToCachedContent() {     try {         if (this.cachedContent.size() == 0) {             String requestEncoding = getCharacterEncoding().             Map<String, String[]> form = super.getParameterMap().             for (Iterator<String> nameIterator = form.keySet().iterator(). nameIterator.hasNext(). ) {                 String name = nameIterator.next().                 List<String> values = Arrays.asList(form.get(name)).                 for (Iterator<String> valueIterator = values.iterator(). valueIterator.hasNext(). ) {                     String value = valueIterator.next().                     this.cachedContent.write(URLEncoder.encode(name, requestEncoding).getBytes()).                     if (value != null) {                         this.cachedContent.write('=').                         this.cachedContent.write(URLEncoder.encode(value, requestEncoding).getBytes()).                         if (valueIterator.hasNext()) {                             this.cachedContent.write('&').                         }                     }                 }                 if (nameIterator.hasNext()) {                     this.cachedContent.write('&').                 }             }         }     } catch (IOException ex) {         throw new IllegalStateException("Failed to write request parameters to cached content", ex).     } }
true;public;0;3;/**  * Return the cached request content as a byte array.  * <p>The returned array will never be larger than the content cache limit.  * @see #ContentCachingRequestWrapper(HttpServletRequest, int)  */ ;/**  * Return the cached request content as a byte array.  * <p>The returned array will never be larger than the content cache limit.  * @see #ContentCachingRequestWrapper(HttpServletRequest, int)  */ public byte[] getContentAsByteArray() {     return this.cachedContent.toByteArray(). }
true;protected;1;2;/**  * Template method for handling a content overflow: specifically, a request  * body being read that exceeds the specified content cache limit.  * <p>The default implementation is empty. Subclasses may override this to  * throw a payload-too-large exception or the like.  * @param contentCacheLimit the maximum number of bytes to cache per request  * which has just been exceeded  * @since 4.3.6  * @see #ContentCachingRequestWrapper(HttpServletRequest, int)  */ ;/**  * Template method for handling a content overflow: specifically, a request  * body being read that exceeds the specified content cache limit.  * <p>The default implementation is empty. Subclasses may override this to  * throw a payload-too-large exception or the like.  * @param contentCacheLimit the maximum number of bytes to cache per request  * which has just been exceeded  * @since 4.3.6  * @see #ContentCachingRequestWrapper(HttpServletRequest, int)  */ protected void handleContentOverflow(int contentCacheLimit) { }
false;public;0;14;;@Override public int read() throws IOException {     int ch = this.is.read().     if (ch != -1 && !this.overflow) {         if (contentCacheLimit != null && cachedContent.size() == contentCacheLimit) {             this.overflow = true.             handleContentOverflow(contentCacheLimit).         } else {             cachedContent.write(ch).         }     }     return ch. }
false;public;1;6;;@Override public int read(byte[] b) throws IOException {     int count = this.is.read(b).     writeToCache(b, 0, count).     return count. }
false;private;3;12;;private void writeToCache(final byte[] b, final int off, int count) {     if (!this.overflow && count > 0) {         if (contentCacheLimit != null && count + cachedContent.size() > contentCacheLimit) {             this.overflow = true.             cachedContent.write(b, off, contentCacheLimit - cachedContent.size()).             handleContentOverflow(contentCacheLimit).             return.         }         cachedContent.write(b, off, count).     } }
false;public;3;6;;@Override public int read(final byte[] b, final int off, final int len) throws IOException {     int count = this.is.read(b, off, len).     writeToCache(b, off, count).     return count. }
false;public;3;6;;@Override public int readLine(final byte[] b, final int off, final int len) throws IOException {     int count = this.is.readLine(b, off, len).     writeToCache(b, off, count).     return count. }
false;public;0;4;;@Override public boolean isFinished() {     return this.is.isFinished(). }
false;public;0;4;;@Override public boolean isReady() {     return this.is.isReady(). }
false;public;1;4;;@Override public void setReadListener(ReadListener readListener) {     this.is.setReadListener(readListener). }
