commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;10;;private static HttpHeaders createDefaultHttpHeaders(HttpServletRequest request) {     HttpHeaders headers = new HttpHeaders().     for (Enumeration<?> names = request.getHeaderNames(). names.hasMoreElements(). ) {         String name = (String) names.nextElement().         for (Enumeration<?> values = request.getHeaders(name). values.hasMoreElements(). ) {             headers.add(name, (String) values.nextElement()).         }     }     return headers. }
false;private,static;1;9;;private static URI initUri(HttpServletRequest request) throws URISyntaxException {     Assert.notNull(request, "'request' must not be null").     StringBuffer url = request.getRequestURL().     String query = request.getQueryString().     if (StringUtils.hasText(query)) {         url.append('?').append(query).     }     return new URI(url.toString()). }
false;private,static;2;29;;private static HttpHeaders initHeaders(HttpHeaders headers, HttpServletRequest request) {     MediaType contentType = headers.getContentType().     if (contentType == null) {         String requestContentType = request.getContentType().         if (StringUtils.hasLength(requestContentType)) {             contentType = MediaType.parseMediaType(requestContentType).             headers.setContentType(contentType).         }     }     if (contentType != null && contentType.getCharset() == null) {         String encoding = request.getCharacterEncoding().         if (StringUtils.hasLength(encoding)) {             Charset charset = Charset.forName(encoding).             Map<String, String> params = new LinkedCaseInsensitiveMap<>().             params.putAll(contentType.getParameters()).             params.put("charset", charset.toString()).             headers.setContentType(new MediaType(contentType.getType(), contentType.getSubtype(), params)).         }     }     if (headers.getContentLength() == -1) {         int contentLength = request.getContentLength().         if (contentLength != -1) {             headers.setContentLength(contentLength).         }     }     return headers. }
false;public;0;4;;@Override public String getMethodValue() {     return this.request.getMethod(). }
false;protected;0;16;;@Override protected MultiValueMap<String, HttpCookie> initCookies() {     MultiValueMap<String, HttpCookie> httpCookies = new LinkedMultiValueMap<>().     Cookie[] cookies.     synchronized (this.cookieLock) {         cookies = this.request.getCookies().     }     if (cookies != null) {         for (Cookie cookie : cookies) {             String name = cookie.getName().             HttpCookie httpCookie = new HttpCookie(name, cookie.getValue()).             httpCookies.add(name, httpCookie).         }     }     return httpCookies. }
false;public;0;4;;@Override public InetSocketAddress getRemoteAddress() {     return new InetSocketAddress(this.request.getRemoteHost(), this.request.getRemotePort()). }
false;protected;0;5;;@Nullable protected SslInfo initSslInfo() {     X509Certificate[] certificates = getX509Certificates().     return certificates != null ? new DefaultSslInfo(getSslSessionId(), certificates) : null. }
false;private;0;4;;@Nullable private String getSslSessionId() {     return (String) this.request.getAttribute("javax.servlet.request.ssl_session_id"). }
false;private;0;5;;@Nullable private X509Certificate[] getX509Certificates() {     String name = "javax.servlet.request.X509Certificate".     return (X509Certificate[]) this.request.getAttribute(name). }
false;public;0;4;;@Override public Flux<DataBuffer> getBody() {     return Flux.from(this.bodyPublisher). }
true;;0;17;/**  * Read from the request body InputStream and return a DataBuffer.  * Invoked only when {@link ServletInputStream#isReady()} returns "true".  * @return a DataBuffer with data read, or {@link #EOF_BUFFER} if the input  * stream returned -1, or null if 0 bytes were read.  */ ;/**  * Read from the request body InputStream and return a DataBuffer.  * Invoked only when {@link ServletInputStream#isReady()} returns "true".  * @return a DataBuffer with data read, or {@link #EOF_BUFFER} if the input  * stream returned -1, or null if 0 bytes were read.  */ @Nullable DataBuffer readFromInputStream() throws IOException {     int read = this.request.getInputStream().read(this.buffer).     logBytesRead(read).     if (read > 0) {         DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(read).         dataBuffer.write(this.buffer, 0, read).         return dataBuffer.     }     if (read == -1) {         return EOF_BUFFER.     }     return null. }
false;protected,final;1;6;;protected final void logBytesRead(int read) {     Log rsReadLogger = AbstractListenerReadPublisher.rsReadLogger.     if (rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + "Read " + read + (read != -1 ? " bytes" : "")).     } }
false;public;0;5;;@SuppressWarnings("unchecked") @Override public <T> T getNativeRequest() {     return (T) this.request. }
false;public;1;3;;@Override public void onStartAsync(AsyncEvent event) { }
false;public;1;6;;@Override public void onTimeout(AsyncEvent event) {     Throwable ex = event.getThrowable().     ex = ex != null ? ex : new IllegalStateException("Async operation timeout.").     bodyPublisher.onError(ex). }
false;public;1;4;;@Override public void onError(AsyncEvent event) {     bodyPublisher.onError(event.getThrowable()). }
false;public;1;4;;@Override public void onComplete(AsyncEvent event) {     bodyPublisher.onAllDataRead(). }
false;public;0;3;;public void registerReadListener() throws IOException {     this.inputStream.setReadListener(new RequestBodyPublisherReadListener()). }
false;protected;0;6;;@Override protected void checkOnDataAvailable() {     if (this.inputStream.isReady() && !this.inputStream.isFinished()) {         onDataAvailable().     } }
false;protected;0;14;;@Override @Nullable protected DataBuffer read() throws IOException {     if (this.inputStream.isReady()) {         DataBuffer dataBuffer = readFromInputStream().         if (dataBuffer == EOF_BUFFER) {             // No need to wait for container callback...             onAllDataRead().             dataBuffer = null.         }         return dataBuffer.     }     return null. }
false;protected;0;4;;@Override protected void readingPaused() { // no-op }
false;protected;0;4;;@Override protected void discardData() { // Nothing to discard since we pass data buffers on immediately.. }
false;public;0;4;;@Override public void onDataAvailable() throws IOException {     RequestBodyPublisher.this.onDataAvailable(). }
false;public;0;4;;@Override public void onAllDataRead() throws IOException {     RequestBodyPublisher.this.onAllDataRead(). }
false;public;1;5;;@Override public void onError(Throwable throwable) {     RequestBodyPublisher.this.onError(throwable). }
