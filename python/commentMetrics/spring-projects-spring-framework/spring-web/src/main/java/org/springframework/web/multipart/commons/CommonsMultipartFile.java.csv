commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the underlying {@code org.apache.commons.fileupload.FileItem}  * instance. There is hardly any need to access this.  */ ;/**  * Return the underlying {@code org.apache.commons.fileupload.FileItem}  * instance. There is hardly any need to access this.  */ public final FileItem getFileItem() {     return this.fileItem. }
true;public;1;3;/**  * Set whether to preserve the filename as sent by the client, not stripping off  * path information in {@link CommonsMultipartFile#getOriginalFilename()}.  * <p>Default is "false", stripping off path information that may prefix the  * actual filename e.g. from Opera. Switch this to "true" for preserving the  * client-specified filename as-is, including potential path separators.  * @since 4.3.5  * @see #getOriginalFilename()  * @see CommonsMultipartResolver#setPreserveFilename(boolean)  */ ;/**  * Set whether to preserve the filename as sent by the client, not stripping off  * path information in {@link CommonsMultipartFile#getOriginalFilename()}.  * <p>Default is "false", stripping off path information that may prefix the  * actual filename e.g. from Opera. Switch this to "true" for preserving the  * client-specified filename as-is, including potential path separators.  * @since 4.3.5  * @see #getOriginalFilename()  * @see CommonsMultipartResolver#setPreserveFilename(boolean)  */ public void setPreserveFilename(boolean preserveFilename) {     this.preserveFilename = preserveFilename. }
false;public;0;4;;@Override public String getName() {     return this.fileItem.getFieldName(). }
false;public;0;27;;@Override public String getOriginalFilename() {     String filename = this.fileItem.getName().     if (filename == null) {         // Should never happen.         return "".     }     if (this.preserveFilename) {         // Do not try to strip off a path...         return filename.     }     // Check for Unix-style path     int unixSep = filename.lastIndexOf('/').     // Check for Windows-style path     int winSep = filename.lastIndexOf('\\').     // Cut off at latest possible point     int pos = (winSep > unixSep ? winSep : unixSep).     if (pos != -1) {         // Any sort of path separator found...         return filename.substring(pos + 1).     } else {         // A plain name         return filename.     } }
false;public;0;4;;@Override public String getContentType() {     return this.fileItem.getContentType(). }
false;public;0;4;;@Override public boolean isEmpty() {     return (this.size == 0). }
false;public;0;4;;@Override public long getSize() {     return this.size. }
false;public;0;8;;@Override public byte[] getBytes() {     if (!isAvailable()) {         throw new IllegalStateException("File has been moved - cannot be read again").     }     byte[] bytes = this.fileItem.get().     return (bytes != null ? bytes : new byte[0]). }
false;public;0;8;;@Override public InputStream getInputStream() throws IOException {     if (!isAvailable()) {         throw new IllegalStateException("File has been moved - cannot be read again").     }     InputStream inputStream = this.fileItem.getInputStream().     return (inputStream != null ? inputStream : StreamUtils.emptyInput()). }
false;public;1;35;;@Override public void transferTo(File dest) throws IOException, IllegalStateException {     if (!isAvailable()) {         throw new IllegalStateException("File has already been moved - cannot be transferred again").     }     if (dest.exists() && !dest.delete()) {         throw new IOException("Destination file [" + dest.getAbsolutePath() + "] already exists and could not be deleted").     }     try {         this.fileItem.write(dest).         LogFormatUtils.traceDebug(logger, traceOn -> {             String action = "transferred".             if (!this.fileItem.isInMemory()) {                 action = (isAvailable() ? "copied" : "moved").             }             return "Part '" + getName() + "',  filename '" + getOriginalFilename() + "'" + (traceOn ? ", stored " + getStorageDescription() : "") + ": " + action + " to [" + dest.getAbsolutePath() + "]".         }).     } catch (FileUploadException ex) {         throw new IllegalStateException(ex.getMessage(), ex).     } catch (IllegalStateException | IOException ex) {         // or propagate an exception from I/O operations within FileItem.write         throw ex.     } catch (Exception ex) {         throw new IOException("File transfer failed", ex).     } }
false;public;1;8;;@Override public void transferTo(Path dest) throws IOException, IllegalStateException {     if (!isAvailable()) {         throw new IllegalStateException("File has already been moved - cannot be transferred again").     }     FileCopyUtils.copy(this.fileItem.getInputStream(), Files.newOutputStream(dest)). }
true;protected;0;12;/**  * Determine whether the multipart content is still available.  * If a temporary file has been moved, the content is no longer available.  */ ;/**  * Determine whether the multipart content is still available.  * If a temporary file has been moved, the content is no longer available.  */ protected boolean isAvailable() {     // If in memory, it's available.     if (this.fileItem.isInMemory()) {         return true.     }     // Check actual existence of temporary file.     if (this.fileItem instanceof DiskFileItem) {         return ((DiskFileItem) this.fileItem).getStoreLocation().exists().     }     // Check whether current file size is different than original one.     return (this.fileItem.getSize() == this.size). }
true;public;0;11;/**  * Return a description for the storage location of the multipart content.  * Tries to be as specific as possible: mentions the file location in case  * of a temporary file.  */ ;/**  * Return a description for the storage location of the multipart content.  * Tries to be as specific as possible: mentions the file location in case  * of a temporary file.  */ public String getStorageDescription() {     if (this.fileItem.isInMemory()) {         return "in memory".     } else if (this.fileItem instanceof DiskFileItem) {         return "at [" + ((DiskFileItem) this.fileItem).getStoreLocation().getAbsolutePath() + "]".     } else {         return "on disk".     } }
