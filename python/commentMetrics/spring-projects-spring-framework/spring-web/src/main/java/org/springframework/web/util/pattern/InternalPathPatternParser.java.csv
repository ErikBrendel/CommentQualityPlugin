# id;timestamp;commentText;codeText;commentWords;codeWords
InternalPathPatternParser -> public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash);1495035625;@param separator the path separator to look for when parsing_@param caseSensitive true if PathPatterns should be sensitive to case_@param matchOptionalTrailingSlash true if patterns without a trailing slash_can match paths that do have a trailing slash;public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash) {_		this.separator = separator__		this.caseSensitive = caseSensitive__		this.matchOptionalTrailingSlash = matchOptionalTrailingSlash__	};param,separator,the,path,separator,to,look,for,when,parsing,param,case,sensitive,true,if,path,patterns,should,be,sensitive,to,case,param,match,optional,trailing,slash,true,if,patterns,without,a,trailing,slash,can,match,paths,that,do,have,a,trailing,slash;public,internal,path,pattern,parser,char,separator,boolean,case,sensitive,boolean,match,optional,trailing,slash,this,separator,separator,this,case,sensitive,case,sensitive,this,match,optional,trailing,slash,match,optional,trailing,slash
InternalPathPatternParser -> public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash);1497038887;@param separator the path separator to look for when parsing_@param caseSensitive true if PathPatterns should be sensitive to case_@param matchOptionalTrailingSlash true if patterns without a trailing slash_can match paths that do have a trailing slash;public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash) {_		this.separator = separator__		this.caseSensitive = caseSensitive__		this.matchOptionalTrailingSlash = matchOptionalTrailingSlash__	};param,separator,the,path,separator,to,look,for,when,parsing,param,case,sensitive,true,if,path,patterns,should,be,sensitive,to,case,param,match,optional,trailing,slash,true,if,patterns,without,a,trailing,slash,can,match,paths,that,do,have,a,trailing,slash;public,internal,path,pattern,parser,char,separator,boolean,case,sensitive,boolean,match,optional,trailing,slash,this,separator,separator,this,case,sensitive,case,sensitive,this,match,optional,trailing,slash,match,optional,trailing,slash
InternalPathPatternParser -> public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash);1497275505;@param separator the path separator to look for when parsing_@param caseSensitive true if PathPatterns should be sensitive to case_@param matchOptionalTrailingSlash true if patterns without a trailing slash_can match paths that do have a trailing slash;public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash) {_		this.separator = separator__		this.caseSensitive = caseSensitive__		this.matchOptionalTrailingSlash = matchOptionalTrailingSlash__	};param,separator,the,path,separator,to,look,for,when,parsing,param,case,sensitive,true,if,path,patterns,should,be,sensitive,to,case,param,match,optional,trailing,slash,true,if,patterns,without,a,trailing,slash,can,match,paths,that,do,have,a,trailing,slash;public,internal,path,pattern,parser,char,separator,boolean,case,sensitive,boolean,match,optional,trailing,slash,this,separator,separator,this,case,sensitive,case,sensitive,this,match,optional,trailing,slash,match,optional,trailing,slash
InternalPathPatternParser -> public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash);1498780456;@param separator the path separator to look for when parsing_@param caseSensitive true if PathPatterns should be sensitive to case_@param matchOptionalTrailingSlash true if patterns without a trailing slash_can match paths that do have a trailing slash;public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash) {_		this.separator = separator__		this.caseSensitive = caseSensitive__		this.matchOptionalTrailingSlash = matchOptionalTrailingSlash__	};param,separator,the,path,separator,to,look,for,when,parsing,param,case,sensitive,true,if,path,patterns,should,be,sensitive,to,case,param,match,optional,trailing,slash,true,if,patterns,without,a,trailing,slash,can,match,paths,that,do,have,a,trailing,slash;public,internal,path,pattern,parser,char,separator,boolean,case,sensitive,boolean,match,optional,trailing,slash,this,separator,separator,this,case,sensitive,case,sensitive,this,match,optional,trailing,slash,match,optional,trailing,slash
InternalPathPatternParser -> public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash);1498861175;@param separator the path separator to look for when parsing_@param caseSensitive true if PathPatterns should be sensitive to case_@param matchOptionalTrailingSlash true if patterns without a trailing slash_can match paths that do have a trailing slash;public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash) {_		this.separator = separator__		this.caseSensitive = caseSensitive__		this.matchOptionalTrailingSlash = matchOptionalTrailingSlash__		this.parser = new PathPatternParser(this.separator)__		this.parser.setCaseSensitive(this.caseSensitive)__		this.parser.setMatchOptionalTrailingSlash(this.matchOptionalTrailingSlash)__	};param,separator,the,path,separator,to,look,for,when,parsing,param,case,sensitive,true,if,path,patterns,should,be,sensitive,to,case,param,match,optional,trailing,slash,true,if,patterns,without,a,trailing,slash,can,match,paths,that,do,have,a,trailing,slash;public,internal,path,pattern,parser,char,separator,boolean,case,sensitive,boolean,match,optional,trailing,slash,this,separator,separator,this,case,sensitive,case,sensitive,this,match,optional,trailing,slash,match,optional,trailing,slash,this,parser,new,path,pattern,parser,this,separator,this,parser,set,case,sensitive,this,case,sensitive,this,parser,set,match,optional,trailing,slash,this,match,optional,trailing,slash
InternalPathPatternParser -> public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash);1499445979;@param separator the path separator to look for when parsing_@param caseSensitive true if PathPatterns should be sensitive to case_@param matchOptionalTrailingSlash true if patterns without a trailing slash_can match paths that do have a trailing slash;public InternalPathPatternParser(char separator, boolean caseSensitive, boolean matchOptionalTrailingSlash) {_		this.separator = separator__		this.caseSensitive = caseSensitive__		this.matchOptionalTrailingSlash = matchOptionalTrailingSlash__		this.parser = new PathPatternParser(this.separator)__		this.parser.setCaseSensitive(this.caseSensitive)__		this.parser.setMatchOptionalTrailingSlash(this.matchOptionalTrailingSlash)__	};param,separator,the,path,separator,to,look,for,when,parsing,param,case,sensitive,true,if,path,patterns,should,be,sensitive,to,case,param,match,optional,trailing,slash,true,if,patterns,without,a,trailing,slash,can,match,paths,that,do,have,a,trailing,slash;public,internal,path,pattern,parser,char,separator,boolean,case,sensitive,boolean,match,optional,trailing,slash,this,separator,separator,this,case,sensitive,case,sensitive,this,match,optional,trailing,slash,match,optional,trailing,slash,this,parser,new,path,pattern,parser,this,separator,this,parser,set,case,sensitive,this,case,sensitive,this,parser,set,match,optional,trailing,slash,this,match,optional,trailing,slash
InternalPathPatternParser -> private boolean peekDoubleWildcard();1495035625;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1497038887;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1497275505;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1498780456;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1498861175;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1499445979;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1501620738;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1501676476;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1520529117;After processing a separator, a quick peek whether it is followed by **_(and only ** before the end of the pattern or the next separator);private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1530174524;After processing a separator, a quick peek whether it is followed by_(and only before the end of the pattern or the next separator).;private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private boolean peekDoubleWildcard();1530174524;After processing a separator, a quick peek whether it is followed by_(and only before the end of the pattern or the next separator).;private boolean peekDoubleWildcard() {_		if ((this.pos + 2) >= this.pathPatternLength) {_			return false__		}_		if (this.pathPatternData[this.pos + 1] != '*' || this.pathPatternData[this.pos + 2] != '*') {_			return false__		}_		return (this.pos + 3 == this.pathPatternLength)__	};after,processing,a,separator,a,quick,peek,whether,it,is,followed,by,and,only,before,the,end,of,the,pattern,or,the,next,separator;private,boolean,peek,double,wildcard,if,this,pos,2,this,path,pattern,length,return,false,if,this,path,pattern,data,this,pos,1,this,path,pattern,data,this,pos,2,return,false,return,this,pos,3,this,path,pattern,length
InternalPathPatternParser -> private void skipCaptureRegex();1495035625;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1497038887;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1497275505;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1498780456;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1498861175;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1499445979;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1501620738;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.separator && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1501676476;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.parser.getSeparator() && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,parser,get,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1520529117;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.parser.getSeparator() && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,parser,get,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1530174524;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.parser.getSeparator() && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,parser,get,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> private void skipCaptureRegex();1530174524;Just hit a ':' and want to jump over the regex specification for this_variable. pos will be pointing at the ':', we want to skip until the }._<p>_Nested {...} pairs don't have to be escaped: <tt>/abc/{var:x{1,2}}/def</tt>_<p>An escaped } will not be treated as the end of the regex: <tt>/abc/{var:x\\{y:}/def</tt>_<p>A separator that should not indicate the end of the regex can be escaped:;private void skipCaptureRegex() {_		this.pos++__		int regexStart = this.pos__		int curlyBracketDepth = 0_ _		boolean previousBackslash = false___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == '\\' && !previousBackslash) {_				this.pos++__				previousBackslash = true__				continue__			}_			if (ch == '{' && !previousBackslash) {_				curlyBracketDepth++__			}_			else if (ch == '}' && !previousBackslash) {_				if (curlyBracketDepth == 0) {_					if (regexStart == this.pos) {_						throw new PatternParseException(regexStart, this.pathPatternData,_								PatternMessage.MISSING_REGEX_CONSTRAINT)__					}_					return__				}_				curlyBracketDepth--__			}_			if (ch == this.parser.getSeparator() && !previousBackslash) {_				throw new PatternParseException(this.pos, this.pathPatternData,_						PatternMessage.MISSING_CLOSE_CAPTURE)__			}_			this.pos++__			previousBackslash = false__		}__		throw new PatternParseException(this.pos - 1, this.pathPatternData,_				PatternMessage.MISSING_CLOSE_CAPTURE)__	};just,hit,a,and,want,to,jump,over,the,regex,specification,for,this,variable,pos,will,be,pointing,at,the,we,want,to,skip,until,the,p,nested,pairs,don,t,have,to,be,escaped,tt,abc,var,x,1,2,def,tt,p,an,escaped,will,not,be,treated,as,the,end,of,the,regex,tt,abc,var,x,y,def,tt,p,a,separator,that,should,not,indicate,the,end,of,the,regex,can,be,escaped;private,void,skip,capture,regex,this,pos,int,regex,start,this,pos,int,curly,bracket,depth,0,boolean,previous,backslash,false,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,previous,backslash,this,pos,previous,backslash,true,continue,if,ch,previous,backslash,curly,bracket,depth,else,if,ch,previous,backslash,if,curly,bracket,depth,0,if,regex,start,this,pos,throw,new,pattern,parse,exception,regex,start,this,path,pattern,data,pattern,message,return,curly,bracket,depth,if,ch,this,parser,get,separator,previous,backslash,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,pos,previous,backslash,false,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1495035625;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(_				pathPattern, this.headPE, this.separator, this.caseSensitive, this.matchOptionalTrailingSlash)__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,head,pe,this,separator,this,case,sensitive,this,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1497038887;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(_				pathPattern, this.headPE, this.separator, this.caseSensitive, this.matchOptionalTrailingSlash)__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,head,pe,this,separator,this,case,sensitive,this,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1497275505;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(_				pathPattern, this.headPE, this.separator, this.caseSensitive, this.matchOptionalTrailingSlash)__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,head,pe,this,separator,this,case,sensitive,this,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1498780456;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(_				pathPattern, this.headPE, this.separator, this.caseSensitive, this.matchOptionalTrailingSlash)__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,head,pe,this,separator,this,case,sensitive,this,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1498861175;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		if (pathPattern == null) {_			pathPattern = ""__		}_		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(_				pathPattern, this.parser, this.headPE, this.separator, this.caseSensitive, this.matchOptionalTrailingSlash)__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,if,path,pattern,null,path,pattern,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe,this,separator,this,case,sensitive,this,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1499445979;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		Assert.notNull(pathPattern, "Path pattern must not be null")___		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = this.pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(_				pathPattern, this.parser, this.headPE, this.separator, this.caseSensitive, this.matchOptionalTrailingSlash)__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,assert,not,null,path,pattern,path,pattern,must,not,be,null,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,this,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe,this,separator,this,case,sensitive,this,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1501620738;Process the path pattern data, a character at a time, breaking it into_path elements around separator boundaries and verifying the structure at each_stage. Produces a PathPattern object that can be used for fast matching_against paths._@param pathPattern the input path pattern, e.g. /foo/{bar}_@return a PathPattern for quickly matching paths against the specified path pattern_@throws PatternParseException in case of parse errors;public PathPattern parse(String pathPattern) throws PatternParseException {_		Assert.notNull(pathPattern, "Path pattern must not be null")___		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = this.pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.separator) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.separator))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.separator))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(pathPattern, this.parser, this.headPE, this.separator,_				this.parser.isCaseSensitive(), this.parser.isMatchOptionalTrailingSlash())__	};process,the,path,pattern,data,a,character,at,a,time,breaking,it,into,path,elements,around,separator,boundaries,and,verifying,the,structure,at,each,stage,produces,a,path,pattern,object,that,can,be,used,for,fast,matching,against,paths,param,path,pattern,the,input,path,pattern,e,g,foo,bar,return,a,path,pattern,for,quickly,matching,paths,against,the,specified,path,pattern,throws,pattern,parse,exception,in,case,of,parse,errors;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,assert,not,null,path,pattern,path,pattern,must,not,be,null,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,this,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe,this,separator,this,parser,is,case,sensitive,this,parser,is,match,optional,trailing,slash
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1501676476;Package private delegate for {@link PathPatternParser#parse(String)}.;public PathPattern parse(String pathPattern) throws PatternParseException {_		Assert.notNull(pathPattern, "Path pattern must not be null")___		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = this.pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.parser.getSeparator()) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture) {_						if (this.variableCaptureStart == pos - 1) {_							this.isCaptureTheRestVariable = true__						}_					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(pathPattern, this.parser, this.headPE)__	};package,private,delegate,for,link,path,pattern,parser,parse,string;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,assert,not,null,path,pattern,path,pattern,must,not,be,null,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,this,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,parser,get,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,parser,get,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,parser,get,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,if,this,variable,capture,start,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1520529117;Package private delegate for {@link PathPatternParser#parse(String)}.;public PathPattern parse(String pathPattern) throws PatternParseException {_		Assert.notNull(pathPattern, "Path pattern must not be null")___		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = this.pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.parser.getSeparator()) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture && this.variableCaptureStart == this.pos - 1) {_						this.isCaptureTheRestVariable = true__					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(pathPattern, this.parser, this.headPE)__	};package,private,delegate,for,link,path,pattern,parser,parse,string;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,assert,not,null,path,pattern,path,pattern,must,not,be,null,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,this,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,parser,get,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,parser,get,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,parser,get,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,variable,capture,start,this,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1530174524;Package private delegate for {@link PathPatternParser#parse(String)}.;public PathPattern parse(String pathPattern) throws PatternParseException {_		Assert.notNull(pathPattern, "Path pattern must not be null")___		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = this.pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.parser.getSeparator()) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture && this.variableCaptureStart == this.pos - 1) {_						this.isCaptureTheRestVariable = true__					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(pathPattern, this.parser, this.headPE)__	};package,private,delegate,for,link,path,pattern,parser,parse,string;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,assert,not,null,path,pattern,path,pattern,must,not,be,null,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,this,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,parser,get,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,parser,get,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,parser,get,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,variable,capture,start,this,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe
InternalPathPatternParser -> public PathPattern parse(String pathPattern) throws PatternParseException;1530174524;Package private delegate for {@link PathPatternParser#parse(String)}.;public PathPattern parse(String pathPattern) throws PatternParseException {_		Assert.notNull(pathPattern, "Path pattern must not be null")___		this.pathPatternData = pathPattern.toCharArray()__		this.pathPatternLength = this.pathPatternData.length__		this.headPE = null__		this.currentPE = null__		this.capturedVariableNames = null__		this.pathElementStart = -1__		this.pos = 0__		resetPathElementState()___		while (this.pos < this.pathPatternLength) {_			char ch = this.pathPatternData[this.pos]__			if (ch == this.parser.getSeparator()) {_				if (this.pathElementStart != -1) {_					pushPathElement(createPathElement())__				}_				if (peekDoubleWildcard()) {_					pushPathElement(new WildcardTheRestPathElement(this.pos, this.parser.getSeparator()))__					this.pos += 2__				}_				else {_					pushPathElement(new SeparatorPathElement(this.pos, this.parser.getSeparator()))__				}_			}_			else {_				if (this.pathElementStart == -1) {_					this.pathElementStart = this.pos__				}_				if (ch == '?') {_					this.singleCharWildcardCount++__				}_				else if (ch == '{') {_					if (this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_NESTED_CAPTURE)__					}_					_					_					_					_					_					this.insideVariableCapture = true__					this.variableCaptureStart = this.pos__				}_				else if (ch == '}') {_					if (!this.insideVariableCapture) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.MISSING_OPEN_CAPTURE)__					}_					this.insideVariableCapture = false__					if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {_						throw new PatternParseException(this.pos + 1, this.pathPatternData,_								PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST)__					}_					this.variableCaptureCount++__				}_				else if (ch == ':') {_					if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {_						skipCaptureRegex()__						this.insideVariableCapture = false__						this.variableCaptureCount++__					}_				}_				else if (ch == '*') {_					if (this.insideVariableCapture && this.variableCaptureStart == this.pos - 1) {_						this.isCaptureTheRestVariable = true__					}_					this.wildcard = true__				}_				_				if (this.insideVariableCapture) {_					if ((this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) == this.pos &&_							!Character.isJavaIdentifierStart(ch)) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,_								Character.toString(ch))___					}_					else if ((this.pos > (this.variableCaptureStart + 1 + (this.isCaptureTheRestVariable ? 1 : 0)) &&_							!Character.isJavaIdentifierPart(ch))) {_						throw new PatternParseException(this.pos, this.pathPatternData,_								PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,_								Character.toString(ch))__					}_				}_			}_			this.pos++__		}_		if (this.pathElementStart != -1) {_			pushPathElement(createPathElement())__		}_		return new PathPattern(pathPattern, this.parser, this.headPE)__	};package,private,delegate,for,link,path,pattern,parser,parse,string;public,path,pattern,parse,string,path,pattern,throws,pattern,parse,exception,assert,not,null,path,pattern,path,pattern,must,not,be,null,this,path,pattern,data,path,pattern,to,char,array,this,path,pattern,length,this,path,pattern,data,length,this,head,pe,null,this,current,pe,null,this,captured,variable,names,null,this,path,element,start,1,this,pos,0,reset,path,element,state,while,this,pos,this,path,pattern,length,char,ch,this,path,pattern,data,this,pos,if,ch,this,parser,get,separator,if,this,path,element,start,1,push,path,element,create,path,element,if,peek,double,wildcard,push,path,element,new,wildcard,the,rest,path,element,this,pos,this,parser,get,separator,this,pos,2,else,push,path,element,new,separator,path,element,this,pos,this,parser,get,separator,else,if,this,path,element,start,1,this,path,element,start,this,pos,if,ch,this,single,char,wildcard,count,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,true,this,variable,capture,start,this,pos,else,if,ch,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,this,inside,variable,capture,false,if,this,is,capture,the,rest,variable,this,pos,1,this,path,pattern,length,throw,new,pattern,parse,exception,this,pos,1,this,path,pattern,data,pattern,message,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,is,capture,the,rest,variable,skip,capture,regex,this,inside,variable,capture,false,this,variable,capture,count,else,if,ch,if,this,inside,variable,capture,this,variable,capture,start,this,pos,1,this,is,capture,the,rest,variable,true,this,wildcard,true,if,this,inside,variable,capture,if,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,this,pos,character,is,java,identifier,start,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,else,if,this,pos,this,variable,capture,start,1,this,is,capture,the,rest,variable,1,0,character,is,java,identifier,part,ch,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,character,to,string,ch,this,pos,if,this,path,element,start,1,push,path,element,create,path,element,return,new,path,pattern,path,pattern,this,parser,this,head,pe
InternalPathPatternParser -> private void resetPathElementState();1495035625;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1497038887;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1497275505;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1498780456;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1498861175;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1499445979;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1501620738;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1501676476;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1520529117;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1530174524;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private void resetPathElementState();1530174524;Reset all the flags and position markers computed during path element processing.;private void resetPathElementState() {_		this.pathElementStart = -1__		this.singleCharWildcardCount = 0__		this.insideVariableCapture = false__		this.variableCaptureCount = 0__		this.wildcard = false__		this.isCaptureTheRestVariable = false__		this.variableCaptureStart = -1__	};reset,all,the,flags,and,position,markers,computed,during,path,element,processing;private,void,reset,path,element,state,this,path,element,start,1,this,single,char,wildcard,count,0,this,inside,variable,capture,false,this,variable,capture,count,0,this,wildcard,false,this,is,capture,the,rest,variable,false,this,variable,capture,start,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1495035625;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1497038887;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1497275505;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1498780456;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1498861175;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1499445979;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1501620738;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1501676476;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1520529117;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1530174524;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private int findRegexStart(char[] data, int offset);1530174524;For a path element representing a captured variable, locate the constraint pattern._Assumes there is a constraint pattern._@param data a complete path expression, e.g. /aaa/bbb/{ccc:...}_@param offset the start of the capture pattern of interest_@return the index of the character after the ':' within_the pattern expression relative to the start of the whole expression;private int findRegexStart(char[] data, int offset) {_		int pos = offset__		while (pos < data.length) {_			if (data[pos] == ':') {_				return pos + 1__			}_			pos++__		}_		return -1__	};for,a,path,element,representing,a,captured,variable,locate,the,constraint,pattern,assumes,there,is,a,constraint,pattern,param,data,a,complete,path,expression,e,g,aaa,bbb,ccc,param,offset,the,start,of,the,capture,pattern,of,interest,return,the,index,of,the,character,after,the,within,the,pattern,expression,relative,to,the,start,of,the,whole,expression;private,int,find,regex,start,char,data,int,offset,int,pos,offset,while,pos,data,length,if,data,pos,return,pos,1,pos,return,1
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1495035625;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1497038887;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1497275505;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1498780456;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1498861175;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1499445979;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1501620738;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1501676476;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1520529117;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1530174524;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void recordCapturedVariable(int pos, String variableName);1530174524;Record a new captured variable. If it clashes with an existing one then report an error.;private void recordCapturedVariable(int pos, String variableName) {_		if (this.capturedVariableNames == null) {_			this.capturedVariableNames = new ArrayList<>()__		}_		if (this.capturedVariableNames.contains(variableName)) {_			throw new PatternParseException(pos, this.pathPatternData,_					PatternMessage.ILLEGAL_DOUBLE_CAPTURE, variableName)__		}_		this.capturedVariableNames.add(variableName)__	};record,a,new,captured,variable,if,it,clashes,with,an,existing,one,then,report,an,error;private,void,record,captured,variable,int,pos,string,variable,name,if,this,captured,variable,names,null,this,captured,variable,names,new,array,list,if,this,captured,variable,names,contains,variable,name,throw,new,pattern,parse,exception,pos,this,path,pattern,data,pattern,message,variable,name,this,captured,variable,names,add,variable,name
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1495035625;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1497038887;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1497275505;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1498780456;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1498861175;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1499445979;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1501620738;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1501676476;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1520529117;@param newPathElement the new path element to add to the chain being built;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};param,new,path,element,the,new,path,element,to,add,to,the,chain,being,built;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1530174524;Push a path element to the chain being build._@param newPathElement the new path element to add;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};push,a,path,element,to,the,chain,being,build,param,new,path,element,the,new,path,element,to,add;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private void pushPathElement(PathElement newPathElement);1530174524;Push a path element to the chain being build._@param newPathElement the new path element to add;private void pushPathElement(PathElement newPathElement) {_		if (newPathElement instanceof CaptureTheRestPathElement) {_			_			_			if (this.currentPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE instanceof SeparatorPathElement) {_				PathElement peBeforeSeparator = this.currentPE.prev__				if (peBeforeSeparator == null) {_					_					this.headPE = newPathElement__					newPathElement.prev = null__				}_				else {_					peBeforeSeparator.next = newPathElement__					newPathElement.prev = peBeforeSeparator__				}_				this.currentPE = newPathElement__			}_			else {_				throw new IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE)__			}_		}_		else {_			if (this.headPE == null) {_				this.headPE = newPathElement__				this.currentPE = newPathElement__			}_			else if (this.currentPE != null) {_				this.currentPE.next = newPathElement__				newPathElement.prev = this.currentPE__				this.currentPE = newPathElement__			}_		}__		resetPathElementState()__	};push,a,path,element,to,the,chain,being,build,param,new,path,element,the,new,path,element,to,add;private,void,push,path,element,path,element,new,path,element,if,new,path,element,instanceof,capture,the,rest,path,element,if,this,current,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,instanceof,separator,path,element,path,element,pe,before,separator,this,current,pe,prev,if,pe,before,separator,null,this,head,pe,new,path,element,new,path,element,prev,null,else,pe,before,separator,next,new,path,element,new,path,element,prev,pe,before,separator,this,current,pe,new,path,element,else,throw,new,illegal,state,exception,expected,separator,path,element,but,was,this,current,pe,else,if,this,head,pe,null,this,head,pe,new,path,element,this,current,pe,new,path,element,else,if,this,current,pe,null,this,current,pe,next,new,path,element,new,path,element,prev,this,current,pe,this,current,pe,new,path,element,reset,path,element,state
InternalPathPatternParser -> private PathElement createPathElement();1495035625;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}__		char[] pathElementText = new char[this.pos - this.pathElementStart]__		System.arraycopy(this.pathPatternData, this.pathElementStart, pathElementText, 0,_				this.pos - this.pathElementStart)__		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, pathElementText, separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, pathElementText,_								this.caseSensitive, this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, pathElementText,_						this.caseSensitive, this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, pathElementText,_							this.caseSensitive, this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, pathElementText,_						this.singleCharWildcardCount, this.caseSensitive, this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, pathElementText,_						this.caseSensitive, this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,char,path,element,text,new,char,this,pos,this,path,element,start,system,arraycopy,this,path,pattern,data,this,path,element,start,path,element,text,0,this,pos,this,path,element,start,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,path,element,text,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,path,element,text,this,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,path,element,text,this,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,path,element,text,this,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,path,element,text,this,single,char,wildcard,count,this,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,path,element,text,this,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1497038887;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, getPathElementText(false), separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(false),_								this.caseSensitive, this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(false), this.caseSensitive,_						this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(false),_							this.caseSensitive, this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(true),_						this.singleCharWildcardCount, this.caseSensitive, this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(true),_						this.caseSensitive, this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,get,path,element,text,false,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,true,this,single,char,wildcard,count,this,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,true,this,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1497275505;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, getPathElementText(false), separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(false),_								this.caseSensitive, this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(false), this.caseSensitive,_						this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(false),_							this.caseSensitive, this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(true),_						this.singleCharWildcardCount, this.caseSensitive, this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(true),_						this.caseSensitive, this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,get,path,element,text,false,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,true,this,single,char,wildcard,count,this,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,true,this,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1498780456;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, getPathElementText(false), separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(false),_								this.caseSensitive, this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(false), this.caseSensitive,_						this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(false),_							this.caseSensitive, this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(true),_						this.singleCharWildcardCount, this.caseSensitive, this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(true),_						this.caseSensitive, this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,get,path,element,text,false,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,false,this,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,true,this,single,char,wildcard,count,this,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,true,this,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1498861175;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, getPathElementText(), separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.caseSensitive, this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(), this.caseSensitive,_						this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.caseSensitive, this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.caseSensitive, this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.caseSensitive, this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,get,path,element,text,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1499445979;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, getPathElementText(), separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.caseSensitive, this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(), this.caseSensitive,_						this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.caseSensitive, this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.caseSensitive, this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.caseSensitive, this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,get,path,element,text,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1501620738;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(pathElementStart, getPathElementText(), separator)__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.parser.isCaseSensitive(), this.separator)__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(), this.parser.isCaseSensitive(),_						this.pathPatternData, this.separator)__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.separator)__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.parser.isCaseSensitive(), this.pathPatternData, this.separator)__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.separator)__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.parser.isCaseSensitive(), this.separator)__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,path,element,start,get,path,element,text,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,parser,is,case,sensitive,this,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1501676476;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(_							this.pathElementStart, getPathElementText(), this.parser.getSeparator())__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.parser.isCaseSensitive(), this.parser.getSeparator())__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(), this.parser.isCaseSensitive(),_						this.pathPatternData, this.parser.getSeparator())__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator())__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator())__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,this,path,element,start,get,path,element,text,this,parser,get,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,parser,get,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,parser,is,case,sensitive,this,parser,get,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1520529117;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}_		_		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(_							this.pathElementStart, getPathElementText(), this.parser.getSeparator())__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.parser.isCaseSensitive(), this.parser.getSeparator())__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart, _						getPathElementText(), this.parser.isCaseSensitive(),_						this.pathPatternData, this.parser.getSeparator())__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator())__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator())__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,this,path,element,start,get,path,element,text,this,parser,get,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,parser,get,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,parser,is,case,sensitive,this,parser,get,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1530174524;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}__		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(_							this.pathElementStart, getPathElementText(), this.parser.getSeparator())__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.parser.isCaseSensitive(), this.parser.getSeparator())__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart,_						getPathElementText(), this.parser.isCaseSensitive(),_						this.pathPatternData, this.parser.getSeparator())__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator())__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator())__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,this,path,element,start,get,path,element,text,this,parser,get,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,parser,get,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,parser,is,case,sensitive,this,parser,get,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,return,new,pe
InternalPathPatternParser -> private PathElement createPathElement();1530174524;Used the knowledge built up whilst processing since the last path element to determine what kind of path_element to create._@return the new path element;private PathElement createPathElement() {_		if (this.insideVariableCapture) {_			throw new PatternParseException(this.pos, this.pathPatternData, PatternMessage.MISSING_CLOSE_CAPTURE)__		}__		PathElement newPE = null___		if (this.variableCaptureCount > 0) {_			if (this.variableCaptureCount == 1 && this.pathElementStart == this.variableCaptureStart &&_					this.pathPatternData[this.pos - 1] == '}') {_				if (this.isCaptureTheRestVariable) {_					_					newPE = new CaptureTheRestPathElement(_							this.pathElementStart, getPathElementText(), this.parser.getSeparator())__				}_				else {_					_					try {_						newPE = new CaptureVariablePathElement(this.pathElementStart, getPathElementText(),_								this.parser.isCaseSensitive(), this.parser.getSeparator())__					}_					catch (PatternSyntaxException pse) {_						throw new PatternParseException(pse,_								findRegexStart(this.pathPatternData, this.pathElementStart) + pse.getIndex(),_								this.pathPatternData, PatternMessage.REGEX_PATTERN_SYNTAX_EXCEPTION)__					}_					recordCapturedVariable(this.pathElementStart,_							((CaptureVariablePathElement) newPE).getVariableName())__				}_			}_			else {_				if (this.isCaptureTheRestVariable) {_					throw new PatternParseException(this.pathElementStart, this.pathPatternData,_							PatternMessage.CAPTURE_ALL_IS_STANDALONE_CONSTRUCT)__				}_				RegexPathElement newRegexSection = new RegexPathElement(this.pathElementStart,_						getPathElementText(), this.parser.isCaseSensitive(),_						this.pathPatternData, this.parser.getSeparator())__				for (String variableName : newRegexSection.getVariableNames()) {_					recordCapturedVariable(this.pathElementStart, variableName)__				}_				newPE = newRegexSection__			}_		}_		else {_			if (this.wildcard) {_				if (this.pos - 1 == this.pathElementStart) {_					newPE = new WildcardPathElement(this.pathElementStart, this.parser.getSeparator())__				}_				else {_					newPE = new RegexPathElement(this.pathElementStart, getPathElementText(),_							this.parser.isCaseSensitive(), this.pathPatternData, this.parser.getSeparator())__				}_			}_			else if (this.singleCharWildcardCount != 0) {_				newPE = new SingleCharWildcardedPathElement(this.pathElementStart, getPathElementText(),_						this.singleCharWildcardCount, this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_			else {_				newPE = new LiteralPathElement(this.pathElementStart, getPathElementText(),_						this.parser.isCaseSensitive(), this.parser.getSeparator())__			}_		}__		return newPE__	};used,the,knowledge,built,up,whilst,processing,since,the,last,path,element,to,determine,what,kind,of,path,element,to,create,return,the,new,path,element;private,path,element,create,path,element,if,this,inside,variable,capture,throw,new,pattern,parse,exception,this,pos,this,path,pattern,data,pattern,message,path,element,new,pe,null,if,this,variable,capture,count,0,if,this,variable,capture,count,1,this,path,element,start,this,variable,capture,start,this,path,pattern,data,this,pos,1,if,this,is,capture,the,rest,variable,new,pe,new,capture,the,rest,path,element,this,path,element,start,get,path,element,text,this,parser,get,separator,else,try,new,pe,new,capture,variable,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,catch,pattern,syntax,exception,pse,throw,new,pattern,parse,exception,pse,find,regex,start,this,path,pattern,data,this,path,element,start,pse,get,index,this,path,pattern,data,pattern,message,record,captured,variable,this,path,element,start,capture,variable,path,element,new,pe,get,variable,name,else,if,this,is,capture,the,rest,variable,throw,new,pattern,parse,exception,this,path,element,start,this,path,pattern,data,pattern,message,regex,path,element,new,regex,section,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,for,string,variable,name,new,regex,section,get,variable,names,record,captured,variable,this,path,element,start,variable,name,new,pe,new,regex,section,else,if,this,wildcard,if,this,pos,1,this,path,element,start,new,pe,new,wildcard,path,element,this,path,element,start,this,parser,get,separator,else,new,pe,new,regex,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,path,pattern,data,this,parser,get,separator,else,if,this,single,char,wildcard,count,0,new,pe,new,single,char,wildcarded,path,element,this,path,element,start,get,path,element,text,this,single,char,wildcard,count,this,parser,is,case,sensitive,this,parser,get,separator,else,new,pe,new,literal,path,element,this,path,element,start,get,path,element,text,this,parser,is,case,sensitive,this,parser,get,separator,return,new,pe
InternalPathPatternParser -> InternalPathPatternParser(PathPatternParser parentParser);1501676476;Package private constructor for use in {@link PathPatternParser#parse}._@param parentParser reference back to the stateless, public parser;InternalPathPatternParser(PathPatternParser parentParser) {_		this.parser = parentParser__	};package,private,constructor,for,use,in,link,path,pattern,parser,parse,param,parent,parser,reference,back,to,the,stateless,public,parser;internal,path,pattern,parser,path,pattern,parser,parent,parser,this,parser,parent,parser
InternalPathPatternParser -> InternalPathPatternParser(PathPatternParser parentParser);1520529117;Package private constructor for use in {@link PathPatternParser#parse}._@param parentParser reference back to the stateless, public parser;InternalPathPatternParser(PathPatternParser parentParser) {_		this.parser = parentParser__	};package,private,constructor,for,use,in,link,path,pattern,parser,parse,param,parent,parser,reference,back,to,the,stateless,public,parser;internal,path,pattern,parser,path,pattern,parser,parent,parser,this,parser,parent,parser
InternalPathPatternParser -> InternalPathPatternParser(PathPatternParser parentParser);1530174524;Package private constructor for use in {@link PathPatternParser#parse}._@param parentParser reference back to the stateless, public parser;InternalPathPatternParser(PathPatternParser parentParser) {_		this.parser = parentParser__	};package,private,constructor,for,use,in,link,path,pattern,parser,parse,param,parent,parser,reference,back,to,the,stateless,public,parser;internal,path,pattern,parser,path,pattern,parser,parent,parser,this,parser,parent,parser
InternalPathPatternParser -> InternalPathPatternParser(PathPatternParser parentParser);1530174524;Package private constructor for use in {@link PathPatternParser#parse}._@param parentParser reference back to the stateless, public parser;InternalPathPatternParser(PathPatternParser parentParser) {_		this.parser = parentParser__	};package,private,constructor,for,use,in,link,path,pattern,parser,parse,param,parent,parser,reference,back,to,the,stateless,public,parser;internal,path,pattern,parser,path,pattern,parser,parent,parser,this,parser,parent,parser
