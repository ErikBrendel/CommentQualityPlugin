commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<MediaType> getReadableMediaTypes() {     return Collections.singletonList(MediaType.MULTIPART_FORM_DATA). }
false;public;2;5;;@Override public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {     return MULTIPART_VALUE_TYPE.isAssignableFrom(elementType) && (mediaType == null || MediaType.MULTIPART_FORM_DATA.isCompatibleWith(mediaType)). }
false;public;3;6;;@Override public Flux<MultiValueMap<String, Part>> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {     return Flux.from(readMono(elementType, message, hints)). }
false;public;3;17;;@Override public Mono<MultiValueMap<String, Part>> readMono(ResolvableType elementType, ReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {     Map<String, Object> allHints = Hints.merge(hints, Hints.SUPPRESS_LOGGING_HINT, true).     return this.partReader.read(elementType, inputMessage, allHints).collectMultimap(Part::name).doOnNext(map -> {         LogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + "Parsed " + (isEnableLoggingRequestDetails() ? LogFormatUtils.formatValue(map, !traceOn) : "parts " + map.keySet() + " (content masked)")).     }).map(this::toMultiValueMap). }
false;private;1;4;;private LinkedMultiValueMap<String, Part> toMultiValueMap(Map<String, Collection<Part>> map) {     return new LinkedMultiValueMap<>(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> toList(e.getValue())))). }
false;private;1;3;;private List<Part> toList(Collection<Part> collection) {     return collection instanceof List ? (List<Part>) collection : new ArrayList<>(collection). }
