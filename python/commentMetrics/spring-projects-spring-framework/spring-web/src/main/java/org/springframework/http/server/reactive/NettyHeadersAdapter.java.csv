commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override @Nullable public String getFirst(String key) {     return this.headers.get(key). }
false;public;2;4;;@Override public void add(String key, @Nullable String value) {     this.headers.add(key, value). }
false;public;2;4;;@Override public void addAll(String key, List<? extends String> values) {     this.headers.add(key, values). }
false;public;1;4;;@Override public void addAll(MultiValueMap<String, String> values) {     values.forEach(this.headers::add). }
false;public;2;4;;@Override public void set(String key, @Nullable String value) {     this.headers.set(key, value). }
false;public;1;4;;@Override public void setAll(Map<String, String> values) {     values.forEach(this.headers::set). }
false;public;0;11;;@Override public Map<String, String> toSingleValueMap() {     Map<String, String> singleValueMap = new LinkedHashMap<>(this.headers.size()).     this.headers.entries().forEach(entry -> {         if (!singleValueMap.containsKey(entry.getKey())) {             singleValueMap.put(entry.getKey(), entry.getValue()).         }     }).     return singleValueMap. }
false;public;0;4;;@Override public int size() {     return this.headers.names().size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return this.headers.isEmpty(). }
false;public;1;4;;@Override public boolean containsKey(Object key) {     return (key instanceof String && this.headers.contains((String) key)). }
false;public;1;6;;@Override public boolean containsValue(Object value) {     return (value instanceof String && this.headers.entries().stream().anyMatch(entry -> value.equals(entry.getValue()))). }
false;public;1;8;;@Override @Nullable public List<String> get(Object key) {     if (containsKey(key)) {         return this.headers.getAll((String) key).     }     return null. }
false;public;2;7;;@Nullable @Override public List<String> put(String key, @Nullable List<String> value) {     List<String> previousValues = this.headers.getAll(key).     this.headers.set(key, value).     return previousValues. }
false;public;1;10;;@Nullable @Override public List<String> remove(Object key) {     if (key instanceof String) {         List<String> previousValues = this.headers.getAll((String) key).         this.headers.remove((String) key).         return previousValues.     }     return null. }
false;public;1;4;;@Override public void putAll(Map<? extends String, ? extends List<String>> map) {     map.forEach(this.headers::add). }
false;public;0;4;;@Override public void clear() {     this.headers.clear(). }
false;public;0;4;;@Override public Set<String> keySet() {     return this.headers.names(). }
false;public;0;5;;@Override public Collection<List<String>> values() {     return this.headers.names().stream().map(this.headers::getAll).collect(Collectors.toList()). }
false;public;0;4;;@Override public Iterator<Entry<String, List<String>>> iterator() {     return new EntryIterator(). }
false;public;0;4;;@Override public int size() {     return headers.size(). }
false;public;0;14;;@Override public Set<Entry<String, List<String>>> entrySet() {     return new AbstractSet<Entry<String, List<String>>>() {          @Override         public Iterator<Entry<String, List<String>>> iterator() {             return new EntryIterator().         }          @Override         public int size() {             return headers.size().         }     }. }
false;public;0;4;;@Override public String toString() {     return org.springframework.http.HttpHeaders.formatHeaders(this). }
false;public;0;4;;@Override public boolean hasNext() {     return this.names.hasNext(). }
false;public;0;4;;@Override public Entry<String, List<String>> next() {     return new HeaderEntry(this.names.next()). }
false;public;0;4;;@Override public String getKey() {     return this.key. }
false;public;0;4;;@Override public List<String> getValue() {     return headers.getAll(this.key). }
false;public;1;6;;@Override public List<String> setValue(List<String> value) {     List<String> previousValues = headers.getAll(this.key).     headers.set(this.key, value).     return previousValues. }
