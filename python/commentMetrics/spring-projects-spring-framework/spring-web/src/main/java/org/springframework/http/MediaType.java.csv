commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;10;;@Override protected void checkParameters(String attribute, String value) {     super.checkParameters(attribute, value).     if (PARAM_QUALITY_FACTOR.equals(attribute)) {         value = unquote(value).         double d = Double.parseDouble(value).         Assert.isTrue(d >= 0D && d <= 1D, "Invalid quality value \"" + value + "\": should be between 0.0 and 1.0").     } }
true;public;0;4;/**  * Return the quality factor, as indicated by a {@code q} parameter, if any.  * Defaults to {@code 1.0}.  * @return the quality factor as double value  */ ;/**  * Return the quality factor, as indicated by a {@code q} parameter, if any.  * Defaults to {@code 1.0}.  * @return the quality factor as double value  */ public double getQualityValue() {     String qualityFactor = getParameter(PARAM_QUALITY_FACTOR).     return (qualityFactor != null ? Double.parseDouble(unquote(qualityFactor)) : 1D). }
true;public;1;3;/**  * Indicate whether this {@code MediaType} includes the given media type.  * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},  * and {@code application/*+xml} includes {@code application/soap+xml}, etc.  * This method is <b>not</b> symmetric.  * <p>Simply calls {@link #includes(MimeType)} but declared with a  * {@code MediaType} parameter for binary backwards compatibility.  * @param other the reference media type with which to compare  * @return {@code true} if this media type includes the given media type.  * {@code false} otherwise  */ ;/**  * Indicate whether this {@code MediaType} includes the given media type.  * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},  * and {@code application/*+xml} includes {@code application/soap+xml}, etc.  * This method is <b>not</b> symmetric.  * <p>Simply calls {@link #includes(MimeType)} but declared with a  * {@code MediaType} parameter for binary backwards compatibility.  * @param other the reference media type with which to compare  * @return {@code true} if this media type includes the given media type.  * {@code false} otherwise  */ public boolean includes(@Nullable MediaType other) {     return super.includes(other). }
true;public;1;3;/**  * Indicate whether this {@code MediaType} is compatible with the given media type.  * <p>For instance, {@code text/*} is compatible with {@code text/plain},  * {@code text/html}, and vice versa. In effect, this method is similar to  * {@link #includes}, except that it <b>is</b> symmetric.  * <p>Simply calls {@link #isCompatibleWith(MimeType)} but declared with a  * {@code MediaType} parameter for binary backwards compatibility.  * @param other the reference media type with which to compare  * @return {@code true} if this media type is compatible with the given media type.  * {@code false} otherwise  */ ;/**  * Indicate whether this {@code MediaType} is compatible with the given media type.  * <p>For instance, {@code text/*} is compatible with {@code text/plain},  * {@code text/html}, and vice versa. In effect, this method is similar to  * {@link #includes}, except that it <b>is</b> symmetric.  * <p>Simply calls {@link #isCompatibleWith(MimeType)} but declared with a  * {@code MediaType} parameter for binary backwards compatibility.  * @param other the reference media type with which to compare  * @return {@code true} if this media type is compatible with the given media type.  * {@code false} otherwise  */ public boolean isCompatibleWith(@Nullable MediaType other) {     return super.isCompatibleWith(other). }
true;public;1;8;/**  * Return a replica of this instance with the quality value of the given {@code MediaType}.  * @return the same instance if the given MediaType doesn't have a quality value,  * or a new one otherwise  */ ;/**  * Return a replica of this instance with the quality value of the given {@code MediaType}.  * @return the same instance if the given MediaType doesn't have a quality value,  * or a new one otherwise  */ public MediaType copyQualityValue(MediaType mediaType) {     if (!mediaType.getParameters().containsKey(PARAM_QUALITY_FACTOR)) {         return this.     }     Map<String, String> params = new LinkedHashMap<>(getParameters()).     params.put(PARAM_QUALITY_FACTOR, mediaType.getParameters().get(PARAM_QUALITY_FACTOR)).     return new MediaType(this, params). }
true;public;0;8;/**  * Return a replica of this instance with its quality value removed.  * @return the same instance if the media type doesn't contain a quality value,  * or a new one otherwise  */ ;/**  * Return a replica of this instance with its quality value removed.  * @return the same instance if the media type doesn't contain a quality value,  * or a new one otherwise  */ public MediaType removeQualityValue() {     if (!getParameters().containsKey(PARAM_QUALITY_FACTOR)) {         return this.     }     Map<String, String> params = new LinkedHashMap<>(getParameters()).     params.remove(PARAM_QUALITY_FACTOR).     return new MediaType(this, params). }
true;public,static;1;3;/**  * Parse the given String value into a {@code MediaType} object,  * with this method name following the 'valueOf' naming convention  * (as supported by {@link org.springframework.core.convert.ConversionService}.  * @param value the string to parse  * @throws InvalidMediaTypeException if the media type value cannot be parsed  * @see #parseMediaType(String)  */ ;/**  * Parse the given String value into a {@code MediaType} object,  * with this method name following the 'valueOf' naming convention  * (as supported by {@link org.springframework.core.convert.ConversionService}.  * @param value the string to parse  * @throws InvalidMediaTypeException if the media type value cannot be parsed  * @see #parseMediaType(String)  */ public static MediaType valueOf(String value) {     return parseMediaType(value). }
true;public,static;1;15;/**  * Parse the given String into a single {@code MediaType}.  * @param mediaType the string to parse  * @return the media type  * @throws InvalidMediaTypeException if the media type value cannot be parsed  */ ;/**  * Parse the given String into a single {@code MediaType}.  * @param mediaType the string to parse  * @return the media type  * @throws InvalidMediaTypeException if the media type value cannot be parsed  */ public static MediaType parseMediaType(String mediaType) {     MimeType type.     try {         type = MimeTypeUtils.parseMimeType(mediaType).     } catch (InvalidMimeTypeException ex) {         throw new InvalidMediaTypeException(ex).     }     try {         return new MediaType(type.getType(), type.getSubtype(), type.getParameters()).     } catch (IllegalArgumentException ex) {         throw new InvalidMediaTypeException(mediaType, ex.getMessage()).     } }
true;public,static;1;12;/**  * Parse the comma-separated string into a list of {@code MediaType} objects.  * <p>This method can be used to parse an Accept or Content-Type header.  * @param mediaTypes the string to parse  * @return the list of media types  * @throws InvalidMediaTypeException if the media type value cannot be parsed  */ ;/**  * Parse the comma-separated string into a list of {@code MediaType} objects.  * <p>This method can be used to parse an Accept or Content-Type header.  * @param mediaTypes the string to parse  * @return the list of media types  * @throws InvalidMediaTypeException if the media type value cannot be parsed  */ public static List<MediaType> parseMediaTypes(@Nullable String mediaTypes) {     if (!StringUtils.hasLength(mediaTypes)) {         return Collections.emptyList().     }     // Avoid using java.util.stream.Stream in hot paths     List<String> tokenizedTypes = MimeTypeUtils.tokenize(mediaTypes).     List<MediaType> result = new ArrayList<>(tokenizedTypes.size()).     for (String type : tokenizedTypes) {         result.add(parseMediaType(type)).     }     return result. }
true;public,static;1;15;/**  * Parse the given list of (potentially) comma-separated strings into a  * list of {@code MediaType} objects.  * <p>This method can be used to parse an Accept or Content-Type header.  * @param mediaTypes the string to parse  * @return the list of media types  * @throws InvalidMediaTypeException if the media type value cannot be parsed  * @since 4.3.2  */ ;/**  * Parse the given list of (potentially) comma-separated strings into a  * list of {@code MediaType} objects.  * <p>This method can be used to parse an Accept or Content-Type header.  * @param mediaTypes the string to parse  * @return the list of media types  * @throws InvalidMediaTypeException if the media type value cannot be parsed  * @since 4.3.2  */ public static List<MediaType> parseMediaTypes(@Nullable List<String> mediaTypes) {     if (CollectionUtils.isEmpty(mediaTypes)) {         return Collections.emptyList().     } else if (mediaTypes.size() == 1) {         return parseMediaTypes(mediaTypes.get(0)).     } else {         List<MediaType> result = new ArrayList<>(8).         for (String mediaType : mediaTypes) {             result.addAll(parseMediaTypes(mediaType)).         }         return result.     } }
true;public,static;1;7;/**  * Re-create the given mime types as media types.  * @since 5.0  */ ;/**  * Re-create the given mime types as media types.  * @since 5.0  */ public static List<MediaType> asMediaTypes(List<MimeType> mimeTypes) {     List<MediaType> mediaTypes = new ArrayList<>(mimeTypes.size()).     for (MimeType mimeType : mimeTypes) {         mediaTypes.add(MediaType.asMediaType(mimeType)).     }     return mediaTypes. }
true;public,static;1;6;/**  * Re-create the given mime type as a media type.  * @since 5.0  */ ;/**  * Re-create the given mime type as a media type.  * @since 5.0  */ public static MediaType asMediaType(MimeType mimeType) {     if (mimeType instanceof MediaType) {         return (MediaType) mimeType.     }     return new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters()). }
true;public,static;1;3;/**  * Return a string representation of the given list of {@code MediaType} objects.  * <p>This method can be used to for an {@code Accept} or {@code Content-Type} header.  * @param mediaTypes the media types to create a string representation for  * @return the string representation  */ ;/**  * Return a string representation of the given list of {@code MediaType} objects.  * <p>This method can be used to for an {@code Accept} or {@code Content-Type} header.  * @param mediaTypes the media types to create a string representation for  * @return the string representation  */ public static String toString(Collection<MediaType> mediaTypes) {     return MimeTypeUtils.toString(mediaTypes). }
true;public,static;1;6;/**  * Sorts the given list of {@code MediaType} objects by specificity.  * <p>Given two media types:  * <ol>  * <li>if either media type has a {@linkplain #isWildcardType() wildcard type}, then the media type without the  * wildcard is ordered before the other.</li>  * <li>if the two media types have different {@linkplain #getType() types}, then they are considered equal and  * remain their current order.</li>  * <li>if either media type has a {@linkplain #isWildcardSubtype() wildcard subtype}, then the media type without  * the wildcard is sorted before the other.</li>  * <li>if the two media types have different {@linkplain #getSubtype() subtypes}, then they are considered equal  * and remain their current order.</li>  * <li>if the two media types have different {@linkplain #getQualityValue() quality value}, then the media type  * with the highest quality value is ordered before the other.</li>  * <li>if the two media types have a different amount of {@linkplain #getParameter(String) parameters}, then the  * media type with the most parameters is ordered before the other.</li>  * </ol>  * <p>For example:  * <blockquote>audio/basic &lt. audio/* &lt. *&#047.*</blockquote>  * <blockquote>audio/* &lt. audio/*.q=0.7. audio/*.q=0.3</blockquote>  * <blockquote>audio/basic.level=1 &lt. audio/basic</blockquote>  * <blockquote>audio/basic == text/html</blockquote>  * <blockquote>audio/basic == audio/wave</blockquote>  * @param mediaTypes the list of media types to be sorted  * @see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics  * and Content, section 5.3.2</a>  */ ;/**  * Sorts the given list of {@code MediaType} objects by specificity.  * <p>Given two media types:  * <ol>  * <li>if either media type has a {@linkplain #isWildcardType() wildcard type}, then the media type without the  * wildcard is ordered before the other.</li>  * <li>if the two media types have different {@linkplain #getType() types}, then they are considered equal and  * remain their current order.</li>  * <li>if either media type has a {@linkplain #isWildcardSubtype() wildcard subtype}, then the media type without  * the wildcard is sorted before the other.</li>  * <li>if the two media types have different {@linkplain #getSubtype() subtypes}, then they are considered equal  * and remain their current order.</li>  * <li>if the two media types have different {@linkplain #getQualityValue() quality value}, then the media type  * with the highest quality value is ordered before the other.</li>  * <li>if the two media types have a different amount of {@linkplain #getParameter(String) parameters}, then the  * media type with the most parameters is ordered before the other.</li>  * </ol>  * <p>For example:  * <blockquote>audio/basic &lt. audio/* &lt. *&#047.*</blockquote>  * <blockquote>audio/* &lt. audio/*.q=0.7. audio/*.q=0.3</blockquote>  * <blockquote>audio/basic.level=1 &lt. audio/basic</blockquote>  * <blockquote>audio/basic == text/html</blockquote>  * <blockquote>audio/basic == audio/wave</blockquote>  * @param mediaTypes the list of media types to be sorted  * @see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics  * and Content, section 5.3.2</a>  */ public static void sortBySpecificity(List<MediaType> mediaTypes) {     Assert.notNull(mediaTypes, "'mediaTypes' must not be null").     if (mediaTypes.size() > 1) {         mediaTypes.sort(SPECIFICITY_COMPARATOR).     } }
true;public,static;1;6;/**  * Sorts the given list of {@code MediaType} objects by quality value.  * <p>Given two media types:  * <ol>  * <li>if the two media types have different {@linkplain #getQualityValue() quality value}, then the media type  * with the highest quality value is ordered before the other.</li>  * <li>if either media type has a {@linkplain #isWildcardType() wildcard type}, then the media type without the  * wildcard is ordered before the other.</li>  * <li>if the two media types have different {@linkplain #getType() types}, then they are considered equal and  * remain their current order.</li>  * <li>if either media type has a {@linkplain #isWildcardSubtype() wildcard subtype}, then the media type without  * the wildcard is sorted before the other.</li>  * <li>if the two media types have different {@linkplain #getSubtype() subtypes}, then they are considered equal  * and remain their current order.</li>  * <li>if the two media types have a different amount of {@linkplain #getParameter(String) parameters}, then the  * media type with the most parameters is ordered before the other.</li>  * </ol>  * @param mediaTypes the list of media types to be sorted  * @see #getQualityValue()  */ ;/**  * Sorts the given list of {@code MediaType} objects by quality value.  * <p>Given two media types:  * <ol>  * <li>if the two media types have different {@linkplain #getQualityValue() quality value}, then the media type  * with the highest quality value is ordered before the other.</li>  * <li>if either media type has a {@linkplain #isWildcardType() wildcard type}, then the media type without the  * wildcard is ordered before the other.</li>  * <li>if the two media types have different {@linkplain #getType() types}, then they are considered equal and  * remain their current order.</li>  * <li>if either media type has a {@linkplain #isWildcardSubtype() wildcard subtype}, then the media type without  * the wildcard is sorted before the other.</li>  * <li>if the two media types have different {@linkplain #getSubtype() subtypes}, then they are considered equal  * and remain their current order.</li>  * <li>if the two media types have a different amount of {@linkplain #getParameter(String) parameters}, then the  * media type with the most parameters is ordered before the other.</li>  * </ol>  * @param mediaTypes the list of media types to be sorted  * @see #getQualityValue()  */ public static void sortByQualityValue(List<MediaType> mediaTypes) {     Assert.notNull(mediaTypes, "'mediaTypes' must not be null").     if (mediaTypes.size() > 1) {         mediaTypes.sort(QUALITY_VALUE_COMPARATOR).     } }
true;public,static;1;6;/**  * Sorts the given list of {@code MediaType} objects by specificity as the  * primary criteria and quality value the secondary.  * @see MediaType#sortBySpecificity(List)  * @see MediaType#sortByQualityValue(List)  */ ;/**  * Sorts the given list of {@code MediaType} objects by specificity as the  * primary criteria and quality value the secondary.  * @see MediaType#sortBySpecificity(List)  * @see MediaType#sortByQualityValue(List)  */ public static void sortBySpecificityAndQuality(List<MediaType> mediaTypes) {     Assert.notNull(mediaTypes, "'mediaTypes' must not be null").     if (mediaTypes.size() > 1) {         mediaTypes.sort(MediaType.SPECIFICITY_COMPARATOR.thenComparing(MediaType.QUALITY_VALUE_COMPARATOR)).     } }
false;protected;2;10;;@Override protected int compareParameters(MediaType mediaType1, MediaType mediaType2) {     double quality1 = mediaType1.getQualityValue().     double quality2 = mediaType2.getQualityValue().     int qualityComparison = Double.compare(quality2, quality1).     if (qualityComparison != 0) {         // audio/*.q=0.7 < audio/*.q=0.3         return qualityComparison.     }     return super.compareParameters(mediaType1, mediaType2). }
