commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void jackson2JsonDecoder(Decoder<?> decoder) {     this.jackson2JsonDecoder = decoder. }
false;public;1;4;;@Override public void jackson2JsonEncoder(Encoder<?> encoder) {     this.jackson2JsonEncoder = encoder. }
false;public;1;4;;@Override public void protobufDecoder(Decoder<?> decoder) {     this.protobufDecoder = decoder. }
false;public;1;4;;@Override public void protobufEncoder(Encoder<?> encoder) {     this.protobufEncoder = encoder. }
false;public;1;4;;@Override public void jaxb2Decoder(Decoder<?> decoder) {     this.jaxb2Decoder = decoder. }
false;public;1;4;;@Override public void jaxb2Encoder(Encoder<?> encoder) {     this.jaxb2Encoder = encoder. }
false;public;1;4;;@Override public void enableLoggingRequestDetails(boolean enable) {     this.enableLoggingRequestDetails = enable. }
false;protected;0;3;;protected boolean isEnableLoggingRequestDetails() {     return this.enableLoggingRequestDetails. }
true;;1;3;/**  * Delegate method used from {@link BaseCodecConfigurer#registerDefaults}.  */ ;/**  * Delegate method used from {@link BaseCodecConfigurer#registerDefaults}.  */ void registerDefaults(boolean registerDefaults) {     this.registerDefaults = registerDefaults. }
true;final;0;23;/**  * Return readers that support specific types.  */ ;/**  * Return readers that support specific types.  */ final List<HttpMessageReader<?>> getTypedReaders() {     if (!this.registerDefaults) {         return Collections.emptyList().     }     List<HttpMessageReader<?>> readers = new ArrayList<>().     readers.add(new DecoderHttpMessageReader<>(new ByteArrayDecoder())).     readers.add(new DecoderHttpMessageReader<>(new ByteBufferDecoder())).     readers.add(new DecoderHttpMessageReader<>(new DataBufferDecoder())).     readers.add(new DecoderHttpMessageReader<>(new ResourceDecoder())).     readers.add(new DecoderHttpMessageReader<>(StringDecoder.textPlainOnly())).     if (protobufPresent) {         Decoder<?> decoder = this.protobufDecoder != null ? this.protobufDecoder : new ProtobufDecoder().         readers.add(new DecoderHttpMessageReader<>(decoder)).     }     FormHttpMessageReader formReader = new FormHttpMessageReader().     formReader.setEnableLoggingRequestDetails(this.enableLoggingRequestDetails).     readers.add(formReader).     extendTypedReaders(readers).     return readers. }
true;protected;1;2;/**  * Hook for client or server specific typed readers.  */ ;/**  * Hook for client or server specific typed readers.  */ protected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders) { }
true;final;0;18;/**  * Return Object readers (JSON, XML, SSE).  */ ;/**  * Return Object readers (JSON, XML, SSE).  */ final List<HttpMessageReader<?>> getObjectReaders() {     if (!this.registerDefaults) {         return Collections.emptyList().     }     List<HttpMessageReader<?>> readers = new ArrayList<>().     if (jackson2Present) {         readers.add(new DecoderHttpMessageReader<>(getJackson2JsonDecoder())).     }     if (jackson2SmilePresent) {         readers.add(new DecoderHttpMessageReader<>(new Jackson2SmileDecoder())).     }     if (jaxb2Present) {         Decoder<?> decoder = this.jaxb2Decoder != null ? this.jaxb2Decoder : new Jaxb2XmlDecoder().         readers.add(new DecoderHttpMessageReader<>(decoder)).     }     extendObjectReaders(readers).     return readers. }
true;protected;1;2;/**  * Hook for client or server specific Object readers.  */ ;/**  * Hook for client or server specific Object readers.  */ protected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders) { }
true;final;0;8;/**  * Return readers that need to be at the end, after all others.  */ ;/**  * Return readers that need to be at the end, after all others.  */ final List<HttpMessageReader<?>> getCatchAllReaders() {     if (!this.registerDefaults) {         return Collections.emptyList().     }     List<HttpMessageReader<?>> result = new ArrayList<>().     result.add(new DecoderHttpMessageReader<>(StringDecoder.allMimeTypes())).     return result. }
true;final;1;21;/**  * Return writers that support specific types.  * @param forMultipart whether to returns writers for general use ("false"),  * or for multipart requests only ("true"). Generally the two sets are the  * same except for the multipart writer itself.  */ ;/**  * Return writers that support specific types.  * @param forMultipart whether to returns writers for general use ("false"),  * or for multipart requests only ("true"). Generally the two sets are the  * same except for the multipart writer itself.  */ @SuppressWarnings("unchecked") final List<HttpMessageWriter<?>> getTypedWriters(boolean forMultipart) {     if (!this.registerDefaults) {         return Collections.emptyList().     }     List<HttpMessageWriter<?>> writers = new ArrayList<>().     writers.add(new EncoderHttpMessageWriter<>(new ByteArrayEncoder())).     writers.add(new EncoderHttpMessageWriter<>(new ByteBufferEncoder())).     writers.add(new EncoderHttpMessageWriter<>(new DataBufferEncoder())).     writers.add(new ResourceHttpMessageWriter()).     writers.add(new EncoderHttpMessageWriter<>(CharSequenceEncoder.textPlainOnly())).     // No client or server specific multipart writers currently..     if (!forMultipart) {         extendTypedWriters(writers).     }     if (protobufPresent) {         Encoder<?> encoder = this.protobufEncoder != null ? this.protobufEncoder : new ProtobufEncoder().         writers.add(new ProtobufHttpMessageWriter((Encoder) encoder)).     }     return writers. }
true;protected;1;2;/**  * Hook for client or server specific typed writers.  */ ;/**  * Hook for client or server specific typed writers.  */ protected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters) { }
true;final;1;21;/**  * Return Object writers (JSON, XML, SSE).  * @param forMultipart whether to returns writers for general use ("false"),  * or for multipart requests only ("true"). Generally the two sets are the  * same except for the multipart writer itself.  */ ;/**  * Return Object writers (JSON, XML, SSE).  * @param forMultipart whether to returns writers for general use ("false"),  * or for multipart requests only ("true"). Generally the two sets are the  * same except for the multipart writer itself.  */ final List<HttpMessageWriter<?>> getObjectWriters(boolean forMultipart) {     if (!this.registerDefaults) {         return Collections.emptyList().     }     List<HttpMessageWriter<?>> writers = new ArrayList<>().     if (jackson2Present) {         writers.add(new EncoderHttpMessageWriter<>(getJackson2JsonEncoder())).     }     if (jackson2SmilePresent) {         writers.add(new EncoderHttpMessageWriter<>(new Jackson2SmileEncoder())).     }     if (jaxb2Present) {         Encoder<?> encoder = this.jaxb2Encoder != null ? this.jaxb2Encoder : new Jaxb2XmlEncoder().         writers.add(new EncoderHttpMessageWriter<>(encoder)).     }     // No client or server specific multipart writers currently..     if (!forMultipart) {         extendObjectWriters(writers).     }     return writers. }
true;protected;1;2;/**  * Hook for client or server specific Object writers.  */ ;/**  * Hook for client or server specific Object writers.  */ protected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters) { }
true;;0;8;/**  * Return writers that need to be at the end, after all others.  */ ;/**  * Return writers that need to be at the end, after all others.  */ List<HttpMessageWriter<?>> getCatchAllWriters() {     if (!this.registerDefaults) {         return Collections.emptyList().     }     List<HttpMessageWriter<?>> result = new ArrayList<>().     result.add(new EncoderHttpMessageWriter<>(CharSequenceEncoder.allMimeTypes())).     return result. }
false;protected;0;3;;// Accessors for use in subclasses... protected Decoder<?> getJackson2JsonDecoder() {     return (this.jackson2JsonDecoder != null ? this.jackson2JsonDecoder : new Jackson2JsonDecoder()). }
false;protected;0;3;;protected Encoder<?> getJackson2JsonEncoder() {     return (this.jackson2JsonEncoder != null ? this.jackson2JsonEncoder : new Jackson2JsonEncoder()). }
