commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Create an instance with the given log prefix.  * @since 5.1  */ ;/**  * Create an instance with the given log prefix.  * @since 5.1  */ public String getLogPrefix() {     return this.logPrefix. }
false;public,final;1;4;;// Subscriber methods and async I/O notification methods... @Override public final void onSubscribe(Subscription subscription) {     this.state.get().onSubscribe(this, subscription). }
false;public,final;1;7;;@Override public final void onNext(Publisher<? extends T> publisher) {     if (rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(getLogPrefix() + "Received onNext publisher").     }     this.state.get().onNext(this, publisher). }
true;public,final;1;7;/**  * Error signal from the upstream, write Publisher. This is also used by  * sub-classes to delegate error notifications from the container.  */ ;/**  * Error signal from the upstream, write Publisher. This is also used by  * sub-classes to delegate error notifications from the container.  */ @Override public final void onError(Throwable ex) {     if (rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(getLogPrefix() + "Received onError: " + ex).     }     this.state.get().onError(this, ex). }
true;public,final;0;7;/**  * Completion signal from the upstream, write Publisher. This is also used  * by sub-classes to delegate completion notifications from the container.  */ ;/**  * Completion signal from the upstream, write Publisher. This is also used  * by sub-classes to delegate completion notifications from the container.  */ @Override public final void onComplete() {     if (rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(getLogPrefix() + "Received onComplete").     }     this.state.get().onComplete(this). }
true;protected,final;0;3;/**  * Invoked when flushing is possible, either in the same thread after a check  * via {@link #isWritePossible()}, or as a callback from the underlying  * container.  */ ;/**  * Invoked when flushing is possible, either in the same thread after a check  * via {@link #isWritePossible()}, or as a callback from the underlying  * container.  */ protected final void onFlushPossible() {     this.state.get().onFlushPossible(this). }
true;protected;0;8;/**  * Invoked during an error or completion callback from the underlying  * container to cancel the upstream subscription.  */ ;/**  * Invoked during an error or completion callback from the underlying  * container to cancel the upstream subscription.  */ protected void cancel() {     if (rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(getLogPrefix() + "Received request to cancel").     }     if (this.subscription != null) {         this.subscription.cancel().     } }
false;public,final;1;4;;// Publisher implementation for result notifications... @Override public final void subscribe(Subscriber<? super Void> subscriber) {     this.resultPublisher.subscribe(subscriber). }
true;protected,abstract;0;1;/**  * Create a new processor for the current flush boundary.  */ ;// Write API methods to be implemented or template methods to override... /**  * Create a new processor for the current flush boundary.  */ protected abstract Processor<? super T, Void> createWriteProcessor().
true;protected,abstract;0;1;/**  * Whether writing/flushing is possible.  */ ;/**  * Whether writing/flushing is possible.  */ protected abstract boolean isWritePossible().
true;protected,abstract;0;1;/**  * Flush the output if ready, or otherwise {@link #isFlushPending()} should  * return true after.  * <p>This is primarily for the Servlet non-blocking I/O API where flush  * cannot be called without a readyToWrite check.  */ ;/**  * Flush the output if ready, or otherwise {@link #isFlushPending()} should  * return true after.  * <p>This is primarily for the Servlet non-blocking I/O API where flush  * cannot be called without a readyToWrite check.  */ protected abstract void flush() throws IOException.
true;protected,abstract;0;1;/**  * Whether flushing is pending.  * <p>This is primarily for the Servlet non-blocking I/O API where flush  * cannot be called without a readyToWrite check.  */ ;/**  * Whether flushing is pending.  * <p>This is primarily for the Servlet non-blocking I/O API where flush  * cannot be called without a readyToWrite check.  */ protected abstract boolean isFlushPending().
true;protected;1;2;/**  * Invoked when an error happens while flushing. Sub-classes may choose  * to ignore this if they know the underlying API will provide an error  * notification in a container thread.  * <p>Defaults to no-op.  */ ;/**  * Invoked when an error happens while flushing. Sub-classes may choose  * to ignore this if they know the underlying API will provide an error  * notification in a container thread.  * <p>Defaults to no-op.  */ protected void flushingFailed(Throwable t) { }
false;private;2;7;;// Private methods for use in State... private boolean changeState(State oldState, State newState) {     boolean result = this.state.compareAndSet(oldState, newState).     if (result && rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(getLogPrefix() + oldState + " -> " + newState).     }     return result. }
false;private;0;9;;private void flushIfPossible() {     boolean result = isWritePossible().     if (rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(getLogPrefix() + "isWritePossible[" + result + "]").     }     if (result) {         onFlushPossible().     } }
false;public;2;11;;@Override public <T> void onSubscribe(AbstractListenerWriteFlushProcessor<T> processor, Subscription subscription) {     Assert.notNull(subscription, "Subscription must not be null").     if (processor.changeState(this, REQUESTED)) {         processor.subscription = subscription.         subscription.request(1).     } else {         super.onSubscribe(processor, subscription).     } }
false;public;2;10;;@Override public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> currentPublisher) {     if (processor.changeState(this, RECEIVED)) {         Processor<? super T, Void> currentProcessor = processor.createWriteProcessor().         currentPublisher.subscribe(currentProcessor).         currentProcessor.subscribe(new WriteResultSubscriber(processor)).     } }
false;public;1;9;;@Override public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {     if (processor.changeState(this, COMPLETED)) {         processor.resultPublisher.publishComplete().     } else {         processor.state.get().onComplete(processor).     } }
false;public;1;29;;@Override public <T> void writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {     try {         processor.flush().     } catch (Throwable ex) {         processor.flushingFailed(ex).         return.     }     if (processor.changeState(this, REQUESTED)) {         if (processor.subscriberCompleted) {             if (processor.isFlushPending()) {                 // Ensure the final flush                 processor.changeState(REQUESTED, FLUSHING).                 processor.flushIfPossible().             } else if (processor.changeState(REQUESTED, COMPLETED)) {                 processor.resultPublisher.publishComplete().             } else {                 processor.state.get().onComplete(processor).             }         } else {             Assert.state(processor.subscription != null, "No subscription").             processor.subscription.request(1).         }     } }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {     processor.subscriberCompleted = true. }
false;public;1;16;;@Override public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {     try {         processor.flush().     } catch (Throwable ex) {         processor.flushingFailed(ex).         return.     }     if (processor.changeState(this, COMPLETED)) {         processor.resultPublisher.publishComplete().     } else {         processor.state.get().onComplete(processor).     } }
false;public;2;4;;@Override public <T> void onNext(AbstractListenerWriteFlushProcessor<T> proc, Publisher<? extends T> pub) { // ignore }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) { // ignore }
false;public;2;4;;@Override public <T> void onNext(AbstractListenerWriteFlushProcessor<T> proc, Publisher<? extends T> pub) { // ignore }
false;public;2;4;;@Override public <T> void onError(AbstractListenerWriteFlushProcessor<T> processor, Throwable t) { // ignore }
false;public;1;4;;@Override public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) { // ignore }
false;public;2;3;;public <T> void onSubscribe(AbstractListenerWriteFlushProcessor<T> proc, Subscription subscription) {     subscription.cancel(). }
false;public;2;3;;public <T> void onNext(AbstractListenerWriteFlushProcessor<T> proc, Publisher<? extends T> pub) {     throw new IllegalStateException(toString()). }
false;public;2;8;;public <T> void onError(AbstractListenerWriteFlushProcessor<T> processor, Throwable ex) {     if (processor.changeState(this, COMPLETED)) {         processor.resultPublisher.publishError(ex).     } else {         processor.state.get().onError(processor, ex).     } }
false;public;1;3;;public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {     throw new IllegalStateException(toString()). }
false;public;1;3;;public <T> void writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {     throw new IllegalStateException(toString()). }
false;public;1;3;;public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) { // ignore }
false;public;1;4;;@Override public void onSubscribe(Subscription subscription) {     subscription.request(Long.MAX_VALUE). }
false;public;1;3;;@Override public void onNext(Void aVoid) { }
false;public;1;5;;@Override public void onError(Throwable ex) {     this.processor.cancel().     this.processor.onError(ex). }
false;public;0;7;;@Override public void onComplete() {     if (rsWriteFlushLogger.isTraceEnabled()) {         rsWriteFlushLogger.trace(this.processor.getLogPrefix() + this.processor.state + " writeComplete").     }     this.processor.state.get().writeComplete(this.processor). }
