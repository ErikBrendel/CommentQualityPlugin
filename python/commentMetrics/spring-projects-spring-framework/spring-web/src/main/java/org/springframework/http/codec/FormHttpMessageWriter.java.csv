commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the default character set to use for writing form data when the response  * Content-Type header does not explicitly specify it.  * <p>By default this is set to "UTF-8".  */ ;/**  * Set the default character set to use for writing form data when the response  * Content-Type header does not explicitly specify it.  * <p>By default this is set to "UTF-8".  */ public void setDefaultCharset(Charset charset) {     Assert.notNull(charset, "Charset must not be null").     this.defaultCharset = charset. }
true;public;0;3;/**  * Return the configured default charset.  */ ;/**  * Return the configured default charset.  */ public Charset getDefaultCharset() {     return this.defaultCharset. }
false;public;0;4;;@Override public List<MediaType> getWritableMediaTypes() {     return MEDIA_TYPES. }
false;public;2;15;;@Override public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {     if (!MultiValueMap.class.isAssignableFrom(elementType.toClass())) {         return false.     }     if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) {         // Optimistically, any MultiValueMap with or without generics         return true.     }     if (mediaType == null) {         // Only String-based MultiValueMap         return MULTIVALUE_TYPE.isAssignableFrom(elementType).     }     return false. }
false;public;5;20;;@Override public Mono<Void> write(Publisher<? extends MultiValueMap<String, String>> inputStream, ResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {     mediaType = getMediaType(mediaType).     message.getHeaders().setContentType(mediaType).     Charset charset = mediaType.getCharset().     // should never occur     Assert.notNull(charset, "No charset").     return Mono.from(inputStream).flatMap(form -> {         logFormData(form, hints).         String value = serializeForm(form, charset).         ByteBuffer byteBuffer = charset.encode(value).         DataBuffer buffer = message.bufferFactory().wrap(byteBuffer).         message.getHeaders().setContentLength(byteBuffer.remaining()).         return message.writeWith(Mono.just(buffer)).     }). }
false;private;1;11;;private MediaType getMediaType(@Nullable MediaType mediaType) {     if (mediaType == null) {         return DEFAULT_FORM_DATA_MEDIA_TYPE.     } else if (mediaType.getCharset() == null) {         return new MediaType(mediaType, getDefaultCharset()).     } else {         return mediaType.     } }
false;private;2;6;;private void logFormData(MultiValueMap<String, String> form, Map<String, Object> hints) {     LogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + "Writing " + (isEnableLoggingRequestDetails() ? LogFormatUtils.formatValue(form, !traceOn) : "form fields " + form.keySet() + " (content masked)")). }
false;protected;2;20;;protected String serializeForm(MultiValueMap<String, String> formData, Charset charset) {     StringBuilder builder = new StringBuilder().     formData.forEach((name, values) -> values.forEach(value -> {         try {             if (builder.length() != 0) {                 builder.append('&').             }             builder.append(URLEncoder.encode(name, charset.name())).             if (value != null) {                 builder.append('=').                 builder.append(URLEncoder.encode(value, charset.name())).             }         } catch (UnsupportedEncodingException ex) {             throw new IllegalStateException(ex).         }     })).     return builder.toString(). }
