commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;public String getId() {     if (this.id == null) {         this.id = initId().         if (this.id == null) {             this.id = ObjectUtils.getIdentityHexString(this).         }     }     return this.id. }
true;protected;0;4;/**  * Obtain the request id to use, or {@code null} in which case the Object  * identity of this request instance is used.  * @since 5.1  */ ;/**  * Obtain the request id to use, or {@code null} in which case the Object  * identity of this request instance is used.  * @since 5.1  */ @Nullable protected String initId() {     return null. }
false;public;0;4;;@Override public URI getURI() {     return this.uri. }
false;public;0;4;;@Override public RequestPath getPath() {     return this.path. }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return this.headers. }
false;public;0;7;;@Override public MultiValueMap<String, String> getQueryParams() {     if (this.queryParams == null) {         this.queryParams = CollectionUtils.unmodifiableMultiValueMap(initQueryParams()).     }     return this.queryParams. }
true;protected;0;15;/**  * A method for parsing of the query into name-value pairs. The return  * value is turned into an immutable map and cached.  * <p>Note that this method is invoked lazily on first access to  * {@link #getQueryParams()}. The invocation is not synchronized but the  * parsing is thread-safe nevertheless.  */ ;/**  * A method for parsing of the query into name-value pairs. The return  * value is turned into an immutable map and cached.  * <p>Note that this method is invoked lazily on first access to  * {@link #getQueryParams()}. The invocation is not synchronized but the  * parsing is thread-safe nevertheless.  */ protected MultiValueMap<String, String> initQueryParams() {     MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<>().     String query = getURI().getRawQuery().     if (query != null) {         Matcher matcher = QUERY_PATTERN.matcher(query).         while (matcher.find()) {             String name = decodeQueryParam(matcher.group(1)).             String eq = matcher.group(2).             String value = matcher.group(3).             value = (value != null ? decodeQueryParam(value) : (StringUtils.hasLength(eq) ? "" : null)).             queryParams.add(name, value).         }     }     return queryParams. }
false;private;1;13;;@SuppressWarnings("deprecation") private String decodeQueryParam(String value) {     try {         return URLDecoder.decode(value, "UTF-8").     } catch (UnsupportedEncodingException ex) {         if (logger.isWarnEnabled()) {             logger.warn(getLogPrefix() + "Could not decode query value [" + value + "] as 'UTF-8'. " + "Falling back on default encoding: " + ex.getMessage()).         }         return URLDecoder.decode(value).     } }
false;public;0;7;;@Override public MultiValueMap<String, HttpCookie> getCookies() {     if (this.cookies == null) {         this.cookies = CollectionUtils.unmodifiableMultiValueMap(initCookies()).     }     return this.cookies. }
true;protected,abstract;0;1;/**  * Obtain the cookies from the underlying "native" request and adapt those to  * an {@link HttpCookie} map. The return value is turned into an immutable  * map and cached.  * <p>Note that this method is invoked lazily on access to  * {@link #getCookies()}. Sub-classes should synchronize cookie  * initialization if the underlying "native" request does not provide  * thread-safe access to cookie data.  */ ;/**  * Obtain the cookies from the underlying "native" request and adapt those to  * an {@link HttpCookie} map. The return value is turned into an immutable  * map and cached.  * <p>Note that this method is invoked lazily on access to  * {@link #getCookies()}. Sub-classes should synchronize cookie  * initialization if the underlying "native" request does not provide  * thread-safe access to cookie data.  */ protected abstract MultiValueMap<String, HttpCookie> initCookies().
false;public;0;8;;@Nullable @Override public SslInfo getSslInfo() {     if (this.sslInfo == null) {         this.sslInfo = initSslInfo().     }     return this.sslInfo. }
true;protected,abstract;0;2;/**  * Obtain SSL session information from the underlying "native" request.  * @return the session information, or {@code null} if none available  * @since 5.0.2  */ ;/**  * Obtain SSL session information from the underlying "native" request.  * @return the session information, or {@code null} if none available  * @since 5.0.2  */ @Nullable protected abstract SslInfo initSslInfo().
true;public,abstract;0;1;/**  * Return the underlying server response.  * <p><strong>Note:</strong> This is exposed mainly for internal framework  * use such as WebSocket upgrades in the spring-webflux module.  */ ;/**  * Return the underlying server response.  * <p><strong>Note:</strong> This is exposed mainly for internal framework  * use such as WebSocket upgrades in the spring-webflux module.  */ public abstract <T> T getNativeRequest().
true;;0;6;/**  * For internal use in logging at the HTTP adapter layer.  * @since 5.1  */ ;/**  * For internal use in logging at the HTTP adapter layer.  * @since 5.1  */ String getLogPrefix() {     if (this.logPrefix == null) {         this.logPrefix = "[" + getId() + "] ".     }     return this.logPrefix. }
