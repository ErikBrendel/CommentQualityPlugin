commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setBufferFactory(DataBufferFactory bufferFactory) {     this.bufferFactory = bufferFactory. }
false;public;3;26;;@Override public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {     if (!uri.isAbsolute()) {         return Mono.error(new IllegalArgumentException("URI is not absolute: " + uri)).     }     if (!this.httpClient.isStarted()) {         try {             this.httpClient.start().         } catch (Exception ex) {             return Mono.error(ex).         }     }     JettyClientHttpRequest clientHttpRequest = new JettyClientHttpRequest(this.httpClient.newRequest(uri).method(method.toString()), this.bufferFactory).     return requestCallback.apply(clientHttpRequest).then(Mono.from(clientHttpRequest.getReactiveRequest().response((response, chunks) -> {         Flux<DataBuffer> content = Flux.from(chunks).map(this::toDataBuffer).         return Mono.just(new JettyClientHttpResponse(response, content)).     }))). }
false;private;1;14;;private DataBuffer toDataBuffer(ContentChunk chunk) {     // We must copy until this is resolved:     // https://github.com/eclipse/jetty.project/issues/2429     // Use copy instead of buffer wrapping because Callback#succeeded() is     // used not only to release the buffer but also to request more data     // which is a problem for codecs that buffer data.     DataBuffer buffer = this.bufferFactory.allocateBuffer(chunk.buffer.capacity()).     buffer.write(chunk.buffer).     chunk.callback.succeeded().     return buffer. }
