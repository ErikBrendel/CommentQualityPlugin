commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporter() throws Throwable {     doTestHttpInvokerProxyFactoryBeanAndServiceExporter(false). }
false;public;0;4;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporterWithExplicitClassLoader() throws Throwable {     doTestHttpInvokerProxyFactoryBeanAndServiceExporter(true). }
false;protected;2;11;;@Override protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {     assertEquals("http://myurl", config.getServiceUrl()).     MockHttpServletRequest request = new MockHttpServletRequest().     MockHttpServletResponse response = new MockHttpServletResponse().     request.setContent(baos.toByteArray()).     exporter.handleRequest(request, response).     return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()). }
false;private;1;65;;private void doTestHttpInvokerProxyFactoryBeanAndServiceExporter(boolean explicitClassLoader) throws Throwable {     TestBean target = new TestBean("myname", 99).     final HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter().     exporter.setServiceInterface(ITestBean.class).     exporter.setService(target).     exporter.afterPropertiesSet().     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl("http://myurl").     pfb.setHttpInvokerRequestExecutor(new AbstractHttpInvokerRequestExecutor() {          @Override         protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {             assertEquals("http://myurl", config.getServiceUrl()).             MockHttpServletRequest request = new MockHttpServletRequest().             MockHttpServletResponse response = new MockHttpServletResponse().             request.setContent(baos.toByteArray()).             exporter.handleRequest(request, response).             return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()).         }     }).     if (explicitClassLoader) {         ((BeanClassLoaderAware) pfb.getHttpInvokerRequestExecutor()).setBeanClassLoader(getClass().getClassLoader()).     }     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     assertEquals("myname", proxy.getName()).     assertEquals(99, proxy.getAge()).     proxy.setAge(50).     assertEquals(50, proxy.getAge()).     proxy.setStringArray(new String[] { "str1", "str2" }).     assertTrue(Arrays.equals(new String[] { "str1", "str2" }, proxy.getStringArray())).     proxy.setSomeIntegerArray(new Integer[] { 1, 2, 3 }).     assertTrue(Arrays.equals(new Integer[] { 1, 2, 3 }, proxy.getSomeIntegerArray())).     proxy.setNestedIntegerArray(new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } }).     Integer[][] integerArray = proxy.getNestedIntegerArray().     assertTrue(Arrays.equals(new Integer[] { 1, 2, 3 }, integerArray[0])).     assertTrue(Arrays.equals(new Integer[] { 4, 5, 6 }, integerArray[1])).     proxy.setSomeIntArray(new int[] { 1, 2, 3 }).     assertTrue(Arrays.equals(new int[] { 1, 2, 3 }, proxy.getSomeIntArray())).     proxy.setNestedIntArray(new int[][] { { 1, 2, 3 }, { 4, 5, 6 } }).     int[][] intArray = proxy.getNestedIntArray().     assertTrue(Arrays.equals(new int[] { 1, 2, 3 }, intArray[0])).     assertTrue(Arrays.equals(new int[] { 4, 5, 6 }, intArray[1])).     try {         proxy.exceptional(new IllegalStateException()).         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected     }     try {         proxy.exceptional(new IllegalAccessException()).         fail("Should have thrown IllegalAccessException").     } catch (IllegalAccessException ex) {     // expected     } }
false;public;2;5;;@Override public RemoteInvocationResult executeRequest(HttpInvokerClientConfiguration config, RemoteInvocation invocation) throws IOException {     throw new IOException("argh"). }
false;public;0;32;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporterWithIOException() throws Exception {     TestBean target = new TestBean("myname", 99).     final HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter().     exporter.setServiceInterface(ITestBean.class).     exporter.setService(target).     exporter.afterPropertiesSet().     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl("http://myurl").     pfb.setHttpInvokerRequestExecutor(new HttpInvokerRequestExecutor() {          @Override         public RemoteInvocationResult executeRequest(HttpInvokerClientConfiguration config, RemoteInvocation invocation) throws IOException {             throw new IOException("argh").         }     }).     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     try {         proxy.setAge(50).         fail("Should have thrown RemoteAccessException").     } catch (RemoteAccessException ex) {         // expected         assertTrue(ex.getCause() instanceof IOException).     } }
false;protected;2;9;;@Override protected InputStream decorateInputStream(HttpServletRequest request, InputStream is) throws IOException {     if ("gzip".equals(request.getHeader("Compression"))) {         return new GZIPInputStream(is).     } else {         return is.     } }
false;protected;3;10;;@Override protected OutputStream decorateOutputStream(HttpServletRequest request, HttpServletResponse response, OutputStream os) throws IOException {     if ("gzip".equals(request.getHeader("Compression"))) {         return new GZIPOutputStream(os).     } else {         return os.     } }
false;protected;2;18;;@Override protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws IOException, ClassNotFoundException {     assertEquals("http://myurl", config.getServiceUrl()).     MockHttpServletRequest request = new MockHttpServletRequest().     request.addHeader("Compression", "gzip").     MockHttpServletResponse response = new MockHttpServletResponse().     request.setContent(baos.toByteArray()).     try {         exporter.handleRequest(request, response).     } catch (ServletException ex) {         throw new IOException(ex.toString()).     }     return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()). }
false;protected;1;4;;@Override protected OutputStream decorateOutputStream(OutputStream os) throws IOException {     return new GZIPOutputStream(os). }
false;protected;1;4;;@Override protected InputStream decorateInputStream(InputStream is) throws IOException {     return new GZIPInputStream(is). }
false;public;0;84;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporterWithGzipCompression() throws Throwable {     TestBean target = new TestBean("myname", 99).     final HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter() {          @Override         protected InputStream decorateInputStream(HttpServletRequest request, InputStream is) throws IOException {             if ("gzip".equals(request.getHeader("Compression"))) {                 return new GZIPInputStream(is).             } else {                 return is.             }         }          @Override         protected OutputStream decorateOutputStream(HttpServletRequest request, HttpServletResponse response, OutputStream os) throws IOException {             if ("gzip".equals(request.getHeader("Compression"))) {                 return new GZIPOutputStream(os).             } else {                 return os.             }         }     }.     exporter.setServiceInterface(ITestBean.class).     exporter.setService(target).     exporter.afterPropertiesSet().     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl("http://myurl").     pfb.setHttpInvokerRequestExecutor(new AbstractHttpInvokerRequestExecutor() {          @Override         protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws IOException, ClassNotFoundException {             assertEquals("http://myurl", config.getServiceUrl()).             MockHttpServletRequest request = new MockHttpServletRequest().             request.addHeader("Compression", "gzip").             MockHttpServletResponse response = new MockHttpServletResponse().             request.setContent(baos.toByteArray()).             try {                 exporter.handleRequest(request, response).             } catch (ServletException ex) {                 throw new IOException(ex.toString()).             }             return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()).         }          @Override         protected OutputStream decorateOutputStream(OutputStream os) throws IOException {             return new GZIPOutputStream(os).         }          @Override         protected InputStream decorateInputStream(InputStream is) throws IOException {             return new GZIPInputStream(is).         }     }).     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     assertEquals("myname", proxy.getName()).     assertEquals(99, proxy.getAge()).     proxy.setAge(50).     assertEquals(50, proxy.getAge()).     try {         proxy.exceptional(new IllegalStateException()).         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected     }     try {         proxy.exceptional(new IllegalAccessException()).         fail("Should have thrown IllegalAccessException").     } catch (IllegalAccessException ex) {     // expected     } }
false;protected;1;10;;@Override protected RemoteInvocation doReadRemoteInvocation(ObjectInputStream ois) throws IOException, ClassNotFoundException {     Object obj = ois.readObject().     if (!(obj instanceof TestRemoteInvocationWrapper)) {         throw new IOException("Deserialized object needs to be assignable to type [" + TestRemoteInvocationWrapper.class.getName() + "]: " + obj).     }     return ((TestRemoteInvocationWrapper) obj).remoteInvocation. }
false;protected;2;5;;@Override protected void doWriteRemoteInvocationResult(RemoteInvocationResult result, ObjectOutputStream oos) throws IOException {     oos.writeObject(new TestRemoteInvocationResultWrapper(result)). }
false;protected;2;11;;@Override protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {     assertEquals("http://myurl", config.getServiceUrl()).     MockHttpServletRequest request = new MockHttpServletRequest().     MockHttpServletResponse response = new MockHttpServletResponse().     request.setContent(baos.toByteArray()).     exporter.handleRequest(request, response).     return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()). }
false;protected;2;4;;@Override protected void doWriteRemoteInvocation(RemoteInvocation invocation, ObjectOutputStream oos) throws IOException {     oos.writeObject(new TestRemoteInvocationWrapper(invocation)). }
false;protected;1;10;;@Override protected RemoteInvocationResult doReadRemoteInvocationResult(ObjectInputStream ois) throws IOException, ClassNotFoundException {     Object obj = ois.readObject().     if (!(obj instanceof TestRemoteInvocationResultWrapper)) {         throw new IOException("Deserialized object needs to be assignable to type [" + TestRemoteInvocationResultWrapper.class.getName() + "]: " + obj).     }     return ((TestRemoteInvocationResultWrapper) obj).remoteInvocationResult. }
false;public;0;79;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporterWithWrappedInvocations() throws Throwable {     TestBean target = new TestBean("myname", 99).     final HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter() {          @Override         protected RemoteInvocation doReadRemoteInvocation(ObjectInputStream ois) throws IOException, ClassNotFoundException {             Object obj = ois.readObject().             if (!(obj instanceof TestRemoteInvocationWrapper)) {                 throw new IOException("Deserialized object needs to be assignable to type [" + TestRemoteInvocationWrapper.class.getName() + "]: " + obj).             }             return ((TestRemoteInvocationWrapper) obj).remoteInvocation.         }          @Override         protected void doWriteRemoteInvocationResult(RemoteInvocationResult result, ObjectOutputStream oos) throws IOException {             oos.writeObject(new TestRemoteInvocationResultWrapper(result)).         }     }.     exporter.setServiceInterface(ITestBean.class).     exporter.setService(target).     exporter.afterPropertiesSet().     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl("http://myurl").     pfb.setHttpInvokerRequestExecutor(new AbstractHttpInvokerRequestExecutor() {          @Override         protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {             assertEquals("http://myurl", config.getServiceUrl()).             MockHttpServletRequest request = new MockHttpServletRequest().             MockHttpServletResponse response = new MockHttpServletResponse().             request.setContent(baos.toByteArray()).             exporter.handleRequest(request, response).             return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()).         }          @Override         protected void doWriteRemoteInvocation(RemoteInvocation invocation, ObjectOutputStream oos) throws IOException {             oos.writeObject(new TestRemoteInvocationWrapper(invocation)).         }          @Override         protected RemoteInvocationResult doReadRemoteInvocationResult(ObjectInputStream ois) throws IOException, ClassNotFoundException {             Object obj = ois.readObject().             if (!(obj instanceof TestRemoteInvocationResultWrapper)) {                 throw new IOException("Deserialized object needs to be assignable to type [" + TestRemoteInvocationResultWrapper.class.getName() + "]: " + obj).             }             return ((TestRemoteInvocationResultWrapper) obj).remoteInvocationResult.         }     }).     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     assertEquals("myname", proxy.getName()).     assertEquals(99, proxy.getAge()).     proxy.setAge(50).     assertEquals(50, proxy.getAge()).     try {         proxy.exceptional(new IllegalStateException()).         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected     }     try {         proxy.exceptional(new IllegalAccessException()).         fail("Should have thrown IllegalAccessException").     } catch (IllegalAccessException ex) {     // expected     } }
false;public;2;9;;@Override public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {     assertNotNull(invocation.getAttributes()).     assertEquals(1, invocation.getAttributes().size()).     assertEquals("myValue", invocation.getAttributes().get("myKey")).     assertEquals("myValue", invocation.getAttribute("myKey")).     return super.invoke(invocation, targetObject). }
false;public;1;17;;@Override public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {     RemoteInvocation invocation = new RemoteInvocation(methodInvocation).     invocation.addAttribute("myKey", "myValue").     try {         invocation.addAttribute("myKey", "myValue").         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected: already defined     }     assertNotNull(invocation.getAttributes()).     assertEquals(1, invocation.getAttributes().size()).     assertEquals("myValue", invocation.getAttributes().get("myKey")).     assertEquals("myValue", invocation.getAttribute("myKey")).     return invocation. }
false;protected;2;11;;@Override protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {     assertEquals("http://myurl", config.getServiceUrl()).     MockHttpServletRequest request = new MockHttpServletRequest().     MockHttpServletResponse response = new MockHttpServletResponse().     request.setContent(baos.toByteArray()).     exporter.handleRequest(request, response).     return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()). }
false;public;0;62;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporterWithInvocationAttributes() throws Exception {     TestBean target = new TestBean("myname", 99).     final HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter().     exporter.setServiceInterface(ITestBean.class).     exporter.setService(target).     exporter.setRemoteInvocationExecutor(new DefaultRemoteInvocationExecutor() {          @Override         public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {             assertNotNull(invocation.getAttributes()).             assertEquals(1, invocation.getAttributes().size()).             assertEquals("myValue", invocation.getAttributes().get("myKey")).             assertEquals("myValue", invocation.getAttribute("myKey")).             return super.invoke(invocation, targetObject).         }     }).     exporter.afterPropertiesSet().     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl("http://myurl").     pfb.setRemoteInvocationFactory(new RemoteInvocationFactory() {          @Override         public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {             RemoteInvocation invocation = new RemoteInvocation(methodInvocation).             invocation.addAttribute("myKey", "myValue").             try {                 invocation.addAttribute("myKey", "myValue").                 fail("Should have thrown IllegalStateException").             } catch (IllegalStateException ex) {             // expected: already defined             }             assertNotNull(invocation.getAttributes()).             assertEquals(1, invocation.getAttributes().size()).             assertEquals("myValue", invocation.getAttributes().get("myKey")).             assertEquals("myValue", invocation.getAttribute("myKey")).             return invocation.         }     }).     pfb.setHttpInvokerRequestExecutor(new AbstractHttpInvokerRequestExecutor() {          @Override         protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {             assertEquals("http://myurl", config.getServiceUrl()).             MockHttpServletRequest request = new MockHttpServletRequest().             MockHttpServletResponse response = new MockHttpServletResponse().             request.setContent(baos.toByteArray()).             exporter.handleRequest(request, response).             return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()).         }     }).     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     assertEquals("myname", proxy.getName()).     assertEquals(99, proxy.getAge()). }
false;public;2;8;;@Override public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {     assertTrue(invocation instanceof TestRemoteInvocation).     assertNull(invocation.getAttributes()).     assertNull(invocation.getAttribute("myKey")).     return super.invoke(invocation, targetObject). }
false;public;1;7;;@Override public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {     RemoteInvocation invocation = new TestRemoteInvocation(methodInvocation).     assertNull(invocation.getAttributes()).     assertNull(invocation.getAttribute("myKey")).     return invocation. }
false;protected;2;11;;@Override protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {     assertEquals("http://myurl", config.getServiceUrl()).     MockHttpServletRequest request = new MockHttpServletRequest().     MockHttpServletResponse response = new MockHttpServletResponse().     request.setContent(baos.toByteArray()).     exporter.handleRequest(request, response).     return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()). }
false;public;0;51;;@Test public void httpInvokerProxyFactoryBeanAndServiceExporterWithCustomInvocationObject() throws Exception {     TestBean target = new TestBean("myname", 99).     final HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter().     exporter.setServiceInterface(ITestBean.class).     exporter.setService(target).     exporter.setRemoteInvocationExecutor(new DefaultRemoteInvocationExecutor() {          @Override         public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {             assertTrue(invocation instanceof TestRemoteInvocation).             assertNull(invocation.getAttributes()).             assertNull(invocation.getAttribute("myKey")).             return super.invoke(invocation, targetObject).         }     }).     exporter.afterPropertiesSet().     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl("http://myurl").     pfb.setRemoteInvocationFactory(new RemoteInvocationFactory() {          @Override         public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {             RemoteInvocation invocation = new TestRemoteInvocation(methodInvocation).             assertNull(invocation.getAttributes()).             assertNull(invocation.getAttribute("myKey")).             return invocation.         }     }).     pfb.setHttpInvokerRequestExecutor(new AbstractHttpInvokerRequestExecutor() {          @Override         protected RemoteInvocationResult doExecuteRequest(HttpInvokerClientConfiguration config, ByteArrayOutputStream baos) throws Exception {             assertEquals("http://myurl", config.getServiceUrl()).             MockHttpServletRequest request = new MockHttpServletRequest().             MockHttpServletResponse response = new MockHttpServletResponse().             request.setContent(baos.toByteArray()).             exporter.handleRequest(request, response).             return readRemoteInvocationResult(new ByteArrayInputStream(response.getContentAsByteArray()), config.getCodebaseUrl()).         }     }).     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     assertEquals("myname", proxy.getName()).     assertEquals(99, proxy.getAge()). }
false;public;2;5;;@Override public RemoteInvocationResult executeRequest(HttpInvokerClientConfiguration config, RemoteInvocation invocation) throws IOException {     throw new IOException("argh"). }
false;public;0;34;;@Test public void httpInvokerWithSpecialLocalMethods() throws Exception {     String serviceUrl = "http://myurl".     HttpInvokerProxyFactoryBean pfb = new HttpInvokerProxyFactoryBean().     pfb.setServiceInterface(ITestBean.class).     pfb.setServiceUrl(serviceUrl).     pfb.setHttpInvokerRequestExecutor(new HttpInvokerRequestExecutor() {          @Override         public RemoteInvocationResult executeRequest(HttpInvokerClientConfiguration config, RemoteInvocation invocation) throws IOException {             throw new IOException("argh").         }     }).     pfb.afterPropertiesSet().     ITestBean proxy = (ITestBean) pfb.getObject().     // shouldn't go through to remote service     assertTrue(proxy.toString().contains("HTTP invoker")).     assertTrue(proxy.toString().contains(serviceUrl)).     assertEquals(proxy.hashCode(), proxy.hashCode()).     assertTrue(proxy.equals(proxy)).     // should go through     try {         proxy.setAge(50).         fail("Should have thrown RemoteAccessException").     } catch (RemoteAccessException ex) {         // expected         assertTrue(ex.getCause() instanceof IOException).     } }
