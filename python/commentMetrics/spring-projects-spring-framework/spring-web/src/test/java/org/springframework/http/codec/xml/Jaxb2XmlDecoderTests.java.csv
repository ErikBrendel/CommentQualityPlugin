commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Test public void canDecode() {     assertTrue(this.decoder.canDecode(ResolvableType.forClass(Pojo.class), MediaType.APPLICATION_XML)).     assertTrue(this.decoder.canDecode(ResolvableType.forClass(Pojo.class), MediaType.TEXT_XML)).     assertFalse(this.decoder.canDecode(ResolvableType.forClass(Pojo.class), MediaType.APPLICATION_JSON)).     assertTrue(this.decoder.canDecode(ResolvableType.forClass(TypePojo.class), MediaType.APPLICATION_XML)).     assertFalse(this.decoder.canDecode(ResolvableType.forClass(getClass()), MediaType.APPLICATION_XML)). }
false;public;0;21;;@Test public void splitOneBranches() {     Flux<XMLEvent> xmlEvents = this.xmlEventDecoder.decode(stringBuffer(POJO_ROOT), null, null, Collections.emptyMap()).     Flux<List<XMLEvent>> result = this.decoder.split(xmlEvents, new QName("pojo")).     StepVerifier.create(result).consumeNextWith(events -> {         assertEquals(8, events.size()).         assertStartElement(events.get(0), "pojo").         assertStartElement(events.get(1), "foo").         assertCharacters(events.get(2), "foofoo").         assertEndElement(events.get(3), "foo").         assertStartElement(events.get(4), "bar").         assertCharacters(events.get(5), "barbar").         assertEndElement(events.get(6), "bar").         assertEndElement(events.get(7), "pojo").     }).expectComplete().verify(). }
false;public;0;33;;@Test public void splitMultipleBranches() throws Exception {     Flux<XMLEvent> xmlEvents = this.xmlEventDecoder.decode(stringBuffer(POJO_CHILD), null, null, Collections.emptyMap()).     Flux<List<XMLEvent>> result = this.decoder.split(xmlEvents, new QName("pojo")).     StepVerifier.create(result).consumeNextWith(events -> {         assertEquals(8, events.size()).         assertStartElement(events.get(0), "pojo").         assertStartElement(events.get(1), "foo").         assertCharacters(events.get(2), "foo").         assertEndElement(events.get(3), "foo").         assertStartElement(events.get(4), "bar").         assertCharacters(events.get(5), "bar").         assertEndElement(events.get(6), "bar").         assertEndElement(events.get(7), "pojo").     }).consumeNextWith(events -> {         assertEquals(8, events.size()).         assertStartElement(events.get(0), "pojo").         assertStartElement(events.get(1), "foo").         assertCharacters(events.get(2), "foofoo").         assertEndElement(events.get(3), "foo").         assertStartElement(events.get(4), "bar").         assertCharacters(events.get(5), "barbar").         assertEndElement(events.get(6), "bar").         assertEndElement(events.get(7), "pojo").     }).expectComplete().verify(). }
false;private,static;2;4;;private static void assertStartElement(XMLEvent event, String expectedLocalName) {     assertTrue(event.isStartElement()).     assertEquals(expectedLocalName, event.asStartElement().getName().getLocalPart()). }
false;private,static;2;4;;private static void assertEndElement(XMLEvent event, String expectedLocalName) {     assertTrue(event.isEndElement()).     assertEquals(expectedLocalName, event.asEndElement().getName().getLocalPart()). }
false;private,static;2;4;;private static void assertCharacters(XMLEvent event, String expectedData) {     assertTrue(event.isCharacters()).     assertEquals(expectedData, event.asCharacters().getData()). }
false;public;0;11;;@Test public void decodeSingleXmlRootElement() throws Exception {     Mono<DataBuffer> source = stringBuffer(POJO_ROOT).     Mono<Object> output = this.decoder.decodeToMono(source, ResolvableType.forClass(Pojo.class), null, Collections.emptyMap()).     StepVerifier.create(output).expectNext(new Pojo("foofoo", "barbar")).expectComplete().verify(). }
false;public;0;11;;@Test public void decodeSingleXmlTypeElement() throws Exception {     Mono<DataBuffer> source = stringBuffer(POJO_ROOT).     Mono<Object> output = this.decoder.decodeToMono(source, ResolvableType.forClass(TypePojo.class), null, Collections.emptyMap()).     StepVerifier.create(output).expectNext(new TypePojo("foofoo", "barbar")).expectComplete().verify(). }
false;public;0;12;;@Test public void decodeMultipleXmlRootElement() throws Exception {     Mono<DataBuffer> source = stringBuffer(POJO_CHILD).     Flux<Object> output = this.decoder.decode(source, ResolvableType.forClass(Pojo.class), null, Collections.emptyMap()).     StepVerifier.create(output).expectNext(new Pojo("foo", "bar")).expectNext(new Pojo("foofoo", "barbar")).expectComplete().verify(). }
false;public;0;12;;@Test public void decodeMultipleXmlTypeElement() throws Exception {     Mono<DataBuffer> source = stringBuffer(POJO_CHILD).     Flux<Object> output = this.decoder.decode(source, ResolvableType.forClass(TypePojo.class), null, Collections.emptyMap()).     StepVerifier.create(output).expectNext(new TypePojo("foo", "bar")).expectNext(new TypePojo("foofoo", "barbar")).expectComplete().verify(). }
false;public;0;13;;@Test public void decodeError() throws Exception {     Flux<DataBuffer> source = Flux.concat(stringBuffer("<pojo>"), Flux.error(new RuntimeException())).     Mono<Object> output = this.decoder.decodeToMono(source, ResolvableType.forClass(Pojo.class), null, Collections.emptyMap()).     StepVerifier.create(output).expectError(RuntimeException.class).verify(). }
false;public;0;20;;@Test public void toExpectedQName() {     assertEquals(new QName("pojo"), this.decoder.toQName(Pojo.class)).     assertEquals(new QName("pojo"), this.decoder.toQName(TypePojo.class)).     assertEquals(new QName("namespace", "name"), this.decoder.toQName(XmlRootElementWithNameAndNamespace.class)).     assertEquals(new QName("namespace", "name"), this.decoder.toQName(XmlRootElementWithName.class)).     assertEquals(new QName("namespace", "xmlRootElement"), this.decoder.toQName(XmlRootElement.class)).     assertEquals(new QName("namespace", "name"), this.decoder.toQName(XmlTypeWithNameAndNamespace.class)).     assertEquals(new QName("namespace", "name"), this.decoder.toQName(XmlTypeWithName.class)).     assertEquals(new QName("namespace", "xmlType"), this.decoder.toQName(XmlType.class)). }
false;private;1;8;;private Mono<DataBuffer> stringBuffer(String value) {     return Mono.defer(() -> {         byte[] bytes = value.getBytes(StandardCharsets.UTF_8).         DataBuffer buffer = this.bufferFactory.allocateBuffer(bytes.length).         buffer.write(bytes).         return Mono.just(buffer).     }). }
false;public;0;3;;public String getFoo() {     return this.foo. }
false;public;1;3;;public void setFoo(String foo) {     this.foo = foo. }
false;public;0;3;;public String getBar() {     return this.bar. }
false;public;1;3;;public void setBar(String bar) {     this.bar = bar. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o instanceof TypePojo) {         TypePojo other = (TypePojo) o.         return this.foo.equals(other.foo) && this.bar.equals(other.bar).     }     return false. }
false;public;0;6;;@Override public int hashCode() {     int result = this.foo.hashCode().     result = 31 * result + this.bar.hashCode().     return result. }
