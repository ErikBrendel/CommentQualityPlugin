commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;public Consumer<DataBuffer> pojoConsumer(Pojo expected) {     return dataBuffer -> {         try {             Pojo actual = this.mapper.reader().forType(Pojo.class).readValue(DataBufferTestUtils.dumpBytes(dataBuffer)).             assertEquals(expected, actual).             release(dataBuffer).         } catch (IOException ex) {             throw new UncheckedIOException(ex).         }     }. }
false;public;0;11;;@Override @Test public void canEncode() {     ResolvableType pojoType = ResolvableType.forClass(Pojo.class).     assertTrue(this.encoder.canEncode(pojoType, SMILE_MIME_TYPE)).     assertTrue(this.encoder.canEncode(pojoType, STREAM_SMILE_MIME_TYPE)).     assertTrue(this.encoder.canEncode(pojoType, null)).     // SPR-15464     assertTrue(this.encoder.canEncode(ResolvableType.NONE, null)). }
false;public;0;8;;@Test public void canNotEncode() {     assertFalse(this.encoder.canEncode(ResolvableType.forClass(String.class), null)).     assertFalse(this.encoder.canEncode(ResolvableType.forClass(Pojo.class), APPLICATION_XML)).     ResolvableType sseType = ResolvableType.forClass(ServerSentEvent.class).     assertFalse(this.encoder.canEncode(sseType, SMILE_MIME_TYPE)). }
false;public;0;13;;@Override @Test public void encode() {     List<Pojo> list = Arrays.asList(new Pojo("foo", "bar"), new Pojo("foofoo", "barbar"), new Pojo("foofoofoo", "barbarbar")).     Flux<Pojo> input = Flux.fromIterable(list).     testEncode(input, Pojo.class, step -> step.consumeNextWith(expect(list, List.class))). }
false;public;0;9;;@Test public void encodeError() throws Exception {     Mono<Pojo> input = Mono.error(new InputException()).     testEncode(input, Pojo.class, step -> step.expectError(InputException.class).verify()). }
false;public;0;15;;@Test public void encodeAsStream() throws Exception {     Pojo pojo1 = new Pojo("foo", "bar").     Pojo pojo2 = new Pojo("foofoo", "barbar").     Pojo pojo3 = new Pojo("foofoofoo", "barbarbar").     Flux<Pojo> input = Flux.just(pojo1, pojo2, pojo3).     ResolvableType type = ResolvableType.forClass(Pojo.class).     testEncodeAll(input, type, step -> step.consumeNextWith(expect(pojo1, Pojo.class)).consumeNextWith(expect(pojo2, Pojo.class)).consumeNextWith(expect(pojo3, Pojo.class)).verifyComplete(), STREAM_SMILE_MIME_TYPE, null). }
false;private;2;16;;private <T> Consumer<DataBuffer> expect(T expected, Class<T> expectedType) {     return dataBuffer -> {         try {             Object actual = this.mapper.reader().forType(expectedType).readValue(dataBuffer.asInputStream()).             assertEquals(expected, actual).         } catch (IOException e) {             throw new UncheckedIOException(e).         } finally {             release(dataBuffer).         }     }. }
