commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override @Test public void canDecode() {     assertTrue(decoder.canDecode(forClass(Pojo.class), SMILE_MIME_TYPE)).     assertTrue(decoder.canDecode(forClass(Pojo.class), STREAM_SMILE_MIME_TYPE)).     assertTrue(decoder.canDecode(forClass(Pojo.class), null)).     assertFalse(decoder.canDecode(forClass(String.class), null)).     assertFalse(decoder.canDecode(forClass(Pojo.class), APPLICATION_JSON)). }
false;public;0;12;;@Override public void decode() {     Flux<DataBuffer> input = Flux.just(this.pojo1, this.pojo2).map(this::writeObject).flatMap(this::dataBuffer).     testDecodeAll(input, Pojo.class, step -> step.expectNext(pojo1).expectNext(pojo2).verifyComplete()). }
false;private;1;9;;private byte[] writeObject(Object o) {     try {         return this.mapper.writer().writeValueAsBytes(o).     } catch (JsonProcessingException e) {         throw new AssertionError(e).     } }
false;public;0;14;;@Override public void decodeToMono() {     List<Pojo> expected = Arrays.asList(pojo1, pojo2).     Flux<DataBuffer> input = Flux.just(expected).map(this::writeObject).flatMap(this::dataBuffer).     ResolvableType elementType = ResolvableType.forClassWithGenerics(List.class, Pojo.class).     testDecodeToMono(input, elementType, step -> step.expectNext(expected).expectComplete().verify(), null, null). }
