commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Override @Test public void canEncode() {     ResolvableType pojoType = ResolvableType.forClass(Pojo.class).     assertTrue(this.encoder.canEncode(pojoType, APPLICATION_JSON)).     assertTrue(this.encoder.canEncode(pojoType, APPLICATION_JSON_UTF8)).     assertTrue(this.encoder.canEncode(pojoType, APPLICATION_STREAM_JSON)).     assertTrue(this.encoder.canEncode(pojoType, null)).     // SPR-15464     assertTrue(this.encoder.canEncode(ResolvableType.NONE, null)).     // SPR-15910     assertFalse(this.encoder.canEncode(ResolvableType.forClass(Object.class), APPLICATION_OCTET_STREAM)). }
false;public;0;15;;@Override public void encode() throws Exception {     Flux<Object> input = Flux.just(new Pojo("foo", "bar"), new Pojo("foofoo", "barbar"), new Pojo("foofoofoo", "barbarbar")).     testEncodeAll(input, ResolvableType.forClass(Pojo.class), step -> step.consumeNextWith(expectString("{\"foo\":\"foo\",\"bar\":\"bar\"}\n")).consumeNextWith(expectString("{\"foo\":\"foofoo\",\"bar\":\"barbar\"}\n")).consumeNextWith(expectString("{\"foo\":\"foofoofoo\",\"bar\":\"barbarbar\"}\n")).verifyComplete(), APPLICATION_STREAM_JSON, null). }
false;public;0;7;;// SPR-15866 @Test public void canEncodeWithCustomMimeType() {     MimeType textJavascript = new MimeType("text", "javascript", StandardCharsets.UTF_8).     Jackson2JsonEncoder encoder = new Jackson2JsonEncoder(new ObjectMapper(), textJavascript).     assertEquals(Collections.singletonList(textJavascript), encoder.getEncodableMimeTypes()). }
false;public;0;7;;@Test(expected = UnsupportedOperationException.class) public void encodableMimeTypesIsImmutable() {     MimeType textJavascript = new MimeType("text", "javascript", StandardCharsets.UTF_8).     Jackson2JsonEncoder encoder = new Jackson2JsonEncoder(new ObjectMapper(), textJavascript).     encoder.getMimeTypes().add(new MimeType("text", "ecmascript")). }
false;public;0;8;;@Test public void canNotEncode() {     assertFalse(this.encoder.canEncode(ResolvableType.forClass(String.class), null)).     assertFalse(this.encoder.canEncode(ResolvableType.forClass(Pojo.class), APPLICATION_XML)).     ResolvableType sseType = ResolvableType.forClass(ServerSentEvent.class).     assertFalse(this.encoder.canEncode(sseType, APPLICATION_JSON)). }
false;public;0;16;;@Test public void encodeNonStream() {     Flux<Pojo> input = Flux.just(new Pojo("foo", "bar"), new Pojo("foofoo", "barbar"), new Pojo("foofoofoo", "barbarbar")).     testEncode(input, Pojo.class, step -> step.consumeNextWith(expectString("[" + "{\"foo\":\"foo\",\"bar\":\"bar\"}," + "{\"foo\":\"foofoo\",\"bar\":\"barbar\"}," + "{\"foo\":\"foofoofoo\",\"bar\":\"barbarbar\"}]").andThen(DataBufferUtils::release)).verifyComplete()). }
false;public;0;9;;@Test public void encodeWithType() {     Flux<ParentClass> input = Flux.just(new Foo(), new Bar()).     testEncode(input, ParentClass.class, step -> step.consumeNextWith(expectString("[{\"type\":\"foo\"},{\"type\":\"bar\"}]").andThen(DataBufferUtils::release)).verifyComplete()). }
false;public;0;21;;// SPR-15727 @Test public void encodeAsStreamWithCustomStreamingType() {     MediaType fooMediaType = new MediaType("application", "foo").     MediaType barMediaType = new MediaType("application", "bar").     this.encoder.setStreamingMediaTypes(Arrays.asList(fooMediaType, barMediaType)).     Flux<Pojo> input = Flux.just(new Pojo("foo", "bar"), new Pojo("foofoo", "barbar"), new Pojo("foofoofoo", "barbarbar")).     testEncode(input, ResolvableType.forClass(Pojo.class), step -> step.consumeNextWith(expectString("{\"foo\":\"foo\",\"bar\":\"bar\"}\n").andThen(DataBufferUtils::release)).consumeNextWith(expectString("{\"foo\":\"foofoo\",\"bar\":\"barbar\"}\n").andThen(DataBufferUtils::release)).consumeNextWith(expectString("{\"foo\":\"foofoofoo\",\"bar\":\"barbarbar\"}\n").andThen(DataBufferUtils::release)).verifyComplete(), barMediaType, null). }
false;public;0;17;;@Test public void fieldLevelJsonView() {     JacksonViewBean bean = new JacksonViewBean().     bean.setWithView1("with").     bean.setWithView2("with").     bean.setWithoutView("without").     Mono<JacksonViewBean> input = Mono.just(bean).     ResolvableType type = ResolvableType.forClass(JacksonViewBean.class).     Map<String, Object> hints = singletonMap(JSON_VIEW_HINT, MyJacksonView1.class).     testEncode(input, type, step -> step.consumeNextWith(expectString("{\"withView1\":\"with\"}").andThen(DataBufferUtils::release)).verifyComplete(), null, hints). }
false;public;0;17;;@Test public void classLevelJsonView() {     JacksonViewBean bean = new JacksonViewBean().     bean.setWithView1("with").     bean.setWithView2("with").     bean.setWithoutView("without").     Mono<JacksonViewBean> input = Mono.just(bean).     ResolvableType type = ResolvableType.forClass(JacksonViewBean.class).     Map<String, Object> hints = singletonMap(JSON_VIEW_HINT, MyJacksonView3.class).     testEncode(input, type, step -> step.consumeNextWith(expectString("{\"withoutView\":\"without\"}").andThen(DataBufferUtils::release)).verifyComplete(), null, hints). }
