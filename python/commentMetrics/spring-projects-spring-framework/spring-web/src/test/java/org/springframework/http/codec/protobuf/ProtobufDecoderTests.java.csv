commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void extensionRegistryNull() {     new ProtobufDecoder(null). }
false;public;0;9;;@Override @Test public void canDecode() {     assertTrue(this.decoder.canDecode(forClass(Msg.class), null)).     assertTrue(this.decoder.canDecode(forClass(Msg.class), PROTOBUF_MIME_TYPE)).     assertTrue(this.decoder.canDecode(forClass(Msg.class), MediaType.APPLICATION_OCTET_STREAM)).     assertFalse(this.decoder.canDecode(forClass(Msg.class), MediaType.APPLICATION_JSON)).     assertFalse(this.decoder.canDecode(forClass(Object.class), PROTOBUF_MIME_TYPE)). }
false;public;0;9;;@Override @Test public void decodeToMono() {     Mono<DataBuffer> input = dataBuffer(this.testMsg1).     testDecodeToMonoAll(input, Msg.class, step -> step.expectNext(this.testMsg1).verifyComplete()). }
false;public;0;17;;@Test public void decodeChunksToMono() {     byte[] full = this.testMsg1.toByteArray().     byte[] chunk1 = Arrays.copyOfRange(full, 0, full.length / 2).     byte[] chunk2 = Arrays.copyOfRange(full, chunk1.length, full.length).     Flux<DataBuffer> input = Flux.just(chunk1, chunk2).flatMap(bytes -> Mono.defer(() -> {         DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length).         dataBuffer.write(bytes).         return Mono.just(dataBuffer).     })).     testDecodeToMono(input, Msg.class, step -> step.expectNext(this.testMsg1).verifyComplete()). }
false;public;0;21;;@Override @Test public void decode() {     Flux<DataBuffer> input = Flux.just(this.testMsg1, this.testMsg2).flatMap(msg -> Mono.defer(() -> {         DataBuffer buffer = this.bufferFactory.allocateBuffer().         try {             msg.writeDelimitedTo(buffer.asOutputStream()).             return Mono.just(buffer).         } catch (IOException e) {             release(buffer).             return Mono.error(e).         }     })).     testDecodeAll(input, Msg.class, step -> step.expectNext(this.testMsg1).expectNext(this.testMsg2).verifyComplete()). }
false;public;0;32;;@Test public void decodeSplitChunks() {     Flux<DataBuffer> input = Flux.just(this.testMsg1, this.testMsg2).flatMap(msg -> Mono.defer(() -> {         DataBuffer buffer = this.bufferFactory.allocateBuffer().         try {             msg.writeDelimitedTo(buffer.asOutputStream()).             return Mono.just(buffer).         } catch (IOException e) {             release(buffer).             return Mono.error(e).         }     })).flatMap(buffer -> {         int len = buffer.readableByteCount() / 2.         Flux<DataBuffer> result = Flux.just(DataBufferUtils.retain(buffer.slice(0, len)), DataBufferUtils.retain(buffer.slice(len, buffer.readableByteCount() - len))).         release(buffer).         return result.     }).     testDecode(input, Msg.class, step -> step.expectNext(this.testMsg1).expectNext(this.testMsg2).verifyComplete()). }
false;public;0;37;;// SPR-17429 @Test public void decodeSplitMessageSize() {     this.decoder.setMaxMessageSize(100009).     StringBuilder builder = new StringBuilder().     for (int i = 0. i < 10000. i++) {         builder.append("azertyuiop").     }     Msg bigMessage = Msg.newBuilder().setFoo(builder.toString()).setBlah(secondMsg2).build().     Flux<DataBuffer> input = Flux.just(bigMessage, bigMessage).flatMap(msg -> Mono.defer(() -> {         DataBuffer buffer = this.bufferFactory.allocateBuffer().         try {             msg.writeDelimitedTo(buffer.asOutputStream()).             return Mono.just(buffer).         } catch (IOException e) {             release(buffer).             return Mono.error(e).         }     })).flatMap(buffer -> {         int len = 2.         Flux<DataBuffer> result = Flux.just(DataBufferUtils.retain(buffer.slice(0, len)), DataBufferUtils.retain(buffer.slice(len, buffer.readableByteCount() - len))).         release(buffer).         return result.     }).     testDecode(input, Msg.class, step -> step.expectNext(bigMessage).expectNext(bigMessage).verifyComplete()). }
false;public;0;14;;@Test public void decodeMergedChunks() throws IOException {     DataBuffer buffer = this.bufferFactory.allocateBuffer().     this.testMsg1.writeDelimitedTo(buffer.asOutputStream()).     this.testMsg1.writeDelimitedTo(buffer.asOutputStream()).     ResolvableType elementType = forClass(Msg.class).     Flux<Message> messages = this.decoder.decode(Mono.just(buffer), elementType, null, emptyMap()).     StepVerifier.create(messages).expectNext(testMsg1).expectNext(testMsg1).verifyComplete(). }
false;public;0;8;;@Test public void exceedMaxSize() {     this.decoder.setMaxMessageSize(1).     Mono<DataBuffer> input = dataBuffer(this.testMsg1).     testDecode(input, Msg.class, step -> step.verifyError(DecodingException.class)). }
false;private;1;8;;private Mono<DataBuffer> dataBuffer(Msg msg) {     return Mono.defer(() -> {         byte[] bytes = msg.toByteArray().         DataBuffer buffer = this.bufferFactory.allocateBuffer(bytes.length).         buffer.write(bytes).         return Mono.just(buffer).     }). }
