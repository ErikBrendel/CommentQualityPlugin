commented;modifiers;parameterAmount;loc;comment;code
false;public;1;11;;public void addDispatchHandler(Runnable handler) {     Assert.notNull(handler, "Dispatch handler must not be null").     synchronized (this) {         if (this.dispatchedPath == null) {             this.dispatchHandlers.add(handler).         } else {             handler.run().         }     } }
false;public;0;4;;@Override public ServletRequest getRequest() {     return this.request. }
false;public;0;5;;@Override @Nullable public ServletResponse getResponse() {     return this.response. }
false;public;0;4;;@Override public boolean hasOriginalRequestAndResponse() {     return (this.request instanceof MockHttpServletRequest && this.response instanceof MockHttpServletResponse). }
false;public;0;4;;@Override public void dispatch() {     dispatch(this.request.getRequestURI()). }
false;public;1;4;;@Override public void dispatch(String path) {     dispatch(null, path). }
false;public;2;7;;@Override public void dispatch(@Nullable ServletContext context, String path) {     synchronized (this) {         this.dispatchedPath = path.         this.dispatchHandlers.forEach(Runnable::run).     } }
false;public;0;4;;@Nullable public String getDispatchedPath() {     return this.dispatchedPath. }
false;public;0;15;;@Override public void complete() {     MockHttpServletRequest mockRequest = WebUtils.getNativeRequest(this.request, MockHttpServletRequest.class).     if (mockRequest != null) {         mockRequest.setAsyncStarted(false).     }     for (AsyncListener listener : this.listeners) {         try {             listener.onComplete(new AsyncEvent(this, this.request, this.response)).         } catch (IOException ex) {             throw new IllegalStateException("AsyncListener failure", ex).         }     } }
false;public;1;4;;@Override public void start(Runnable runnable) {     runnable.run(). }
false;public;1;4;;@Override public void addListener(AsyncListener listener) {     this.listeners.add(listener). }
false;public;3;4;;@Override public void addListener(AsyncListener listener, ServletRequest request, ServletResponse response) {     this.listeners.add(listener). }
false;public;0;3;;public List<AsyncListener> getListeners() {     return this.listeners. }
false;public;1;4;;@Override public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException {     return BeanUtils.instantiateClass(clazz). }
true;public;1;4;/**  * By default this is set to 10000 (10 seconds) even though the Servlet API  * specifies a default async request timeout of 30 seconds. Keep in mind the  * timeout could further be impacted by global configuration through the MVC  * Java config or the XML namespace, as well as be overridden per request on  * {@link org.springframework.web.context.request.async.DeferredResult DeferredResult}  * or on  * {@link org.springframework.web.servlet.mvc.method.annotation.SseEmitter SseEmitter}.  * @param timeout the timeout value to use.  * @see AsyncContext#setTimeout(long)  */ ;/**  * By default this is set to 10000 (10 seconds) even though the Servlet API  * specifies a default async request timeout of 30 seconds. Keep in mind the  * timeout could further be impacted by global configuration through the MVC  * Java config or the XML namespace, as well as be overridden per request on  * {@link org.springframework.web.context.request.async.DeferredResult DeferredResult}  * or on  * {@link org.springframework.web.servlet.mvc.method.annotation.SseEmitter SseEmitter}.  * @param timeout the timeout value to use.  * @see AsyncContext#setTimeout(long)  */ @Override public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;4;;@Override public long getTimeout() {     return this.timeout. }
