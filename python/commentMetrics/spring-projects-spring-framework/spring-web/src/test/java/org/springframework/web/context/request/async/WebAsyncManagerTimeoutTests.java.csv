commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Before public void setup() {     this.servletRequest = new MockHttpServletRequest("GET", "/test").     this.servletRequest.setAsyncSupported(true).     this.servletResponse = new MockHttpServletResponse().     this.asyncWebRequest = new StandardServletAsyncWebRequest(servletRequest, servletResponse).     AsyncTaskExecutor executor = mock(AsyncTaskExecutor.class).     this.asyncManager = WebAsyncUtils.getAsyncManager(servletRequest).     this.asyncManager.setTaskExecutor(executor).     this.asyncManager.setAsyncWebRequest(this.asyncWebRequest). }
false;public;0;19;;@Test public void startCallableProcessingTimeoutAndComplete() throws Exception {     StubCallable callable = new StubCallable().     CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class).     given(interceptor.handleTimeout(this.asyncWebRequest, callable)).willReturn(RESULT_NONE).     this.asyncManager.registerCallableInterceptor("interceptor", interceptor).     this.asyncManager.startCallableProcessing(callable).     this.asyncWebRequest.onTimeout(ASYNC_EVENT).     this.asyncWebRequest.onComplete(ASYNC_EVENT).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(AsyncRequestTimeoutException.class, this.asyncManager.getConcurrentResult().getClass()).     verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, callable).     verify(interceptor).afterCompletion(this.asyncWebRequest, callable). }
false;public;0;4;;@Override public Object call() throws Exception {     return 7. }
false;public;0;20;;@Test public void startCallableProcessingTimeoutAndResumeThroughCallback() throws Exception {     StubCallable callable = new StubCallable().     WebAsyncTask<Object> webAsyncTask = new WebAsyncTask<>(callable).     webAsyncTask.onTimeout(new Callable<Object>() {          @Override         public Object call() throws Exception {             return 7.         }     }).     this.asyncManager.startCallableProcessing(webAsyncTask).     this.asyncWebRequest.onTimeout(ASYNC_EVENT).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(7, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()). }
false;public;0;19;;@Test public void startCallableProcessingTimeoutAndResumeThroughInterceptor() throws Exception {     StubCallable callable = new StubCallable().     CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class).     given(interceptor.handleTimeout(this.asyncWebRequest, callable)).willReturn(22).     this.asyncManager.registerCallableInterceptor("timeoutInterceptor", interceptor).     this.asyncManager.startCallableProcessing(callable).     this.asyncWebRequest.onTimeout(ASYNC_EVENT).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(22, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()).     verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, callable). }
false;public;0;20;;@Test public void startCallableProcessingAfterTimeoutException() throws Exception {     StubCallable callable = new StubCallable().     Exception exception = new Exception().     CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class).     given(interceptor.handleTimeout(this.asyncWebRequest, callable)).willThrow(exception).     this.asyncManager.registerCallableInterceptor("timeoutInterceptor", interceptor).     this.asyncManager.startCallableProcessing(callable).     this.asyncWebRequest.onTimeout(ASYNC_EVENT).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(exception, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()).     verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, callable). }
false;public;0;20;;@SuppressWarnings("unchecked") @Test public void startCallableProcessingTimeoutAndCheckThreadInterrupted() throws Exception {     StubCallable callable = new StubCallable().     Future future = mock(Future.class).     AsyncTaskExecutor executor = mock(AsyncTaskExecutor.class).     when(executor.submit(any(Runnable.class))).thenReturn(future).     this.asyncManager.setTaskExecutor(executor).     this.asyncManager.startCallableProcessing(callable).     this.asyncWebRequest.onTimeout(ASYNC_EVENT).     assertTrue(this.asyncManager.hasConcurrentResult()).     verify(future).cancel(true).     verifyNoMoreInteractions(future). }
false;public;0;21;;@Test public void startDeferredResultProcessingTimeoutAndComplete() throws Exception {     DeferredResult<Integer> deferredResult = new DeferredResult<>().     DeferredResultProcessingInterceptor interceptor = mock(DeferredResultProcessingInterceptor.class).     given(interceptor.handleTimeout(this.asyncWebRequest, deferredResult)).willReturn(true).     this.asyncManager.registerDeferredResultInterceptor("interceptor", interceptor).     this.asyncManager.startDeferredResultProcessing(deferredResult).     this.asyncWebRequest.onTimeout(ASYNC_EVENT).     this.asyncWebRequest.onComplete(ASYNC_EVENT).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(AsyncRequestTimeoutException.class, this.asyncManager.getConcurrentResult().getClass()).     verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, deferredResult).     verify(interceptor).preProcess(this.asyncWebRequest, deferredResult).     verify(interceptor).afterCompletion(this.asyncWebRequest, deferredResult). }
false;public;0;13;;@Test public void startDeferredResultProcessingTimeoutAndResumeWithDefaultResult() throws Exception {     DeferredResult<Integer> deferredResult = new DeferredResult<>(null, 23).     this.asyncManager.startDeferredResultProcessing(deferredResult).     AsyncEvent event = null.     this.asyncWebRequest.onTimeout(event).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(23, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()). }
false;public;0;4;;@Override public void run() {     deferredResult.setResult(23). }
false;public;0;20;;@Test public void startDeferredResultProcessingTimeoutAndResumeThroughCallback() throws Exception {     final DeferredResult<Integer> deferredResult = new DeferredResult<>().     deferredResult.onTimeout(new Runnable() {          @Override         public void run() {             deferredResult.setResult(23).         }     }).     this.asyncManager.startDeferredResultProcessing(deferredResult).     AsyncEvent event = null.     this.asyncWebRequest.onTimeout(event).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(23, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()). }
false;public;2;5;;@Override public <T> boolean handleTimeout(NativeWebRequest request, DeferredResult<T> result) throws Exception {     result.setErrorResult(23).     return true. }
false;public;0;23;;@Test public void startDeferredResultProcessingTimeoutAndResumeThroughInterceptor() throws Exception {     DeferredResult<Integer> deferredResult = new DeferredResult<>().     DeferredResultProcessingInterceptor interceptor = new DeferredResultProcessingInterceptor() {          @Override         public <T> boolean handleTimeout(NativeWebRequest request, DeferredResult<T> result) throws Exception {             result.setErrorResult(23).             return true.         }     }.     this.asyncManager.registerDeferredResultInterceptor("interceptor", interceptor).     this.asyncManager.startDeferredResultProcessing(deferredResult).     AsyncEvent event = null.     this.asyncWebRequest.onTimeout(event).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(23, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()). }
false;public;2;4;;@Override public <T> boolean handleTimeout(NativeWebRequest request, DeferredResult<T> result) throws Exception {     throw exception. }
false;public;0;23;;@Test public void startDeferredResultProcessingAfterTimeoutException() throws Exception {     DeferredResult<Integer> deferredResult = new DeferredResult<>().     final Exception exception = new Exception().     DeferredResultProcessingInterceptor interceptor = new DeferredResultProcessingInterceptor() {          @Override         public <T> boolean handleTimeout(NativeWebRequest request, DeferredResult<T> result) throws Exception {             throw exception.         }     }.     this.asyncManager.registerDeferredResultInterceptor("interceptor", interceptor).     this.asyncManager.startDeferredResultProcessing(deferredResult).     AsyncEvent event = null.     this.asyncWebRequest.onTimeout(event).     assertTrue(this.asyncManager.hasConcurrentResult()).     assertEquals(exception, this.asyncManager.getConcurrentResult()).     assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath()). }
false;public;0;4;;@Override public Object call() throws Exception {     return 21. }
