commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Override @Test public void canEncode() {     assertTrue(this.encoder.canEncode(forClass(Msg.class), null)).     assertTrue(this.encoder.canEncode(forClass(Msg.class), PROTOBUF_MIME_TYPE)).     assertTrue(this.encoder.canEncode(forClass(Msg.class), MediaType.APPLICATION_OCTET_STREAM)).     assertFalse(this.encoder.canEncode(forClass(Msg.class), MediaType.APPLICATION_JSON)).     assertFalse(this.encoder.canEncode(forClass(Object.class), PROTOBUF_MIME_TYPE)). }
false;public;0;20;;@Override @Test public void encode() {     Mono<Message> input = Mono.just(this.msg1).     testEncodeAll(input, Msg.class, step -> step.consumeNextWith(dataBuffer -> {         try {             assertEquals(this.msg1, Msg.parseFrom(dataBuffer.asInputStream())).         } catch (IOException ex) {             throw new UncheckedIOException(ex).         } finally {             DataBufferUtils.release(dataBuffer).         }     }).verifyComplete()). }
false;public;0;9;;@Test public void encodeStream() {     Flux<Message> input = Flux.just(this.msg1, this.msg2).     testEncodeAll(input, Msg.class, step -> step.consumeNextWith(expect(this.msg1)).consumeNextWith(expect(this.msg2)).verifyComplete()). }
false;protected,final;1;14;;protected final Consumer<DataBuffer> expect(Msg msg) {     return dataBuffer -> {         try {             assertEquals(msg, Msg.parseDelimitedFrom(dataBuffer.asInputStream())).         } catch (IOException ex) {             throw new UncheckedIOException(ex).         } finally {             DataBufferUtils.release(dataBuffer).         }     }. }
