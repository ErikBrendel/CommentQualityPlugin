commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Configure a custom handler to consume the response body.  * <p>By default, response body content is consumed in full and cached for  * subsequent access in tests. Use this option to take control over how the  * response body is consumed.  * @param writeHandler the write handler to use returning {@code Mono<Void>}  * when the body has been "written" (i.e. consumed).  */ ;/**  * Configure a custom handler to consume the response body.  * <p>By default, response body content is consumed in full and cached for  * subsequent access in tests. Use this option to take control over how the  * response body is consumed.  * @param writeHandler the write handler to use returning {@code Mono<Void>}  * when the body has been "written" (i.e. consumed).  */ public void setWriteHandler(Function<Flux<DataBuffer>, Mono<Void>> writeHandler) {     Assert.notNull(writeHandler, "'writeHandler' is required").     this.body = Flux.error(new IllegalStateException("Not available with custom write handler.")).     this.writeHandler = writeHandler. }
false;public;0;4;;@Override public <T> T getNativeResponse() {     throw new IllegalStateException("This is a mock. No running server, no native response."). }
false;protected;0;3;;@Override protected void applyStatusCode() { }
false;protected;0;3;;@Override protected void applyHeaders() { }
false;protected;0;5;;@Override protected void applyCookies() {     getCookies().values().stream().flatMap(Collection::stream).forEach(cookie -> getHeaders().add(HttpHeaders.SET_COOKIE, cookie.toString())). }
false;protected;1;4;;@Override protected Mono<Void> writeWithInternal(Publisher<? extends DataBuffer> body) {     return this.writeHandler.apply(Flux.from(body)). }
false;protected;1;6;;@Override protected Mono<Void> writeAndFlushWithInternal(Publisher<? extends Publisher<? extends DataBuffer>> body) {     return this.writeHandler.apply(Flux.from(body).concatMap(Flux::from)). }
false;public;0;4;;@Override public Mono<Void> setComplete() {     return doCommit(() -> Mono.defer(() -> this.writeHandler.apply(Flux.empty()))). }
true;public;0;3;/**  * Return the response body or an error stream if the body was not set.  */ ;/**  * Return the response body or an error stream if the body was not set.  */ public Flux<DataBuffer> getBody() {     return this.body. }
true;public;0;13;/**  * Aggregate response data and convert to a String using the "Content-Type"  * charset or "UTF-8" by default.  */ ;/**  * Aggregate response data and convert to a String using the "Content-Type"  * charset or "UTF-8" by default.  */ public Mono<String> getBodyAsString() {     Charset charset = Optional.ofNullable(getHeaders().getContentType()).map(MimeType::getCharset).orElse(StandardCharsets.UTF_8).     return getBody().reduce(bufferFactory().allocateBuffer(), (previous, current) -> {         previous.write(current).         DataBufferUtils.release(current).         return previous.     }).map(buffer -> bufferToString(buffer, charset)). }
false;private,static;2;6;;private static String bufferToString(DataBuffer buffer, Charset charset) {     Assert.notNull(charset, "'charset' must not be null").     byte[] bytes = new byte[buffer.readableByteCount()].     buffer.read(bytes).     return new String(bytes, charset). }
