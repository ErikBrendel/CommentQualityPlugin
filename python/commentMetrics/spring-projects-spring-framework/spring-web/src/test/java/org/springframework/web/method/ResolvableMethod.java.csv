commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the resolved method.  */ ;/**  * Return the resolved method.  */ public Method method() {     return this.method. }
true;public;0;3;/**  * Return the declared return type of the resolved method.  */ ;/**  * Return the declared return type of the resolved method.  */ public MethodParameter returnType() {     return new SynthesizingMethodParameter(this.method, -1). }
true;public;2;3;/**  * Find a unique argument matching the given type.  * @param type the expected type  * @param generics optional array of generic types  */ ;/**  * Find a unique argument matching the given type.  * @param type the expected type  * @param generics optional array of generic types  */ public MethodParameter arg(Class<?> type, Class<?>... generics) {     return new ArgResolver().arg(type, generics). }
true;public;3;3;/**  * Find a unique argument matching the given type.  * @param type the expected type  * @param generic at least one generic type  * @param generics optional array of generic types  */ ;/**  * Find a unique argument matching the given type.  * @param type the expected type  * @param generic at least one generic type  * @param generics optional array of generic types  */ public MethodParameter arg(Class<?> type, ResolvableType generic, ResolvableType... generics) {     return new ArgResolver().arg(type, generic, generics). }
true;public;1;3;/**  * Find a unique argument matching the given type.  * @param type the expected type  */ ;/**  * Find a unique argument matching the given type.  * @param type the expected type  */ public MethodParameter arg(ResolvableType type) {     return new ArgResolver().arg(type). }
true;public,final;1;4;/**  * Filter on method arguments with annotation.  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ ;/**  * Filter on method arguments with annotation.  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ @SafeVarargs public final ArgResolver annot(Predicate<MethodParameter>... filter) {     return new ArgResolver(filter). }
false;public,final;1;4;;@SafeVarargs public final ArgResolver annotPresent(Class<? extends Annotation>... annotationTypes) {     return new ArgResolver().annotPresent(annotationTypes). }
true;public,final;1;4;/**  * Filter on method arguments that don't have the given annotation type(s).  * @param annotationTypes the annotation types  */ ;/**  * Filter on method arguments that don't have the given annotation type(s).  * @param annotationTypes the annotation types  */ @SafeVarargs public final ArgResolver annotNotPresent(Class<? extends Annotation>... annotationTypes) {     return new ArgResolver().annotNotPresent(annotationTypes). }
false;public;0;4;;@Override public String toString() {     return "ResolvableMethod=" + formatMethod(). }
false;private;0;6;;private String formatMethod() {     return (method().getName() + Arrays.stream(this.method.getParameters()).map(this::formatParameter).collect(joining(",\n\t", "(\n\t", "\n)"))). }
false;private;1;6;;private String formatParameter(Parameter param) {     Annotation[] anns = param.getAnnotations().     return (anns.length > 0 ? Arrays.stream(anns).map(this::formatAnnotation).collect(joining(",", "[", "]")) + " " + param : param.toString()). }
false;private;1;9;;private String formatAnnotation(Annotation annotation) {     Map<String, Object> map = AnnotationUtils.getAnnotationAttributes(annotation).     map.forEach((key, value) -> {         if (value.equals(DEFAULT_VALUE_NONE)) {             map.put(key, "NONE").         }     }).     return annotation.annotationType().getName() + map. }
false;private,static;2;4;;private static ResolvableType toResolvableType(Class<?> type, Class<?>... generics) {     return (ObjectUtils.isEmpty(generics) ? ResolvableType.forClass(type) : ResolvableType.forClassWithGenerics(type, generics)). }
false;private,static;3;6;;private static ResolvableType toResolvableType(Class<?> type, ResolvableType generic, ResolvableType... generics) {     ResolvableType[] genericTypes = new ResolvableType[generics.length + 1].     genericTypes[0] = generic.     System.arraycopy(generics, 0, genericTypes, 1, generics.length).     return ResolvableType.forClassWithGenerics(type, genericTypes). }
true;public,static;1;3;/**  * Create a {@code ResolvableMethod} builder for the given handler class.  */ ;/**  * Create a {@code ResolvableMethod} builder for the given handler class.  */ public static <T> Builder<T> on(Class<T> objectClass) {     return new Builder<>(objectClass). }
false;private;2;3;;private void addFilter(String message, Predicate<Method> filter) {     this.filters.add(new LabeledPredicate<>(message, filter)). }
true;public;1;4;/**  * Filter on methods with the given name.  */ ;/**  * Filter on methods with the given name.  */ public Builder<T> named(String methodName) {     addFilter("methodName=" + methodName, method -> method.getName().equals(methodName)).     return this. }
true;public;1;6;/**  * Filter on methods with the given parameter types.  */ ;/**  * Filter on methods with the given parameter types.  */ public Builder<T> argTypes(Class<?>... argTypes) {     addFilter("argTypes=" + Arrays.toString(argTypes), method -> ObjectUtils.isEmpty(argTypes) ? method.getParameterCount() == 0 : Arrays.equals(method.getParameterTypes(), argTypes)).     return this. }
true;public,final;1;5;/**  * Filter on annotated methods.  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ ;/**  * Filter on annotated methods.  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ @SafeVarargs public final Builder<T> annot(Predicate<Method>... filters) {     this.filters.addAll(Arrays.asList(filters)).     return this. }
true;public,final;1;8;/**  * Filter on methods annotated with the given annotation type.  * @see #annot(Predicate[])  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ ;/**  * Filter on methods annotated with the given annotation type.  * @see #annot(Predicate[])  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ @SafeVarargs public final Builder<T> annotPresent(Class<? extends Annotation>... annotationTypes) {     String message = "annotationPresent=" + Arrays.toString(annotationTypes).     addFilter(message, method -> Arrays.stream(annotationTypes).allMatch(annotType -> AnnotatedElementUtils.findMergedAnnotation(method, annotType) != null)).     return this. }
true;public,final;1;14;/**  * Filter on methods not annotated with the given annotation type.  */ ;/**  * Filter on methods not annotated with the given annotation type.  */ @SafeVarargs public final Builder<T> annotNotPresent(Class<? extends Annotation>... annotationTypes) {     String message = "annotationNotPresent=" + Arrays.toString(annotationTypes).     addFilter(message, method -> {         if (annotationTypes.length != 0) {             return Arrays.stream(annotationTypes).noneMatch(annotType -> AnnotatedElementUtils.findMergedAnnotation(method, annotType) != null).         } else {             return method.getAnnotations().length == 0.         }     }).     return this. }
true;public;2;3;/**  * Filter on methods returning the given type.  * @param returnType the return type  * @param generics optional array of generic types  */ ;/**  * Filter on methods returning the given type.  * @param returnType the return type  * @param generics optional array of generic types  */ public Builder<T> returning(Class<?> returnType, Class<?>... generics) {     return returning(toResolvableType(returnType, generics)). }
true;public;3;3;/**  * Filter on methods returning the given type with generics.  * @param returnType the return type  * @param generic at least one generic type  * @param generics optional extra generic types  */ ;/**  * Filter on methods returning the given type with generics.  * @param returnType the return type  * @param generic at least one generic type  * @param generics optional extra generic types  */ public Builder<T> returning(Class<?> returnType, ResolvableType generic, ResolvableType... generics) {     return returning(toResolvableType(returnType, generic, generics)). }
true;public;1;6;/**  * Filter on methods returning the given type.  * @param returnType the return type  */ ;/**  * Filter on methods returning the given type.  * @param returnType the return type  */ public Builder<T> returning(ResolvableType returnType) {     String expected = returnType.toString().     String message = "returnType=" + expected.     addFilter(message, m -> expected.equals(ResolvableType.forMethodReturnType(m).toString())).     return this. }
true;public;0;6;/**  * Build a {@code ResolvableMethod} from the provided filters which must  * resolve to a unique, single method.  * <p>See additional resolveXxx shortcut methods going directly to  * {@link Method} or return type parameter.  * @throws IllegalStateException for no match or multiple matches  */ ;/**  * Build a {@code ResolvableMethod} from the provided filters which must  * resolve to a unique, single method.  * <p>See additional resolveXxx shortcut methods going directly to  * {@link Method} or return type parameter.  * @throws IllegalStateException for no match or multiple matches  */ public ResolvableMethod build() {     Set<Method> methods = MethodIntrospector.selectMethods(this.objectClass, this::isMatch).     Assert.state(!methods.isEmpty(), () -> "No matching method: " + this).     Assert.state(methods.size() == 1, () -> "Multiple matching methods: " + this + formatMethods(methods)).     return new ResolvableMethod(methods.iterator().next()). }
false;private;1;3;;private boolean isMatch(Method method) {     return this.filters.stream().allMatch(p -> p.test(method)). }
false;private;1;4;;private String formatMethods(Set<Method> methods) {     return "\nMatched:\n" + methods.stream().map(Method::toGenericString).collect(joining(",\n\t", "[\n\t", "\n]")). }
false;public;1;7;;public ResolvableMethod mockCall(Consumer<T> invoker) {     MethodInvocationInterceptor interceptor = new MethodInvocationInterceptor().     T proxy = initProxy(this.objectClass, interceptor).     invoker.accept(proxy).     Method method = interceptor.getInvokedMethod().     return new ResolvableMethod(method). }
true;public,final;0;3;/**  * Resolve and return the {@code Method} equivalent to:  * <p>{@code build().method()}  */ ;// Build & resolve shortcuts... /**  * Resolve and return the {@code Method} equivalent to:  * <p>{@code build().method()}  */ public final Method resolveMethod() {     return build().method(). }
true;public;1;3;/**  * Resolve and return the {@code Method} equivalent to:  * <p>{@code named(methodName).build().method()}  */ ;/**  * Resolve and return the {@code Method} equivalent to:  * <p>{@code named(methodName).build().method()}  */ public Method resolveMethod(String methodName) {     return named(methodName).build().method(). }
true;public,final;0;3;/**  * Resolve and return the declared return type equivalent to:  * <p>{@code build().returnType()}  */ ;/**  * Resolve and return the declared return type equivalent to:  * <p>{@code build().returnType()}  */ public final MethodParameter resolveReturnType() {     return build().returnType(). }
true;public;2;3;/**  * Shortcut to the unique return type equivalent to:  * <p>{@code returning(returnType).build().returnType()}  * @param returnType the return type  * @param generics optional array of generic types  */ ;/**  * Shortcut to the unique return type equivalent to:  * <p>{@code returning(returnType).build().returnType()}  * @param returnType the return type  * @param generics optional array of generic types  */ public MethodParameter resolveReturnType(Class<?> returnType, Class<?>... generics) {     return returning(returnType, generics).build().returnType(). }
true;public;3;5;/**  * Shortcut to the unique return type equivalent to:  * <p>{@code returning(returnType).build().returnType()}  * @param returnType the return type  * @param generic at least one generic type  * @param generics optional extra generic types  */ ;/**  * Shortcut to the unique return type equivalent to:  * <p>{@code returning(returnType).build().returnType()}  * @param returnType the return type  * @param generic at least one generic type  * @param generics optional extra generic types  */ public MethodParameter resolveReturnType(Class<?> returnType, ResolvableType generic, ResolvableType... generics) {     return returning(returnType, generic, generics).build().returnType(). }
false;public;1;3;;public MethodParameter resolveReturnType(ResolvableType returnType) {     return returning(returnType).build().returnType(). }
false;public;0;6;;@Override public String toString() {     return "ResolvableMethod.Builder[\n" + "\tobjectClass = " + this.objectClass.getName() + ",\n" + "\tfilters = " + formatFilters() + "\n]". }
false;private;0;4;;private String formatFilters() {     return this.filters.stream().map(Object::toString).collect(joining(",\n\t\t", "[\n\t\t", "\n\t]")). }
false;public;1;4;;@Override public boolean test(T method) {     return this.delegate.test(method). }
false;public;1;4;;@Override public Predicate<T> and(Predicate<? super T> other) {     return this.delegate.and(other). }
false;public;0;4;;@Override public Predicate<T> negate() {     return this.delegate.negate(). }
false;public;1;4;;@Override public Predicate<T> or(Predicate<? super T> other) {     return this.delegate.or(other). }
false;public;0;4;;@Override public String toString() {     return this.label. }
true;public,final;1;5;/**  * Filter on method arguments with annotations.  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ ;/**  * Filter on method arguments with annotations.  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ @SafeVarargs public final ArgResolver annot(Predicate<MethodParameter>... filters) {     this.filters.addAll(Arrays.asList(filters)).     return this. }
true;public,final;1;5;/**  * Filter on method arguments that have the given annotations.  * @param annotationTypes the annotation types  * @see #annot(Predicate[])  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ ;/**  * Filter on method arguments that have the given annotations.  * @param annotationTypes the annotation types  * @see #annot(Predicate[])  * See {@link org.springframework.web.method.MvcAnnotationPredicates}.  */ @SafeVarargs public final ArgResolver annotPresent(Class<? extends Annotation>... annotationTypes) {     this.filters.add(param -> Arrays.stream(annotationTypes).allMatch(param::hasParameterAnnotation)).     return this. }
true;public,final;1;8;/**  * Filter on method arguments that don't have the given annotations.  * @param annotationTypes the annotation types  */ ;/**  * Filter on method arguments that don't have the given annotations.  * @param annotationTypes the annotation types  */ @SafeVarargs public final ArgResolver annotNotPresent(Class<? extends Annotation>... annotationTypes) {     this.filters.add(param -> (annotationTypes.length > 0 ? Arrays.stream(annotationTypes).noneMatch(param::hasParameterAnnotation) : param.getParameterAnnotations().length == 0)).     return this. }
true;public;2;3;/**  * Resolve the argument also matching to the given type.  * @param type the expected type  */ ;/**  * Resolve the argument also matching to the given type.  * @param type the expected type  */ public MethodParameter arg(Class<?> type, Class<?>... generics) {     return arg(toResolvableType(type, generics)). }
true;public;3;3;/**  * Resolve the argument also matching to the given type.  * @param type the expected type  */ ;/**  * Resolve the argument also matching to the given type.  * @param type the expected type  */ public MethodParameter arg(Class<?> type, ResolvableType generic, ResolvableType... generics) {     return arg(toResolvableType(type, generic, generics)). }
true;public;1;4;/**  * Resolve the argument also matching to the given type.  * @param type the expected type  */ ;/**  * Resolve the argument also matching to the given type.  * @param type the expected type  */ public MethodParameter arg(ResolvableType type) {     this.filters.add(p -> type.toString().equals(ResolvableType.forMethodParameter(p).toString())).     return arg(). }
true;public,final;0;8;/**  * Resolve the argument.  */ ;/**  * Resolve the argument.  */ public final MethodParameter arg() {     List<MethodParameter> matches = applyFilters().     Assert.state(!matches.isEmpty(), () -> "No matching arg in method\n" + formatMethod()).     Assert.state(matches.size() == 1, () -> "Multiple matching args in method\n" + formatMethod() + "\nMatches:\n\t" + matches).     return matches.get(0). }
false;private;0;11;;private List<MethodParameter> applyFilters() {     List<MethodParameter> matches = new ArrayList<>().     for (int i = 0. i < method.getParameterCount(). i++) {         MethodParameter param = new SynthesizingMethodParameter(method, i).         param.initParameterNameDiscovery(nameDiscoverer).         if (this.filters.stream().allMatch(p -> p.test(param))) {             matches.add(param).         }     }     return matches. }
false;;0;3;;Method getInvokedMethod() {     return this.invokedMethod. }
false;public;4;11;;@Override @Nullable public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) {     if (ReflectionUtils.isObjectMethod(method)) {         return ReflectionUtils.invokeMethod(method, object, args).     } else {         this.invokedMethod = method.         return null.     } }
false;public;1;5;;@Override @Nullable public Object invoke(org.aopalliance.intercept.MethodInvocation inv) throws Throwable {     return intercept(inv.getThis(), inv.getMethod(), inv.getArguments(), null). }
false;private,static;2;44;;@SuppressWarnings("unchecked") private static <T> T initProxy(Class<?> type, MethodInvocationInterceptor interceptor) {     Assert.notNull(type, "'type' must not be null").     if (type.isInterface()) {         ProxyFactory factory = new ProxyFactory(EmptyTargetSource.INSTANCE).         factory.addInterface(type).         factory.addInterface(Supplier.class).         factory.addAdvice(interceptor).         return (T) factory.getProxy().     } else {         Enhancer enhancer = new Enhancer().         enhancer.setSuperclass(type).         enhancer.setInterfaces(new Class<?>[] { Supplier.class }).         enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE).         enhancer.setCallbackType(org.springframework.cglib.proxy.MethodInterceptor.class).         Class<?> proxyClass = enhancer.createClass().         Object proxy = null.         if (objenesis.isWorthTrying()) {             try {                 proxy = objenesis.newInstance(proxyClass, enhancer.getUseCache()).             } catch (ObjenesisException ex) {                 logger.debug("Objenesis failed, falling back to default constructor", ex).             }         }         if (proxy == null) {             try {                 proxy = ReflectionUtils.accessibleConstructor(proxyClass).newInstance().             } catch (Throwable ex) {                 throw new IllegalStateException("Unable to instantiate proxy " + "via both Objenesis and default constructor fails as well", ex).             }         }         ((Factory) proxy).setCallbacks(new Callback[] { interceptor }).         return (T) proxy.     } }
