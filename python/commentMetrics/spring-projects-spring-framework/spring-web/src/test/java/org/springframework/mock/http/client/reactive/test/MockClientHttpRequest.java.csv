commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Configure a custom handler for writing the request body.  *  * <p>The default write handler consumes and caches the request body so it  * may be accessed subsequently, e.g. in test assertions. Use this property  * when the request body is an infinite stream.  *  * @param writeHandler the write handler to use returning {@code Mono<Void>}  * when the body has been "written" (i.e. consumed).  */ ;/**  * Configure a custom handler for writing the request body.  *  * <p>The default write handler consumes and caches the request body so it  * may be accessed subsequently, e.g. in test assertions. Use this property  * when the request body is an infinite stream.  *  * @param writeHandler the write handler to use returning {@code Mono<Void>}  * when the body has been "written" (i.e. consumed).  */ public void setWriteHandler(Function<Flux<DataBuffer>, Mono<Void>> writeHandler) {     Assert.notNull(writeHandler, "'writeHandler' is required").     this.writeHandler = writeHandler. }
false;public;0;4;;@Override public HttpMethod getMethod() {     return this.httpMethod. }
false;public;0;4;;@Override public URI getURI() {     return this.url. }
false;public;0;4;;@Override public DataBufferFactory bufferFactory() {     return this.bufferFactory. }
false;protected;0;3;;@Override protected void applyHeaders() { }
false;protected;0;5;;@Override protected void applyCookies() {     getCookies().values().stream().flatMap(Collection::stream).forEach(cookie -> getHeaders().add(HttpHeaders.COOKIE, cookie.toString())). }
false;public;1;4;;@Override public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {     return doCommit(() -> Mono.defer(() -> this.writeHandler.apply(Flux.from(body)))). }
false;public;1;4;;@Override public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {     return writeWith(Flux.from(body).flatMap(p -> p)). }
false;public;0;4;;@Override public Mono<Void> setComplete() {     return writeWith(Flux.empty()). }
true;public;0;3;/**  * Return the request body, or an error stream if the body was never set  * or when {@link #setWriteHandler} is configured.  */ ;/**  * Return the request body, or an error stream if the body was never set  * or when {@link #setWriteHandler} is configured.  */ public Flux<DataBuffer> getBody() {     return this.body. }
true;public;0;13;/**  * Aggregate response data and convert to a String using the "Content-Type"  * charset or "UTF-8" by default.  */ ;/**  * Aggregate response data and convert to a String using the "Content-Type"  * charset or "UTF-8" by default.  */ public Mono<String> getBodyAsString() {     Charset charset = Optional.ofNullable(getHeaders().getContentType()).map(MimeType::getCharset).orElse(StandardCharsets.UTF_8).     return getBody().reduce(bufferFactory().allocateBuffer(), (previous, current) -> {         previous.write(current).         DataBufferUtils.release(current).         return previous.     }).map(buffer -> bufferToString(buffer, charset)). }
false;private,static;2;6;;private static String bufferToString(DataBuffer buffer, Charset charset) {     Assert.notNull(charset, "'charset' must not be null").     byte[] bytes = new byte[buffer.readableByteCount()].     buffer.read(bytes).     return new String(bytes, charset). }
