commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Override @Test public void canDecode() {     assertTrue(decoder.canDecode(forClass(Pojo.class), APPLICATION_JSON)).     assertTrue(decoder.canDecode(forClass(Pojo.class), APPLICATION_JSON_UTF8)).     assertTrue(decoder.canDecode(forClass(Pojo.class), APPLICATION_STREAM_JSON)).     assertTrue(decoder.canDecode(forClass(Pojo.class), null)).     assertFalse(decoder.canDecode(forClass(String.class), null)).     assertFalse(decoder.canDecode(forClass(Pojo.class), APPLICATION_XML)). }
false;public;0;7;;// SPR-15866 @Test public void canDecodeWithProvidedMimeType() {     MimeType textJavascript = new MimeType("text", "javascript", StandardCharsets.UTF_8).     Jackson2JsonDecoder decoder = new Jackson2JsonDecoder(new ObjectMapper(), textJavascript).     assertEquals(Collections.singletonList(textJavascript), decoder.getDecodableMimeTypes()). }
false;public;0;7;;@Test(expected = UnsupportedOperationException.class) public void decodableMimeTypesIsImmutable() {     MimeType textJavascript = new MimeType("text", "javascript", StandardCharsets.UTF_8).     Jackson2JsonDecoder decoder = new Jackson2JsonDecoder(new ObjectMapper(), textJavascript).     decoder.getMimeTypes().add(new MimeType("text", "ecmascript")). }
false;public;0;12;;@Override @Test public void decode() {     Flux<DataBuffer> input = Flux.concat(stringBuffer("[{\"bar\":\"b1\",\"foo\":\"f1\"},"), stringBuffer("{\"bar\":\"b2\",\"foo\":\"f2\"}]")).     testDecodeAll(input, Pojo.class, step -> step.expectNext(pojo1).expectNext(pojo2).verifyComplete()). }
false;public;0;13;;@Override public void decodeToMono() {     Flux<DataBuffer> input = Flux.concat(stringBuffer("[{\"bar\":\"b1\",\"foo\":\"f1\"},"), stringBuffer("{\"bar\":\"b2\",\"foo\":\"f2\"}]")).     ResolvableType elementType = ResolvableType.forClassWithGenerics(List.class, Pojo.class).     testDecodeToMonoAll(input, elementType, step -> step.expectNext(asList(new Pojo("f1", "b1"), new Pojo("f2", "b2"))).expectComplete().verify(), null, null). }
false;public;0;6;;@Test public void decodeEmptyArrayToFlux() {     Flux<DataBuffer> input = Flux.from(stringBuffer("[]")).     testDecode(input, Pojo.class, step -> step.verifyComplete()). }
false;public;0;15;;@Test public void fieldLevelJsonView() {     Flux<DataBuffer> input = Flux.from(stringBuffer("{\"withView1\" : \"with\", \"withView2\" : \"with\", \"withoutView\" : \"without\"}")).     ResolvableType elementType = forClass(JacksonViewBean.class).     Map<String, Object> hints = singletonMap(JSON_VIEW_HINT, MyJacksonView1.class).     testDecode(input, elementType, step -> step.consumeNextWith(o -> {         JacksonViewBean b = (JacksonViewBean) o.         assertEquals("with", b.getWithView1()).         assertNull(b.getWithView2()).         assertNull(b.getWithoutView()).     }), null, hints). }
false;public;0;16;;@Test public void classLevelJsonView() {     Flux<DataBuffer> input = Flux.from(stringBuffer("{\"withView1\" : \"with\", \"withView2\" : \"with\", \"withoutView\" : \"without\"}")).     ResolvableType elementType = forClass(JacksonViewBean.class).     Map<String, Object> hints = singletonMap(JSON_VIEW_HINT, MyJacksonView3.class).     testDecode(input, elementType, step -> step.consumeNextWith(o -> {         JacksonViewBean b = (JacksonViewBean) o.         assertEquals("without", b.getWithoutView()).         assertNull(b.getWithView1()).         assertNull(b.getWithView2()).     }).verifyComplete(), null, hints). }
false;public;0;7;;@Test public void invalidData() {     Flux<DataBuffer> input = Flux.from(stringBuffer("{\"foofoo\": \"foofoo\", \"barbar\": \"barbar\"")).     testDecode(input, Pojo.class, step -> step.verifyError(DecodingException.class)). }
false;public;0;7;;// gh-22042 @Test public void decodeWithNullLiteral() {     Flux<Object> result = this.decoder.decode(Flux.concat(stringBuffer("null")), ResolvableType.forType(Pojo.class), MediaType.APPLICATION_JSON, Collections.emptyMap()).     StepVerifier.create(result).expectComplete().verify(). }
false;public;0;8;;@Test public void noDefaultConstructor() {     Flux<DataBuffer> input = Flux.from(stringBuffer("{\"property1\":\"foo\",\"property2\":\"bar\"}")).     ResolvableType elementType = forClass(BeanWithNoDefaultConstructor.class).     Flux<Object> flux = new Jackson2JsonDecoder().decode(input, elementType, null, emptyMap()).     StepVerifier.create(flux).verifyError(CodecException.class). }
false;public;0;9;;// SPR-15975 @Test public void customDeserializer() {     Mono<DataBuffer> input = stringBuffer("{\"test\": 1}").     testDecode(input, TestObject.class, step -> step.consumeNextWith(o -> assertEquals(1, o.getTest())).verifyComplete()). }
false;private;1;8;;private Mono<DataBuffer> stringBuffer(String value) {     return Mono.defer(() -> {         byte[] bytes = value.getBytes(StandardCharsets.UTF_8).         DataBuffer buffer = this.bufferFactory.allocateBuffer(bytes.length).         buffer.write(bytes).         return Mono.just(buffer).     }). }
false;public;0;3;;public String getProperty1() {     return this.property1. }
false;public;0;3;;public String getProperty2() {     return this.property2. }
false;public;0;3;;public int getTest() {     return this.test. }
false;public;1;3;;public void setTest(int test) {     this.test = test. }
false;public;2;8;;@Override public TestObject deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {     JsonNode node = p.readValueAsTree().     TestObject result = new TestObject().     result.setTest(node.get("test").asInt()).     return result. }
