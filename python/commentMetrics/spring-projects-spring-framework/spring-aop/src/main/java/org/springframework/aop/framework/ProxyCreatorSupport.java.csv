commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Customize the AopProxyFactory, allowing different strategies  * to be dropped in without changing the core framework.  * <p>Default is {@link DefaultAopProxyFactory}, using dynamic JDK  * proxies or CGLIB proxies based on the requirements.  */ ;/**  * Customize the AopProxyFactory, allowing different strategies  * to be dropped in without changing the core framework.  * <p>Default is {@link DefaultAopProxyFactory}, using dynamic JDK  * proxies or CGLIB proxies based on the requirements.  */ public void setAopProxyFactory(AopProxyFactory aopProxyFactory) {     Assert.notNull(aopProxyFactory, "AopProxyFactory must not be null").     this.aopProxyFactory = aopProxyFactory. }
true;public;0;3;/**  * Return the AopProxyFactory that this ProxyConfig uses.  */ ;/**  * Return the AopProxyFactory that this ProxyConfig uses.  */ public AopProxyFactory getAopProxyFactory() {     return this.aopProxyFactory. }
true;public;1;4;/**  * Add the given AdvisedSupportListener to this proxy configuration.  * @param listener the listener to register  */ ;/**  * Add the given AdvisedSupportListener to this proxy configuration.  * @param listener the listener to register  */ public void addListener(AdvisedSupportListener listener) {     Assert.notNull(listener, "AdvisedSupportListener must not be null").     this.listeners.add(listener). }
true;public;1;4;/**  * Remove the given AdvisedSupportListener from this proxy configuration.  * @param listener the listener to deregister  */ ;/**  * Remove the given AdvisedSupportListener from this proxy configuration.  * @param listener the listener to deregister  */ public void removeListener(AdvisedSupportListener listener) {     Assert.notNull(listener, "AdvisedSupportListener must not be null").     this.listeners.remove(listener). }
true;protected,final,synchronized;0;6;/**  * Subclasses should call this to get a new AOP proxy. They should <b>not</b>  * create an AOP proxy with {@code this} as an argument.  */ ;/**  * Subclasses should call this to get a new AOP proxy. They should <b>not</b>  * create an AOP proxy with {@code this} as an argument.  */ protected final synchronized AopProxy createAopProxy() {     if (!this.active) {         activate().     }     return getAopProxyFactory().createAopProxy(this). }
true;private;0;6;/**  * Activate this proxy configuration.  * @see AdvisedSupportListener#activated  */ ;/**  * Activate this proxy configuration.  * @see AdvisedSupportListener#activated  */ private void activate() {     this.active = true.     for (AdvisedSupportListener listener : this.listeners) {         listener.activated(this).     } }
true;protected;0;11;/**  * Propagate advice change event to all AdvisedSupportListeners.  * @see AdvisedSupportListener#adviceChanged  */ ;/**  * Propagate advice change event to all AdvisedSupportListeners.  * @see AdvisedSupportListener#adviceChanged  */ @Override protected void adviceChanged() {     super.adviceChanged().     synchronized (this) {         if (this.active) {             for (AdvisedSupportListener listener : this.listeners) {                 listener.adviceChanged(this).             }         }     } }
true;protected,final,synchronized;0;3;/**  * Subclasses can call this to check whether any AOP proxies have been created yet.  */ ;/**  * Subclasses can call this to check whether any AOP proxies have been created yet.  */ protected final synchronized boolean isActive() {     return this.active. }
