commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public boolean matches(Method method, Class<?> targetClass) {     if (matchesMethod(method)) {         return true.     }     // Proxy classes never have annotations on their redeclared methods.     if (Proxy.isProxyClass(targetClass)) {         return false.     }     // The method may be on an interface, so let's check on the target class as well.     Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass).     return (specificMethod != method && matchesMethod(specificMethod)). }
false;private;1;4;;private boolean matchesMethod(Method method) {     return (this.checkInherited ? AnnotatedElementUtils.hasAnnotation(method, this.annotationType) : method.isAnnotationPresent(this.annotationType)). }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof AnnotationMethodMatcher)) {         return false.     }     AnnotationMethodMatcher otherMm = (AnnotationMethodMatcher) other.     return this.annotationType.equals(otherMm.annotationType). }
false;public;0;4;;@Override public int hashCode() {     return this.annotationType.hashCode(). }
false;public;0;4;;@Override public String toString() {     return getClass().getName() + ": " + this.annotationType. }
