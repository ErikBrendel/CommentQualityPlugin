commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Add the supplied aspect instance to the chain. The type of the aspect instance  * supplied must be a singleton aspect. True singleton lifecycle is not honoured when  * using this method - the caller is responsible for managing the lifecycle of any  * aspects added in this way.  * @param aspectInstance the AspectJ aspect instance  */ ;/**  * Add the supplied aspect instance to the chain. The type of the aspect instance  * supplied must be a singleton aspect. True singleton lifecycle is not honoured when  * using this method - the caller is responsible for managing the lifecycle of any  * aspects added in this way.  * @param aspectInstance the AspectJ aspect instance  */ public void addAspect(Object aspectInstance) {     Class<?> aspectClass = aspectInstance.getClass().     String aspectName = aspectClass.getName().     AspectMetadata am = createAspectMetadata(aspectClass, aspectName).     if (am.getAjType().getPerClause().getKind() != PerClauseKind.SINGLETON) {         throw new IllegalArgumentException("Aspect class [" + aspectClass.getName() + "] does not define a singleton aspect").     }     addAdvisorsFromAspectInstanceFactory(new SingletonMetadataAwareAspectInstanceFactory(aspectInstance, aspectName)). }
true;public;1;6;/**  * Add an aspect of the supplied type to the end of the advice chain.  * @param aspectClass the AspectJ aspect class  */ ;/**  * Add an aspect of the supplied type to the end of the advice chain.  * @param aspectClass the AspectJ aspect class  */ public void addAspect(Class<?> aspectClass) {     String aspectName = aspectClass.getName().     AspectMetadata am = createAspectMetadata(aspectClass, aspectName).     MetadataAwareAspectInstanceFactory instanceFactory = createAspectInstanceFactory(am, aspectClass, aspectName).     addAdvisorsFromAspectInstanceFactory(instanceFactory). }
true;private;1;9;/**  * Add all {@link Advisor Advisors} from the supplied {@link MetadataAwareAspectInstanceFactory}  * to the current chain. Exposes any special purpose {@link Advisor Advisors} if needed.  * @see AspectJProxyUtils#makeAdvisorChainAspectJCapableIfNecessary(List)  */ ;/**  * Add all {@link Advisor Advisors} from the supplied {@link MetadataAwareAspectInstanceFactory}  * to the current chain. Exposes any special purpose {@link Advisor Advisors} if needed.  * @see AspectJProxyUtils#makeAdvisorChainAspectJCapableIfNecessary(List)  */ private void addAdvisorsFromAspectInstanceFactory(MetadataAwareAspectInstanceFactory instanceFactory) {     List<Advisor> advisors = this.aspectFactory.getAdvisors(instanceFactory).     Class<?> targetClass = getTargetClass().     Assert.state(targetClass != null, "Unresolvable target class").     advisors = AopUtils.findAdvisorsThatCanApply(advisors, targetClass).     AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(advisors).     AnnotationAwareOrderComparator.sort(advisors).     addAdvisors(advisors). }
true;private;2;7;/**  * Create an {@link AspectMetadata} instance for the supplied aspect type.  */ ;/**  * Create an {@link AspectMetadata} instance for the supplied aspect type.  */ private AspectMetadata createAspectMetadata(Class<?> aspectClass, String aspectName) {     AspectMetadata am = new AspectMetadata(aspectClass, aspectName).     if (!am.getAjType().isAspect()) {         throw new IllegalArgumentException("Class [" + aspectClass.getName() + "] is not a valid aspect type").     }     return am. }
true;private;3;15;/**  * Create a {@link MetadataAwareAspectInstanceFactory} for the supplied aspect type. If the aspect type  * has no per clause, then a {@link SingletonMetadataAwareAspectInstanceFactory} is returned, otherwise  * a {@link PrototypeAspectInstanceFactory} is returned.  */ ;/**  * Create a {@link MetadataAwareAspectInstanceFactory} for the supplied aspect type. If the aspect type  * has no per clause, then a {@link SingletonMetadataAwareAspectInstanceFactory} is returned, otherwise  * a {@link PrototypeAspectInstanceFactory} is returned.  */ private MetadataAwareAspectInstanceFactory createAspectInstanceFactory(AspectMetadata am, Class<?> aspectClass, String aspectName) {     MetadataAwareAspectInstanceFactory instanceFactory.     if (am.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {         // Create a shared aspect instance.         Object instance = getSingletonAspectInstance(aspectClass).         instanceFactory = new SingletonMetadataAwareAspectInstanceFactory(instance, aspectName).     } else {         // Create a factory for independent aspect instances.         instanceFactory = new SimpleMetadataAwareAspectInstanceFactory(aspectClass, aspectName).     }     return instanceFactory. }
true;private;1;15;/**  * Get the singleton aspect instance for the supplied aspect type. An instance  * is created if one cannot be found in the instance cache.  */ ;/**  * Get the singleton aspect instance for the supplied aspect type. An instance  * is created if one cannot be found in the instance cache.  */ private Object getSingletonAspectInstance(Class<?> aspectClass) {     // Quick check without a lock...     Object instance = aspectCache.get(aspectClass).     if (instance == null) {         synchronized (aspectCache) {             // To be safe, check within full lock now...             instance = aspectCache.get(aspectClass).             if (instance == null) {                 instance = new SimpleAspectInstanceFactory(aspectClass).getAspectInstance().                 aspectCache.put(aspectClass, instance).             }         }     }     return instance. }
true;public;0;4;/**  * Create a new proxy according to the settings in this factory.  * <p>Can be called repeatedly. Effect will vary if we've added  * or removed interfaces. Can add and remove interceptors.  * <p>Uses a default class loader: Usually, the thread context class loader  * (if necessary for proxy creation).  * @return the new proxy  */ ;/**  * Create a new proxy according to the settings in this factory.  * <p>Can be called repeatedly. Effect will vary if we've added  * or removed interfaces. Can add and remove interceptors.  * <p>Uses a default class loader: Usually, the thread context class loader  * (if necessary for proxy creation).  * @return the new proxy  */ @SuppressWarnings("unchecked") public <T> T getProxy() {     return (T) createAopProxy().getProxy(). }
true;public;1;4;/**  * Create a new proxy according to the settings in this factory.  * <p>Can be called repeatedly. Effect will vary if we've added  * or removed interfaces. Can add and remove interceptors.  * <p>Uses the given class loader (if necessary for proxy creation).  * @param classLoader the class loader to create the proxy with  * @return the new proxy  */ ;/**  * Create a new proxy according to the settings in this factory.  * <p>Can be called repeatedly. Effect will vary if we've added  * or removed interfaces. Can add and remove interceptors.  * <p>Uses the given class loader (if necessary for proxy creation).  * @param classLoader the class loader to create the proxy with  * @return the new proxy  */ @SuppressWarnings("unchecked") public <T> T getProxy(ClassLoader classLoader) {     return (T) createAopProxy().getProxy(classLoader). }
