# id;timestamp;commentText;codeText;commentWords;codeWords
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1496837955;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1497300858;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1498780456;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1522580222;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1522716161;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1524846214;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args) 			throws Throwable;1531945062;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,nullable,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static boolean isEqualsMethod(Method method);1328020251;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1337516454;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1353977966;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1356735495;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1385412762;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1412692679;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1419966315;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1431196347;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1450900048;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1460663185;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1467730834;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1467846264;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(Method method);1495868221;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1328020251;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1337516454;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1353977966;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1356735495;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1385412762;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1412692679;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1419966315;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1431196347;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1450900048;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1460663185;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1467730834;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1467846264;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1495868221;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1496837955;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1496955179;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1497300858;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1498780456;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1522580222;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1522716161;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1524846214;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions);1531945062;Can the given advisor apply at all on the given class?_<p>This is an important test as it can be used to optimize out a advisor for a class._This version also takes into account introductions (for IntroductionAwareMethodMatchers)._@param advisor the advisor to check_@param targetClass class we're testing_@param hasIntroductions whether or not the advisor chain for this bean includes_any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {_		if (advisor instanceof IntroductionAdvisor) {_			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass)__		}_		else if (advisor instanceof PointcutAdvisor) {_			PointcutAdvisor pca = (PointcutAdvisor) advisor__			return canApply(pca.getPointcut(), targetClass, hasIntroductions)__		}_		else {_			_			return true__		}_	};can,the,given,advisor,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,this,version,also,takes,into,account,introductions,for,introduction,aware,method,matchers,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,boolean,has,introductions,if,advisor,instanceof,introduction,advisor,return,introduction,advisor,advisor,get,class,filter,matches,target,class,else,if,advisor,instanceof,pointcut,advisor,pointcut,advisor,pca,pointcut,advisor,advisor,return,can,apply,pca,get,pointcut,target,class,has,introductions,else,return,true
AopUtils -> public static boolean isCglibProxy(@Nullable Object object);1498780456;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,nullable,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(@Nullable Object object);1522580222;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,nullable,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(@Nullable Object object);1522716161;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,nullable,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(@Nullable Object object);1524846214;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,nullable,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(@Nullable Object object);1531945062;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,nullable,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1328020251;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class> classes = new HashSet<Class>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1337516454;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class> classes = new HashSet<Class>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1353977966;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class> classes = new HashSet<Class>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1356735495;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class> classes = new HashSet<Class>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1385412762;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new HashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1412692679;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1419966315;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1431196347;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1450900048;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = clazz.getMethods()__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,clazz,get,methods,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1460663185;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1467730834;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1467846264;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1495868221;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1496837955;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1496955179;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1497300858;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1498780456;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		classes.add(targetClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,classes,add,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1522580222;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass))__		Class<?> userClass = ClassUtils.getUserClass(targetClass)__		classes.add(userClass)__		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, userClass, hasIntroductions)) ||_						methodMatcher.matches(method, userClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,class,utils,get,all,interfaces,for,class,as,set,target,class,class,user,class,class,utils,get,user,class,target,class,classes,add,user,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,user,class,has,introductions,method,matcher,matches,method,user,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1522716161;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>()__		if (!Proxy.isProxyClass(targetClass)) {_			classes.add(ClassUtils.getUserClass(targetClass))__		}_		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass))___		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if ((introductionAwareMethodMatcher != null &&_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,if,proxy,is,proxy,class,target,class,classes,add,class,utils,get,user,class,target,class,classes,add,all,class,utils,get,all,interfaces,for,class,as,set,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1524846214;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>()__		if (!Proxy.isProxyClass(targetClass)) {_			classes.add(ClassUtils.getUserClass(targetClass))__		}_		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass))___		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if (introductionAwareMethodMatcher != null ?_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,if,proxy,is,proxy,class,target,class,classes,add,class,utils,get,user,class,target,class,classes,add,all,class,utils,get,all,interfaces,for,class,as,set,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions);1531945062;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@param hasIntroductions whether or not the advisor chain_for this bean includes any introductions_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {_		Assert.notNull(pc, "Pointcut must not be null")__		if (!pc.getClassFilter().matches(targetClass)) {_			return false__		}__		MethodMatcher methodMatcher = pc.getMethodMatcher()__		if (methodMatcher == MethodMatcher.TRUE) {_			_			return true__		}__		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null__		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {_			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher__		}__		Set<Class<?>> classes = new LinkedHashSet<>()__		if (!Proxy.isProxyClass(targetClass)) {_			classes.add(ClassUtils.getUserClass(targetClass))__		}_		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass))___		for (Class<?> clazz : classes) {_			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz)__			for (Method method : methods) {_				if (introductionAwareMethodMatcher != null ?_						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :_						methodMatcher.matches(method, targetClass)) {_					return true__				}_			}_		}__		return false__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,param,has,introductions,whether,or,not,the,advisor,chain,for,this,bean,includes,any,introductions,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,boolean,has,introductions,assert,not,null,pc,pointcut,must,not,be,null,if,pc,get,class,filter,matches,target,class,return,false,method,matcher,method,matcher,pc,get,method,matcher,if,method,matcher,method,matcher,true,return,true,introduction,aware,method,matcher,introduction,aware,method,matcher,null,if,method,matcher,instanceof,introduction,aware,method,matcher,introduction,aware,method,matcher,introduction,aware,method,matcher,method,matcher,set,class,classes,new,linked,hash,set,if,proxy,is,proxy,class,target,class,classes,add,class,utils,get,user,class,target,class,classes,add,all,class,utils,get,all,interfaces,for,class,as,set,target,class,for,class,clazz,classes,method,methods,reflection,utils,get,all,declared,methods,clazz,for,method,method,methods,if,introduction,aware,method,matcher,null,introduction,aware,method,matcher,matches,method,target,class,has,introductions,method,matcher,matches,method,target,class,return,true,return,false
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1496837955;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1496955179;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1497300858;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1498780456;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1522580222;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1522716161;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1524846214;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static boolean isEqualsMethod(@Nullable Method method);1531945062;Determine whether the given method is an "equals" method._@see java.lang.Object#equals;public static boolean isEqualsMethod(@Nullable Method method) {_		return ReflectionUtils.isEqualsMethod(method)__	};determine,whether,the,given,method,is,an,equals,method,see,java,lang,object,equals;public,static,boolean,is,equals,method,nullable,method,method,return,reflection,utils,is,equals,method,method
AopUtils -> public static Class<?> getTargetClass(Object candidate);1328020251;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never <code>null</code>)_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,code,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1337516454;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never <code>null</code>)_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,code,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1353977966;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never <code>null</code>)_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,code,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1356735495;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1385412762;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1412692679;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1419966315;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy and the plain class else._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,and,the,plain,class,else,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1431196347;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1450900048;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1460663185;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1467730834;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1467846264;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1495868221;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1496837955;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1496955179;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1497300858;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1498780456;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1522580222;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1522716161;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1524846214;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static Class<?> getTargetClass(Object candidate);1531945062;Determine the target class of the given bean instance which might be an AOP proxy._<p>Returns the target class for an AOP proxy or the plain class otherwise._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object);public static Class<?> getTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Class<?> result = null__		if (candidate instanceof TargetClassAware) {_			result = ((TargetClassAware) candidate).getTargetClass()__		}_		if (result == null) {_			result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,target,class,of,the,given,bean,instance,which,might,be,an,aop,proxy,p,returns,the,target,class,for,an,aop,proxy,or,the,plain,class,otherwise,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,aop,proxy,utils,ultimate,target,class,object;public,static,class,get,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,class,result,null,if,candidate,instanceof,target,class,aware,result,target,class,aware,candidate,get,target,class,if,result,null,result,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1328020251;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1337516454;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1353977966;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1356735495;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1385412762;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1412692679;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1419966315;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1431196347;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1450900048;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1460663185;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1467730834;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1467846264;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1495868221;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1496837955;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1496955179;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1497300858;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1498780456;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1522580222;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1522716161;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1524846214;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean canApply(Advisor advisor, Class<?> targetClass);1531945062;Can the given advisor apply at all on the given class?_This is an important test as it can be used to optimize_out a advisor for a class._@param advisor the advisor to check_@param targetClass class we're testing_@return whether the pointcut can apply on any method;public static boolean canApply(Advisor advisor, Class<?> targetClass) {_		return canApply(advisor, targetClass, false)__	};can,the,given,advisor,apply,at,all,on,the,given,class,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,advisor,for,a,class,param,advisor,the,advisor,to,check,param,target,class,class,we,re,testing,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,advisor,advisor,class,target,class,return,can,apply,advisor,target,class,false
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1328020251;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1337516454;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1353977966;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1356735495;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1385412762;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1412692679;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1419966315;Check whether the given object is a JDK dynamic proxy._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1431196347;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1450900048;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1460663185;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1467730834;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1467846264;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1495868221;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1496837955;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1496955179;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(Object object);1497300858;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> @Deprecated 	public static boolean isCglibProxyClassName(String className);1328020251;Check whether the specified class name is a CGLIB-generated class._@param className the class name to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)};@Deprecated_	public static boolean isCglibProxyClassName(String className) {_		return ClassUtils.isCglibProxyClassName(className)__	};check,whether,the,specified,class,name,is,a,cglib,generated,class,param,class,name,the,class,name,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,name,string;deprecated,public,static,boolean,is,cglib,proxy,class,name,string,class,name,return,class,utils,is,cglib,proxy,class,name,class,name
AopUtils -> @Deprecated 	public static boolean isCglibProxyClassName(String className);1337516454;Check whether the specified class name is a CGLIB-generated class._@param className the class name to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)};@Deprecated_	public static boolean isCglibProxyClassName(String className) {_		return ClassUtils.isCglibProxyClassName(className)__	};check,whether,the,specified,class,name,is,a,cglib,generated,class,param,class,name,the,class,name,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,name,string;deprecated,public,static,boolean,is,cglib,proxy,class,name,string,class,name,return,class,utils,is,cglib,proxy,class,name,class,name
AopUtils -> @Deprecated 	public static boolean isCglibProxyClassName(String className);1353977966;Check whether the specified class name is a CGLIB-generated class._@param className the class name to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)};@Deprecated_	public static boolean isCglibProxyClassName(String className) {_		return ClassUtils.isCglibProxyClassName(className)__	};check,whether,the,specified,class,name,is,a,cglib,generated,class,param,class,name,the,class,name,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,name,string;deprecated,public,static,boolean,is,cglib,proxy,class,name,string,class,name,return,class,utils,is,cglib,proxy,class,name,class,name
AopUtils -> @Deprecated 	public static boolean isCglibProxyClassName(String className);1356735495;Check whether the specified class name is a CGLIB-generated class._@param className the class name to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)};@Deprecated_	public static boolean isCglibProxyClassName(String className) {_		return ClassUtils.isCglibProxyClassName(className)__	};check,whether,the,specified,class,name,is,a,cglib,generated,class,param,class,name,the,class,name,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,name,string;deprecated,public,static,boolean,is,cglib,proxy,class,name,string,class,name,return,class,utils,is,cglib,proxy,class,name,class,name
AopUtils -> @Deprecated 	public static boolean isCglibProxyClassName(String className);1385412762;Check whether the specified class name is a CGLIB-generated class._@param className the class name to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)};@Deprecated_	public static boolean isCglibProxyClassName(String className) {_		return ClassUtils.isCglibProxyClassName(className)__	};check,whether,the,specified,class,name,is,a,cglib,generated,class,param,class,name,the,class,name,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,name,string;deprecated,public,static,boolean,is,cglib,proxy,class,name,string,class,name,return,class,utils,is,cglib,proxy,class,name,class,name
AopUtils -> @Deprecated 	public static boolean isCglibProxyClassName(String className);1412692679;Check whether the specified class name is a CGLIB-generated class._@param className the class name to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)};@Deprecated_	public static boolean isCglibProxyClassName(String className) {_		return ClassUtils.isCglibProxyClassName(className)__	};check,whether,the,specified,class,name,is,a,cglib,generated,class,param,class,name,the,class,name,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,name,string;deprecated,public,static,boolean,is,cglib,proxy,class,name,string,class,name,return,class,utils,is,cglib,proxy,class,name,class,name
AopUtils -> public static boolean isCglibProxy(Object object);1328020251;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1337516454;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1353977966;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1356735495;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1385412762;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1412692679;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1419966315;Check whether the given object is a CGLIB proxy. Goes beyond the implementation_in {@link ClassUtils#isCglibProxy(Object)} by checking also to see if the given_object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,goes,beyond,the,implementation,in,link,class,utils,is,cglib,proxy,object,by,checking,also,to,see,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1431196347;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1450900048;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1460663185;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1467730834;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1467846264;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1495868221;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1496837955;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1496955179;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean isCglibProxy(Object object);1497300858;Check whether the given object is a CGLIB proxy._<p>This method goes beyond the implementation of_{@link ClassUtils#isCglibProxy(Object)} by additionally checking if_the given object is an instance of {@link SpringProxy}._@param object the object to check_@see ClassUtils#isCglibProxy(Object);public static boolean isCglibProxy(Object object) {_		return (object instanceof SpringProxy && ClassUtils.isCglibProxy(object))__	};check,whether,the,given,object,is,a,cglib,proxy,p,this,method,goes,beyond,the,implementation,of,link,class,utils,is,cglib,proxy,object,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,class,utils,is,cglib,proxy,object;public,static,boolean,is,cglib,proxy,object,object,return,object,instanceof,spring,proxy,class,utils,is,cglib,proxy,object
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1328020251;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1337516454;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1353977966;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1356735495;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1385412762;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1412692679;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1419966315;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1431196347;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1450900048;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1460663185;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1467730834;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1467846264;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1495868221;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1496837955;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1496955179;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1497300858;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1498780456;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1522580222;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1522716161;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1524846214;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> public static boolean canApply(Pointcut pc, Class<?> targetClass);1531945062;Can the given pointcut apply at all on the given class?_<p>This is an important test as it can be used to optimize_out a pointcut for a class._@param pc the static or dynamic pointcut to check_@param targetClass the class to test_@return whether the pointcut can apply on any method;public static boolean canApply(Pointcut pc, Class<?> targetClass) {_		return canApply(pc, targetClass, false)__	};can,the,given,pointcut,apply,at,all,on,the,given,class,p,this,is,an,important,test,as,it,can,be,used,to,optimize,out,a,pointcut,for,a,class,param,pc,the,static,or,dynamic,pointcut,to,check,param,target,class,the,class,to,test,return,whether,the,pointcut,can,apply,on,any,method;public,static,boolean,can,apply,pointcut,pc,class,target,class,return,can,apply,pc,target,class,false
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1495868221;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> @Nullable 	public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1496955179;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;@Nullable_	public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;nullable,public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static boolean isAopProxy(@Nullable Object object);1498780456;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(@Nullable Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(@Nullable Object object);1522580222;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(@Nullable Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(@Nullable Object object);1522716161;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(@Nullable Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(@Nullable Object object);1524846214;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(@Nullable Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(@Nullable Object object);1531945062;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(@Nullable Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isToStringMethod(Method method);1328020251;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1337516454;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1353977966;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1356735495;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1385412762;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1412692679;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1419966315;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1431196347;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1450900048;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1460663185;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1467730834;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1467846264;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(Method method);1495868221;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1496837955;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1496955179;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1497300858;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1498780456;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1522580222;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1522716161;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1524846214;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(@Nullable Method method);1531945062;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(@Nullable Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,nullable,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> @Deprecated 	public static boolean isCglibProxyClass(Class<?> clazz);1328020251;Check whether the specified class is a CGLIB-generated class._@param clazz the class to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)};@Deprecated_	public static boolean isCglibProxyClass(Class<?> clazz) {_		return ClassUtils.isCglibProxyClass(clazz)__	};check,whether,the,specified,class,is,a,cglib,generated,class,param,clazz,the,class,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,class;deprecated,public,static,boolean,is,cglib,proxy,class,class,clazz,return,class,utils,is,cglib,proxy,class,clazz
AopUtils -> @Deprecated 	public static boolean isCglibProxyClass(Class<?> clazz);1337516454;Check whether the specified class is a CGLIB-generated class._@param clazz the class to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)};@Deprecated_	public static boolean isCglibProxyClass(Class<?> clazz) {_		return ClassUtils.isCglibProxyClass(clazz)__	};check,whether,the,specified,class,is,a,cglib,generated,class,param,clazz,the,class,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,class;deprecated,public,static,boolean,is,cglib,proxy,class,class,clazz,return,class,utils,is,cglib,proxy,class,clazz
AopUtils -> @Deprecated 	public static boolean isCglibProxyClass(Class<?> clazz);1353977966;Check whether the specified class is a CGLIB-generated class._@param clazz the class to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)};@Deprecated_	public static boolean isCglibProxyClass(Class<?> clazz) {_		return ClassUtils.isCglibProxyClass(clazz)__	};check,whether,the,specified,class,is,a,cglib,generated,class,param,clazz,the,class,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,class;deprecated,public,static,boolean,is,cglib,proxy,class,class,clazz,return,class,utils,is,cglib,proxy,class,clazz
AopUtils -> @Deprecated 	public static boolean isCglibProxyClass(Class<?> clazz);1356735495;Check whether the specified class is a CGLIB-generated class._@param clazz the class to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)};@Deprecated_	public static boolean isCglibProxyClass(Class<?> clazz) {_		return ClassUtils.isCglibProxyClass(clazz)__	};check,whether,the,specified,class,is,a,cglib,generated,class,param,clazz,the,class,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,class;deprecated,public,static,boolean,is,cglib,proxy,class,class,clazz,return,class,utils,is,cglib,proxy,class,clazz
AopUtils -> @Deprecated 	public static boolean isCglibProxyClass(Class<?> clazz);1385412762;Check whether the specified class is a CGLIB-generated class._@param clazz the class to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)};@Deprecated_	public static boolean isCglibProxyClass(Class<?> clazz) {_		return ClassUtils.isCglibProxyClass(clazz)__	};check,whether,the,specified,class,is,a,cglib,generated,class,param,clazz,the,class,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,class;deprecated,public,static,boolean,is,cglib,proxy,class,class,clazz,return,class,utils,is,cglib,proxy,class,clazz
AopUtils -> @Deprecated 	public static boolean isCglibProxyClass(Class<?> clazz);1412692679;Check whether the specified class is a CGLIB-generated class._@param clazz the class to check_@deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)};@Deprecated_	public static boolean isCglibProxyClass(Class<?> clazz) {_		return ClassUtils.isCglibProxyClass(clazz)__	};check,whether,the,specified,class,is,a,cglib,generated,class,param,clazz,the,class,to,check,deprecated,as,of,spring,3,1,in,favor,of,link,class,utils,is,cglib,proxy,class,class;deprecated,public,static,boolean,is,cglib,proxy,class,class,clazz,return,class,utils,is,cglib,proxy,class,clazz
AopUtils -> public static boolean isHashCodeMethod(Method method);1328020251;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1337516454;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1353977966;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1356735495;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1385412762;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1412692679;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1419966315;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1431196347;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1450900048;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1460663185;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1467730834;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1467846264;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static boolean isHashCodeMethod(Method method);1495868221;Determine whether the given method is a "hashCode" method._@see java.lang.Object#hashCode;public static boolean isHashCodeMethod(Method method) {_		return ReflectionUtils.isHashCodeMethod(method)__	};determine,whether,the,given,method,is,a,hash,code,method,see,java,lang,object,hash,code;public,static,boolean,is,hash,code,method,method,method,return,reflection,utils,is,hash,code,method,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1495868221;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1496837955;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1496955179;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1497300858;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1498780456;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1522580222;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1522716161;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Class<?> specificTargetClass = (targetClass != null && !Proxy.isProxyClass(targetClass) ?_				ClassUtils.getUserClass(targetClass) : null)__		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,class,specific,target,class,target,class,null,proxy,is,proxy,class,target,class,class,utils,get,user,class,target,class,null,method,resolved,method,class,utils,get,most,specific,method,method,specific,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1524846214;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Class<?> specificTargetClass = (targetClass != null ? ClassUtils.getUserClass(targetClass) : null)__		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,class,specific,target,class,target,class,null,class,utils,get,user,class,target,class,null,method,resolved,method,class,utils,get,most,specific,method,method,specific,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass);1531945062;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {_		Class<?> specificTargetClass = (targetClass != null ? ClassUtils.getUserClass(targetClass) : null)__		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,nullable,class,target,class,class,specific,target,class,target,class,null,class,utils,get,user,class,target,class,null,method,resolved,method,class,utils,get,most,specific,method,method,specific,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1496837955;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1496955179;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1497300858;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1498780456;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1522580222;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1522716161;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1524846214;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(@Nullable Method method);1531945062;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(@Nullable Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,nullable,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1496837955;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1496955179;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1497300858;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1498780456;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1522580222;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1522716161;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1524846214;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static boolean isToStringMethod(@Nullable Method method);1531945062;Determine whether the given method is a "toString" method._@see java.lang.Object#toString();public static boolean isToStringMethod(@Nullable Method method) {_		return ReflectionUtils.isToStringMethod(method)__	};determine,whether,the,given,method,is,a,to,string,method,see,java,lang,object,to,string;public,static,boolean,is,to,string,method,nullable,method,method,return,reflection,utils,is,to,string,method,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1328020251;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be <code>IFoo.bar()</code> and the target class_may be <code>DefaultFoo</code>. In this case, the method may be_<code>DefaultFoo.bar()</code>. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be <code>null</code> or may not even implement the method._@return the specific target method, or the original method if the_<code>targetClass</code> doesn't implement it or is <code>null</code>_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,code,and,the,target,class,may,be,code,default,foo,code,in,this,case,the,method,may,be,code,default,foo,bar,code,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,code,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,code,doesn,t,implement,it,or,is,code,null,code,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1337516454;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be <code>IFoo.bar()</code> and the target class_may be <code>DefaultFoo</code>. In this case, the method may be_<code>DefaultFoo.bar()</code>. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be <code>null</code> or may not even implement the method._@return the specific target method, or the original method if the_<code>targetClass</code> doesn't implement it or is <code>null</code>_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,code,and,the,target,class,may,be,code,default,foo,code,in,this,case,the,method,may,be,code,default,foo,bar,code,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,code,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,code,doesn,t,implement,it,or,is,code,null,code,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1353977966;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be <code>IFoo.bar()</code> and the target class_may be <code>DefaultFoo</code>. In this case, the method may be_<code>DefaultFoo.bar()</code>. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be <code>null</code> or may not even implement the method._@return the specific target method, or the original method if the_<code>targetClass</code> doesn't implement it or is <code>null</code>_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,code,and,the,target,class,may,be,code,default,foo,code,in,this,case,the,method,may,be,code,default,foo,bar,code,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,code,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,code,doesn,t,implement,it,or,is,code,null,code,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1356735495;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1385412762;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1412692679;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1419966315;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1431196347;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1450900048;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1460663185;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1467730834;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Method getMostSpecificMethod(Method method, Class<?> targetClass);1467846264;Given a method, which may come from an interface, and a target class used_in the current AOP invocation, find the corresponding target method if there_is one. E.g. the method may be {@code IFoo.bar()} and the target class_may be {@code DefaultFoo}. In this case, the method may be_{@code DefaultFoo.bar()}. This enables attributes on that method to be found._<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},_this method resolves Java 5 bridge methods in order to retrieve attributes_from the <i>original</i> method definition._@param method the method to be invoked, which may come from an interface_@param targetClass the target class for the current invocation._May be {@code null} or may not even implement the method._@return the specific target method, or the original method if the_{@code targetClass} doesn't implement it or is {@code null}_@see org.springframework.util.ClassUtils#getMostSpecificMethod;public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {_		Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__		_		return BridgeMethodResolver.findBridgedMethod(resolvedMethod)__	};given,a,method,which,may,come,from,an,interface,and,a,target,class,used,in,the,current,aop,invocation,find,the,corresponding,target,method,if,there,is,one,e,g,the,method,may,be,code,ifoo,bar,and,the,target,class,may,be,code,default,foo,in,this,case,the,method,may,be,code,default,foo,bar,this,enables,attributes,on,that,method,to,be,found,p,b,note,b,in,contrast,to,link,org,springframework,util,class,utils,get,most,specific,method,this,method,resolves,java,5,bridge,methods,in,order,to,retrieve,attributes,from,the,i,original,i,method,definition,param,method,the,method,to,be,invoked,which,may,come,from,an,interface,param,target,class,the,target,class,for,the,current,invocation,may,be,code,null,or,may,not,even,implement,the,method,return,the,specific,target,method,or,the,original,method,if,the,code,target,class,doesn,t,implement,it,or,is,code,null,see,org,springframework,util,class,utils,get,most,specific,method;public,static,method,get,most,specific,method,method,method,class,target,class,method,resolved,method,class,utils,get,most,specific,method,method,target,class,return,bridge,method,resolver,find,bridged,method,resolved,method
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1328020251;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1337516454;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1353977966;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1356735495;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1385412762;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1412692679;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1419966315;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1431196347;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1450900048;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1460663185;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1467730834;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) 			throws Throwable;1467846264;Invoke the given target via reflection, as part of an AOP method invocation._@param target the target object_@param method the method to invoke_@param args the arguments for the method_@return the invocation result, if any_@throws Throwable if thrown by the target method_@throws org.springframework.aop.AopInvocationException in case of a reflection error;public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)_			throws Throwable {__		_		try {_			ReflectionUtils.makeAccessible(method)__			return method.invoke(target, args)__		}_		catch (InvocationTargetException ex) {_			_			_			throw ex.getTargetException()__		}_		catch (IllegalArgumentException ex) {_			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +_					method + "] on target [" + target + "]", ex)__		}_		catch (IllegalAccessException ex) {_			throw new AopInvocationException("Could not access method [" + method + "]", ex)__		}_	};invoke,the,given,target,via,reflection,as,part,of,an,aop,method,invocation,param,target,the,target,object,param,method,the,method,to,invoke,param,args,the,arguments,for,the,method,return,the,invocation,result,if,any,throws,throwable,if,thrown,by,the,target,method,throws,org,springframework,aop,aop,invocation,exception,in,case,of,a,reflection,error;public,static,object,invoke,joinpoint,using,reflection,object,target,method,method,object,args,throws,throwable,try,reflection,utils,make,accessible,method,return,method,invoke,target,args,catch,invocation,target,exception,ex,throw,ex,get,target,exception,catch,illegal,argument,exception,ex,throw,new,aop,invocation,exception,aop,configuration,seems,to,be,invalid,tried,calling,method,method,on,target,target,ex,catch,illegal,access,exception,ex,throw,new,aop,invocation,exception,could,not,access,method,method,ex
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1496837955;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1496955179;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1497300858;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1498780456;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1522580222;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1522716161;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1524846214;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType);1531945062;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {_		if (targetType == null) {_			return method__		}_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,nullable,class,target,type,if,target,type,null,return,method,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static boolean isFinalizeMethod(Method method);1328020251;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1337516454;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1353977966;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1356735495;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1385412762;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1412692679;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1419966315;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1431196347;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1450900048;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1460663185;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1467730834;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterTypes().length == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,types,length,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1467846264;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static boolean isFinalizeMethod(Method method);1495868221;Determine whether the given method is a "finalize" method._@see java.lang.Object#finalize();public static boolean isFinalizeMethod(Method method) {_		return (method != null && method.getName().equals("finalize") &&_				method.getParameterCount() == 0)__	};determine,whether,the,given,method,is,a,finalize,method,see,java,lang,object,finalize;public,static,boolean,is,finalize,method,method,method,return,method,null,method,get,name,equals,finalize,method,get,parameter,count,0
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1328020251;Determine the sublist of the <code>candidateAdvisors</code> list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,code,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1337516454;Determine the sublist of the <code>candidateAdvisors</code> list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,code,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1353977966;Determine the sublist of the <code>candidateAdvisors</code> list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,code,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1356735495;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1385412762;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1412692679;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1419966315;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1431196347;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1450900048;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1460663185;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<Advisor>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,advisor,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1467730834;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1467846264;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1495868221;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1496837955;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1496955179;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1497300858;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1498780456;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1522580222;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1522716161;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1524846214;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new LinkedList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,linked,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz);1531945062;Determine the sublist of the {@code candidateAdvisors} list_that is applicable to the given class._@param candidateAdvisors the Advisors to evaluate_@param clazz the target class_@return sublist of Advisors that can apply to an object of the given class_(may be the incoming List as-is);public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {_		if (candidateAdvisors.isEmpty()) {_			return candidateAdvisors__		}_		List<Advisor> eligibleAdvisors = new ArrayList<>()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {_				eligibleAdvisors.add(candidate)__			}_		}_		boolean hasIntroductions = !eligibleAdvisors.isEmpty()__		for (Advisor candidate : candidateAdvisors) {_			if (candidate instanceof IntroductionAdvisor) {_				_				continue__			}_			if (canApply(candidate, clazz, hasIntroductions)) {_				eligibleAdvisors.add(candidate)__			}_		}_		return eligibleAdvisors__	};determine,the,sublist,of,the,code,candidate,advisors,list,that,is,applicable,to,the,given,class,param,candidate,advisors,the,advisors,to,evaluate,param,clazz,the,target,class,return,sublist,of,advisors,that,can,apply,to,an,object,of,the,given,class,may,be,the,incoming,list,as,is;public,static,list,advisor,find,advisors,that,can,apply,list,advisor,candidate,advisors,class,clazz,if,candidate,advisors,is,empty,return,candidate,advisors,list,advisor,eligible,advisors,new,array,list,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,can,apply,candidate,clazz,eligible,advisors,add,candidate,boolean,has,introductions,eligible,advisors,is,empty,for,advisor,candidate,candidate,advisors,if,candidate,instanceof,introduction,advisor,continue,if,can,apply,candidate,clazz,has,introductions,eligible,advisors,add,candidate,return,eligible,advisors
AopUtils -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1450900048;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,class,target,type,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1460663185;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,class,target,type,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1467730834;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,class,target,type,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1467846264;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,class,target,type,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1495868221;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._@param method the method to check_@param targetType the target type to search methods on (typically an AOP proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch)_@since 4.3_@see MethodIntrospector#selectInvocableMethod(Method, Class);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType)__		if (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&_				SpringProxy.class.isAssignableFrom(targetType)) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +_					"be delegated to target bean. Switch its visibility to package or protected.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_		return methodToUse__	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,aop,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch,since,4,3,see,method,introspector,select,invocable,method,method,class;public,static,method,select,invocable,method,method,method,class,target,type,method,method,to,use,method,introspector,select,invocable,method,method,target,type,if,modifier,is,private,method,to,use,get,modifiers,modifier,is,static,method,to,use,get,modifiers,spring,proxy,class,is,assignable,from,target,type,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,found,on,proxy,for,target,class,s,but,cannot,be,delegated,to,target,bean,switch,its,visibility,to,package,or,protected,method,get,name,method,get,declaring,class,get,simple,name,return,method,to,use
AopUtils -> public static boolean isJdkDynamicProxy(@Nullable Object object);1498780456;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(@Nullable Object object);1522580222;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(@Nullable Object object);1522716161;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(@Nullable Object object);1524846214;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isJdkDynamicProxy(@Nullable Object object);1531945062;Check whether the given object is a JDK dynamic proxy._<p>This method goes beyond the implementation of_{@link Proxy#isProxyClass(Class)} by additionally checking if the_given object is an instance of {@link SpringProxy}._@param object the object to check_@see java.lang.reflect.Proxy#isProxyClass;public static boolean isJdkDynamicProxy(@Nullable Object object) {_		return (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,p,this,method,goes,beyond,the,implementation,of,link,proxy,is,proxy,class,class,by,additionally,checking,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,java,lang,reflect,proxy,is,proxy,class;public,static,boolean,is,jdk,dynamic,proxy,nullable,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1328020251;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1337516454;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1353977966;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1356735495;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1385412762;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1412692679;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1419966315;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1431196347;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1450900048;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1460663185;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1467730834;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1467846264;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1495868221;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1496837955;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1496955179;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
AopUtils -> public static boolean isAopProxy(Object object);1497300858;Check whether the given object is a JDK dynamic proxy or a CGLIB proxy._<p>This method additionally checks if the given object is an instance_of {@link SpringProxy}._@param object the object to check_@see #isJdkDynamicProxy_@see #isCglibProxy;public static boolean isAopProxy(Object object) {_		return (object instanceof SpringProxy &&_				(Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())))__	};check,whether,the,given,object,is,a,jdk,dynamic,proxy,or,a,cglib,proxy,p,this,method,additionally,checks,if,the,given,object,is,an,instance,of,link,spring,proxy,param,object,the,object,to,check,see,is,jdk,dynamic,proxy,see,is,cglib,proxy;public,static,boolean,is,aop,proxy,object,object,return,object,instanceof,spring,proxy,proxy,is,proxy,class,object,get,class,class,utils,is,cglib,proxy,class,object,get,class
