# id;timestamp;commentText;codeText;commentWords;codeWords
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1328020251;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1356735495;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1357119239;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1368482696;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1385412762;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1413848647;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1467730834;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1495868221;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1496837955;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1498780456;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1502974979;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf("(")__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1519588127;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf('(')__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1530174524;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf('(')__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> private void maybeBindAnnotationsFromPointcutExpression();1545727613;Parse the string pointcut expression looking for:_&#64_this, &#64_target, &#64_args, &#64_within, &#64_withincode, &#64_annotation._If we find one of these pointcut expressions, try and extract a candidate variable_name (or variable names, in the case of args)._<p>Some more support from AspectJ in doing this exercise would be nice... :);private void maybeBindAnnotationsFromPointcutExpression() {_		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			String toMatch = tokens[i]__			int firstParenIndex = toMatch.indexOf('(')__			if (firstParenIndex != -1) {_				toMatch = toMatch.substring(0, firstParenIndex)__			}_			if (singleValuedAnnotationPcds.contains(toMatch)) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].startsWith("@args(") || tokens[i].equals("@args")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				maybeExtractVariableNamesFromArgs(body.text, varNames)__			}_		}__		bindAnnotationsFromVarNames(varNames)__	};parse,the,string,pointcut,expression,looking,for,64,this,64,target,64,args,64,within,64,withincode,64,annotation,if,we,find,one,of,these,pointcut,expressions,try,and,extract,a,candidate,variable,name,or,variable,names,in,the,case,of,args,p,some,more,support,from,aspect,j,in,doing,this,exercise,would,be,nice;private,void,maybe,bind,annotations,from,pointcut,expression,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,string,to,match,tokens,i,int,first,paren,index,to,match,index,of,if,first,paren,index,1,to,match,to,match,substring,0,first,paren,index,if,single,valued,annotation,pcds,contains,to,match,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,starts,with,args,tokens,i,equals,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,bind,annotations,from,var,names,var,names
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression);1496837955;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,nullable,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression);1498780456;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,nullable,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression);1502974979;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,nullable,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression);1519588127;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,nullable,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression);1530174524;Create a new discoverer that attempts to discover parameter names._from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,nullable,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression);1545727613;Create a new discoverer that attempts to discover parameter names._from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,nullable,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1328020251;Given an args pointcut body (could be <code>args</code> or <code>at_args</code>),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,code,or,code,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1356735495;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1357119239;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1368482696;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1385412762;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1413848647;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1467730834;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames);1495868221;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(@Nullable String returningName);1498780456;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(@Nullable String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,nullable,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(@Nullable String returningName);1502974979;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(@Nullable String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,nullable,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(@Nullable String returningName);1519588127;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(@Nullable String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,nullable,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(@Nullable String returningName);1530174524;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(@Nullable String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,nullable,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(@Nullable String returningName);1545727613;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(@Nullable String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,nullable,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor ctor);1356735495;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor ctor);1368482696;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1328020251;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1356735495;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1357119239;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1368482696;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1385412762;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1413848647;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1467730834;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1495868221;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1496837955;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1498780456;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1502974979;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1519588127;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1530174524;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> private boolean maybeBindThisJoinPoint();1545727613;If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as_parameter name and return true, else return false.;private boolean maybeBindThisJoinPoint() {_		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {_			bindParameterName(0, THIS_JOIN_POINT)__			return true__		}_		else {_			return false__		}_	};if,the,first,parameter,is,of,type,join,point,or,proceeding,join,point,bind,this,join,point,as,parameter,name,and,return,true,else,return,false;private,boolean,maybe,bind,this,join,point,if,this,argument,types,0,join,point,class,this,argument,types,0,proceeding,join,point,class,bind,parameter,name,0,return,true,else,return,false
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1328020251;If <code>afterThrowing</code> advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,code,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1356735495;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1357119239;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1368482696;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1385412762;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1413848647;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1467730834;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1495868221;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(String throwingName);1496837955;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(@Nullable String throwingName);1498780456;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(@Nullable String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,nullable,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(@Nullable String throwingName);1502974979;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(@Nullable String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,nullable,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(@Nullable String throwingName);1519588127;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(@Nullable String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,nullable,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(@Nullable String throwingName);1530174524;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(@Nullable String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,nullable,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setThrowingName(@Nullable String throwingName);1545727613;If {@code afterThrowing} advice binds the thrown value, the_throwing variable name must be specified._@param throwingName the name of the throwing variable;public void setThrowingName(@Nullable String throwingName) {_		this.throwingName = throwingName__	};if,code,after,throwing,advice,binds,the,thrown,value,the,throwing,variable,name,must,be,specified,param,throwing,name,the,name,of,the,throwing,variable;public,void,set,throwing,name,nullable,string,throwing,name,this,throwing,name,throwing,name
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1328020251;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions <code>true</code> if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,code,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1356735495;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1357119239;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1368482696;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1385412762;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1413848647;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1467730834;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1495868221;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1496837955;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1498780456;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1502974979;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1519588127;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1530174524;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> public void setRaiseExceptions(boolean raiseExceptions);1545727613;Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}_must be thrown as appropriate in the case of failing to deduce advice parameter names._@param raiseExceptions {@code true} if exceptions are to be thrown;public void setRaiseExceptions(boolean raiseExceptions) {_		this.raiseExceptions = raiseExceptions__	};indicate,whether,link,illegal,argument,exception,and,link,ambiguous,binding,exception,must,be,thrown,as,appropriate,in,the,case,of,failing,to,deduce,advice,parameter,names,param,raise,exceptions,code,true,if,exceptions,are,to,be,thrown;public,void,set,raise,exceptions,boolean,raise,exceptions,this,raise,exceptions,raise,exceptions
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1328020251;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1356735495;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1357119239;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1368482696;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1385412762;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1413848647;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1467730834;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1495868221;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1496837955;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1498780456;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1502974979;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1519588127;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1530174524;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThrowingVariable();1545727613;If a throwing name was specified and there is exactly one choice remaining_(argument that is a subtype of Throwable) then bind it.;private void maybeBindThrowingVariable() {_		if (this.throwingName == null) {_			return__		}__		_		int throwableIndex = -1__		for (int i = 0_ i < this.argumentTypes.length_ i++) {_			if (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {_				if (throwableIndex == -1) {_					throwableIndex = i__				}_				else {_					_					throw new AmbiguousBindingException("Binding of throwing parameter '" +_							this.throwingName + "' is ambiguous: could be bound to argument " +_							throwableIndex + " or argument " + i)__				}_			}_		}__		if (throwableIndex == -1) {_			throw new IllegalStateException("Binding of throwing parameter '" + this.throwingName_					+ "' could not be completed as no available arguments are a subtype of Throwable")__		}_		else {_			bindParameterName(throwableIndex, this.throwingName)__		}_	};if,a,throwing,name,was,specified,and,there,is,exactly,one,choice,remaining,argument,that,is,a,subtype,of,throwable,then,bind,it;private,void,maybe,bind,throwing,variable,if,this,throwing,name,null,return,int,throwable,index,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,is,subtype,of,throwable,class,i,if,throwable,index,1,throwable,index,i,else,throw,new,ambiguous,binding,exception,binding,of,throwing,parameter,this,throwing,name,is,ambiguous,could,be,bound,to,argument,throwable,index,or,argument,i,if,throwable,index,1,throw,new,illegal,state,exception,binding,of,throwing,parameter,this,throwing,name,could,not,be,completed,as,no,available,arguments,are,a,subtype,of,throwable,else,bind,parameter,name,throwable,index,this,throwing,name
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1328020251;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1356735495;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1357119239;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1368482696;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1385412762;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1413848647;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1467730834;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1495868221;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1496837955;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1498780456;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1502974979;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1519588127;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1530174524;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindReturningVariable();1545727613;If a returning variable was specified and there is only one choice remaining, bind it.;private void maybeBindReturningVariable() {_		if (this.numberOfRemainingUnboundArguments == 0) {_			throw new IllegalStateException(_					"Algorithm assumes that there must be at least one unbound parameter on entry to this method")__		}__		if (this.returningName != null) {_			if (this.numberOfRemainingUnboundArguments > 1) {_				throw new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +_						"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.")__			}__			_			for (int i = 0_ i < this.parameterNameBindings.length_ i++) {_				if (this.parameterNameBindings[i] == null) {_					bindParameterName(i, this.returningName)__					break__				}_			}_		}_	};if,a,returning,variable,was,specified,and,there,is,only,one,choice,remaining,bind,it;private,void,maybe,bind,returning,variable,if,this,number,of,remaining,unbound,arguments,0,throw,new,illegal,state,exception,algorithm,assumes,that,there,must,be,at,least,one,unbound,parameter,on,entry,to,this,method,if,this,returning,name,null,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,binding,of,returning,parameter,this,returning,name,is,ambiguous,there,are,this,number,of,remaining,unbound,arguments,candidates,for,int,i,0,i,this,parameter,name,bindings,length,i,if,this,parameter,name,bindings,i,null,bind,parameter,name,i,this,returning,name,break
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1328020251;If <code>afterReturning</code> advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,code,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1356735495;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1357119239;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1368482696;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1385412762;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1413848647;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1467730834;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1495868221;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> public void setReturningName(String returningName);1496837955;If {@code afterReturning} advice binds the return value, the_returning variable name must be specified._@param returningName the name of the returning variable;public void setReturningName(String returningName) {_		this.returningName = returningName__	};if,code,after,returning,advice,binds,the,return,value,the,returning,variable,name,must,be,specified,param,returning,name,the,name,of,the,returning,variable;public,void,set,returning,name,string,returning,name,this,returning,name,returning,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames);1496837955;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,nullable,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames);1498780456;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,nullable,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames);1502974979;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,nullable,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames);1519588127;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,nullable,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames);1530174524;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,nullable,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames);1545727613;Given an args pointcut body (could be {@code args} or {@code at_args}),_add any candidate variable names to the given list.;private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {_		if (argsSpec == null) {_			return__		}_		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, ",")__		for (int i = 0_ i < tokens.length_ i++) {_			tokens[i] = StringUtils.trimWhitespace(tokens[i])__			String varName = maybeExtractVariableName(tokens[i])__			if (varName != null) {_				varNames.add(varName)__			}_		}_	};given,an,args,pointcut,body,could,be,code,args,or,code,add,any,candidate,variable,names,to,the,given,list;private,void,maybe,extract,variable,names,from,args,nullable,string,args,spec,list,string,var,names,if,args,spec,null,return,string,tokens,string,utils,tokenize,to,string,array,args,spec,for,int,i,0,i,tokens,length,i,tokens,i,string,utils,trim,whitespace,tokens,i,string,var,name,maybe,extract,variable,name,tokens,i,if,var,name,null,var,names,add,var,name
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1328020251;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1356735495;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1357119239;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1368482696;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1385412762;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1413848647;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1467730834;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> public AspectJAdviceParameterNameDiscoverer(String pointcutExpression);1495868221;Create a new discoverer that attempts to discover parameter names_from the given pointcut expression.;public AspectJAdviceParameterNameDiscoverer(String pointcutExpression) {_		this.pointcutExpression = pointcutExpression__	};create,a,new,discoverer,that,attempts,to,discover,parameter,names,from,the,given,pointcut,expression;public,aspect,jadvice,parameter,name,discoverer,string,pointcut,expression,this,pointcut,expression,pointcut,expression
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1328020251;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1356735495;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1357119239;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1368482696;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1385412762;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1413848647;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1467730834;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1495868221;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1496837955;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1498780456;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1502974979;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1519588127;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1530174524;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> AmbiguousBindingException -> public AmbiguousBindingException(String msg);1545727613;Construct a new AmbiguousBindingException with the specified message._@param msg the detail message;public AmbiguousBindingException(String msg) {_			super(msg)__		};construct,a,new,ambiguous,binding,exception,with,the,specified,message,param,msg,the,detail,message;public,ambiguous,binding,exception,string,msg,super,msg
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1356735495;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1368482696;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1385412762;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1413848647;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1467730834;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1495868221;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1496837955;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Method method);1498780456;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> public String[] getParameterNames(Constructor ctor);1328020251;An advice method can never be a constructor in Spring._@return <code>null</code>_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to <code>true</code>;public String[] getParameterNames(Constructor ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,code,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true,code;public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> public String[] getParameterNames(Constructor ctor);1357119239;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};public String[] getParameterNames(Constructor ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1328020251;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1356735495;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1357119239;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1368482696;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1385412762;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1413848647;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1467730834;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1495868221;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1496837955;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1498780456;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1502974979;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1519588127;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1530174524;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> private void bindAnnotationsFromVarNames(List<String> varNames);1545727613;Match the given list of extracted variable names to argument slots.;private void bindAnnotationsFromVarNames(List<String> varNames) {_		if (!varNames.isEmpty()) {_			_			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments()__			if (numAnnotationSlots > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" potential annotation variable(s), and " +_						numAnnotationSlots + " potential argument slots")__			}_			else if (numAnnotationSlots == 1) {_				if (varNames.size() == 1) {_					_					findAndBind(Annotation.class, varNames.get(0))__				}_				else {_					_					throw new IllegalArgumentException("Found " + varNames.size() +_							" candidate annotation binding variables" +_							" but only one potential argument binding slot")__				}_			}_			else {_				_			}_		}_	};match,the,given,list,of,extracted,variable,names,to,argument,slots;private,void,bind,annotations,from,var,names,list,string,var,names,if,var,names,is,empty,int,num,annotation,slots,count,number,of,unbound,annotation,arguments,if,num,annotation,slots,1,throw,new,ambiguous,binding,exception,found,var,names,size,potential,annotation,variable,s,and,num,annotation,slots,potential,argument,slots,else,if,num,annotation,slots,1,if,var,names,size,1,find,and,bind,annotation,class,var,names,get,0,else,throw,new,illegal,argument,exception,found,var,names,size,candidate,annotation,binding,variables,but,only,one,potential,argument,binding,slot,else
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor<?> ctor);1385412762;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor<?> ctor);1413848647;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor<?> ctor);1467730834;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor<?> ctor);1495868221;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor<?> ctor);1496837955;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	public String[] getParameterNames(Constructor<?> ctor);1498780456;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Constructor<?> ctor);1502974979;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	@Nullable_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,nullable,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Constructor<?> ctor);1519588127;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	@Nullable_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,nullable,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Constructor<?> ctor);1530174524;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	@Nullable_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,nullable,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Constructor<?> ctor);1545727613;An advice method can never be a constructor in Spring._@return {@code null}_@throws UnsupportedOperationException if_{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true};@Override_	@Nullable_	public String[] getParameterNames(Constructor<?> ctor) {_		if (this.raiseExceptions) {_			throw new UnsupportedOperationException("An advice method can never be a constructor")__		}_		else {_			_			_			return null__		}_	};an,advice,method,can,never,be,a,constructor,in,spring,return,code,null,throws,unsupported,operation,exception,if,link,set,raise,exceptions,boolean,raise,exceptions,has,been,set,to,code,true;override,nullable,public,string,get,parameter,names,constructor,ctor,if,this,raise,exceptions,throw,new,unsupported,operation,exception,an,advice,method,can,never,be,a,constructor,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Method method);1502974979;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	@Nullable_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,nullable,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Method method);1519588127;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	@Nullable_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,nullable,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Method method);1530174524;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	@Nullable_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,nullable,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> @Override 	@Nullable 	public String[] getParameterNames(Method method);1545727613;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;@Override_	@Nullable_	public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException | IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;override,nullable,public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> public String[] getParameterNames(Method method);1328020251;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> public String[] getParameterNames(Method method);1357119239;Deduce the parameter names for an advice method._<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}_for this class for details of the algorithm used._@param method the target {@link Method}_@return the parameter names;public String[] getParameterNames(Method method) {_		this.argumentTypes = method.getParameterTypes()__		this.numberOfRemainingUnboundArguments = this.argumentTypes.length__		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments]___		int minimumNumberUnboundArgs = 0__		if (this.returningName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.throwingName != null) {_			minimumNumberUnboundArgs++__		}_		if (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {_			throw new IllegalStateException(_					"Not enough arguments in method to satisfy binding of returning and throwing variables")__		}__		try {_			int algorithmicStep = STEP_JOIN_POINT_BINDING__			while ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {_				switch (algorithmicStep++) {_					case STEP_JOIN_POINT_BINDING:_						if (!maybeBindThisJoinPoint()) {_							maybeBindThisJoinPointStaticPart()__						}_						break__					case STEP_THROWING_BINDING:_						maybeBindThrowingVariable()__						break__					case STEP_ANNOTATION_BINDING:_						maybeBindAnnotationsFromPointcutExpression()__						break__					case STEP_RETURNING_BINDING:_						maybeBindReturningVariable()__						break__					case STEP_PRIMITIVE_ARGS_BINDING:_						maybeBindPrimitiveArgsFromPointcutExpression()__						break__					case STEP_THIS_TARGET_ARGS_BINDING:_						maybeBindThisOrTargetOrArgsFromPointcutExpression()__						break__					case STEP_REFERENCE_PCUT_BINDING:_						maybeBindReferencePointcutParameter()__						break__					default:_						throw new IllegalStateException("Unknown algorithmic step: " + (algorithmicStep - 1))__				}_			}_		}_		catch (AmbiguousBindingException ambigEx) {_			if (this.raiseExceptions) {_				throw ambigEx__			}_			else {_				return null__			}_		}_		catch (IllegalArgumentException ex) {_			if (this.raiseExceptions) {_				throw ex__			}_			else {_				return null__			}_		}__		if (this.numberOfRemainingUnboundArguments == 0) {_			return this.parameterNameBindings__		}_		else {_			if (this.raiseExceptions) {_				throw new IllegalStateException("Failed to bind all argument names: " +_						this.numberOfRemainingUnboundArguments + " argument(s) could not be bound")__			}_			else {_				_				return null__			}_		}_	};deduce,the,parameter,names,for,an,advice,method,p,see,the,link,aspect,jadvice,parameter,name,discoverer,class,level,javadoc,for,this,class,for,details,of,the,algorithm,used,param,method,the,target,link,method,return,the,parameter,names;public,string,get,parameter,names,method,method,this,argument,types,method,get,parameter,types,this,number,of,remaining,unbound,arguments,this,argument,types,length,this,parameter,name,bindings,new,string,this,number,of,remaining,unbound,arguments,int,minimum,number,unbound,args,0,if,this,returning,name,null,minimum,number,unbound,args,if,this,throwing,name,null,minimum,number,unbound,args,if,this,number,of,remaining,unbound,arguments,minimum,number,unbound,args,throw,new,illegal,state,exception,not,enough,arguments,in,method,to,satisfy,binding,of,returning,and,throwing,variables,try,int,algorithmic,step,while,this,number,of,remaining,unbound,arguments,0,algorithmic,step,switch,algorithmic,step,case,if,maybe,bind,this,join,point,maybe,bind,this,join,point,static,part,break,case,maybe,bind,throwing,variable,break,case,maybe,bind,annotations,from,pointcut,expression,break,case,maybe,bind,returning,variable,break,case,maybe,bind,primitive,args,from,pointcut,expression,break,case,maybe,bind,this,or,target,or,args,from,pointcut,expression,break,case,maybe,bind,reference,pointcut,parameter,break,default,throw,new,illegal,state,exception,unknown,algorithmic,step,algorithmic,step,1,catch,ambiguous,binding,exception,ambig,ex,if,this,raise,exceptions,throw,ambig,ex,else,return,null,catch,illegal,argument,exception,ex,if,this,raise,exceptions,throw,ex,else,return,null,if,this,number,of,remaining,unbound,arguments,0,return,this,parameter,name,bindings,else,if,this,raise,exceptions,throw,new,illegal,state,exception,failed,to,bind,all,argument,names,this,number,of,remaining,unbound,arguments,argument,s,could,not,be,bound,else,return,null
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1328020251;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<String>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,string,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1356735495;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<String>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,string,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1357119239;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<String>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,string,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1368482696;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<String>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,string,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1385412762;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<String>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,string,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1413848647;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<String>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<String>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,string,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1467730834;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1495868221;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1496837955;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1498780456;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1502974979;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1519588127;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1530174524;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindThisOrTargetOrArgsFromPointcutExpression();1545727613;Parse the string pointcut expression looking for this(), target() and args() expressions._If we find one, try and extract a candidate variable name and bind it.;private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {_		if (this.numberOfRemainingUnboundArguments > 1) {_			throw new AmbiguousBindingException("Still " + this.numberOfRemainingUnboundArguments_					+ " unbound args at this(),target(),args() binding stage, with no way to determine between them")__		}__		List<String> varNames = new ArrayList<>()__		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__		for (int i = 0_ i < tokens.length_ i++) {_			if (tokens[i].equals("this") ||_					tokens[i].startsWith("this(") ||_					tokens[i].equals("target") ||_					tokens[i].startsWith("target(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				String varName = maybeExtractVariableName(body.text)__				if (varName != null) {_					varNames.add(varName)__				}_			}_			else if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_				PointcutBody body = getPointcutBody(tokens, i)__				i += body.numTokensConsumed__				List<String> candidateVarNames = new ArrayList<>()__				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames)__				_				_				for (String varName : candidateVarNames) {_					if (!alreadyBound(varName)) {_						varNames.add(varName)__					}_				}_			}_		}___		if (varNames.size() > 1) {_			throw new AmbiguousBindingException("Found " + varNames.size() +_					" candidate this(), target() or args() variables but only one unbound argument slot")__		}_		else if (varNames.size() == 1) {_			for (int j = 0_ j < this.parameterNameBindings.length_ j++) {_				if (isUnbound(j)) {_					bindParameterName(j, varNames.get(0))__					break__				}_			}_		}_		_	};parse,the,string,pointcut,expression,looking,for,this,target,and,args,expressions,if,we,find,one,try,and,extract,a,candidate,variable,name,and,bind,it;private,void,maybe,bind,this,or,target,or,args,from,pointcut,expression,if,this,number,of,remaining,unbound,arguments,1,throw,new,ambiguous,binding,exception,still,this,number,of,remaining,unbound,arguments,unbound,args,at,this,target,args,binding,stage,with,no,way,to,determine,between,them,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,this,tokens,i,starts,with,this,tokens,i,equals,target,tokens,i,starts,with,target,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,string,var,name,maybe,extract,variable,name,body,text,if,var,name,null,var,names,add,var,name,else,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,list,string,candidate,var,names,new,array,list,maybe,extract,variable,names,from,args,body,text,candidate,var,names,for,string,var,name,candidate,var,names,if,already,bound,var,name,var,names,add,var,name,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,this,target,or,args,variables,but,only,one,unbound,argument,slot,else,if,var,names,size,1,for,int,j,0,j,this,parameter,name,bindings,length,j,if,is,unbound,j,bind,parameter,name,j,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1328020251;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<String>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, (String) varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,string,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1356735495;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<String>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1357119239;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<String>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1368482696;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<String>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1385412762;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<String>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1413848647;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<String>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1467730834;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1495868221;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1496837955;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1498780456;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1502974979;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1519588127;Match up args against unbound arguments of primitive types;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1530174524;Match up args against unbound arguments of primitive types.;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
AspectJAdviceParameterNameDiscoverer -> private void maybeBindPrimitiveArgsFromPointcutExpression();1545727613;Match up args against unbound arguments of primitive types.;private void maybeBindPrimitiveArgsFromPointcutExpression() {_		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments()__		if (numUnboundPrimitives > 1) {_			throw new AmbiguousBindingException("Found '" + numUnboundPrimitives +_					"' unbound primitive arguments with no way to distinguish between them.")__		}_		if (numUnboundPrimitives == 1) {_			_			List<String> varNames = new ArrayList<>()__			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, " ")__			for (int i = 0_ i < tokens.length_ i++) {_				if (tokens[i].equals("args") || tokens[i].startsWith("args(")) {_					PointcutBody body = getPointcutBody(tokens, i)__					i += body.numTokensConsumed__					maybeExtractVariableNamesFromArgs(body.text, varNames)__				}_			}_			if (varNames.size() > 1) {_				throw new AmbiguousBindingException("Found " + varNames.size() +_						" candidate variable names but only one candidate binding slot when matching primitive args")__			}_			else if (varNames.size() == 1) {_				_				for (int i = 0_ i < this.argumentTypes.length_ i++) {_					if (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {_						bindParameterName(i, varNames.get(0))__						break__					}_				}_			}_		}_	};match,up,args,against,unbound,arguments,of,primitive,types;private,void,maybe,bind,primitive,args,from,pointcut,expression,int,num,unbound,primitives,count,number,of,unbound,primitive,arguments,if,num,unbound,primitives,1,throw,new,ambiguous,binding,exception,found,num,unbound,primitives,unbound,primitive,arguments,with,no,way,to,distinguish,between,them,if,num,unbound,primitives,1,list,string,var,names,new,array,list,string,tokens,string,utils,tokenize,to,string,array,this,pointcut,expression,for,int,i,0,i,tokens,length,i,if,tokens,i,equals,args,tokens,i,starts,with,args,pointcut,body,body,get,pointcut,body,tokens,i,i,body,num,tokens,consumed,maybe,extract,variable,names,from,args,body,text,var,names,if,var,names,size,1,throw,new,ambiguous,binding,exception,found,var,names,size,candidate,variable,names,but,only,one,candidate,binding,slot,when,matching,primitive,args,else,if,var,names,size,1,for,int,i,0,i,this,argument,types,length,i,if,is,unbound,i,this,argument,types,i,is,primitive,bind,parameter,name,i,var,names,get,0,break
