# id;timestamp;commentText;codeText;commentWords;codeWords
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1385412762;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null && targetClass.isInterface()) {_				specifiedInterfaces = new Class<?>[] {targetClass}__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,target,class,is,interface,specified,interfaces,new,class,target,class,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1427811322;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					specifiedInterfaces = new Class<?>[] {targetClass}__				}_				else if (Proxy.isProxyClass(targetClass)) {_					specifiedInterfaces = targetClass.getInterfaces()__				}_			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,specified,interfaces,new,class,target,class,else,if,proxy,is,proxy,class,target,class,specified,interfaces,target,class,get,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1427907287;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1431196347;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1445895817;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1458335530;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@return the complete set of interfaces to proxy_@see SpringProxy_@see Advised;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		return completeProxiedInterfaces(advised, false)__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,return,the,complete,set,of,interfaces,to,proxy,see,spring,proxy,see,advised;public,static,class,complete,proxied,interfaces,advised,support,advised,return,complete,proxied,interfaces,advised,false
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1492258228;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@return the complete set of interfaces to proxy_@see SpringProxy_@see Advised;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		return completeProxiedInterfaces(advised, false)__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,return,the,complete,set,of,interfaces,to,proxy,see,spring,proxy,see,advised;public,static,class,complete,proxied,interfaces,advised,support,advised,return,complete,proxied,interfaces,advised,false
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1495868221;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@return the complete set of interfaces to proxy_@see SpringProxy_@see Advised;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		return completeProxiedInterfaces(advised, false)__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,return,the,complete,set,of,interfaces,to,proxy,see,spring,proxy,see,advised;public,static,class,complete,proxied,interfaces,advised,support,advised,return,complete,proxied,interfaces,advised,false
AopProxyUtils -> public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised);1498780456;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@return the complete set of interfaces to proxy_@see SpringProxy_@see Advised;public static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised) {_		return completeProxiedInterfaces(advised, false)__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,return,the,complete,set,of,interfaces,to,proxy,see,spring,proxy,see,advised;public,static,class,complete,proxied,interfaces,advised,support,advised,return,complete,proxied,interfaces,advised,false
AopProxyUtils -> static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy);1458335530;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@param decoratingProxy whether to expose the {@link DecoratingProxy} interface_@return the complete set of interfaces to proxy_@since 4.3_@see SpringProxy_@see Advised_@see DecoratingProxy;static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		boolean addDecoratingProxy = (decoratingProxy && !advised.isInterfaceProxied(DecoratingProxy.class))__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		if (addDecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		int index = specifiedInterfaces.length__		if (addSpringProxy) {_			proxiedInterfaces[index] = SpringProxy.class__			index++__		}_		if (addAdvised) {_			proxiedInterfaces[index] = Advised.class__			index++__		}_		if (addDecoratingProxy) {_			proxiedInterfaces[index] = DecoratingProxy.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,param,decorating,proxy,whether,to,expose,the,link,decorating,proxy,interface,return,the,complete,set,of,interfaces,to,proxy,since,4,3,see,spring,proxy,see,advised,see,decorating,proxy;static,class,complete,proxied,interfaces,advised,support,advised,boolean,decorating,proxy,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,boolean,add,decorating,proxy,decorating,proxy,advised,is,interface,proxied,decorating,proxy,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,if,add,decorating,proxy,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,int,index,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,index,spring,proxy,class,index,if,add,advised,proxied,interfaces,index,advised,class,index,if,add,decorating,proxy,proxied,interfaces,index,decorating,proxy,class,return,proxied,interfaces
AopProxyUtils -> static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy);1492258228;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@param decoratingProxy whether to expose the {@link DecoratingProxy} interface_@return the complete set of interfaces to proxy_@since 4.3_@see SpringProxy_@see Advised_@see DecoratingProxy;static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		boolean addDecoratingProxy = (decoratingProxy && !advised.isInterfaceProxied(DecoratingProxy.class))__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		if (addDecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		int index = specifiedInterfaces.length__		if (addSpringProxy) {_			proxiedInterfaces[index] = SpringProxy.class__			index++__		}_		if (addAdvised) {_			proxiedInterfaces[index] = Advised.class__			index++__		}_		if (addDecoratingProxy) {_			proxiedInterfaces[index] = DecoratingProxy.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,param,decorating,proxy,whether,to,expose,the,link,decorating,proxy,interface,return,the,complete,set,of,interfaces,to,proxy,since,4,3,see,spring,proxy,see,advised,see,decorating,proxy;static,class,complete,proxied,interfaces,advised,support,advised,boolean,decorating,proxy,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,boolean,add,decorating,proxy,decorating,proxy,advised,is,interface,proxied,decorating,proxy,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,if,add,decorating,proxy,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,int,index,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,index,spring,proxy,class,index,if,add,advised,proxied,interfaces,index,advised,class,index,if,add,decorating,proxy,proxied,interfaces,index,decorating,proxy,class,return,proxied,interfaces
AopProxyUtils -> static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy);1495868221;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@param decoratingProxy whether to expose the {@link DecoratingProxy} interface_@return the complete set of interfaces to proxy_@since 4.3_@see SpringProxy_@see Advised_@see DecoratingProxy;static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		boolean addDecoratingProxy = (decoratingProxy && !advised.isInterfaceProxied(DecoratingProxy.class))__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		if (addDecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		int index = specifiedInterfaces.length__		if (addSpringProxy) {_			proxiedInterfaces[index] = SpringProxy.class__			index++__		}_		if (addAdvised) {_			proxiedInterfaces[index] = Advised.class__			index++__		}_		if (addDecoratingProxy) {_			proxiedInterfaces[index] = DecoratingProxy.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,param,decorating,proxy,whether,to,expose,the,link,decorating,proxy,interface,return,the,complete,set,of,interfaces,to,proxy,since,4,3,see,spring,proxy,see,advised,see,decorating,proxy;static,class,complete,proxied,interfaces,advised,support,advised,boolean,decorating,proxy,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,boolean,add,decorating,proxy,decorating,proxy,advised,is,interface,proxied,decorating,proxy,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,if,add,decorating,proxy,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,int,index,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,index,spring,proxy,class,index,if,add,advised,proxied,interfaces,index,advised,class,index,if,add,decorating,proxy,proxied,interfaces,index,decorating,proxy,class,return,proxied,interfaces
AopProxyUtils -> static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy);1498780456;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@param advised the proxy config_@param decoratingProxy whether to expose the {@link DecoratingProxy} interface_@return the complete set of interfaces to proxy_@since 4.3_@see SpringProxy_@see Advised_@see DecoratingProxy;static Class<?>[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy) {_		Class<?>[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class<?> targetClass = advised.getTargetClass()__			if (targetClass != null) {_				if (targetClass.isInterface()) {_					advised.setInterfaces(targetClass)__				}_				else if (Proxy.isProxyClass(targetClass)) {_					advised.setInterfaces(targetClass.getInterfaces())__				}_				specifiedInterfaces = advised.getProxiedInterfaces()__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		boolean addDecoratingProxy = (decoratingProxy && !advised.isInterfaceProxied(DecoratingProxy.class))__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		if (addDecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] proxiedInterfaces = new Class<?>[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		int index = specifiedInterfaces.length__		if (addSpringProxy) {_			proxiedInterfaces[index] = SpringProxy.class__			index++__		}_		if (addAdvised) {_			proxiedInterfaces[index] = Advised.class__			index++__		}_		if (addDecoratingProxy) {_			proxiedInterfaces[index] = DecoratingProxy.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,param,advised,the,proxy,config,param,decorating,proxy,whether,to,expose,the,link,decorating,proxy,interface,return,the,complete,set,of,interfaces,to,proxy,since,4,3,see,spring,proxy,see,advised,see,decorating,proxy;static,class,complete,proxied,interfaces,advised,support,advised,boolean,decorating,proxy,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,if,target,class,is,interface,advised,set,interfaces,target,class,else,if,proxy,is,proxy,class,target,class,advised,set,interfaces,target,class,get,interfaces,specified,interfaces,advised,get,proxied,interfaces,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,boolean,add,decorating,proxy,decorating,proxy,advised,is,interface,proxied,decorating,proxy,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,if,add,decorating,proxy,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,int,index,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,index,spring,proxy,class,index,if,add,advised,proxied,interfaces,index,advised,class,index,if,add,decorating,proxy,proxied,interfaces,index,decorating,proxy,class,return,proxied,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1385412762;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1427811322;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1427907287;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1431196347;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1445895817;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1458335530;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		if (proxy instanceof DecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,if,proxy,instanceof,decorating,proxy,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1492258228;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		if (proxy instanceof DecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,if,proxy,instanceof,decorating,proxy,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1495868221;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		if (proxy instanceof DecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,if,proxy,instanceof,decorating,proxy,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class<?>[] proxiedUserInterfaces(Object proxy);1498780456;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class<?>[] proxiedUserInterfaces(Object proxy) {_		Class<?>[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		if (proxy instanceof DecoratingProxy) {_			nonUserIfcCount++__		}_		Class<?>[] userInterfaces = new Class<?>[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,if,proxy,instanceof,decorating,proxy,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> @Nullable 	public static Object getSingletonTarget(Object candidate);1495868221;Obtain the singleton target object behind the given proxy, if any._@param candidate the (potential) proxy to check_@return the singleton target object managed in a {@link SingletonTargetSource},_or {@code null} in any other case (not a proxy, not an existing singleton target)_@since 4.3.8_@see Advised#getTargetSource()_@see SingletonTargetSource#getTarget();@Nullable_	public static Object getSingletonTarget(Object candidate) {_		if (candidate instanceof Advised) {_			TargetSource targetSource = ((Advised) candidate).getTargetSource()__			if (targetSource instanceof SingletonTargetSource) {_				return ((SingletonTargetSource) targetSource).getTarget()__			}_		}_		return null__	};obtain,the,singleton,target,object,behind,the,given,proxy,if,any,param,candidate,the,potential,proxy,to,check,return,the,singleton,target,object,managed,in,a,link,singleton,target,source,or,code,null,in,any,other,case,not,a,proxy,not,an,existing,singleton,target,since,4,3,8,see,advised,get,target,source,see,singleton,target,source,get,target;nullable,public,static,object,get,singleton,target,object,candidate,if,candidate,instanceof,advised,target,source,target,source,advised,candidate,get,target,source,if,target,source,instanceof,singleton,target,source,return,singleton,target,source,target,source,get,target,return,null
AopProxyUtils -> @Nullable 	public static Object getSingletonTarget(Object candidate);1498780456;Obtain the singleton target object behind the given proxy, if any._@param candidate the (potential) proxy to check_@return the singleton target object managed in a {@link SingletonTargetSource},_or {@code null} in any other case (not a proxy, not an existing singleton target)_@since 4.3.8_@see Advised#getTargetSource()_@see SingletonTargetSource#getTarget();@Nullable_	public static Object getSingletonTarget(Object candidate) {_		if (candidate instanceof Advised) {_			TargetSource targetSource = ((Advised) candidate).getTargetSource()__			if (targetSource instanceof SingletonTargetSource) {_				return ((SingletonTargetSource) targetSource).getTarget()__			}_		}_		return null__	};obtain,the,singleton,target,object,behind,the,given,proxy,if,any,param,candidate,the,potential,proxy,to,check,return,the,singleton,target,object,managed,in,a,link,singleton,target,source,or,code,null,in,any,other,case,not,a,proxy,not,an,existing,singleton,target,since,4,3,8,see,advised,get,target,source,see,singleton,target,source,get,target;nullable,public,static,object,get,singleton,target,object,candidate,if,candidate,instanceof,advised,target,source,target,source,advised,candidate,get,target,source,if,target,source,instanceof,singleton,target,source,return,singleton,target,source,target,source,get,target,return,null
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1328020251;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well -_as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never <code>null</code>)_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see org.springframework.aop.framework.Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,code,see,org,springframework,aop,target,class,aware,get,target,class,see,org,springframework,aop,framework,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1356735495;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well -_as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1385412762;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well -_as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1427811322;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well -_as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1427907287;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well -_as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the target class (or the plain class of the given object as fallback__never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1431196347;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well &mdash__as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the ultimate target class (or the plain class of the given_object as fallback_ never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,mdash,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,ultimate,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1445895817;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well &mdash__as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the ultimate target class (or the plain class of the given_object as fallback_ never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,mdash,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,ultimate,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1458335530;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well &mdash__as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the ultimate target class (or the plain class of the given_object as fallback_ never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			Object nested = null__			if (current instanceof Advised) {_				TargetSource targetSource = ((Advised) current).getTargetSource()__				if (targetSource instanceof SingletonTargetSource) {_					nested = ((SingletonTargetSource) targetSource).getTarget()__				}_			}_			current = nested__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,mdash,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,ultimate,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,object,nested,null,if,current,instanceof,advised,target,source,target,source,advised,current,get,target,source,if,target,source,instanceof,singleton,target,source,nested,singleton,target,source,target,source,get,target,current,nested,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1492258228;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well &mdash__as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the ultimate target class (or the plain class of the given_object as fallback_ never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			current = getSingletonTarget(current)__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,mdash,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,ultimate,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,current,get,singleton,target,current,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1495868221;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well &mdash__as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the ultimate target class (or the plain class of the given_object as fallback_ never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			current = getSingletonTarget(current)__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,mdash,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,ultimate,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,current,get,singleton,target,current,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static Class<?> ultimateTargetClass(Object candidate);1498780456;Determine the ultimate target class of the given bean instance, traversing_not only a top-level proxy but any number of nested proxies as well &mdash__as long as possible without side effects, that is, just for singleton targets._@param candidate the instance to check (might be an AOP proxy)_@return the ultimate target class (or the plain class of the given_object as fallback_ never {@code null})_@see org.springframework.aop.TargetClassAware#getTargetClass()_@see Advised#getTargetSource();public static Class<?> ultimateTargetClass(Object candidate) {_		Assert.notNull(candidate, "Candidate object must not be null")__		Object current = candidate__		Class<?> result = null__		while (current instanceof TargetClassAware) {_			result = ((TargetClassAware) current).getTargetClass()__			current = getSingletonTarget(current)__		}_		if (result == null) {_			result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass())__		}_		return result__	};determine,the,ultimate,target,class,of,the,given,bean,instance,traversing,not,only,a,top,level,proxy,but,any,number,of,nested,proxies,as,well,mdash,as,long,as,possible,without,side,effects,that,is,just,for,singleton,targets,param,candidate,the,instance,to,check,might,be,an,aop,proxy,return,the,ultimate,target,class,or,the,plain,class,of,the,given,object,as,fallback,never,code,null,see,org,springframework,aop,target,class,aware,get,target,class,see,advised,get,target,source;public,static,class,ultimate,target,class,object,candidate,assert,not,null,candidate,candidate,object,must,not,be,null,object,current,candidate,class,result,null,while,current,instanceof,target,class,aware,result,target,class,aware,current,get,target,class,current,get,singleton,target,current,if,result,null,result,aop,utils,is,cglib,proxy,candidate,candidate,get,class,get,superclass,candidate,get,class,return,result
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1328020251;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1356735495;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1385412762;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1427811322;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1427907287;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1431196347;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1445895817;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1458335530;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1492258228;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1495868221;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b);1498780456;Check equality of the proxied interfaces behind the given AdvisedSupport objects.;public static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces())__	};check,equality,of,the,proxied,interfaces,behind,the,given,advised,support,objects;public,static,boolean,equals,proxied,interfaces,advised,support,a,advised,support,b,return,arrays,equals,a,get,proxied,interfaces,b,get,proxied,interfaces
AopProxyUtils -> static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments);1445895817;Adapt the given arguments to the target signature in the given method,_if necessary: in particular, if a given vararg argument array does not_match the array type of the declared vararg parameter in the method._@param method the target method_@param arguments the given arguments_@return a cloned argument array, or the original if no adaptation is needed_@since 4.2.3;static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments) {_		if (method.isVarArgs() && !ObjectUtils.isEmpty(arguments)) {_			Class<?>[] paramTypes = method.getParameterTypes()__			if (paramTypes.length == arguments.length) {_				int varargIndex = paramTypes.length - 1__				Class<?> varargType = paramTypes[varargIndex]__				if (varargType.isArray()) {_					Object varargArray = arguments[varargIndex]__					if (varargArray instanceof Object[] && !varargType.isInstance(varargArray)) {_						Object[] newArguments = new Object[arguments.length]__						System.arraycopy(arguments, 0, newArguments, 0, varargIndex)__						Class<?> targetElementType = varargType.getComponentType()__						int varargLength = Array.getLength(varargArray)__						Object newVarargArray = Array.newInstance(targetElementType, varargLength)__						System.arraycopy(varargArray, 0, newVarargArray, 0, varargLength)__						newArguments[varargIndex] = newVarargArray__						return newArguments__					}_				}_			}_		}_		return arguments__	};adapt,the,given,arguments,to,the,target,signature,in,the,given,method,if,necessary,in,particular,if,a,given,vararg,argument,array,does,not,match,the,array,type,of,the,declared,vararg,parameter,in,the,method,param,method,the,target,method,param,arguments,the,given,arguments,return,a,cloned,argument,array,or,the,original,if,no,adaptation,is,needed,since,4,2,3;static,object,adapt,arguments,if,necessary,method,method,object,arguments,if,method,is,var,args,object,utils,is,empty,arguments,class,param,types,method,get,parameter,types,if,param,types,length,arguments,length,int,vararg,index,param,types,length,1,class,vararg,type,param,types,vararg,index,if,vararg,type,is,array,object,vararg,array,arguments,vararg,index,if,vararg,array,instanceof,object,vararg,type,is,instance,vararg,array,object,new,arguments,new,object,arguments,length,system,arraycopy,arguments,0,new,arguments,0,vararg,index,class,target,element,type,vararg,type,get,component,type,int,vararg,length,array,get,length,vararg,array,object,new,vararg,array,array,new,instance,target,element,type,vararg,length,system,arraycopy,vararg,array,0,new,vararg,array,0,vararg,length,new,arguments,vararg,index,new,vararg,array,return,new,arguments,return,arguments
AopProxyUtils -> static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments);1458335530;Adapt the given arguments to the target signature in the given method,_if necessary: in particular, if a given vararg argument array does not_match the array type of the declared vararg parameter in the method._@param method the target method_@param arguments the given arguments_@return a cloned argument array, or the original if no adaptation is needed_@since 4.2.3;static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments) {_		if (method.isVarArgs() && !ObjectUtils.isEmpty(arguments)) {_			Class<?>[] paramTypes = method.getParameterTypes()__			if (paramTypes.length == arguments.length) {_				int varargIndex = paramTypes.length - 1__				Class<?> varargType = paramTypes[varargIndex]__				if (varargType.isArray()) {_					Object varargArray = arguments[varargIndex]__					if (varargArray instanceof Object[] && !varargType.isInstance(varargArray)) {_						Object[] newArguments = new Object[arguments.length]__						System.arraycopy(arguments, 0, newArguments, 0, varargIndex)__						Class<?> targetElementType = varargType.getComponentType()__						int varargLength = Array.getLength(varargArray)__						Object newVarargArray = Array.newInstance(targetElementType, varargLength)__						System.arraycopy(varargArray, 0, newVarargArray, 0, varargLength)__						newArguments[varargIndex] = newVarargArray__						return newArguments__					}_				}_			}_		}_		return arguments__	};adapt,the,given,arguments,to,the,target,signature,in,the,given,method,if,necessary,in,particular,if,a,given,vararg,argument,array,does,not,match,the,array,type,of,the,declared,vararg,parameter,in,the,method,param,method,the,target,method,param,arguments,the,given,arguments,return,a,cloned,argument,array,or,the,original,if,no,adaptation,is,needed,since,4,2,3;static,object,adapt,arguments,if,necessary,method,method,object,arguments,if,method,is,var,args,object,utils,is,empty,arguments,class,param,types,method,get,parameter,types,if,param,types,length,arguments,length,int,vararg,index,param,types,length,1,class,vararg,type,param,types,vararg,index,if,vararg,type,is,array,object,vararg,array,arguments,vararg,index,if,vararg,array,instanceof,object,vararg,type,is,instance,vararg,array,object,new,arguments,new,object,arguments,length,system,arraycopy,arguments,0,new,arguments,0,vararg,index,class,target,element,type,vararg,type,get,component,type,int,vararg,length,array,get,length,vararg,array,object,new,vararg,array,array,new,instance,target,element,type,vararg,length,system,arraycopy,vararg,array,0,new,vararg,array,0,vararg,length,new,arguments,vararg,index,new,vararg,array,return,new,arguments,return,arguments
AopProxyUtils -> static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments);1492258228;Adapt the given arguments to the target signature in the given method,_if necessary: in particular, if a given vararg argument array does not_match the array type of the declared vararg parameter in the method._@param method the target method_@param arguments the given arguments_@return a cloned argument array, or the original if no adaptation is needed_@since 4.2.3;static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments) {_		if (method.isVarArgs() && !ObjectUtils.isEmpty(arguments)) {_			Class<?>[] paramTypes = method.getParameterTypes()__			if (paramTypes.length == arguments.length) {_				int varargIndex = paramTypes.length - 1__				Class<?> varargType = paramTypes[varargIndex]__				if (varargType.isArray()) {_					Object varargArray = arguments[varargIndex]__					if (varargArray instanceof Object[] && !varargType.isInstance(varargArray)) {_						Object[] newArguments = new Object[arguments.length]__						System.arraycopy(arguments, 0, newArguments, 0, varargIndex)__						Class<?> targetElementType = varargType.getComponentType()__						int varargLength = Array.getLength(varargArray)__						Object newVarargArray = Array.newInstance(targetElementType, varargLength)__						System.arraycopy(varargArray, 0, newVarargArray, 0, varargLength)__						newArguments[varargIndex] = newVarargArray__						return newArguments__					}_				}_			}_		}_		return arguments__	};adapt,the,given,arguments,to,the,target,signature,in,the,given,method,if,necessary,in,particular,if,a,given,vararg,argument,array,does,not,match,the,array,type,of,the,declared,vararg,parameter,in,the,method,param,method,the,target,method,param,arguments,the,given,arguments,return,a,cloned,argument,array,or,the,original,if,no,adaptation,is,needed,since,4,2,3;static,object,adapt,arguments,if,necessary,method,method,object,arguments,if,method,is,var,args,object,utils,is,empty,arguments,class,param,types,method,get,parameter,types,if,param,types,length,arguments,length,int,vararg,index,param,types,length,1,class,vararg,type,param,types,vararg,index,if,vararg,type,is,array,object,vararg,array,arguments,vararg,index,if,vararg,array,instanceof,object,vararg,type,is,instance,vararg,array,object,new,arguments,new,object,arguments,length,system,arraycopy,arguments,0,new,arguments,0,vararg,index,class,target,element,type,vararg,type,get,component,type,int,vararg,length,array,get,length,vararg,array,object,new,vararg,array,array,new,instance,target,element,type,vararg,length,system,arraycopy,vararg,array,0,new,vararg,array,0,vararg,length,new,arguments,vararg,index,new,vararg,array,return,new,arguments,return,arguments
AopProxyUtils -> static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments);1495868221;Adapt the given arguments to the target signature in the given method,_if necessary: in particular, if a given vararg argument array does not_match the array type of the declared vararg parameter in the method._@param method the target method_@param arguments the given arguments_@return a cloned argument array, or the original if no adaptation is needed_@since 4.2.3;static Object[] adaptArgumentsIfNecessary(Method method, Object... arguments) {_		if (method.isVarArgs() && !ObjectUtils.isEmpty(arguments)) {_			Class<?>[] paramTypes = method.getParameterTypes()__			if (paramTypes.length == arguments.length) {_				int varargIndex = paramTypes.length - 1__				Class<?> varargType = paramTypes[varargIndex]__				if (varargType.isArray()) {_					Object varargArray = arguments[varargIndex]__					if (varargArray instanceof Object[] && !varargType.isInstance(varargArray)) {_						Object[] newArguments = new Object[arguments.length]__						System.arraycopy(arguments, 0, newArguments, 0, varargIndex)__						Class<?> targetElementType = varargType.getComponentType()__						int varargLength = Array.getLength(varargArray)__						Object newVarargArray = Array.newInstance(targetElementType, varargLength)__						System.arraycopy(varargArray, 0, newVarargArray, 0, varargLength)__						newArguments[varargIndex] = newVarargArray__						return newArguments__					}_				}_			}_		}_		return arguments__	};adapt,the,given,arguments,to,the,target,signature,in,the,given,method,if,necessary,in,particular,if,a,given,vararg,argument,array,does,not,match,the,array,type,of,the,declared,vararg,parameter,in,the,method,param,method,the,target,method,param,arguments,the,given,arguments,return,a,cloned,argument,array,or,the,original,if,no,adaptation,is,needed,since,4,2,3;static,object,adapt,arguments,if,necessary,method,method,object,arguments,if,method,is,var,args,object,utils,is,empty,arguments,class,param,types,method,get,parameter,types,if,param,types,length,arguments,length,int,vararg,index,param,types,length,1,class,vararg,type,param,types,vararg,index,if,vararg,type,is,array,object,vararg,array,arguments,vararg,index,if,vararg,array,instanceof,object,vararg,type,is,instance,vararg,array,object,new,arguments,new,object,arguments,length,system,arraycopy,arguments,0,new,arguments,0,vararg,index,class,target,element,type,vararg,type,get,component,type,int,vararg,length,array,get,length,vararg,array,object,new,vararg,array,array,new,instance,target,element,type,vararg,length,system,arraycopy,vararg,array,0,new,vararg,array,0,vararg,length,new,arguments,vararg,index,new,vararg,array,return,new,arguments,return,arguments
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1328020251;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1356735495;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1385412762;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1427811322;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1427907287;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1431196347;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1445895817;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1458335530;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1492258228;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1495868221;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b);1498780456;Check equality of the advisors behind the given AdvisedSupport objects.;public static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {_		return Arrays.equals(a.getAdvisors(), b.getAdvisors())__	};check,equality,of,the,advisors,behind,the,given,advised,support,objects;public,static,boolean,equals,advisors,advised,support,a,advised,support,b,return,arrays,equals,a,get,advisors,b,get,advisors
AopProxyUtils -> public static Class[] proxiedUserInterfaces(Object proxy);1328020251;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never <code>null</code> or empty)_@see Advised;public static Class[] proxiedUserInterfaces(Object proxy) {_		Class[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class[] userInterfaces = new Class[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,code,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static Class[] proxiedUserInterfaces(Object proxy);1356735495;Extract the user-specified interfaces that the given proxy implements,_i.e. all non-Advised interfaces that the proxy implements._@param proxy the proxy to analyze (usually a JDK dynamic proxy)_@return all user-specified interfaces that the proxy implements,_in the original order (never {@code null} or empty)_@see Advised;public static Class[] proxiedUserInterfaces(Object proxy) {_		Class[] proxyInterfaces = proxy.getClass().getInterfaces()__		int nonUserIfcCount = 0__		if (proxy instanceof SpringProxy) {_			nonUserIfcCount++__		}_		if (proxy instanceof Advised) {_			nonUserIfcCount++__		}_		Class[] userInterfaces = new Class[proxyInterfaces.length - nonUserIfcCount]__		System.arraycopy(proxyInterfaces, 0, userInterfaces, 0, userInterfaces.length)__		Assert.notEmpty(userInterfaces, "JDK proxy must implement one or more interfaces")__		return userInterfaces__	};extract,the,user,specified,interfaces,that,the,given,proxy,implements,i,e,all,non,advised,interfaces,that,the,proxy,implements,param,proxy,the,proxy,to,analyze,usually,a,jdk,dynamic,proxy,return,all,user,specified,interfaces,that,the,proxy,implements,in,the,original,order,never,code,null,or,empty,see,advised;public,static,class,proxied,user,interfaces,object,proxy,class,proxy,interfaces,proxy,get,class,get,interfaces,int,non,user,ifc,count,0,if,proxy,instanceof,spring,proxy,non,user,ifc,count,if,proxy,instanceof,advised,non,user,ifc,count,class,user,interfaces,new,class,proxy,interfaces,length,non,user,ifc,count,system,arraycopy,proxy,interfaces,0,user,interfaces,0,user,interfaces,length,assert,not,empty,user,interfaces,jdk,proxy,must,implement,one,or,more,interfaces,return,user,interfaces
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1328020251;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1356735495;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1385412762;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1427811322;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1427907287;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1431196347;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1445895817;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1458335530;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1492258228;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1495868221;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b);1498780456;Check equality of the proxies behind the given AdvisedSupport objects._Not the same as equality of the AdvisedSupport objects:_rather, equality of interfaces, advisors and target sources.;public static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {_		return (a == b ||_				(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())))__	};check,equality,of,the,proxies,behind,the,given,advised,support,objects,not,the,same,as,equality,of,the,advised,support,objects,rather,equality,of,interfaces,advisors,and,target,sources;public,static,boolean,equals,in,proxy,advised,support,a,advised,support,b,return,a,b,equals,proxied,interfaces,a,b,equals,advisors,a,b,a,get,target,source,equals,b,get,target,source
AopProxyUtils -> public static Class[] completeProxiedInterfaces(AdvisedSupport advised);1328020251;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class targetClass = advised.getTargetClass()__			if (targetClass != null && targetClass.isInterface()) {_				specifiedInterfaces = new Class[] {targetClass}__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class[] proxiedInterfaces = new Class[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,target,class,is,interface,specified,interfaces,new,class,target,class,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
AopProxyUtils -> public static Class[] completeProxiedInterfaces(AdvisedSupport advised);1356735495;Determine the complete set of interfaces to proxy for the given AOP configuration._<p>This will always add the {@link Advised} interface unless the AdvisedSupport's_{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the_{@link org.springframework.aop.SpringProxy} marker interface._@return the complete set of interfaces to proxy_@see Advised_@see org.springframework.aop.SpringProxy;public static Class[] completeProxiedInterfaces(AdvisedSupport advised) {_		Class[] specifiedInterfaces = advised.getProxiedInterfaces()__		if (specifiedInterfaces.length == 0) {_			_			Class targetClass = advised.getTargetClass()__			if (targetClass != null && targetClass.isInterface()) {_				specifiedInterfaces = new Class[] {targetClass}__			}_		}_		boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)__		boolean addAdvised = !advised.isOpaque() && !advised.isInterfaceProxied(Advised.class)__		int nonUserIfcCount = 0__		if (addSpringProxy) {_			nonUserIfcCount++__		}_		if (addAdvised) {_			nonUserIfcCount++__		}_		Class[] proxiedInterfaces = new Class[specifiedInterfaces.length + nonUserIfcCount]__		System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length)__		if (addSpringProxy) {_			proxiedInterfaces[specifiedInterfaces.length] = SpringProxy.class__		}_		if (addAdvised) {_			proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class__		}_		return proxiedInterfaces__	};determine,the,complete,set,of,interfaces,to,proxy,for,the,given,aop,configuration,p,this,will,always,add,the,link,advised,interface,unless,the,advised,support,s,link,advised,support,set,opaque,opaque,flag,is,on,always,adds,the,link,org,springframework,aop,spring,proxy,marker,interface,return,the,complete,set,of,interfaces,to,proxy,see,advised,see,org,springframework,aop,spring,proxy;public,static,class,complete,proxied,interfaces,advised,support,advised,class,specified,interfaces,advised,get,proxied,interfaces,if,specified,interfaces,length,0,class,target,class,advised,get,target,class,if,target,class,null,target,class,is,interface,specified,interfaces,new,class,target,class,boolean,add,spring,proxy,advised,is,interface,proxied,spring,proxy,class,boolean,add,advised,advised,is,opaque,advised,is,interface,proxied,advised,class,int,non,user,ifc,count,0,if,add,spring,proxy,non,user,ifc,count,if,add,advised,non,user,ifc,count,class,proxied,interfaces,new,class,specified,interfaces,length,non,user,ifc,count,system,arraycopy,specified,interfaces,0,proxied,interfaces,0,specified,interfaces,length,if,add,spring,proxy,proxied,interfaces,specified,interfaces,length,spring,proxy,class,if,add,advised,proxied,interfaces,proxied,interfaces,length,1,advised,class,return,proxied,interfaces
