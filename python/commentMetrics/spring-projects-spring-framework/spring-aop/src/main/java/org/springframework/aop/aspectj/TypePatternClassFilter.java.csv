# id;timestamp;commentText;codeText;commentWords;codeWords
TypePatternClassFilter -> public TypePatternClassFilter();1328020251;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> public TypePatternClassFilter();1356735495;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> public TypePatternClassFilter();1357119239;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> public TypePatternClassFilter();1368482696;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> public TypePatternClassFilter();1385412762;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> public TypePatternClassFilter();1485810955;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> public TypePatternClassFilter();1498780456;Creates a new instance of the {@link TypePatternClassFilter} class._<p>This is the JavaBean constructor_ be sure to set the_{@link #setTypePattern(String) typePattern} property, else a_no doubt fatal {@link IllegalStateException} will be thrown_when the {@link #matches(Class)} method is first invoked.;public TypePatternClassFilter() {_	};creates,a,new,instance,of,the,link,type,pattern,class,filter,class,p,this,is,the,java,bean,constructor,be,sure,to,set,the,link,set,type,pattern,string,type,pattern,property,else,a,no,doubt,fatal,link,illegal,state,exception,will,be,thrown,when,the,link,matches,class,method,is,first,invoked;public,type,pattern,class,filter
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1328020251;If a type pattern has been specified in XML, the user cannot_write <code>and</code> as "&&" (though &amp_&amp_ will work)._We also allow <code>and</code> between two sub-expressions._<p>This method converts back to <code>&&</code> for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		pcExpr = StringUtils.replace(pcExpr," and "," && ")__		pcExpr = StringUtils.replace(pcExpr, " or ", " || ")__		pcExpr = StringUtils.replace(pcExpr, " not ", " ! ")__		return pcExpr__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,code,as,though,amp,amp,will,work,we,also,allow,code,and,code,between,two,sub,expressions,p,this,method,converts,back,to,code,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,pc,expr,string,utils,replace,pc,expr,and,pc,expr,string,utils,replace,pc,expr,or,pc,expr,string,utils,replace,pc,expr,not,return,pc,expr
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1356735495;If a type pattern has been specified in XML, the user cannot_write {@code and} as "&&" (though &amp_&amp_ will work)._We also allow {@code and} between two sub-expressions._<p>This method converts back to {@code &&} for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		pcExpr = StringUtils.replace(pcExpr," and "," && ")__		pcExpr = StringUtils.replace(pcExpr, " or ", " || ")__		pcExpr = StringUtils.replace(pcExpr, " not ", " ! ")__		return pcExpr__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,as,though,amp,amp,will,work,we,also,allow,code,and,between,two,sub,expressions,p,this,method,converts,back,to,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,pc,expr,string,utils,replace,pc,expr,and,pc,expr,string,utils,replace,pc,expr,or,pc,expr,string,utils,replace,pc,expr,not,return,pc,expr
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1357119239;If a type pattern has been specified in XML, the user cannot_write {@code and} as "&&" (though &amp_&amp_ will work)._We also allow {@code and} between two sub-expressions._<p>This method converts back to {@code &&} for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		pcExpr = StringUtils.replace(pcExpr," and "," && ")__		pcExpr = StringUtils.replace(pcExpr, " or ", " || ")__		pcExpr = StringUtils.replace(pcExpr, " not ", " ! ")__		return pcExpr__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,as,though,amp,amp,will,work,we,also,allow,code,and,between,two,sub,expressions,p,this,method,converts,back,to,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,pc,expr,string,utils,replace,pc,expr,and,pc,expr,string,utils,replace,pc,expr,or,pc,expr,string,utils,replace,pc,expr,not,return,pc,expr
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1368482696;If a type pattern has been specified in XML, the user cannot_write {@code and} as "&&" (though &amp_&amp_ will work)._We also allow {@code and} between two sub-expressions._<p>This method converts back to {@code &&} for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		pcExpr = StringUtils.replace(pcExpr," and "," && ")__		pcExpr = StringUtils.replace(pcExpr, " or ", " || ")__		pcExpr = StringUtils.replace(pcExpr, " not ", " ! ")__		return pcExpr__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,as,though,amp,amp,will,work,we,also,allow,code,and,between,two,sub,expressions,p,this,method,converts,back,to,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,pc,expr,string,utils,replace,pc,expr,and,pc,expr,string,utils,replace,pc,expr,or,pc,expr,string,utils,replace,pc,expr,not,return,pc,expr
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1385412762;If a type pattern has been specified in XML, the user cannot_write {@code and} as "&&" (though &amp_&amp_ will work)._We also allow {@code and} between two sub-expressions._<p>This method converts back to {@code &&} for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		pcExpr = StringUtils.replace(pcExpr," and "," && ")__		pcExpr = StringUtils.replace(pcExpr, " or ", " || ")__		pcExpr = StringUtils.replace(pcExpr, " not ", " ! ")__		return pcExpr__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,as,though,amp,amp,will,work,we,also,allow,code,and,between,two,sub,expressions,p,this,method,converts,back,to,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,pc,expr,string,utils,replace,pc,expr,and,pc,expr,string,utils,replace,pc,expr,or,pc,expr,string,utils,replace,pc,expr,not,return,pc,expr
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1485810955;If a type pattern has been specified in XML, the user cannot_write {@code and} as "&&" (though &amp_&amp_ will work)._We also allow {@code and} between two sub-expressions._<p>This method converts back to {@code &&} for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		String result = StringUtils.replace(pcExpr," and "," && ")__		result = StringUtils.replace(result, " or ", " || ")__		return StringUtils.replace(result, " not ", " ! ")__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,as,though,amp,amp,will,work,we,also,allow,code,and,between,two,sub,expressions,p,this,method,converts,back,to,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,string,result,string,utils,replace,pc,expr,and,result,string,utils,replace,result,or,return,string,utils,replace,result,not
TypePatternClassFilter -> private String replaceBooleanOperators(String pcExpr);1498780456;If a type pattern has been specified in XML, the user cannot_write {@code and} as "&&" (though &amp_&amp_ will work)._We also allow {@code and} between two sub-expressions._<p>This method converts back to {@code &&} for the AspectJ pointcut parser.;private String replaceBooleanOperators(String pcExpr) {_		String result = StringUtils.replace(pcExpr," and "," && ")__		result = StringUtils.replace(result, " or ", " || ")__		return StringUtils.replace(result, " not ", " ! ")__	};if,a,type,pattern,has,been,specified,in,xml,the,user,cannot,write,code,and,as,though,amp,amp,will,work,we,also,allow,code,and,between,two,sub,expressions,p,this,method,converts,back,to,code,for,the,aspect,j,pointcut,parser;private,string,replace,boolean,operators,string,pc,expr,string,result,string,utils,replace,pc,expr,and,result,string,utils,replace,result,or,return,string,utils,replace,result,not
TypePatternClassFilter -> @Override 	public boolean matches(Class clazz);1356735495;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;@Override_	public boolean matches(Class clazz) {_		if (this.aspectJTypePatternMatcher == null) {_			throw new IllegalStateException("No 'typePattern' has been set via ctor/setter.")__		}_		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;override,public,boolean,matches,class,clazz,if,this,aspect,jtype,pattern,matcher,null,throw,new,illegal,state,exception,no,type,pattern,has,been,set,via,ctor,setter,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> @Override 	public boolean matches(Class clazz);1368482696;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;@Override_	public boolean matches(Class clazz) {_		if (this.aspectJTypePatternMatcher == null) {_			throw new IllegalStateException("No 'typePattern' has been set via ctor/setter.")__		}_		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;override,public,boolean,matches,class,clazz,if,this,aspect,jtype,pattern,matcher,null,throw,new,illegal,state,exception,no,type,pattern,has,been,set,via,ctor,setter,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> public boolean matches(Class clazz);1328020251;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;public boolean matches(Class clazz) {_		if (this.aspectJTypePatternMatcher == null) {_			throw new IllegalStateException("No 'typePattern' has been set via ctor/setter.")__		}_		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;public,boolean,matches,class,clazz,if,this,aspect,jtype,pattern,matcher,null,throw,new,illegal,state,exception,no,type,pattern,has,been,set,via,ctor,setter,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> public boolean matches(Class clazz);1357119239;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;public boolean matches(Class clazz) {_		if (this.aspectJTypePatternMatcher == null) {_			throw new IllegalStateException("No 'typePattern' has been set via ctor/setter.")__		}_		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;public,boolean,matches,class,clazz,if,this,aspect,jtype,pattern,matcher,null,throw,new,illegal,state,exception,no,type,pattern,has,been,set,via,ctor,setter,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> public void setTypePattern(String typePattern);1328020251;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the <code>ITestBean</code> interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied <code>typePattern</code> is <code>null</code>_or is recognized as invalid;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern)__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,code,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,code,is,code,null,code,or,is,recognized,as,invalid;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public void setTypePattern(String typePattern);1356735495;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the {@code ITestBean} interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern)__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public void setTypePattern(String typePattern);1357119239;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the {@code ITestBean} interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern)__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public void setTypePattern(String typePattern);1368482696;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the {@code ITestBean} interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern)__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public void setTypePattern(String typePattern);1385412762;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the {@code ITestBean} interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern)__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public void setTypePattern(String typePattern);1485810955;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the {@code ITestBean} interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern, "Type pattern must not be null")__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,type,pattern,must,not,be,null,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public void setTypePattern(String typePattern);1498780456;Set the AspectJ type pattern to match._<p>Examples include:_<code class="code">_org.springframework.beans.*_</code>_This will match any class or interface in the given package._<code class="code">_org.springframework.beans.ITestBean+_</code>_This will match the {@code ITestBean} interface and any class_that implements it._<p>These conventions are established by AspectJ, not Spring AOP._@param typePattern the type pattern that AspectJ weaver should parse;public void setTypePattern(String typePattern) {_		Assert.notNull(typePattern, "Type pattern must not be null")__		this.typePattern = typePattern__		this.aspectJTypePatternMatcher =_				PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()._				parseTypePattern(replaceBooleanOperators(typePattern))__	};set,the,aspect,j,type,pattern,to,match,p,examples,include,code,class,code,org,springframework,beans,code,this,will,match,any,class,or,interface,in,the,given,package,code,class,code,org,springframework,beans,itest,bean,code,this,will,match,the,code,itest,bean,interface,and,any,class,that,implements,it,p,these,conventions,are,established,by,aspect,j,not,spring,aop,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse;public,void,set,type,pattern,string,type,pattern,assert,not,null,type,pattern,type,pattern,must,not,be,null,this,type,pattern,type,pattern,this,aspect,jtype,pattern,matcher,pointcut,parser,get,pointcut,parser,supporting,all,primitives,and,using,context,classloader,for,resolution,parse,type,pattern,replace,boolean,operators,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1328020251;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied <code>typePattern</code> is <code>null</code>_or is recognized as invalid;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,code,is,code,null,code,or,is,recognized,as,invalid;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1356735495;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1357119239;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1368482696;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1385412762;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1485810955;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse_@throws IllegalArgumentException if the supplied {@code typePattern} is {@code null}_or is recognized as invalid;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse,throws,illegal,argument,exception,if,the,supplied,code,type,pattern,is,code,null,or,is,recognized,as,invalid;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> public TypePatternClassFilter(String typePattern);1498780456;Create a fully configured {@link TypePatternClassFilter} using the_given type pattern._@param typePattern the type pattern that AspectJ weaver should parse;public TypePatternClassFilter(String typePattern) {_		setTypePattern(typePattern)__	};create,a,fully,configured,link,type,pattern,class,filter,using,the,given,type,pattern,param,type,pattern,the,type,pattern,that,aspect,j,weaver,should,parse;public,type,pattern,class,filter,string,type,pattern,set,type,pattern,type,pattern
TypePatternClassFilter -> @Override 	public boolean matches(Class<?> clazz);1385412762;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;@Override_	public boolean matches(Class<?> clazz) {_		if (this.aspectJTypePatternMatcher == null) {_			throw new IllegalStateException("No 'typePattern' has been set via ctor/setter.")__		}_		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;override,public,boolean,matches,class,clazz,if,this,aspect,jtype,pattern,matcher,null,throw,new,illegal,state,exception,no,type,pattern,has,been,set,via,ctor,setter,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> @Override 	public boolean matches(Class<?> clazz);1485810955;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;@Override_	public boolean matches(Class<?> clazz) {_		Assert.state(this.aspectJTypePatternMatcher != null, "No type pattern has been set")__		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;override,public,boolean,matches,class,clazz,assert,state,this,aspect,jtype,pattern,matcher,null,no,type,pattern,has,been,set,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> @Override 	public boolean matches(Class<?> clazz);1498780456;Should the pointcut apply to the given interface or target class?_@param clazz candidate target class_@return whether the advice should apply to this candidate target class_@throws IllegalStateException if no {@link #setTypePattern(String)} has been set;@Override_	public boolean matches(Class<?> clazz) {_		Assert.state(this.aspectJTypePatternMatcher != null, "No type pattern has been set")__		return this.aspectJTypePatternMatcher.matches(clazz)__	};should,the,pointcut,apply,to,the,given,interface,or,target,class,param,clazz,candidate,target,class,return,whether,the,advice,should,apply,to,this,candidate,target,class,throws,illegal,state,exception,if,no,link,set,type,pattern,string,has,been,set;override,public,boolean,matches,class,clazz,assert,state,this,aspect,jtype,pattern,matcher,null,no,type,pattern,has,been,set,return,this,aspect,jtype,pattern,matcher,matches,clazz
TypePatternClassFilter -> public String getTypePattern();1485810955;Return the AspectJ type pattern to match.;public String getTypePattern() {_		return this.typePattern__	};return,the,aspect,j,type,pattern,to,match;public,string,get,type,pattern,return,this,type,pattern
TypePatternClassFilter -> public String getTypePattern();1498780456;Return the AspectJ type pattern to match.;public String getTypePattern() {_		return this.typePattern__	};return,the,aspect,j,type,pattern,to,match;public,string,get,type,pattern,return,this,type,pattern
