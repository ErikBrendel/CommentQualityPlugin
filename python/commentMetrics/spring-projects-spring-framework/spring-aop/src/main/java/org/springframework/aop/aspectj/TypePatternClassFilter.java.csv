commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Set the AspectJ type pattern to match.  * <p>Examples include:  * <code class="code">  * org.springframework.beans.*  * </code>  * This will match any class or interface in the given package.  * <code class="code">  * org.springframework.beans.ITestBean+  * </code>  * This will match the {@code ITestBean} interface and any class  * that implements it.  * <p>These conventions are established by AspectJ, not Spring AOP.  * @param typePattern the type pattern that AspectJ weaver should parse  */ ;/**  * Set the AspectJ type pattern to match.  * <p>Examples include:  * <code class="code">  * org.springframework.beans.*  * </code>  * This will match any class or interface in the given package.  * <code class="code">  * org.springframework.beans.ITestBean+  * </code>  * This will match the {@code ITestBean} interface and any class  * that implements it.  * <p>These conventions are established by AspectJ, not Spring AOP.  * @param typePattern the type pattern that AspectJ weaver should parse  */ public void setTypePattern(String typePattern) {     Assert.notNull(typePattern, "Type pattern must not be null").     this.typePattern = typePattern.     this.aspectJTypePatternMatcher = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution().parseTypePattern(replaceBooleanOperators(typePattern)). }
true;public;0;3;/**  * Return the AspectJ type pattern to match.  */ ;/**  * Return the AspectJ type pattern to match.  */ public String getTypePattern() {     return this.typePattern. }
true;public;1;5;/**  * Should the pointcut apply to the given interface or target class?  * @param clazz candidate target class  * @return whether the advice should apply to this candidate target class  * @throws IllegalStateException if no {@link #setTypePattern(String)} has been set  */ ;/**  * Should the pointcut apply to the given interface or target class?  * @param clazz candidate target class  * @return whether the advice should apply to this candidate target class  * @throws IllegalStateException if no {@link #setTypePattern(String)} has been set  */ @Override public boolean matches(Class<?> clazz) {     Assert.state(this.aspectJTypePatternMatcher != null, "No type pattern has been set").     return this.aspectJTypePatternMatcher.matches(clazz). }
true;private;1;5;/**  * If a type pattern has been specified in XML, the user cannot  * write {@code and} as "&&" (though &amp.&amp. will work).  * We also allow {@code and} between two sub-expressions.  * <p>This method converts back to {@code &&} for the AspectJ pointcut parser.  */ ;/**  * If a type pattern has been specified in XML, the user cannot  * write {@code and} as "&&" (though &amp.&amp. will work).  * We also allow {@code and} between two sub-expressions.  * <p>This method converts back to {@code &&} for the AspectJ pointcut parser.  */ private String replaceBooleanOperators(String pcExpr) {     String result = StringUtils.replace(pcExpr, " and ", " && ").     result = StringUtils.replace(result, " or ", " || ").     return StringUtils.replace(result, " not ", " ! "). }
