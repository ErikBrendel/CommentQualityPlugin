commented;modifiers;parameterAmount;loc;comment;code
false;public;3;58;;@Override public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class<?> targetClass) {     // This is somewhat tricky... We have to process introductions first,     // but we need to preserve order in the ultimate list.     AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance().     Advisor[] advisors = config.getAdvisors().     List<Object> interceptorList = new ArrayList<>(advisors.length).     Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()).     Boolean hasIntroductions = null.     for (Advisor advisor : advisors) {         if (advisor instanceof PointcutAdvisor) {             // Add it conditionally.             PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor.             if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {                 MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher().                 boolean match.                 if (mm instanceof IntroductionAwareMethodMatcher) {                     if (hasIntroductions == null) {                         hasIntroductions = hasMatchingIntroductions(advisors, actualClass).                     }                     match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions).                 } else {                     match = mm.matches(method, actualClass).                 }                 if (match) {                     MethodInterceptor[] interceptors = registry.getInterceptors(advisor).                     if (mm.isRuntime()) {                         // isn't a problem as we normally cache created chains.                         for (MethodInterceptor interceptor : interceptors) {                             interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)).                         }                     } else {                         interceptorList.addAll(Arrays.asList(interceptors)).                     }                 }             }         } else if (advisor instanceof IntroductionAdvisor) {             IntroductionAdvisor ia = (IntroductionAdvisor) advisor.             if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {                 Interceptor[] interceptors = registry.getInterceptors(advisor).                 interceptorList.addAll(Arrays.asList(interceptors)).             }         } else {             Interceptor[] interceptors = registry.getInterceptors(advisor).             interceptorList.addAll(Arrays.asList(interceptors)).         }     }     return interceptorList. }
true;private,static;2;11;/**  * Determine whether the Advisors contain matching introductions.  */ ;/**  * Determine whether the Advisors contain matching introductions.  */ private static boolean hasMatchingIntroductions(Advisor[] advisors, Class<?> actualClass) {     for (Advisor advisor : advisors) {         if (advisor instanceof IntroductionAdvisor) {             IntroductionAdvisor ia = (IntroductionAdvisor) advisor.             if (ia.getClassFilter().matches(actualClass)) {                 return true.             }         }     }     return false. }
