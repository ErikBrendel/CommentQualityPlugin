# id;timestamp;commentText;codeText;commentWords;codeWords
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1328020251;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never <code>null</code>);public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null,code;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1356735495;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1357119239;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1368482696;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1385412762;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1445895817;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1467730834;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1496242568;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1496837955;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1496955179;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1497300858;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1498780456;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1502974979;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> public Map<String, Object> getUserAttributes();1532038651;Return user attributes associated with this invocation._This method provides an invocation-bound alternative to a ThreadLocal._<p>This map is initialized lazily and is not used in the AOP framework itself._@return any user attributes associated with this invocation_(never {@code null});public Map<String, Object> getUserAttributes() {_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}_		return this.userAttributes__	};return,user,attributes,associated,with,this,invocation,this,method,provides,an,invocation,bound,alternative,to,a,thread,local,p,this,map,is,initialized,lazily,and,is,not,used,in,the,aop,framework,itself,return,any,user,attributes,associated,with,this,invocation,never,code,null;public,map,string,object,get,user,attributes,if,this,user,attributes,null,this,user,attributes,new,hash,map,return,this,user,attributes
ReflectiveMethodInvocation -> @Nullable 	protected Object invokeJoinpoint() throws Throwable;1496837955;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;@Nullable_	protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;nullable,protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Nullable 	protected Object invokeJoinpoint() throws Throwable;1496955179;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;@Nullable_	protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;nullable,protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Nullable 	protected Object invokeJoinpoint() throws Throwable;1497300858;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;@Nullable_	protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;nullable,protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Nullable 	protected Object invokeJoinpoint() throws Throwable;1498780456;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;@Nullable_	protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;nullable,protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Nullable 	protected Object invokeJoinpoint() throws Throwable;1502974979;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;@Nullable_	protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;nullable,protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Nullable 	protected Object invokeJoinpoint() throws Throwable;1532038651;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;@Nullable_	protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;nullable,protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object... arguments);1445895817;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object... arguments);1467730834;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object... arguments);1496242568;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object... arguments);1498780456;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object... arguments);1502974979;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object... arguments);1532038651;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1328020251;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1356735495;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1357119239;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1368482696;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1385412762;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1445895817;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1467730834;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> protected Object invokeJoinpoint() throws Throwable;1496242568;Invoke the joinpoint using reflection._Subclasses can override this to use custom invocation._@return the return value of the joinpoint_@throws Throwable if invoking the joinpoint resulted in an exception;protected Object invokeJoinpoint() throws Throwable {_		return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments)__	};invoke,the,joinpoint,using,reflection,subclasses,can,override,this,to,use,custom,invocation,return,the,return,value,of,the,joinpoint,throws,throwable,if,invoking,the,joinpoint,resulted,in,an,exception;protected,object,invoke,joinpoint,throws,throwable,return,aop,utils,invoke,joinpoint,using,reflection,this,target,this,method,this,arguments
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1356735495;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1368482696;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1385412762;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1445895817;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1467730834;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1496242568;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1496837955;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1496955179;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1497300858;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1498780456;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1502974979;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public final Method getMethod();1532038651;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;@Override_	public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;override,public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object[] arguments);1356735495;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object[] arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object[] arguments);1368482696;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object[] arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(Object[] arguments);1385412762;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(Object[] arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1385412762;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = arguments__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1445895817;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1467730834;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1496242568;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1496955179;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, @Nullable Object target, Method method, Object[] arguments, 			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1496837955;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, @Nullable Object target, Method method, Object[] arguments,_			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,nullable,object,target,method,method,object,arguments,nullable,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, @Nullable Object target, Method method, Object[] arguments, 			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1497300858;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, @Nullable Object target, Method method, Object[] arguments,_			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,nullable,object,target,method,method,object,arguments,nullable,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> public MethodInvocation invocableClone();1328020251;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> public MethodInvocation invocableClone();1357119239;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(@Nullable Object... arguments);1496837955;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(@Nullable Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,nullable,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(@Nullable Object... arguments);1496955179;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(@Nullable Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,nullable,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone(@Nullable Object... arguments);1497300858;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone(@Nullable Object... arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,nullable,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, 			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1498780456;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments,_			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,nullable,object,target,method,method,nullable,object,arguments,nullable,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, 			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1502974979;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments,_			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,nullable,object,target,method,method,nullable,object,arguments,nullable,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, 			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1532038651;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments,_			@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments)__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,nullable,object,target,method,method,nullable,object,arguments,nullable,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,aop,proxy,utils,adapt,arguments,if,necessary,method,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> public final Method getMethod();1328020251;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> public final Method getMethod();1357119239;Return the method invoked on the proxied interface._May or may not correspond with a method invoked on an underlying_implementation of that interface.;public final Method getMethod() {_		return this.method__	};return,the,method,invoked,on,the,proxied,interface,may,or,may,not,correspond,with,a,method,invoked,on,an,underlying,implementation,of,that,interface;public,final,method,get,method,return,this,method
ReflectiveMethodInvocation -> public MethodInvocation invocableClone(Object[] arguments);1328020251;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();public MethodInvocation invocableClone(Object[] arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> public MethodInvocation invocableClone(Object[] arguments);1357119239;This implementation returns a shallow copy of this invocation object,_using the given arguments array for the clone._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();public MethodInvocation invocableClone(Object[] arguments) {_		_		_		if (this.userAttributes == null) {_			this.userAttributes = new HashMap<String, Object>()__		}__		_		try {_			ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone()__			clone.arguments = arguments__			return clone__		}_		catch (CloneNotSupportedException ex) {_			throw new IllegalStateException(_					"Should be able to clone object of type [" + getClass() + "]: " + ex)__		}_	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,using,the,given,arguments,array,for,the,clone,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;public,method,invocation,invocable,clone,object,arguments,if,this,user,attributes,null,this,user,attributes,new,hash,map,string,object,try,reflective,method,invocation,clone,reflective,method,invocation,clone,clone,arguments,arguments,return,clone,catch,clone,not,supported,exception,ex,throw,new,illegal,state,exception,should,be,able,to,clone,object,of,type,get,class,ex
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1328020251;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = arguments__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1356735495;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = arguments__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1357119239;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = arguments__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> protected ReflectiveMethodInvocation( 			Object proxy, Object target, Method method, Object[] arguments, 			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers);1368482696;Construct a new ReflectiveMethodInvocation with the given arguments._@param proxy the proxy object that the invocation was made on_@param target the target object to invoke_@param method the method to invoke_@param arguments the arguments to invoke the method with_@param targetClass the target class, for MethodMatcher invocations_@param interceptorsAndDynamicMethodMatchers interceptors that should be applied,_along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime._MethodMatchers included in this struct must already have been found to have matched_as far as was possibly statically. Passing an array might be about 10% faster,_but would complicate the code. And it would work only for static pointcuts.;protected ReflectiveMethodInvocation(_			Object proxy, Object target, Method method, Object[] arguments,_			Class targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {__		this.proxy = proxy__		this.target = target__		this.targetClass = targetClass__		this.method = BridgeMethodResolver.findBridgedMethod(method)__		this.arguments = arguments__		this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers__	};construct,a,new,reflective,method,invocation,with,the,given,arguments,param,proxy,the,proxy,object,that,the,invocation,was,made,on,param,target,the,target,object,to,invoke,param,method,the,method,to,invoke,param,arguments,the,arguments,to,invoke,the,method,with,param,target,class,the,target,class,for,method,matcher,invocations,param,interceptors,and,dynamic,method,matchers,interceptors,that,should,be,applied,along,with,any,interceptor,and,dynamic,method,matchers,that,need,evaluation,at,runtime,method,matchers,included,in,this,struct,must,already,have,been,found,to,have,matched,as,far,as,was,possibly,statically,passing,an,array,might,be,about,10,faster,but,would,complicate,the,code,and,it,would,work,only,for,static,pointcuts;protected,reflective,method,invocation,object,proxy,object,target,method,method,object,arguments,class,target,class,list,object,interceptors,and,dynamic,method,matchers,this,proxy,proxy,this,target,target,this,target,class,target,class,this,method,bridge,method,resolver,find,bridged,method,method,this,arguments,arguments,this,interceptors,and,dynamic,method,matchers,interceptors,and,dynamic,method,matchers
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1356735495;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1368482696;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1385412762;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1445895817;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1467730834;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1496242568;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1496837955;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1496955179;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1497300858;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = null__		if (this.arguments != null) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,null,if,this,arguments,null,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1498780456;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = this.arguments__		if (this.arguments.length > 0) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,this,arguments,if,this,arguments,length,0,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1502974979;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = this.arguments__		if (this.arguments.length > 0) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,this,arguments,if,this,arguments,length,0,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
ReflectiveMethodInvocation -> @Override 	public MethodInvocation invocableClone();1532038651;This implementation returns a shallow copy of this invocation object,_including an independent copy of the original arguments array._<p>We want a shallow copy in this case: We want to use the same interceptor_chain and other object references, but we want an independent value for the_current interceptor index._@see java.lang.Object#clone();@Override_	public MethodInvocation invocableClone() {_		Object[] cloneArguments = this.arguments__		if (this.arguments.length > 0) {_			_			cloneArguments = new Object[this.arguments.length]__			System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length)__		}_		return invocableClone(cloneArguments)__	};this,implementation,returns,a,shallow,copy,of,this,invocation,object,including,an,independent,copy,of,the,original,arguments,array,p,we,want,a,shallow,copy,in,this,case,we,want,to,use,the,same,interceptor,chain,and,other,object,references,but,we,want,an,independent,value,for,the,current,interceptor,index,see,java,lang,object,clone;override,public,method,invocation,invocable,clone,object,clone,arguments,this,arguments,if,this,arguments,length,0,clone,arguments,new,object,this,arguments,length,system,arraycopy,this,arguments,0,clone,arguments,0,this,arguments,length,return,invocable,clone,clone,arguments
