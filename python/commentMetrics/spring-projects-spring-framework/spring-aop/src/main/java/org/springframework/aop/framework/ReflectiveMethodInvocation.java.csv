commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;4;;@Override public final Object getProxy() {     return this.proxy. }
false;public,final;0;5;;@Override @Nullable public final Object getThis() {     return this.target. }
false;public,final;0;4;;@Override public final AccessibleObject getStaticPart() {     return this.method. }
true;public,final;0;4;/**  * Return the method invoked on the proxied interface.  * May or may not correspond with a method invoked on an underlying  * implementation of that interface.  */ ;/**  * Return the method invoked on the proxied interface.  * May or may not correspond with a method invoked on an underlying  * implementation of that interface.  */ @Override public final Method getMethod() {     return this.method. }
false;public,final;0;4;;@Override public final Object[] getArguments() {     return this.arguments. }
false;public;1;4;;@Override public void setArguments(Object... arguments) {     this.arguments = arguments. }
false;public;0;31;;@Override @Nullable public Object proceed() throws Throwable {     // We start with an index of -1 and increment early.     if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {         return invokeJoinpoint().     }     Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex).     if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {         // Evaluate dynamic method matcher here: static part will already have         // been evaluated and found to match.         InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice.         Class<?> targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass()).         if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {             return dm.interceptor.invoke(this).         } else {             // Skip this interceptor and invoke the next in the chain.             return proceed().         }     } else {         // been evaluated statically before this object was constructed.         return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this).     } }
true;protected;0;4;/**  * Invoke the joinpoint using reflection.  * Subclasses can override this to use custom invocation.  * @return the return value of the joinpoint  * @throws Throwable if invoking the joinpoint resulted in an exception  */ ;/**  * Invoke the joinpoint using reflection.  * Subclasses can override this to use custom invocation.  * @return the return value of the joinpoint  * @throws Throwable if invoking the joinpoint resulted in an exception  */ @Nullable protected Object invokeJoinpoint() throws Throwable {     return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments). }
true;public;0;10;/**  * This implementation returns a shallow copy of this invocation object,  * including an independent copy of the original arguments array.  * <p>We want a shallow copy in this case: We want to use the same interceptor  * chain and other object references, but we want an independent value for the  * current interceptor index.  * @see java.lang.Object#clone()  */ ;/**  * This implementation returns a shallow copy of this invocation object,  * including an independent copy of the original arguments array.  * <p>We want a shallow copy in this case: We want to use the same interceptor  * chain and other object references, but we want an independent value for the  * current interceptor index.  * @see java.lang.Object#clone()  */ @Override public MethodInvocation invocableClone() {     Object[] cloneArguments = this.arguments.     if (this.arguments.length > 0) {         // Build an independent copy of the arguments array.         cloneArguments = new Object[this.arguments.length].         System.arraycopy(this.arguments, 0, cloneArguments, 0, this.arguments.length).     }     return invocableClone(cloneArguments). }
true;public;1;19;/**  * This implementation returns a shallow copy of this invocation object,  * using the given arguments array for the clone.  * <p>We want a shallow copy in this case: We want to use the same interceptor  * chain and other object references, but we want an independent value for the  * current interceptor index.  * @see java.lang.Object#clone()  */ ;/**  * This implementation returns a shallow copy of this invocation object,  * using the given arguments array for the clone.  * <p>We want a shallow copy in this case: We want to use the same interceptor  * chain and other object references, but we want an independent value for the  * current interceptor index.  * @see java.lang.Object#clone()  */ @Override public MethodInvocation invocableClone(Object... arguments) {     // for having a shared Map reference in the clone.     if (this.userAttributes == null) {         this.userAttributes = new HashMap<>().     }     // Create the MethodInvocation clone.     try {         ReflectiveMethodInvocation clone = (ReflectiveMethodInvocation) clone().         clone.arguments = arguments.         return clone.     } catch (CloneNotSupportedException ex) {         throw new IllegalStateException("Should be able to clone object of type [" + getClass() + "]: " + ex).     } }
false;public;2;14;;@Override public void setUserAttribute(String key, @Nullable Object value) {     if (value != null) {         if (this.userAttributes == null) {             this.userAttributes = new HashMap<>().         }         this.userAttributes.put(key, value).     } else {         if (this.userAttributes != null) {             this.userAttributes.remove(key).         }     } }
false;public;1;5;;@Override @Nullable public Object getUserAttribute(String key) {     return (this.userAttributes != null ? this.userAttributes.get(key) : null). }
true;public;0;6;/**  * Return user attributes associated with this invocation.  * This method provides an invocation-bound alternative to a ThreadLocal.  * <p>This map is initialized lazily and is not used in the AOP framework itself.  * @return any user attributes associated with this invocation  * (never {@code null})  */ ;/**  * Return user attributes associated with this invocation.  * This method provides an invocation-bound alternative to a ThreadLocal.  * <p>This map is initialized lazily and is not used in the AOP framework itself.  * @return any user attributes associated with this invocation  * (never {@code null})  */ public Map<String, Object> getUserAttributes() {     if (this.userAttributes == null) {         this.userAttributes = new HashMap<>().     }     return this.userAttributes. }
false;public;0;13;;@Override public String toString() {     // Don't do toString on target, it may be proxied.     StringBuilder sb = new StringBuilder("ReflectiveMethodInvocation: ").     sb.append(this.method).append(". ").     if (this.target == null) {         sb.append("target is null").     } else {         sb.append("target is of class [").append(this.target.getClass().getName()).append(']').     }     return sb.toString(). }
