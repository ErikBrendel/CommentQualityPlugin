commented;modifiers;parameterAmount;loc;comment;code
false;public;2;26;;@Override @Nullable public BeanDefinition parse(Element element, ParserContext parserContext) {     CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)).     parserContext.pushContainingComponent(compositeDef).     configureAutoProxyCreator(parserContext, element).     List<Element> childElts = DomUtils.getChildElements(element).     for (Element elt : childElts) {         String localName = parserContext.getDelegate().getLocalName(elt).         if (POINTCUT.equals(localName)) {             parsePointcut(elt, parserContext).         } else if (ADVISOR.equals(localName)) {             parseAdvisor(elt, parserContext).         } else if (ASPECT.equals(localName)) {             parseAspect(elt, parserContext).         }     }     parserContext.popAndRegisterContainingComponent().     return null. }
true;private;2;3;/**  * Configures the auto proxy creator needed to support the {@link BeanDefinition BeanDefinitions}  * created by the '{@code <aop:config/>}' tag. Will force class proxying if the  * '{@code proxy-target-class}' attribute is set to '{@code true}'.  * @see AopNamespaceUtils  */ ;/**  * Configures the auto proxy creator needed to support the {@link BeanDefinition BeanDefinitions}  * created by the '{@code <aop:config/>}' tag. Will force class proxying if the  * '{@code proxy-target-class}' attribute is set to '{@code true}'.  * @see AopNamespaceUtils  */ private void configureAutoProxyCreator(ParserContext parserContext, Element element) {     AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element). }
true;private;2;30;/**  * Parses the supplied {@code <advisor>} element and registers the resulting  * {@link org.springframework.aop.Advisor} and any resulting {@link org.springframework.aop.Pointcut}  * with the supplied {@link BeanDefinitionRegistry}.  */ ;/**  * Parses the supplied {@code <advisor>} element and registers the resulting  * {@link org.springframework.aop.Advisor} and any resulting {@link org.springframework.aop.Pointcut}  * with the supplied {@link BeanDefinitionRegistry}.  */ private void parseAdvisor(Element advisorElement, ParserContext parserContext) {     AbstractBeanDefinition advisorDef = createAdvisorBeanDefinition(advisorElement, parserContext).     String id = advisorElement.getAttribute(ID).     try {         this.parseState.push(new AdvisorEntry(id)).         String advisorBeanName = id.         if (StringUtils.hasText(advisorBeanName)) {             parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef).         } else {             advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef).         }         Object pointcut = parsePointcutProperty(advisorElement, parserContext).         if (pointcut instanceof BeanDefinition) {             advisorDef.getPropertyValues().add(POINTCUT, pointcut).             parserContext.registerComponent(new AdvisorComponentDefinition(advisorBeanName, advisorDef, (BeanDefinition) pointcut)).         } else if (pointcut instanceof String) {             advisorDef.getPropertyValues().add(POINTCUT, new RuntimeBeanReference((String) pointcut)).             parserContext.registerComponent(new AdvisorComponentDefinition(advisorBeanName, advisorDef)).         }     } finally {         this.parseState.pop().     } }
true;private;2;21;/**  * Create a {@link RootBeanDefinition} for the advisor described in the supplied. Does <strong>not</strong>  * parse any associated '{@code pointcut}' or '{@code pointcut-ref}' attributes.  */ ;/**  * Create a {@link RootBeanDefinition} for the advisor described in the supplied. Does <strong>not</strong>  * parse any associated '{@code pointcut}' or '{@code pointcut-ref}' attributes.  */ private AbstractBeanDefinition createAdvisorBeanDefinition(Element advisorElement, ParserContext parserContext) {     RootBeanDefinition advisorDefinition = new RootBeanDefinition(DefaultBeanFactoryPointcutAdvisor.class).     advisorDefinition.setSource(parserContext.extractSource(advisorElement)).     String adviceRef = advisorElement.getAttribute(ADVICE_REF).     if (!StringUtils.hasText(adviceRef)) {         parserContext.getReaderContext().error("'advice-ref' attribute contains empty value.", advisorElement, this.parseState.snapshot()).     } else {         advisorDefinition.getPropertyValues().add(ADVICE_BEAN_NAME, new RuntimeBeanNameReference(adviceRef)).     }     if (advisorElement.hasAttribute(ORDER_PROPERTY)) {         advisorDefinition.getPropertyValues().add(ORDER_PROPERTY, advisorElement.getAttribute(ORDER_PROPERTY)).     }     return advisorDefinition. }
false;private;2;53;;private void parseAspect(Element aspectElement, ParserContext parserContext) {     String aspectId = aspectElement.getAttribute(ID).     String aspectName = aspectElement.getAttribute(REF).     try {         this.parseState.push(new AspectEntry(aspectId, aspectName)).         List<BeanDefinition> beanDefinitions = new ArrayList<>().         List<BeanReference> beanReferences = new ArrayList<>().         List<Element> declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS).         for (int i = METHOD_INDEX. i < declareParents.size(). i++) {             Element declareParentsElement = declareParents.get(i).             beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext)).         }         // We have to parse "advice" and all the advice kinds in one loop, to get the         // ordering semantics right.         NodeList nodeList = aspectElement.getChildNodes().         boolean adviceFoundAlready = false.         for (int i = 0. i < nodeList.getLength(). i++) {             Node node = nodeList.item(i).             if (isAdviceNode(node, parserContext)) {                 if (!adviceFoundAlready) {                     adviceFoundAlready = true.                     if (!StringUtils.hasText(aspectName)) {                         parserContext.getReaderContext().error("<aspect> tag needs aspect bean reference via 'ref' attribute when declaring advices.", aspectElement, this.parseState.snapshot()).                         return.                     }                     beanReferences.add(new RuntimeBeanReference(aspectName)).                 }                 AbstractBeanDefinition advisorDefinition = parseAdvice(aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences).                 beanDefinitions.add(advisorDefinition).             }         }         AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(aspectElement, aspectId, beanDefinitions, beanReferences, parserContext).         parserContext.pushContainingComponent(aspectComponentDefinition).         List<Element> pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT).         for (Element pointcutElement : pointcuts) {             parsePointcut(pointcutElement, parserContext).         }         parserContext.popAndRegisterContainingComponent().     } finally {         this.parseState.pop().     } }
false;private;5;9;;private AspectComponentDefinition createAspectComponentDefinition(Element aspectElement, String aspectId, List<BeanDefinition> beanDefs, List<BeanReference> beanRefs, ParserContext parserContext) {     BeanDefinition[] beanDefArray = beanDefs.toArray(new BeanDefinition[0]).     BeanReference[] beanRefArray = beanRefs.toArray(new BeanReference[0]).     Object source = parserContext.extractSource(aspectElement).     return new AspectComponentDefinition(aspectId, beanDefArray, beanRefArray, source). }
true;private;2;10;/**  * Return {@code true} if the supplied node describes an advice type. May be one of:  * '{@code before}', '{@code after}', '{@code after-returning}',  * '{@code after-throwing}' or '{@code around}'.  */ ;/**  * Return {@code true} if the supplied node describes an advice type. May be one of:  * '{@code before}', '{@code after}', '{@code after-returning}',  * '{@code after-throwing}' or '{@code around}'.  */ private boolean isAdviceNode(Node aNode, ParserContext parserContext) {     if (!(aNode instanceof Element)) {         return false.     } else {         String name = parserContext.getDelegate().getLocalName(aNode).         return (BEFORE.equals(name) || AFTER.equals(name) || AFTER_RETURNING_ELEMENT.equals(name) || AFTER_THROWING_ELEMENT.equals(name) || AROUND.equals(name)).     } }
true;private;2;25;/**  * Parse a '{@code declare-parents}' element and register the appropriate  * DeclareParentsAdvisor with the BeanDefinitionRegistry encapsulated in the  * supplied ParserContext.  */ ;/**  * Parse a '{@code declare-parents}' element and register the appropriate  * DeclareParentsAdvisor with the BeanDefinitionRegistry encapsulated in the  * supplied ParserContext.  */ private AbstractBeanDefinition parseDeclareParents(Element declareParentsElement, ParserContext parserContext) {     BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(DeclareParentsAdvisor.class).     builder.addConstructorArgValue(declareParentsElement.getAttribute(IMPLEMENT_INTERFACE)).     builder.addConstructorArgValue(declareParentsElement.getAttribute(TYPE_PATTERN)).     String defaultImpl = declareParentsElement.getAttribute(DEFAULT_IMPL).     String delegateRef = declareParentsElement.getAttribute(DELEGATE_REF).     if (StringUtils.hasText(defaultImpl) && !StringUtils.hasText(delegateRef)) {         builder.addConstructorArgValue(defaultImpl).     } else if (StringUtils.hasText(delegateRef) && !StringUtils.hasText(defaultImpl)) {         builder.addConstructorArgReference(delegateRef).     } else {         parserContext.getReaderContext().error("Exactly one of the " + DEFAULT_IMPL + " or " + DELEGATE_REF + " attributes must be specified", declareParentsElement, this.parseState.snapshot()).     }     AbstractBeanDefinition definition = builder.getBeanDefinition().     definition.setSource(parserContext.extractSource(declareParentsElement)).     parserContext.getReaderContext().registerWithGeneratedName(definition).     return definition. }
true;private;7;42;/**  * Parses one of '{@code before}', '{@code after}', '{@code after-returning}',  * '{@code after-throwing}' or '{@code around}' and registers the resulting  * BeanDefinition with the supplied BeanDefinitionRegistry.  * @return the generated advice RootBeanDefinition  */ ;/**  * Parses one of '{@code before}', '{@code after}', '{@code after-returning}',  * '{@code after-throwing}' or '{@code around}' and registers the resulting  * BeanDefinition with the supplied BeanDefinitionRegistry.  * @return the generated advice RootBeanDefinition  */ private AbstractBeanDefinition parseAdvice(String aspectName, int order, Element aspectElement, Element adviceElement, ParserContext parserContext, List<BeanDefinition> beanDefinitions, List<BeanReference> beanReferences) {     try {         this.parseState.push(new AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement))).         // create the method factory bean         RootBeanDefinition methodDefinition = new RootBeanDefinition(MethodLocatingFactoryBean.class).         methodDefinition.getPropertyValues().add("targetBeanName", aspectName).         methodDefinition.getPropertyValues().add("methodName", adviceElement.getAttribute("method")).         methodDefinition.setSynthetic(true).         // create instance factory definition         RootBeanDefinition aspectFactoryDef = new RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class).         aspectFactoryDef.getPropertyValues().add("aspectBeanName", aspectName).         aspectFactoryDef.setSynthetic(true).         // register the pointcut         AbstractBeanDefinition adviceDef = createAdviceDefinition(adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef, beanDefinitions, beanReferences).         // configure the advisor         RootBeanDefinition advisorDefinition = new RootBeanDefinition(AspectJPointcutAdvisor.class).         advisorDefinition.setSource(parserContext.extractSource(adviceElement)).         advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef).         if (aspectElement.hasAttribute(ORDER_PROPERTY)) {             advisorDefinition.getPropertyValues().add(ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY)).         }         // register the final advisor         parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition).         return advisorDefinition.     } finally {         this.parseState.pop().     } }
true;private;8;42;/**  * Creates the RootBeanDefinition for a POJO advice bean. Also causes pointcut  * parsing to occur so that the pointcut may be associate with the advice bean.  * This same pointcut is also configured as the pointcut for the enclosing  * Advisor definition using the supplied MutablePropertyValues.  */ ;/**  * Creates the RootBeanDefinition for a POJO advice bean. Also causes pointcut  * parsing to occur so that the pointcut may be associate with the advice bean.  * This same pointcut is also configured as the pointcut for the enclosing  * Advisor definition using the supplied MutablePropertyValues.  */ private AbstractBeanDefinition createAdviceDefinition(Element adviceElement, ParserContext parserContext, String aspectName, int order, RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef, List<BeanDefinition> beanDefinitions, List<BeanReference> beanReferences) {     RootBeanDefinition adviceDefinition = new RootBeanDefinition(getAdviceClass(adviceElement, parserContext)).     adviceDefinition.setSource(parserContext.extractSource(adviceElement)).     adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName).     adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order).     if (adviceElement.hasAttribute(RETURNING)) {         adviceDefinition.getPropertyValues().add(RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING)).     }     if (adviceElement.hasAttribute(THROWING)) {         adviceDefinition.getPropertyValues().add(THROWING_PROPERTY, adviceElement.getAttribute(THROWING)).     }     if (adviceElement.hasAttribute(ARG_NAMES)) {         adviceDefinition.getPropertyValues().add(ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES)).     }     ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues().     cav.addIndexedArgumentValue(METHOD_INDEX, methodDef).     Object pointcut = parsePointcutProperty(adviceElement, parserContext).     if (pointcut instanceof BeanDefinition) {         cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut).         beanDefinitions.add((BeanDefinition) pointcut).     } else if (pointcut instanceof String) {         RuntimeBeanReference pointcutRef = new RuntimeBeanReference((String) pointcut).         cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef).         beanReferences.add(pointcutRef).     }     cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef).     return adviceDefinition. }
true;private;2;21;/**  * Gets the advice implementation class corresponding to the supplied {@link Element}.  */ ;/**  * Gets the advice implementation class corresponding to the supplied {@link Element}.  */ private Class<?> getAdviceClass(Element adviceElement, ParserContext parserContext) {     String elementName = parserContext.getDelegate().getLocalName(adviceElement).     if (BEFORE.equals(elementName)) {         return AspectJMethodBeforeAdvice.class.     } else if (AFTER.equals(elementName)) {         return AspectJAfterAdvice.class.     } else if (AFTER_RETURNING_ELEMENT.equals(elementName)) {         return AspectJAfterReturningAdvice.class.     } else if (AFTER_THROWING_ELEMENT.equals(elementName)) {         return AspectJAfterThrowingAdvice.class.     } else if (AROUND.equals(elementName)) {         return AspectJAroundAdvice.class.     } else {         throw new IllegalArgumentException("Unknown advice kind [" + elementName + "].").     } }
true;private;2;28;/**  * Parses the supplied {@code <pointcut>} and registers the resulting  * Pointcut with the BeanDefinitionRegistry.  */ ;/**  * Parses the supplied {@code <pointcut>} and registers the resulting  * Pointcut with the BeanDefinitionRegistry.  */ private AbstractBeanDefinition parsePointcut(Element pointcutElement, ParserContext parserContext) {     String id = pointcutElement.getAttribute(ID).     String expression = pointcutElement.getAttribute(EXPRESSION).     AbstractBeanDefinition pointcutDefinition = null.     try {         this.parseState.push(new PointcutEntry(id)).         pointcutDefinition = createPointcutDefinition(expression).         pointcutDefinition.setSource(parserContext.extractSource(pointcutElement)).         String pointcutBeanName = id.         if (StringUtils.hasText(pointcutBeanName)) {             parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition).         } else {             pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition).         }         parserContext.registerComponent(new PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression)).     } finally {         this.parseState.pop().     }     return pointcutDefinition. }
true;private;2;31;/**  * Parses the {@code pointcut} or {@code pointcut-ref} attributes of the supplied  * {@link Element} and add a {@code pointcut} property as appropriate. Generates a  * {@link org.springframework.beans.factory.config.BeanDefinition} for the pointcut if  necessary  * and returns its bean name, otherwise returns the bean name of the referred pointcut.  */ ;/**  * Parses the {@code pointcut} or {@code pointcut-ref} attributes of the supplied  * {@link Element} and add a {@code pointcut} property as appropriate. Generates a  * {@link org.springframework.beans.factory.config.BeanDefinition} for the pointcut if  necessary  * and returns its bean name, otherwise returns the bean name of the referred pointcut.  */ @Nullable private Object parsePointcutProperty(Element element, ParserContext parserContext) {     if (element.hasAttribute(POINTCUT) && element.hasAttribute(POINTCUT_REF)) {         parserContext.getReaderContext().error("Cannot define both 'pointcut' and 'pointcut-ref' on <advisor> tag.", element, this.parseState.snapshot()).         return null.     } else if (element.hasAttribute(POINTCUT)) {         // Create a pointcut for the anonymous pc and register it.         String expression = element.getAttribute(POINTCUT).         AbstractBeanDefinition pointcutDefinition = createPointcutDefinition(expression).         pointcutDefinition.setSource(parserContext.extractSource(element)).         return pointcutDefinition.     } else if (element.hasAttribute(POINTCUT_REF)) {         String pointcutRef = element.getAttribute(POINTCUT_REF).         if (!StringUtils.hasText(pointcutRef)) {             parserContext.getReaderContext().error("'pointcut-ref' attribute contains empty value.", element, this.parseState.snapshot()).             return null.         }         return pointcutRef.     } else {         parserContext.getReaderContext().error("Must define one of 'pointcut' or 'pointcut-ref' on <advisor> tag.", element, this.parseState.snapshot()).         return null.     } }
true;protected;1;7;/**  * Creates a {@link BeanDefinition} for the {@link AspectJExpressionPointcut} class using  * the supplied pointcut expression.  */ ;/**  * Creates a {@link BeanDefinition} for the {@link AspectJExpressionPointcut} class using  * the supplied pointcut expression.  */ protected AbstractBeanDefinition createPointcutDefinition(String expression) {     RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class).     beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE).     beanDefinition.setSynthetic(true).     beanDefinition.getPropertyValues().add(EXPRESSION, expression).     return beanDefinition. }
