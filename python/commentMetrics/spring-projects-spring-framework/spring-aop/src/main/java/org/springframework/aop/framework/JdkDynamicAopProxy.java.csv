commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Object getProxy() {     return getProxy(ClassUtils.getDefaultClassLoader()). }
false;public;1;9;;@Override public Object getProxy(@Nullable ClassLoader classLoader) {     if (logger.isTraceEnabled()) {         logger.trace("Creating JDK dynamic proxy: " + this.advised.getTargetSource()).     }     Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true).     findDefinedEqualsAndHashCodeMethods(proxiedInterfaces).     return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this). }
true;private;1;16;/**  * Finds any {@link #equals} or {@link #hashCode} method that may be defined  * on the supplied set of interfaces.  * @param proxiedInterfaces the interfaces to introspect  */ ;/**  * Finds any {@link #equals} or {@link #hashCode} method that may be defined  * on the supplied set of interfaces.  * @param proxiedInterfaces the interfaces to introspect  */ private void findDefinedEqualsAndHashCodeMethods(Class<?>[] proxiedInterfaces) {     for (Class<?> proxiedInterface : proxiedInterfaces) {         Method[] methods = proxiedInterface.getDeclaredMethods().         for (Method method : methods) {             if (AopUtils.isEqualsMethod(method)) {                 this.equalsDefined = true.             }             if (AopUtils.isHashCodeMethod(method)) {                 this.hashCodeDefined = true.             }             if (this.equalsDefined && this.hashCodeDefined) {                 return.             }         }     } }
true;public;3;88;/**  * Implementation of {@code InvocationHandler.invoke}.  * <p>Callers will see exactly the exception thrown by the target,  * unless a hook method throws an exception.  */ ;/**  * Implementation of {@code InvocationHandler.invoke}.  * <p>Callers will see exactly the exception thrown by the target,  * unless a hook method throws an exception.  */ @Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     MethodInvocation invocation.     Object oldProxy = null.     boolean setProxyContext = false.     TargetSource targetSource = this.advised.targetSource.     Object target = null.     try {         if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {             // The target does not implement the equals(Object) method itself.             return equals(args[0]).         } else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {             // The target does not implement the hashCode() method itself.             return hashCode().         } else if (method.getDeclaringClass() == DecoratingProxy.class) {             // There is only getDecoratedClass() declared -> dispatch to proxy config.             return AopProxyUtils.ultimateTargetClass(this.advised).         } else if (!this.advised.opaque && method.getDeclaringClass().isInterface() && method.getDeclaringClass().isAssignableFrom(Advised.class)) {             // Service invocations on ProxyConfig with the proxy config...             return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args).         }         Object retVal.         if (this.advised.exposeProxy) {             // Make invocation available if necessary.             oldProxy = AopContext.setCurrentProxy(proxy).             setProxyContext = true.         }         // Get as late as possible to minimize the time we "own" the target,         // in case it comes from a pool.         target = targetSource.getTarget().         Class<?> targetClass = (target != null ? target.getClass() : null).         // Get the interception chain for this method.         List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass).         // reflective invocation of the target, and avoid creating a MethodInvocation.         if (chain.isEmpty()) {             // We can skip creating a MethodInvocation: just invoke the target directly             // Note that the final invoker must be an InvokerInterceptor so we know it does             // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.             Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args).             retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse).         } else {             // We need to create a method invocation...             invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain).             // Proceed to the joinpoint through the interceptor chain.             retVal = invocation.proceed().         }         // Massage return value if necessary.         Class<?> returnType = method.getReturnType().         if (retVal != null && retVal == target && returnType != Object.class && returnType.isInstance(proxy) && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {             // Special case: it returned "this" and the return type of the method             // is type-compatible. Note that we can't help if the target sets             // a reference to itself in another returned object.             retVal = proxy.         } else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {             throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method).         }         return retVal.     } finally {         if (target != null && !targetSource.isStatic()) {             // Must have come from TargetSource.             targetSource.releaseTarget(target).         }         if (setProxyContext) {             // Restore old proxy.             AopContext.setCurrentProxy(oldProxy).         }     } }
true;public;1;28;/**  * Equality means interfaces, advisors and TargetSource are equal.  * <p>The compared object may be a JdkDynamicAopProxy instance itself  * or a dynamic proxy wrapping a JdkDynamicAopProxy instance.  */ ;/**  * Equality means interfaces, advisors and TargetSource are equal.  * <p>The compared object may be a JdkDynamicAopProxy instance itself  * or a dynamic proxy wrapping a JdkDynamicAopProxy instance.  */ @Override public boolean equals(@Nullable Object other) {     if (other == this) {         return true.     }     if (other == null) {         return false.     }     JdkDynamicAopProxy otherProxy.     if (other instanceof JdkDynamicAopProxy) {         otherProxy = (JdkDynamicAopProxy) other.     } else if (Proxy.isProxyClass(other.getClass())) {         InvocationHandler ih = Proxy.getInvocationHandler(other).         if (!(ih instanceof JdkDynamicAopProxy)) {             return false.         }         otherProxy = (JdkDynamicAopProxy) ih.     } else {         // Not a valid comparison...         return false.     }     // If we get here, otherProxy is the other AopProxy.     return AopProxyUtils.equalsInProxy(this.advised, otherProxy.advised). }
true;public;0;4;/**  * Proxy uses the hash code of the TargetSource.  */ ;/**  * Proxy uses the hash code of the TargetSource.  */ @Override public int hashCode() {     return JdkDynamicAopProxy.class.hashCode() * 13 + this.advised.getTargetSource().hashCode(). }
