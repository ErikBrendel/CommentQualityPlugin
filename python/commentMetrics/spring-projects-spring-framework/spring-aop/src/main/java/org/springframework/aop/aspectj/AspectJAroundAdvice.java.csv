commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isBeforeAdvice() {     return false. }
false;public;0;4;;@Override public boolean isAfterAdvice() {     return false. }
false;protected;0;4;;@Override protected boolean supportsProceedingJoinPoint() {     return true. }
false;public;1;10;;@Override public Object invoke(MethodInvocation mi) throws Throwable {     if (!(mi instanceof ProxyMethodInvocation)) {         throw new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi).     }     ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi.     ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi).     JoinPointMatch jpm = getJoinPointMatch(pmi).     return invokeAdviceMethod(pjp, jpm, null, null). }
true;protected;1;3;/**  * Return the ProceedingJoinPoint for the current invocation,  * instantiating it lazily if it hasn't been bound to the thread already.  * @param rmi the current Spring AOP ReflectiveMethodInvocation,  * which we'll use for attribute binding  * @return the ProceedingJoinPoint to make available to advice methods  */ ;/**  * Return the ProceedingJoinPoint for the current invocation,  * instantiating it lazily if it hasn't been bound to the thread already.  * @param rmi the current Spring AOP ReflectiveMethodInvocation,  * which we'll use for attribute binding  * @return the ProceedingJoinPoint to make available to advice methods  */ protected ProceedingJoinPoint lazyGetProceedingJoinPoint(ProxyMethodInvocation rmi) {     return new MethodInvocationProceedingJoinPoint(rmi). }
