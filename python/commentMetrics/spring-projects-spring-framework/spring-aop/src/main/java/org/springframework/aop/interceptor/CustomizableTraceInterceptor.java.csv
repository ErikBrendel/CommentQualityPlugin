commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Set the template used for method entry log messages.  * This template can contain any of the following placeholders:  * <ul>  * <li>{@code $[targetClassName]}</li>  * <li>{@code $[targetClassShortName]}</li>  * <li>{@code $[argumentTypes]}</li>  * <li>{@code $[arguments]}</li>  * </ul>  */ ;/**  * Set the template used for method entry log messages.  * This template can contain any of the following placeholders:  * <ul>  * <li>{@code $[targetClassName]}</li>  * <li>{@code $[targetClassShortName]}</li>  * <li>{@code $[argumentTypes]}</li>  * <li>{@code $[arguments]}</li>  * </ul>  */ public void setEnterMessage(String enterMessage) throws IllegalArgumentException {     Assert.hasText(enterMessage, "enterMessage must not be empty").     checkForInvalidPlaceholders(enterMessage).     Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE, "enterMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE).     Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION, "enterMessage cannot contain placeholder " + PLACEHOLDER_EXCEPTION).     Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME, "enterMessage cannot contain placeholder " + PLACEHOLDER_INVOCATION_TIME).     this.enterMessage = enterMessage. }
true;public;1;7;/**  * Set the template used for method exit log messages.  * This template can contain any of the following placeholders:  * <ul>  * <li>{@code $[targetClassName]}</li>  * <li>{@code $[targetClassShortName]}</li>  * <li>{@code $[argumentTypes]}</li>  * <li>{@code $[arguments]}</li>  * <li>{@code $[returnValue]}</li>  * <li>{@code $[invocationTime]}</li>  * </ul>  */ ;/**  * Set the template used for method exit log messages.  * This template can contain any of the following placeholders:  * <ul>  * <li>{@code $[targetClassName]}</li>  * <li>{@code $[targetClassShortName]}</li>  * <li>{@code $[argumentTypes]}</li>  * <li>{@code $[arguments]}</li>  * <li>{@code $[returnValue]}</li>  * <li>{@code $[invocationTime]}</li>  * </ul>  */ public void setExitMessage(String exitMessage) {     Assert.hasText(exitMessage, "exitMessage must not be empty").     checkForInvalidPlaceholders(exitMessage).     Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION, "exitMessage cannot contain placeholder" + PLACEHOLDER_EXCEPTION).     this.exitMessage = exitMessage. }
true;public;1;7;/**  * Set the template used for method exception log messages.  * This template can contain any of the following placeholders:  * <ul>  * <li>{@code $[targetClassName]}</li>  * <li>{@code $[targetClassShortName]}</li>  * <li>{@code $[argumentTypes]}</li>  * <li>{@code $[arguments]}</li>  * <li>{@code $[exception]}</li>  * </ul>  */ ;/**  * Set the template used for method exception log messages.  * This template can contain any of the following placeholders:  * <ul>  * <li>{@code $[targetClassName]}</li>  * <li>{@code $[targetClassShortName]}</li>  * <li>{@code $[argumentTypes]}</li>  * <li>{@code $[arguments]}</li>  * <li>{@code $[exception]}</li>  * </ul>  */ public void setExceptionMessage(String exceptionMessage) {     Assert.hasText(exceptionMessage, "exceptionMessage must not be empty").     checkForInvalidPlaceholders(exceptionMessage).     Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE, "exceptionMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE).     this.exceptionMessage = exceptionMessage. }
true;protected;2;32;/**  * Writes a log message before the invocation based on the value of {@code enterMessage}.  * If the invocation succeeds, then a log message is written on exit based on the value  * {@code exitMessage}. If an exception occurs during invocation, then a message is  * written based on the value of {@code exceptionMessage}.  * @see #setEnterMessage  * @see #setExitMessage  * @see #setExceptionMessage  */ ;/**  * Writes a log message before the invocation based on the value of {@code enterMessage}.  * If the invocation succeeds, then a log message is written on exit based on the value  * {@code exitMessage}. If an exception occurs during invocation, then a message is  * written based on the value of {@code exceptionMessage}.  * @see #setEnterMessage  * @see #setExitMessage  * @see #setExceptionMessage  */ @Override protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {     String name = ClassUtils.getQualifiedMethodName(invocation.getMethod()).     StopWatch stopWatch = new StopWatch(name).     Object returnValue = null.     boolean exitThroughException = false.     try {         stopWatch.start(name).         writeToLog(logger, replacePlaceholders(this.enterMessage, invocation, null, null, -1)).         returnValue = invocation.proceed().         return returnValue.     } catch (Throwable ex) {         if (stopWatch.isRunning()) {             stopWatch.stop().         }         exitThroughException = true.         writeToLog(logger, replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex).         throw ex.     } finally {         if (!exitThroughException) {             if (stopWatch.isRunning()) {                 stopWatch.stop().             }             writeToLog(logger, replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis())).         }     } }
true;protected;5;44;/**  * Replace the placeholders in the given message with the supplied values,  * or values derived from those supplied.  * @param message the message template containing the placeholders to be replaced  * @param methodInvocation the {@code MethodInvocation} being logged.  * Used to derive values for all placeholders except {@code $[exception]}  * and {@code $[returnValue]}.  * @param returnValue any value returned by the invocation.  * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.  * @param throwable any {@code Throwable} raised during the invocation.  * The value of {@code Throwable.toString()} is replaced for the  * {@code $[exception]} placeholder. May be {@code null}.  * @param invocationTime the value to write in place of the  * {@code $[invocationTime]} placeholder  * @return the formatted output to write to the log  */ ;/**  * Replace the placeholders in the given message with the supplied values,  * or values derived from those supplied.  * @param message the message template containing the placeholders to be replaced  * @param methodInvocation the {@code MethodInvocation} being logged.  * Used to derive values for all placeholders except {@code $[exception]}  * and {@code $[returnValue]}.  * @param returnValue any value returned by the invocation.  * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.  * @param throwable any {@code Throwable} raised during the invocation.  * The value of {@code Throwable.toString()} is replaced for the  * {@code $[exception]} placeholder. May be {@code null}.  * @param invocationTime the value to write in place of the  * {@code $[invocationTime]} placeholder  * @return the formatted output to write to the log  */ protected String replacePlaceholders(String message, MethodInvocation methodInvocation, @Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {     Matcher matcher = PATTERN.matcher(message).     StringBuffer output = new StringBuffer().     while (matcher.find()) {         String match = matcher.group().         if (PLACEHOLDER_METHOD_NAME.equals(match)) {             matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName())).         } else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {             String className = getClassForLogging(methodInvocation.getThis()).getName().             matcher.appendReplacement(output, Matcher.quoteReplacement(className)).         } else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {             String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis())).             matcher.appendReplacement(output, Matcher.quoteReplacement(shortName)).         } else if (PLACEHOLDER_ARGUMENTS.equals(match)) {             matcher.appendReplacement(output, Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments()))).         } else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {             appendArgumentTypes(methodInvocation, matcher, output).         } else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {             appendReturnValue(methodInvocation, matcher, output, returnValue).         } else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {             matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString())).         } else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {             matcher.appendReplacement(output, Long.toString(invocationTime)).         } else {             // Should not happen since placeholders are checked earlier.             throw new IllegalArgumentException("Unknown placeholder [" + match + "]").         }     }     matcher.appendTail(output).     return output.toString(). }
true;private;4;13;/**  * Adds the {@code String} representation of the method return value  * to the supplied {@code StringBuffer}. Correctly handles  * {@code null} and {@code void} results.  * @param methodInvocation the {@code MethodInvocation} that returned the value  * @param matcher the {@code Matcher} containing the matched placeholder  * @param output the {@code StringBuffer} to write output to  * @param returnValue the value returned by the method invocation.  */ ;/**  * Adds the {@code String} representation of the method return value  * to the supplied {@code StringBuffer}. Correctly handles  * {@code null} and {@code void} results.  * @param methodInvocation the {@code MethodInvocation} that returned the value  * @param matcher the {@code Matcher} containing the matched placeholder  * @param output the {@code StringBuffer} to write output to  * @param returnValue the value returned by the method invocation.  */ private void appendReturnValue(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue) {     if (methodInvocation.getMethod().getReturnType() == void.class) {         matcher.appendReplacement(output, "void").     } else if (returnValue == null) {         matcher.appendReplacement(output, "null").     } else {         matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString())).     } }
true;private;3;9;/**  * Adds a comma-separated list of the short {@code Class} names of the  * method argument types to the output. For example, if a method has signature  * {@code put(java.lang.String, java.lang.Object)} then the value returned  * will be {@code String, Object}.  * @param methodInvocation the {@code MethodInvocation} being logged.  * Arguments will be retrieved from the corresponding {@code Method}.  * @param matcher the {@code Matcher} containing the state of the output  * @param output the {@code StringBuffer} containing the output  */ ;/**  * Adds a comma-separated list of the short {@code Class} names of the  * method argument types to the output. For example, if a method has signature  * {@code put(java.lang.String, java.lang.Object)} then the value returned  * will be {@code String, Object}.  * @param methodInvocation the {@code MethodInvocation} being logged.  * Arguments will be retrieved from the corresponding {@code Method}.  * @param matcher the {@code Matcher} containing the state of the output  * @param output the {@code StringBuffer} containing the output  */ private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {     Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes().     String[] argumentTypeShortNames = new String[argumentTypes.length].     for (int i = 0. i < argumentTypeShortNames.length. i++) {         argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i]).     }     matcher.appendReplacement(output, Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames))). }
true;private;1;9;/**  * Checks to see if the supplied {@code String} has any placeholders  * that are not specified as constants on this class and throws an  * {@code IllegalArgumentException} if so.  */ ;/**  * Checks to see if the supplied {@code String} has any placeholders  * that are not specified as constants on this class and throws an  * {@code IllegalArgumentException} if so.  */ private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {     Matcher matcher = PATTERN.matcher(message).     while (matcher.find()) {         String match = matcher.group().         if (!ALLOWED_PLACEHOLDERS.contains(match)) {             throw new IllegalArgumentException("Placeholder [" + match + "] is not valid").         }     } }
