# id;timestamp;commentText;codeText;commentWords;codeWords
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			Object returnValue, Throwable throwable, long invocationTime);1328020251;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the <code>MethodInvocation</code> being logged._Used to derive values for all placeholders except <code>$[exception]</code>_and <code>$[returnValue]</code>._@param returnValue any value returned by the invocation._Used to replace the <code>$[returnValue]</code> placeholder. May be <code>null</code>._@param throwable any <code>Throwable</code> raised during the invocation._The value of <code>Throwable.toString()</code> is replaced for the_<code>$[exception]</code> placeholder. May be <code>null</code>._@param invocationTime the value to write in place of the_<code>$[invocationTime]</code> placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			Object returnValue, Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, escape(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, escape(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, escape(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output, escape(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, escape(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,code,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,code,and,code,return,value,code,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,code,placeholder,may,be,code,null,code,param,throwable,any,code,throwable,code,raised,during,the,invocation,the,value,of,code,throwable,to,string,code,is,replaced,for,the,code,exception,code,placeholder,may,be,code,null,code,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,code,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,object,return,value,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,escape,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,escape,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,escape,short,name,else,if,equals,match,matcher,append,replacement,output,escape,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,escape,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			Object returnValue, Throwable throwable, long invocationTime);1356735495;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			Object returnValue, Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, escape(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, escape(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, escape(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output, escape(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, escape(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,object,return,value,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,escape,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,escape,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,escape,short,name,else,if,equals,match,matcher,append,replacement,output,escape,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,escape,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			Object returnValue, Throwable throwable, long invocationTime);1363695345;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			Object returnValue, Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,object,return,value,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			Object returnValue, Throwable throwable, long invocationTime);1385412762;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			Object returnValue, Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,object,return,value,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			Object returnValue, Throwable throwable, long invocationTime);1405696918;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			Object returnValue, Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,object,return,value,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			Object returnValue, Throwable throwable, long invocationTime);1477045587;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			Object returnValue, Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,object,return,value,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1328020251;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li><code>$[targetClassName]</code></li>_<li><code>$[targetClassShortName]</code></li>_<li><code>$[argumentTypes]</code></li>_<li><code>$[arguments]</code></li>_<li><code>$[returnValue]</code></li>_<li><code>$[invocationTime]</code></li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,code,li,li,code,target,class,short,name,code,li,li,code,argument,types,code,li,li,code,arguments,code,li,li,code,return,value,code,li,li,code,invocation,time,code,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1356735495;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1363695345;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1385412762;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1405696918;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1477045587;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1495868221;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1496837955;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "'exitMessage' must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1499879592;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "exitMessage must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder" + PLACEHOLDER_EXCEPTION)__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1499944780;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "exitMessage must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder" + PLACEHOLDER_EXCEPTION)__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> public void setExitMessage(String exitMessage);1542468661;Set the template used for method exit log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[returnValue]}</li>_<li>{@code $[invocationTime]}</li>_</ul>;public void setExitMessage(String exitMessage) {_		Assert.hasText(exitMessage, "exitMessage must not be empty")__		checkForInvalidPlaceholders(exitMessage)__		Assert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,_				"exitMessage cannot contain placeholder" + PLACEHOLDER_EXCEPTION)__		this.exitMessage = exitMessage__	};set,the,template,used,for,method,exit,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,return,value,li,li,code,invocation,time,li,ul;public,void,set,exit,message,string,exit,message,assert,has,text,exit,message,exit,message,must,not,be,empty,check,for,invalid,placeholders,exit,message,assert,does,not,contain,exit,message,exit,message,cannot,contain,placeholder,this,exit,message,exit,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, @Nullable Throwable ex);1496837955;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, @Nullable Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,nullable,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, @Nullable Throwable ex);1499879592;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, @Nullable Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,nullable,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime);1495868221;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,nullable,object,return,value,nullable,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime);1496837955;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,nullable,object,return,value,nullable,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime);1499879592;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,nullable,object,return,value,nullable,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime);1499944780;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,nullable,object,return,value,nullable,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> protected String replacePlaceholders(String message, MethodInvocation methodInvocation, 			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime);1542468661;Replace the placeholders in the given message with the supplied values,_or values derived from those supplied._@param message the message template containing the placeholders to be replaced_@param methodInvocation the {@code MethodInvocation} being logged._Used to derive values for all placeholders except {@code $[exception]}_and {@code $[returnValue]}._@param returnValue any value returned by the invocation._Used to replace the {@code $[returnValue]} placeholder. May be {@code null}._@param throwable any {@code Throwable} raised during the invocation._The value of {@code Throwable.toString()} is replaced for the_{@code $[exception]} placeholder. May be {@code null}._@param invocationTime the value to write in place of the_{@code $[invocationTime]} placeholder_@return the formatted output to write to the log;protected String replacePlaceholders(String message, MethodInvocation methodInvocation,_			@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {__		Matcher matcher = PATTERN.matcher(message)___		StringBuffer output = new StringBuffer()__		while (matcher.find()) {_			String match = matcher.group()__			if (PLACEHOLDER_METHOD_NAME.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(methodInvocation.getMethod().getName()))__			}_			else if (PLACEHOLDER_TARGET_CLASS_NAME.equals(match)) {_				String className = getClassForLogging(methodInvocation.getThis()).getName()__				matcher.appendReplacement(output, Matcher.quoteReplacement(className))__			}_			else if (PLACEHOLDER_TARGET_CLASS_SHORT_NAME.equals(match)) {_				String shortName = ClassUtils.getShortName(getClassForLogging(methodInvocation.getThis()))__				matcher.appendReplacement(output, Matcher.quoteReplacement(shortName))__			}_			else if (PLACEHOLDER_ARGUMENTS.equals(match)) {_				matcher.appendReplacement(output,_						Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())))__			}_			else if (PLACEHOLDER_ARGUMENT_TYPES.equals(match)) {_				appendArgumentTypes(methodInvocation, matcher, output)__			}_			else if (PLACEHOLDER_RETURN_VALUE.equals(match)) {_				appendReturnValue(methodInvocation, matcher, output, returnValue)__			}_			else if (throwable != null && PLACEHOLDER_EXCEPTION.equals(match)) {_				matcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()))__			}_			else if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {_				matcher.appendReplacement(output, Long.toString(invocationTime))__			}_			else {_				_				throw new IllegalArgumentException("Unknown placeholder [" + match + "]")__			}_		}_		matcher.appendTail(output)___		return output.toString()__	};replace,the,placeholders,in,the,given,message,with,the,supplied,values,or,values,derived,from,those,supplied,param,message,the,message,template,containing,the,placeholders,to,be,replaced,param,method,invocation,the,code,method,invocation,being,logged,used,to,derive,values,for,all,placeholders,except,code,exception,and,code,return,value,param,return,value,any,value,returned,by,the,invocation,used,to,replace,the,code,return,value,placeholder,may,be,code,null,param,throwable,any,code,throwable,raised,during,the,invocation,the,value,of,code,throwable,to,string,is,replaced,for,the,code,exception,placeholder,may,be,code,null,param,invocation,time,the,value,to,write,in,place,of,the,code,invocation,time,placeholder,return,the,formatted,output,to,write,to,the,log;protected,string,replace,placeholders,string,message,method,invocation,method,invocation,nullable,object,return,value,nullable,throwable,throwable,long,invocation,time,matcher,matcher,pattern,matcher,message,string,buffer,output,new,string,buffer,while,matcher,find,string,match,matcher,group,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,method,invocation,get,method,get,name,else,if,equals,match,string,class,name,get,class,for,logging,method,invocation,get,this,get,name,matcher,append,replacement,output,matcher,quote,replacement,class,name,else,if,equals,match,string,short,name,class,utils,get,short,name,get,class,for,logging,method,invocation,get,this,matcher,append,replacement,output,matcher,quote,replacement,short,name,else,if,equals,match,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,method,invocation,get,arguments,else,if,equals,match,append,argument,types,method,invocation,matcher,output,else,if,equals,match,append,return,value,method,invocation,matcher,output,return,value,else,if,throwable,null,equals,match,matcher,append,replacement,output,matcher,quote,replacement,throwable,to,string,else,if,equals,match,matcher,append,replacement,output,long,to,string,invocation,time,else,throw,new,illegal,argument,exception,unknown,placeholder,match,matcher,append,tail,output,return,output,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue);1495868221;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,nullable,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue);1496837955;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,nullable,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue);1499879592;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,nullable,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue);1499944780;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,nullable,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue);1542468661;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, @Nullable Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,nullable,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1328020251;Checks to see if the supplied <code>String</code> has any placeholders_that are not specified as constants on this class and throws an_<code>IllegalArgumentException</code> if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,code,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,code,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1356735495;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1363695345;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1385412762;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1405696918;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1477045587;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1495868221;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1496837955;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1499879592;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1499944780;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException;1542468661;Checks to see if the supplied {@code String} has any placeholders_that are not specified as constants on this class and throws an_{@code IllegalArgumentException} if so.;private void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {_		Matcher matcher = PATTERN.matcher(message)__		while (matcher.find()) {_			String match = matcher.group()__			if (!ALLOWED_PLACEHOLDERS.contains(match)) {_				throw new IllegalArgumentException("Placeholder [" + match + "] is not valid")__			}_		}_	};checks,to,see,if,the,supplied,code,string,has,any,placeholders,that,are,not,specified,as,constants,on,this,class,and,throws,an,code,illegal,argument,exception,if,so;private,void,check,for,invalid,placeholders,string,message,throws,illegal,argument,exception,matcher,matcher,pattern,matcher,message,while,matcher,find,string,match,matcher,group,if,contains,match,throw,new,illegal,argument,exception,placeholder,match,is,not,valid
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1328020251;Writes a log message before the invocation based on the value of <code>enterMessage</code>._If the invocation succeeds, then a log message is written on exit based on the value_<code>exitMessage</code>. If an exception occurs during invocation, then a message is_written based on the value of <code>exceptionMessage</code>._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = invocation.getMethod().getDeclaringClass().getName() + "." + invocation.getMethod().getName()__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if(stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if(stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,code,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,code,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,code,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,invocation,get,method,get,declaring,class,get,name,invocation,get,method,get,name,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1356735495;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = invocation.getMethod().getDeclaringClass().getName() + "." + invocation.getMethod().getName()__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if(stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if(stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,invocation,get,method,get,declaring,class,get,name,invocation,get,method,get,name,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1363695345;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = invocation.getMethod().getDeclaringClass().getName() + "." + invocation.getMethod().getName()__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if(stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if(stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,invocation,get,method,get,declaring,class,get,name,invocation,get,method,get,name,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1385412762;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = invocation.getMethod().getDeclaringClass().getName() + "." + invocation.getMethod().getName()__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if(stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if(stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,invocation,get,method,get,declaring,class,get,name,invocation,get,method,get,name,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1405696918;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = invocation.getMethod().getDeclaringClass().getName() + "." + invocation.getMethod().getName()__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,invocation,get,method,get,declaring,class,get,name,invocation,get,method,get,name,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1477045587;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = ClassUtils.getQualifiedMethodName(invocation.getMethod())__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,class,utils,get,qualified,method,name,invocation,get,method,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1495868221;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = ClassUtils.getQualifiedMethodName(invocation.getMethod())__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,class,utils,get,qualified,method,name,invocation,get,method,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1496837955;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = ClassUtils.getQualifiedMethodName(invocation.getMethod())__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger,_					replacePlaceholders(this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger,_						replacePlaceholders(this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,class,utils,get,qualified,method,name,invocation,get,method,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1499879592;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = ClassUtils.getQualifiedMethodName(invocation.getMethod())__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger, replacePlaceholders(_					this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger, replacePlaceholders(_						this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,class,utils,get,qualified,method,name,invocation,get,method,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1499944780;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = ClassUtils.getQualifiedMethodName(invocation.getMethod())__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger, replacePlaceholders(_					this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger, replacePlaceholders(_						this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,class,utils,get,qualified,method,name,invocation,get,method,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> @Override 	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;1542468661;Writes a log message before the invocation based on the value of {@code enterMessage}._If the invocation succeeds, then a log message is written on exit based on the value_{@code exitMessage}. If an exception occurs during invocation, then a message is_written based on the value of {@code exceptionMessage}._@see #setEnterMessage_@see #setExitMessage_@see #setExceptionMessage;@Override_	protected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {_		String name = ClassUtils.getQualifiedMethodName(invocation.getMethod())__		StopWatch stopWatch = new StopWatch(name)__		Object returnValue = null__		boolean exitThroughException = false__		try {_			stopWatch.start(name)__			writeToLog(logger,_					replacePlaceholders(this.enterMessage, invocation, null, null, -1))__			returnValue = invocation.proceed()__			return returnValue__		}_		catch (Throwable ex) {_			if (stopWatch.isRunning()) {_				stopWatch.stop()__			}_			exitThroughException = true__			writeToLog(logger, replacePlaceholders(_					this.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex)__			throw ex__		}_		finally {_			if (!exitThroughException) {_				if (stopWatch.isRunning()) {_					stopWatch.stop()__				}_				writeToLog(logger, replacePlaceholders(_						this.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()))__			}_		}_	};writes,a,log,message,before,the,invocation,based,on,the,value,of,code,enter,message,if,the,invocation,succeeds,then,a,log,message,is,written,on,exit,based,on,the,value,code,exit,message,if,an,exception,occurs,during,invocation,then,a,message,is,written,based,on,the,value,of,code,exception,message,see,set,enter,message,see,set,exit,message,see,set,exception,message;override,protected,object,invoke,under,trace,method,invocation,invocation,log,logger,throws,throwable,string,name,class,utils,get,qualified,method,name,invocation,get,method,stop,watch,stop,watch,new,stop,watch,name,object,return,value,null,boolean,exit,through,exception,false,try,stop,watch,start,name,write,to,log,logger,replace,placeholders,this,enter,message,invocation,null,null,1,return,value,invocation,proceed,return,return,value,catch,throwable,ex,if,stop,watch,is,running,stop,watch,stop,exit,through,exception,true,write,to,log,logger,replace,placeholders,this,exception,message,invocation,null,ex,stop,watch,get,total,time,millis,ex,throw,ex,finally,if,exit,through,exception,if,stop,watch,is,running,stop,watch,stop,write,to,log,logger,replace,placeholders,this,exit,message,invocation,return,value,null,stop,watch,get,total,time,millis
CustomizableTraceInterceptor -> private String escape(String input);1328020251;Replaces <code>$</code> in inner class names with <code>\$</code>._<p>This code is equivalent to JDK 1.5's <code>quoteReplacement</code>_method in the Matcher class itself. We're keeping our own version_here for JDK 1.4 compliance reasons only.;private String escape(String input) {_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < input.length()_ i++) {_			char c = input.charAt(i)__			if (c == '\\') {_				sb.append("\\\\")__			}_			else if (c == '$') {_				sb.append("\\$")__			}_			else {_				sb.append(c)__			}_		}_		return sb.toString()__	};replaces,code,code,in,inner,class,names,with,code,code,p,this,code,is,equivalent,to,jdk,1,5,s,code,quote,replacement,code,method,in,the,matcher,class,itself,we,re,keeping,our,own,version,here,for,jdk,1,4,compliance,reasons,only;private,string,escape,string,input,string,builder,sb,new,string,builder,for,int,i,0,i,input,length,i,char,c,input,char,at,i,if,c,sb,append,else,if,c,sb,append,else,sb,append,c,return,sb,to,string
CustomizableTraceInterceptor -> private String escape(String input);1356735495;Replaces {@code $} in inner class names with {@code \$}._<p>This code is equivalent to JDK 1.5's {@code quoteReplacement}_method in the Matcher class itself. We're keeping our own version_here for JDK 1.4 compliance reasons only.;private String escape(String input) {_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < input.length()_ i++) {_			char c = input.charAt(i)__			if (c == '\\') {_				sb.append("\\\\")__			}_			else if (c == '$') {_				sb.append("\\$")__			}_			else {_				sb.append(c)__			}_		}_		return sb.toString()__	};replaces,code,in,inner,class,names,with,code,p,this,code,is,equivalent,to,jdk,1,5,s,code,quote,replacement,method,in,the,matcher,class,itself,we,re,keeping,our,own,version,here,for,jdk,1,4,compliance,reasons,only;private,string,escape,string,input,string,builder,sb,new,string,builder,for,int,i,0,i,input,length,i,char,c,input,char,at,i,if,c,sb,append,else,if,c,sb,append,else,sb,append,c,return,sb,to,string
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1328020251;Adds a comma-separated list of the short <code>Class</code> names of the_method argument types to the output. For example, if a method has signature_<code>put(java.lang.String, java.lang.Object)</code> then the value returned_will be <code>String, Object</code>._@param methodInvocation the <code>MethodInvocation</code> being logged._Arguments will be retrieved from the corresponding <code>Method</code>._@param matcher the <code>Matcher</code> containing the state of the output_@param output the <code>StringBuffer</code> containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output, escape(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,code,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,code,then,the,value,returned,will,be,code,string,object,code,param,method,invocation,the,code,method,invocation,code,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,code,param,matcher,the,code,matcher,code,containing,the,state,of,the,output,param,output,the,code,string,buffer,code,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,escape,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1356735495;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output, escape(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,escape,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1363695345;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1385412762;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1405696918;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1477045587;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1495868221;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1496837955;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1499879592;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1499944780;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output);1542468661;Adds a comma-separated list of the short {@code Class} names of the_method argument types to the output. For example, if a method has signature_{@code put(java.lang.String, java.lang.Object)} then the value returned_will be {@code String, Object}._@param methodInvocation the {@code MethodInvocation} being logged._Arguments will be retrieved from the corresponding {@code Method}._@param matcher the {@code Matcher} containing the state of the output_@param output the {@code StringBuffer} containing the output;private void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuffer output) {_		Class<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes()__		String[] argumentTypeShortNames = new String[argumentTypes.length]__		for (int i = 0_ i < argumentTypeShortNames.length_ i++) {_			argumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i])__		}_		matcher.appendReplacement(output,_				Matcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)))__	};adds,a,comma,separated,list,of,the,short,code,class,names,of,the,method,argument,types,to,the,output,for,example,if,a,method,has,signature,code,put,java,lang,string,java,lang,object,then,the,value,returned,will,be,code,string,object,param,method,invocation,the,code,method,invocation,being,logged,arguments,will,be,retrieved,from,the,corresponding,code,method,param,matcher,the,code,matcher,containing,the,state,of,the,output,param,output,the,code,string,buffer,containing,the,output;private,void,append,argument,types,method,invocation,method,invocation,matcher,matcher,string,buffer,output,class,argument,types,method,invocation,get,method,get,parameter,types,string,argument,type,short,names,new,string,argument,types,length,for,int,i,0,i,argument,type,short,names,length,i,argument,type,short,names,i,class,utils,get,short,name,argument,types,i,matcher,append,replacement,output,matcher,quote,replacement,string,utils,array,to,comma,delimited,string,argument,type,short,names
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue);1328020251;Adds the <code>String</code> representation of the method return value_to the supplied <code>StringBuffer</code>. Correctly handles_<code>null</code> and <code>void</code> results._@param methodInvocation the <code>MethodInvocation</code> that returned the value_@param matcher the <code>Matcher</code> containing the matched placeholder_@param output the <code>StringBuffer</code> to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, escape(returnValue.toString()))__		}_	};adds,the,code,string,code,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,code,correctly,handles,code,null,code,and,code,void,code,results,param,method,invocation,the,code,method,invocation,code,that,returned,the,value,param,matcher,the,code,matcher,code,containing,the,matched,placeholder,param,output,the,code,string,buffer,code,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,escape,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue);1356735495;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, escape(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,escape,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue);1363695345;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue);1385412762;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue);1405696918;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> private void appendReturnValue( 			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue);1477045587;Adds the {@code String} representation of the method return value_to the supplied {@code StringBuffer}. Correctly handles_{@code null} and {@code void} results._@param methodInvocation the {@code MethodInvocation} that returned the value_@param matcher the {@code Matcher} containing the matched placeholder_@param output the {@code StringBuffer} to write output to_@param returnValue the value returned by the method invocation.;private void appendReturnValue(_			MethodInvocation methodInvocation, Matcher matcher, StringBuffer output, Object returnValue) {__		if (methodInvocation.getMethod().getReturnType() == void.class) {_			matcher.appendReplacement(output, "void")__		}_		else if (returnValue == null) {_			matcher.appendReplacement(output, "null")__		}_		else {_			matcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()))__		}_	};adds,the,code,string,representation,of,the,method,return,value,to,the,supplied,code,string,buffer,correctly,handles,code,null,and,code,void,results,param,method,invocation,the,code,method,invocation,that,returned,the,value,param,matcher,the,code,matcher,containing,the,matched,placeholder,param,output,the,code,string,buffer,to,write,output,to,param,return,value,the,value,returned,by,the,method,invocation;private,void,append,return,value,method,invocation,method,invocation,matcher,matcher,string,buffer,output,object,return,value,if,method,invocation,get,method,get,return,type,void,class,matcher,append,replacement,output,void,else,if,return,value,null,matcher,append,replacement,output,null,else,matcher,append,replacement,output,matcher,quote,replacement,return,value,to,string
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1328020251;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li><code>$[targetClassName]</code></li>_<li><code>$[targetClassShortName]</code></li>_<li><code>$[argumentTypes]</code></li>_<li><code>$[arguments]</code></li>_<li><code>$[exception]</code></li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,code,li,li,code,target,class,short,name,code,li,li,code,argument,types,code,li,li,code,arguments,code,li,li,code,exception,code,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1356735495;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1363695345;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1385412762;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1405696918;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1477045587;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1495868221;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1496837955;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "'exceptionMessage' must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_INVOCATION_TIME,_				"exceptionMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1499879592;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "exceptionMessage must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE)__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1499944780;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "exceptionMessage must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE)__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setExceptionMessage(String exceptionMessage);1542468661;Set the template used for method exception log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_<li>{@code $[exception]}</li>_</ul>;public void setExceptionMessage(String exceptionMessage) {_		Assert.hasText(exceptionMessage, "exceptionMessage must not be empty")__		checkForInvalidPlaceholders(exceptionMessage)__		Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,_				"exceptionMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE)__		this.exceptionMessage = exceptionMessage__	};set,the,template,used,for,method,exception,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,li,code,exception,li,ul;public,void,set,exception,message,string,exception,message,assert,has,text,exception,message,exception,message,must,not,be,empty,check,for,invalid,placeholders,exception,message,assert,does,not,contain,exception,message,exception,message,cannot,contain,placeholder,this,exception,message,exception,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1328020251;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li><code>$[targetClassName]</code></li>_<li><code>$[targetClassShortName]</code></li>_<li><code>$[argumentTypes]</code></li>_<li><code>$[arguments]</code></li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,code,li,li,code,target,class,short,name,code,li,li,code,argument,types,code,li,li,code,arguments,code,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1356735495;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1363695345;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1385412762;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1405696918;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1477045587;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1495868221;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1496837955;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "'enterMessage' must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_RETURN_VALUE + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_EXCEPTION + "]")__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder [" + PLACEHOLDER_INVOCATION_TIME + "]")__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1499879592;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "enterMessage must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_EXCEPTION)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_INVOCATION_TIME)__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1499944780;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "enterMessage must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_EXCEPTION)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_INVOCATION_TIME)__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> public void setEnterMessage(String enterMessage) throws IllegalArgumentException;1542468661;Set the template used for method entry log messages._This template can contain any of the following placeholders:_<ul>_<li>{@code $[targetClassName]}</li>_<li>{@code $[targetClassShortName]}</li>_<li>{@code $[argumentTypes]}</li>_<li>{@code $[arguments]}</li>_</ul>;public void setEnterMessage(String enterMessage) throws IllegalArgumentException {_		Assert.hasText(enterMessage, "enterMessage must not be empty")__		checkForInvalidPlaceholders(enterMessage)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_RETURN_VALUE)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_EXCEPTION)__		Assert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,_				"enterMessage cannot contain placeholder " + PLACEHOLDER_INVOCATION_TIME)__		this.enterMessage = enterMessage__	};set,the,template,used,for,method,entry,log,messages,this,template,can,contain,any,of,the,following,placeholders,ul,li,code,target,class,name,li,li,code,target,class,short,name,li,li,code,argument,types,li,li,code,arguments,li,ul;public,void,set,enter,message,string,enter,message,throws,illegal,argument,exception,assert,has,text,enter,message,enter,message,must,not,be,empty,check,for,invalid,placeholders,enter,message,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,assert,does,not,contain,enter,message,enter,message,cannot,contain,placeholder,this,enter,message,enter,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1328020251;Writes the supplied message and {@link Throwable} to the_supplied <code>Log</code> instance. By default messages are written_at <code>TRACE</code> level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,code,instance,by,default,messages,are,written,at,code,trace,code,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1356735495;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1363695345;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1385412762;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1405696918;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1477045587;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message, Throwable ex);1495868221;Writes the supplied message and {@link Throwable} to the_supplied {@code Log} instance. By default messages are written_at {@code TRACE} level. Sub-classes can override this method_to control which level the message is written at.;protected void writeToLog(Log logger, String message, Throwable ex) {_		if (ex != null) {_			logger.trace(message, ex)__		}_		else {_			logger.trace(message)__		}_	};writes,the,supplied,message,and,link,throwable,to,the,supplied,code,log,instance,by,default,messages,are,written,at,code,trace,level,sub,classes,can,override,this,method,to,control,which,level,the,message,is,written,at;protected,void,write,to,log,log,logger,string,message,throwable,ex,if,ex,null,logger,trace,message,ex,else,logger,trace,message
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1328020251;Writes the supplied message to the supplied <code>Log</code> instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,code,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1356735495;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1363695345;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1385412762;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1405696918;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1477045587;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1495868221;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1496837955;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
CustomizableTraceInterceptor -> protected void writeToLog(Log logger, String message);1499879592;Writes the supplied message to the supplied {@code Log} instance._@see #writeToLog(org.apache.commons.logging.Log, String, Throwable);protected void writeToLog(Log logger, String message) {_		writeToLog(logger, message, null)__	};writes,the,supplied,message,to,the,supplied,code,log,instance,see,write,to,log,org,apache,commons,logging,log,string,throwable;protected,void,write,to,log,log,logger,string,message,write,to,log,logger,message,null
