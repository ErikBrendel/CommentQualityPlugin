commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Suppress the specified interface, which may have been autodetected  * due to the delegate implementing it. Call this method to exclude  * internal interfaces from being visible at the proxy level.  * <p>Does nothing if the interface is not implemented by the delegate.  * @param ifc the interface to suppress  */ ;/**  * Suppress the specified interface, which may have been autodetected  * due to the delegate implementing it. Call this method to exclude  * internal interfaces from being visible at the proxy level.  * <p>Does nothing if the interface is not implemented by the delegate.  * @param ifc the interface to suppress  */ public void suppressInterface(Class<?> ifc) {     this.publishedInterfaces.remove(ifc). }
false;public;0;4;;@Override public Class<?>[] getInterfaces() {     return ClassUtils.toClassArray(this.publishedInterfaces). }
true;public;1;8;/**  * Check whether the specified interfaces is a published introduction interface.  * @param ifc the interface to check  * @return whether the interface is part of this introduction  */ ;/**  * Check whether the specified interfaces is a published introduction interface.  * @param ifc the interface to check  * @return whether the interface is part of this introduction  */ public boolean implementsInterface(Class<?> ifc) {     for (Class<?> pubIfc : this.publishedInterfaces) {         if (ifc.isInterface() && ifc.isAssignableFrom(pubIfc)) {             return true.         }     }     return false. }
true;protected;1;3;/**  * Publish all interfaces that the given delegate implements at the proxy level.  * @param delegate the delegate object  */ ;/**  * Publish all interfaces that the given delegate implements at the proxy level.  * @param delegate the delegate object  */ protected void implementInterfacesOnObject(Object delegate) {     this.publishedInterfaces.addAll(ClassUtils.getAllInterfacesAsSet(delegate)). }
true;protected,final;1;12;/**  * Is this method on an introduced interface?  * @param mi the method invocation  * @return whether the invoked method is on an introduced interface  */ ;/**  * Is this method on an introduced interface?  * @param mi the method invocation  * @return whether the invoked method is on an introduced interface  */ protected final boolean isMethodOnIntroducedInterface(MethodInvocation mi) {     Boolean rememberedResult = this.rememberedMethods.get(mi.getMethod()).     if (rememberedResult != null) {         return rememberedResult.     } else {         // Work it out and cache it.         boolean result = implementsInterface(mi.getMethod().getDeclaringClass()).         this.rememberedMethods.put(mi.getMethod(), result).         return result.     } }
true;private;1;6;/**  * This method is implemented only to restore the logger.  * We don't make the logger static as that would mean that subclasses  * would use this class's log category.  */ ;// --------------------------------------------------------------------- // Serialization support // --------------------------------------------------------------------- /**  * This method is implemented only to restore the logger.  * We don't make the logger static as that would mean that subclasses  * would use this class's log category.  */ private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     // Rely on default serialization. just initialize state after deserialization.     ois.defaultReadObject().     // Initialize transient fields.     this.rememberedMethods = new ConcurrentHashMap<>(32). }
