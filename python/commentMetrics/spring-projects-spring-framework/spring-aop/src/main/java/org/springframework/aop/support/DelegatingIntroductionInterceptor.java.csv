commented;modifiers;parameterAmount;loc;comment;code
true;private;1;9;/**  * Both constructors use this init method, as it is impossible to pass  * a "this" reference from one constructor to another.  * @param delegate the delegate object  */ ;/**  * Both constructors use this init method, as it is impossible to pass  * a "this" reference from one constructor to another.  * @param delegate the delegate object  */ private void init(Object delegate) {     Assert.notNull(delegate, "Delegate must not be null").     this.delegate = delegate.     implementInterfacesOnObject(delegate).     // We don't want to expose the control interface     suppressInterface(IntroductionInterceptor.class).     suppressInterface(DynamicIntroductionAdvice.class). }
true;public;1;22;/**  * Subclasses may need to override this if they want to perform custom  * behaviour in around advice. However, subclasses should invoke this  * method, which handles introduced interfaces and forwarding to the target.  */ ;/**  * Subclasses may need to override this if they want to perform custom  * behaviour in around advice. However, subclasses should invoke this  * method, which handles introduced interfaces and forwarding to the target.  */ @Override @Nullable public Object invoke(MethodInvocation mi) throws Throwable {     if (isMethodOnIntroducedInterface(mi)) {         // Using the following method rather than direct reflection, we         // get correct handling of InvocationTargetException         // if the introduced method throws an exception.         Object retVal = AopUtils.invokeJoinpointUsingReflection(this.delegate, mi.getMethod(), mi.getArguments()).         // we really want to return the proxy.         if (retVal == this.delegate && mi instanceof ProxyMethodInvocation) {             Object proxy = ((ProxyMethodInvocation) mi).getProxy().             if (mi.getMethod().getReturnType().isInstance(proxy)) {                 retVal = proxy.             }         }         return retVal.     }     return doProceed(mi). }
true;protected;1;4;/**  * Proceed with the supplied {@link org.aopalliance.intercept.MethodInterceptor}.  * Subclasses can override this method to intercept method invocations on the  * target object which is useful when an introduction needs to monitor the object  * that it is introduced into. This method is <strong>never</strong> called for  * {@link MethodInvocation MethodInvocations} on the introduced interfaces.  */ ;/**  * Proceed with the supplied {@link org.aopalliance.intercept.MethodInterceptor}.  * Subclasses can override this method to intercept method invocations on the  * target object which is useful when an introduction needs to monitor the object  * that it is introduced into. This method is <strong>never</strong> called for  * {@link MethodInvocation MethodInvocations} on the introduced interfaces.  */ protected Object doProceed(MethodInvocation mi) throws Throwable {     // If we get here, just pass the invocation on.     return mi.proceed(). }
