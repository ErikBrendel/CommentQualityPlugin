commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Convenience method when we have only a single pattern.  * Use either this method or {@link #setPatterns}, not both.  * @see #setPatterns  */ ;/**  * Convenience method when we have only a single pattern.  * Use either this method or {@link #setPatterns}, not both.  * @see #setPatterns  */ public void setPattern(String pattern) {     setPatterns(pattern). }
true;public;1;8;/**  * Set the regular expressions defining methods to match.  * Matching will be the union of all these. if any match, the pointcut matches.  * @see #setPattern  */ ;/**  * Set the regular expressions defining methods to match.  * Matching will be the union of all these. if any match, the pointcut matches.  * @see #setPattern  */ public void setPatterns(String... patterns) {     Assert.notEmpty(patterns, "'patterns' must not be empty").     this.patterns = new String[patterns.length].     for (int i = 0. i < patterns.length. i++) {         this.patterns[i] = StringUtils.trimWhitespace(patterns[i]).     }     initPatternRepresentation(this.patterns). }
true;public;0;3;/**  * Return the regular expressions for method matching.  */ ;/**  * Return the regular expressions for method matching.  */ public String[] getPatterns() {     return this.patterns. }
true;public;1;3;/**  * Convenience method when we have only a single exclusion pattern.  * Use either this method or {@link #setExcludedPatterns}, not both.  * @see #setExcludedPatterns  */ ;/**  * Convenience method when we have only a single exclusion pattern.  * Use either this method or {@link #setExcludedPatterns}, not both.  * @see #setExcludedPatterns  */ public void setExcludedPattern(String excludedPattern) {     setExcludedPatterns(excludedPattern). }
true;public;1;8;/**  * Set the regular expressions defining methods to match for exclusion.  * Matching will be the union of all these. if any match, the pointcut matches.  * @see #setExcludedPattern  */ ;/**  * Set the regular expressions defining methods to match for exclusion.  * Matching will be the union of all these. if any match, the pointcut matches.  * @see #setExcludedPattern  */ public void setExcludedPatterns(String... excludedPatterns) {     Assert.notEmpty(excludedPatterns, "'excludedPatterns' must not be empty").     this.excludedPatterns = new String[excludedPatterns.length].     for (int i = 0. i < excludedPatterns.length. i++) {         this.excludedPatterns[i] = StringUtils.trimWhitespace(excludedPatterns[i]).     }     initExcludedPatternRepresentation(this.excludedPatterns). }
true;public;0;3;/**  * Returns the regular expressions for exclusion matching.  */ ;/**  * Returns the regular expressions for exclusion matching.  */ public String[] getExcludedPatterns() {     return this.excludedPatterns. }
true;public;2;6;/**  * Try to match the regular expression against the fully qualified name  * of the target class as well as against the method's declaring class,  * plus the name of the method.  */ ;/**  * Try to match the regular expression against the fully qualified name  * of the target class as well as against the method's declaring class,  * plus the name of the method.  */ @Override public boolean matches(Method method, Class<?> targetClass) {     return (matchesPattern(ClassUtils.getQualifiedMethodName(method, targetClass)) || (targetClass != method.getDeclaringClass() && matchesPattern(ClassUtils.getQualifiedMethodName(method, method.getDeclaringClass())))). }
true;protected;1;15;/**  * Match the specified candidate against the configured patterns.  * @param signatureString "java.lang.Object.hashCode" style signature  * @return whether the candidate matches at least one of the specified patterns  */ ;/**  * Match the specified candidate against the configured patterns.  * @param signatureString "java.lang.Object.hashCode" style signature  * @return whether the candidate matches at least one of the specified patterns  */ protected boolean matchesPattern(String signatureString) {     for (int i = 0. i < this.patterns.length. i++) {         boolean matched = matches(signatureString, i).         if (matched) {             for (int j = 0. j < this.excludedPatterns.length. j++) {                 boolean excluded = matchesExclusion(signatureString, j).                 if (excluded) {                     return false.                 }             }             return true.         }     }     return false. }
true;protected,abstract;1;1;/**  * Subclasses must implement this to initialize regexp pointcuts.  * Can be invoked multiple times.  * <p>This method will be invoked from the {@link #setPatterns} method,  * and also on deserialization.  * @param patterns the patterns to initialize  * @throws IllegalArgumentException in case of an invalid pattern  */ ;/**  * Subclasses must implement this to initialize regexp pointcuts.  * Can be invoked multiple times.  * <p>This method will be invoked from the {@link #setPatterns} method,  * and also on deserialization.  * @param patterns the patterns to initialize  * @throws IllegalArgumentException in case of an invalid pattern  */ protected abstract void initPatternRepresentation(String[] patterns) throws IllegalArgumentException.
true;protected,abstract;1;1;/**  * Subclasses must implement this to initialize regexp pointcuts.  * Can be invoked multiple times.  * <p>This method will be invoked from the {@link #setExcludedPatterns} method,  * and also on deserialization.  * @param patterns the patterns to initialize  * @throws IllegalArgumentException in case of an invalid pattern  */ ;/**  * Subclasses must implement this to initialize regexp pointcuts.  * Can be invoked multiple times.  * <p>This method will be invoked from the {@link #setExcludedPatterns} method,  * and also on deserialization.  * @param patterns the patterns to initialize  * @throws IllegalArgumentException in case of an invalid pattern  */ protected abstract void initExcludedPatternRepresentation(String[] patterns) throws IllegalArgumentException.
true;protected,abstract;2;1;/**  * Does the pattern at the given index match the given String?  * @param pattern the {@code String} pattern to match  * @param patternIndex index of pattern (starting from 0)  * @return {@code true} if there is a match, {@code false} otherwise  */ ;/**  * Does the pattern at the given index match the given String?  * @param pattern the {@code String} pattern to match  * @param patternIndex index of pattern (starting from 0)  * @return {@code true} if there is a match, {@code false} otherwise  */ protected abstract boolean matches(String pattern, int patternIndex).
true;protected,abstract;2;1;/**  * Does the exclusion pattern at the given index match the given String?  * @param pattern the {@code String} pattern to match  * @param patternIndex index of pattern (starting from 0)  * @return {@code true} if there is a match, {@code false} otherwise  */ ;/**  * Does the exclusion pattern at the given index match the given String?  * @param pattern the {@code String} pattern to match  * @param patternIndex index of pattern (starting from 0)  * @return {@code true} if there is a match, {@code false} otherwise  */ protected abstract boolean matchesExclusion(String pattern, int patternIndex).
false;public;1;12;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof AbstractRegexpMethodPointcut)) {         return false.     }     AbstractRegexpMethodPointcut otherPointcut = (AbstractRegexpMethodPointcut) other.     return (Arrays.equals(this.patterns, otherPointcut.patterns) && Arrays.equals(this.excludedPatterns, otherPointcut.excludedPatterns)). }
false;public;0;11;;@Override public int hashCode() {     int result = 27.     for (String pattern : this.patterns) {         result = 13 * result + pattern.hashCode().     }     for (String excludedPattern : this.excludedPatterns) {         result = 13 * result + excludedPattern.hashCode().     }     return result. }
false;public;0;5;;@Override public String toString() {     return getClass().getName() + ": patterns " + ObjectUtils.nullSafeToString(this.patterns) + ", excluded patterns " + ObjectUtils.nullSafeToString(this.excludedPatterns). }
