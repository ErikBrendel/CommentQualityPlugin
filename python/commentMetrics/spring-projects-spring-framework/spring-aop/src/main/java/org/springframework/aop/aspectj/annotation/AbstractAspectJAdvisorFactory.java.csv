# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1328020251;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1356735495;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1357119239;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1368482696;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1375969963;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1385412762;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1413848647;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}_		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1450827071;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}__		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1467730834;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}__		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod);1467846264;Create the pointcut parameters needed by aspectj based on the given argument names_and the argument types that are available from the adviceMethod. Needs to take into_account (ignore) any JoinPoint based arguments as these are not pointcut context but_rather part of the advice execution context (thisJoinPoint, thisJoinPointStaticPart);private Class<?>[] extractPointcutParameterTypes(String[] argNames, Method adviceMethod) {_		Class<?>[] ret = new Class<?>[argNames.length]__		Class<?>[] paramTypes = adviceMethod.getParameterTypes()__		if (argNames.length > paramTypes.length) {_			throw new IllegalStateException("Expecting at least " + argNames.length +_					" arguments in the advice declaration, but only found " + paramTypes.length)__		}__		_		_		int typeOffset = paramTypes.length - argNames.length__		for (int i = 0_ i < ret.length_ i++) {_			ret[i] = paramTypes[i + typeOffset]__		}_		return ret__	};create,the,pointcut,parameters,needed,by,aspectj,based,on,the,given,argument,names,and,the,argument,types,that,are,available,from,the,advice,method,needs,to,take,into,account,ignore,any,join,point,based,arguments,as,these,are,not,pointcut,context,but,rather,part,of,the,advice,execution,context,this,join,point,this,join,point,static,part;private,class,extract,pointcut,parameter,types,string,arg,names,method,advice,method,class,ret,new,class,arg,names,length,class,param,types,advice,method,get,parameter,types,if,arg,names,length,param,types,length,throw,new,illegal,state,exception,expecting,at,least,arg,names,length,arguments,in,the,advice,declaration,but,only,found,param,types,length,int,type,offset,param,types,length,arg,names,length,for,int,i,0,i,ret,length,i,ret,i,param,types,i,type,offset,return,ret
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method);1328020251;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {_		Class<? extends Annotation>[] classesToLookFor = new Class[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<? extends Annotation> c : classesToLookFor) {_			AspectJAnnotation foundAnnotation = findAnnotation(method, c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,extends,annotation,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,extends,annotation,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method);1356735495;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {_		Class<? extends Annotation>[] classesToLookFor = new Class[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<? extends Annotation> c : classesToLookFor) {_			AspectJAnnotation foundAnnotation = findAnnotation(method, c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,extends,annotation,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,extends,annotation,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method);1357119239;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {_		Class<? extends Annotation>[] classesToLookFor = new Class[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<? extends Annotation> c : classesToLookFor) {_			AspectJAnnotation foundAnnotation = findAnnotation(method, c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,extends,annotation,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,extends,annotation,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method);1368482696;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {_		Class<? extends Annotation>[] classesToLookFor = new Class[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<? extends Annotation> c : classesToLookFor) {_			AspectJAnnotation foundAnnotation = findAnnotation(method, c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,extends,annotation,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,extends,annotation,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method);1375969963;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {_		Class<? extends Annotation>[] classesToLookFor = new Class[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<? extends Annotation> c : classesToLookFor) {_			AspectJAnnotation foundAnnotation = findAnnotation(method, c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,extends,annotation,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,extends,annotation,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames);1328020251;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}_		_		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames);1356735495;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames);1357119239;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames);1368482696;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames);1375969963;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1356735495;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1368482696;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1375969963;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1385412762;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1413848647;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1450827071;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1467730834;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1467846264;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1482422404;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1482492427;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1495868221;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1496837955;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1498780456;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1502974979;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1530174524;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1532171563;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1533765377;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> @Override 	public boolean isAspect(Class<?> clazz);1533774388;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;@Override_	public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;override,public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> public boolean isAspect(Class<?> clazz);1328020251;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> public boolean isAspect(Class<?> clazz);1357119239;We consider something to be an AspectJ aspect suitable for use by the Spring AOP system_if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test_is that aspects written in the code-style (AspectJ language) also have the annotation present_when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.;public boolean isAspect(Class<?> clazz) {_		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz))__	};we,consider,something,to,be,an,aspect,j,aspect,suitable,for,use,by,the,spring,aop,system,if,it,has,the,aspect,annotation,and,was,not,compiled,by,ajc,the,reason,for,this,latter,test,is,that,aspects,written,in,the,code,style,aspect,j,language,also,have,the,annotation,present,when,compiled,by,ajc,with,the,1,5,flag,yet,they,cannot,be,consumed,by,spring,aop;public,boolean,is,aspect,class,clazz,return,has,aspect,annotation,clazz,compiled,by,ajc,clazz
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1328020251;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1356735495;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1357119239;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1368482696;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1375969963;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1385412762;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1413848647;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1450827071;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1467730834;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1467846264;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1482422404;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1482492427;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1495868221;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1496837955;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1498780456;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1502974979;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1530174524;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1532171563;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1533765377;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> private boolean compiledByAjc(Class<?> clazz);1533774388;We need to detect this as "code-style" AspectJ aspects should not be_interpreted by Spring AOP.;private boolean compiledByAjc(Class<?> clazz) {_		_		_		_		for (Field field : clazz.getDeclaredFields()) {_			if (field.getName().startsWith(AJC_MAGIC)) {_				return true__			}_		}_		return false__	};we,need,to,detect,this,as,code,style,aspect,j,aspects,should,not,be,interpreted,by,spring,aop;private,boolean,compiled,by,ajc,class,clazz,for,field,field,clazz,get,declared,fields,if,field,get,name,starts,with,return,true,return,false
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames);1385412762;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames);1413848647;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames);1450827071;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames);1467730834;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> protected AspectJExpressionPointcut createPointcutExpression( 			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames);1467846264;The pointcut and advice annotations both have an "argNames" member which contains a_comma-separated list of the argument names. We use this (if non-empty) to build the_formal parameters for the pointcut.;protected AspectJExpressionPointcut createPointcutExpression(_			Method annotatedMethod, Class<?> declarationScope, String[] pointcutParameterNames) {__		Class<?> [] pointcutParameterTypes = new Class<?>[0]__		if (pointcutParameterNames != null) {_			pointcutParameterTypes = extractPointcutParameterTypes(pointcutParameterNames,annotatedMethod)__		}__		AspectJExpressionPointcut ajexp =_				new AspectJExpressionPointcut(declarationScope,pointcutParameterNames,pointcutParameterTypes)__		ajexp.setLocation(annotatedMethod.toString())__		return ajexp__	};the,pointcut,and,advice,annotations,both,have,an,arg,names,member,which,contains,a,comma,separated,list,of,the,argument,names,we,use,this,if,non,empty,to,build,the,formal,parameters,for,the,pointcut;protected,aspect,jexpression,pointcut,create,pointcut,expression,method,annotated,method,class,declaration,scope,string,pointcut,parameter,names,class,pointcut,parameter,types,new,class,0,if,pointcut,parameter,names,null,pointcut,parameter,types,extract,pointcut,parameter,types,pointcut,parameter,names,annotated,method,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,declaration,scope,pointcut,parameter,names,pointcut,parameter,types,ajexp,set,location,annotated,method,to,string,return,ajexp
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1385412762;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1413848647;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1450827071;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1467730834;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1467846264;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1482422404;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1482492427;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1495868221;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1496837955;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1498780456;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1502974979;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...);@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1530174524;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...).;@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1532171563;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...).;@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> c : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,c,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,c,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1533765377;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...).;@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		Class<?>[] classesToLookFor = new Class<?>[] {_				Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class}__		for (Class<?> clazz : classesToLookFor) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) clazz)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,class,classes,to,look,for,new,class,before,class,around,class,after,class,after,returning,class,after,throwing,class,pointcut,class,for,class,clazz,classes,to,look,for,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,clazz,if,found,annotation,null,return,found,annotation,return,null
AbstractAspectJAdvisorFactory -> @SuppressWarnings("unchecked") 	@Nullable 	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method);1533774388;Find and return the first AspectJ annotation on the given method_(there <i>should</i> only be one anyway...).;@SuppressWarnings("unchecked")_	@Nullable_	protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {_		for (Class<?> clazz : ASPECTJ_ANNOTATION_CLASSES) {_			AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) clazz)__			if (foundAnnotation != null) {_				return foundAnnotation__			}_		}_		return null__	};find,and,return,the,first,aspect,j,annotation,on,the,given,method,there,i,should,i,only,be,one,anyway;suppress,warnings,unchecked,nullable,protected,static,aspect,jannotation,find,aspect,jannotation,on,method,method,method,for,class,clazz,aspect,jannotation,found,annotation,find,annotation,method,class,annotation,clazz,if,found,annotation,null,return,found,annotation,return,null
