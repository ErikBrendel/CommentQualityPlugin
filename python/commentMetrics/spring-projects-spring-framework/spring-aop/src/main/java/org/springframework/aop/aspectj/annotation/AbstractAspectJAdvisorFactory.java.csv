commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * We consider something to be an AspectJ aspect suitable for use by the Spring AOP system  * if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test  * is that aspects written in the code-style (AspectJ language) also have the annotation present  * when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.  */ ;/**  * We consider something to be an AspectJ aspect suitable for use by the Spring AOP system  * if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test  * is that aspects written in the code-style (AspectJ language) also have the annotation present  * when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.  */ @Override public boolean isAspect(Class<?> clazz) {     return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz)). }
false;private;1;3;;private boolean hasAspectAnnotation(Class<?> clazz) {     return (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null). }
true;private;1;11;/**  * We need to detect this as "code-style" AspectJ aspects should not be  * interpreted by Spring AOP.  */ ;/**  * We need to detect this as "code-style" AspectJ aspects should not be  * interpreted by Spring AOP.  */ private boolean compiledByAjc(Class<?> clazz) {     // an implementation detail of the AspectJ compiler.     for (Field field : clazz.getDeclaredFields()) {         if (field.getName().startsWith(AJC_MAGIC)) {             return true.         }     }     return false. }
false;public;1;22;;@Override public void validate(Class<?> aspectClass) throws AopConfigException {     // If the parent has the annotation and isn't abstract it's an error     if (aspectClass.getSuperclass().getAnnotation(Aspect.class) != null && !Modifier.isAbstract(aspectClass.getSuperclass().getModifiers())) {         throw new AopConfigException("[" + aspectClass.getName() + "] cannot extend concrete aspect [" + aspectClass.getSuperclass().getName() + "]").     }     AjType<?> ajType = AjTypeSystem.getAjType(aspectClass).     if (!ajType.isAspect()) {         throw new NotAnAtAspectException(aspectClass).     }     if (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOW) {         throw new AopConfigException(aspectClass.getName() + " uses percflow instantiation model: " + "This is not supported in Spring AOP.").     }     if (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOWBELOW) {         throw new AopConfigException(aspectClass.getName() + " uses percflowbelow instantiation model: " + "This is not supported in Spring AOP.").     } }
true;protected,static;1;11;/**  * Find and return the first AspectJ annotation on the given method  * (there <i>should</i> only be one anyway...).  */ ;/**  * Find and return the first AspectJ annotation on the given method  * (there <i>should</i> only be one anyway...).  */ @SuppressWarnings("unchecked") @Nullable protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {     for (Class<?> clazz : ASPECTJ_ANNOTATION_CLASSES) {         AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) clazz).         if (foundAnnotation != null) {             return foundAnnotation.         }     }     return null. }
false;private,static;2;10;;@Nullable private static <A extends Annotation> AspectJAnnotation<A> findAnnotation(Method method, Class<A> toLookFor) {     A result = AnnotationUtils.findAnnotation(method, toLookFor).     if (result != null) {         return new AspectJAnnotation<>(result).     } else {         return null.     } }
false;private;1;7;;private AspectJAnnotationType determineAnnotationType(A annotation) {     AspectJAnnotationType type = annotationTypeMap.get(annotation.annotationType()).     if (type != null) {         return type.     }     throw new IllegalStateException("Unknown annotation type: " + annotation). }
false;private;1;12;;private String resolveExpression(A annotation) {     for (String attributeName : EXPRESSION_ATTRIBUTES) {         Object val = AnnotationUtils.getValue(annotation, attributeName).         if (val instanceof String) {             String str = (String) val.             if (!str.isEmpty()) {                 return str.             }         }     }     throw new IllegalStateException("Failed to resolve expression: " + annotation). }
false;public;0;3;;public AspectJAnnotationType getAnnotationType() {     return this.annotationType. }
false;public;0;3;;public A getAnnotation() {     return this.annotation. }
false;public;0;3;;public String getPointcutExpression() {     return this.pointcutExpression. }
false;public;0;3;;public String getArgumentNames() {     return this.argumentNames. }
false;public;0;4;;@Override public String toString() {     return this.annotation.toString(). }
false;public;1;22;;@Override @Nullable public String[] getParameterNames(Method method) {     if (method.getParameterCount() == 0) {         return new String[0].     }     AspectJAnnotation<?> annotation = findAspectJAnnotationOnMethod(method).     if (annotation == null) {         return null.     }     StringTokenizer nameTokens = new StringTokenizer(annotation.getArgumentNames(), ",").     if (nameTokens.countTokens() > 0) {         String[] names = new String[nameTokens.countTokens()].         for (int i = 0. i < names.length. i++) {             names[i] = nameTokens.nextToken().         }         return names.     } else {         return null.     } }
false;public;1;5;;@Override @Nullable public String[] getParameterNames(Constructor<?> ctor) {     throw new UnsupportedOperationException("Spring AOP cannot handle constructor advice"). }
