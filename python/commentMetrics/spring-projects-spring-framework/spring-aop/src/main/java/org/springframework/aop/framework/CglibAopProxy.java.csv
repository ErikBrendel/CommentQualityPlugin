# id;timestamp;commentText;codeText;commentWords;codeWords
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1492434133;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1492451244;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1495868221;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1496242568;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1496837955;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1496955179;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1497300858;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1498780456;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1501077477;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1523443675;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1530174524;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1530190293;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1532091916;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1532706365;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1542468661;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1542747868;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> private static boolean implementsInterface(Method method, Set<Class<?>> ifcs);1550238806;Check whether the given method is declared on any of the given interfaces.;private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {_		for (Class<?> ifc : ifcs) {_			if (ClassUtils.hasMethod(ifc, method.getName(), method.getParameterTypes())) {_				return true__			}_		}_		return false__	};check,whether,the,given,method,is,declared,on,any,of,the,given,interfaces;private,static,boolean,implements,interface,method,method,set,class,ifcs,for,class,ifc,ifcs,if,class,utils,has,method,ifc,method,get,name,method,get,parameter,types,return,true,return,false
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1497300858;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1498780456;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1501077477;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1523443675;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1530174524;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1530190293;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1532091916;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1532706365;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1542468661;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1542747868;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> @Nullable 	private static Object processReturnType( 			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue);1550238806;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(_			Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {__		_		if (returnValue != null && returnValue == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			returnValue = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return returnValue__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,nullable,object,target,method,method,nullable,object,return,value,if,return,value,null,return,value,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,return,value,proxy,class,return,type,method,get,return,type,if,return,value,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,return,value
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1344552803;Checks for final methods on the <code>Class</code> and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,code,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1351638660;Checks for final methods on the <code>Class</code> and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,code,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1356735495;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1357119239;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1368482696;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1374269779;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1379028754;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1385412762;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		Method[] methods = proxySuperClass.getMethods()__		for (Method method : methods) {_			if (!Object.class.equals(method.getDeclaringClass()) && Modifier.isFinal(method.getModifiers())) {_				logger.warn("Unable to proxy method [" + method + "] because it is final: " +_						"All calls to this method via a proxy will be routed directly to the proxy.")__			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1386761699;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			Method[] methods = proxySuperClass.getMethods()__			for (Method method : methods) {_				if (!Object.class.equals(method.getDeclaringClass()) && !Modifier.isStatic(method.getModifiers()) &&_						Modifier.isFinal(method.getModifiers())) {_					logger.warn("Unable to proxy method [" + method + "] because it is final: " +_							"All calls to this method via a proxy will be routed directly to the proxy.")__				}_			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,if,logger,is,warn,enabled,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,static,method,get,modifiers,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1388872086;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			Method[] methods = proxySuperClass.getMethods()__			for (Method method : methods) {_				if (!Object.class.equals(method.getDeclaringClass()) && !Modifier.isStatic(method.getModifiers()) &&_						Modifier.isFinal(method.getModifiers())) {_					logger.warn("Unable to proxy method [" + method + "] because it is final: " +_							"All calls to this method via a proxy will be routed directly to the proxy.")__				}_			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,if,logger,is,warn,enabled,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,static,method,get,modifiers,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass);1391714711;Checks for final methods on the {@code Class} and writes warnings to the log_for each one found.;private void doValidateClass(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			Method[] methods = proxySuperClass.getMethods()__			for (Method method : methods) {_				if (!Object.class.equals(method.getDeclaringClass()) && !Modifier.isStatic(method.getModifiers()) &&_						Modifier.isFinal(method.getModifiers())) {_					logger.warn("Unable to proxy method [" + method + "] because it is final: " +_							"All calls to this method via a proxy will be routed directly to the proxy.")__				}_			}_		}_	};checks,for,final,methods,on,the,code,class,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,if,logger,is,warn,enabled,method,methods,proxy,super,class,get,methods,for,method,method,methods,if,object,class,equals,method,get,declaring,class,modifier,is,static,method,get,modifiers,modifier,is,final,method,get,modifiers,logger,warn,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,be,routed,directly,to,the,proxy
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1351638660;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1356735495;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1357119239;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1368482696;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1374269779;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1379028754;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1385412762;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1386761699;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_				throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1388872086;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1391714711;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1397664430;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1432125256;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1434484897;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1445895817;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1448383082;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1449660489;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1450295040;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1467730834;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1481749241;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1487773939;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1492434133;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private static Object processReturnType(Object proxy, Object target, Method method, Object retVal);1492451244;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;private,static,object,process,return,type,object,proxy,object,target,method,method,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1397664430;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1432125256;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1434484897;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1445895817;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1448383082;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1449660489;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1450295040;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1467730834;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1481749241;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1487773939;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isInfoEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,info,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1492434133;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1492451244;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1495868221;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1496242568;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1344552803;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1351638660;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1356735495;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1357119239;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1368482696;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1374269779;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1379028754;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1385412762;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1386761699;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1388872086;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1391714711;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1397664430;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1432125256;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1434484897;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1445895817;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1448383082;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1449660489;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1450295040;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1467730834;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1481749241;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1487773939;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1492434133;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1492451244;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1495868221;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1496242568;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1496837955;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1496955179;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1497300858;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1498780456;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1501077477;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1523443675;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1530174524;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1530190293;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1532091916;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1532706365;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1542468661;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1542747868;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> public CglibAopProxy(AdvisedSupport config) throws AopConfigException;1550238806;Create a new CglibAopProxy for the given AOP configuration._@param config the AOP configuration as AdvisedSupport object_@throws AopConfigException if the config is invalid. We try to throw an informative_exception in this case, rather than let a mysterious failure happen later.;public CglibAopProxy(AdvisedSupport config) throws AopConfigException {_		Assert.notNull(config, "AdvisedSupport must not be null")__		if (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {_			throw new AopConfigException("No advisors and no TargetSource specified")__		}_		this.advised = config__		this.advisedDispatcher = new AdvisedDispatcher(this.advised)__	};create,a,new,cglib,aop,proxy,for,the,given,aop,configuration,param,config,the,aop,configuration,as,advised,support,object,throws,aop,config,exception,if,the,config,is,invalid,we,try,to,throw,an,informative,exception,in,this,case,rather,than,let,a,mysterious,failure,happen,later;public,cglib,aop,proxy,advised,support,config,throws,aop,config,exception,assert,not,null,config,advised,support,must,not,be,null,if,config,get,advisors,length,0,config,get,target,source,advised,support,throw,new,aop,config,exception,no,advisors,and,no,target,source,specified,this,advised,config,this,advised,dispatcher,new,advised,dispatcher,this,advised
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1344552803;Checks to see whether the supplied <code>Class</code> has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,code,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1351638660;Checks to see whether the supplied <code>Class</code> has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,code,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1356735495;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1357119239;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1368482696;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1374269779;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1379028754;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1385412762;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1386761699;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1388872086;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass);1391714711;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass)__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1344552803;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1351638660;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1356735495;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1357119239;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1368482696;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1374269779;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1379028754;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1385412762;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1386761699;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1388872086;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1391714711;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1397664430;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1432125256;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1434484897;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1445895817;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1448383082;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1449660489;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1450295040;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1467730834;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1481749241;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1487773939;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1492434133;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1492451244;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1495868221;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1496242568;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1496837955;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1496955179;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1497300858;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1498780456;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1501077477;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1523443675;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1530174524;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1530190293;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1532091916;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1532706365;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1542468661;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1542747868;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> DynamicAdvisedInterceptor -> @Override 		public int hashCode();1550238806;CGLIB uses this to drive proxy creation.;@Override_		public int hashCode() {_			return this.advised.hashCode()__		};cglib,uses,this,to,drive,proxy,creation;override,public,int,hash,code,return,this,advised,hash,code
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1344552803;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1351638660;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1356735495;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1357119239;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1368482696;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1374269779;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1379028754;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1385412762;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1386761699;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1388872086;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1391714711;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.protectedMethod) {_				return super.invokeJoinpoint()__			}_			else {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,protected,method,return,super,invoke,joinpoint,else,return,this,method,proxy,invoke,this,target,this,arguments
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1397664430;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1432125256;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1434484897;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1445895817;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1448383082;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1449660489;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1450295040;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1467730834;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1481749241;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1487773939;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1492434133;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1492451244;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1495868221;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1496242568;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1496837955;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1496955179;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1497300858;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1498780456;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1501077477;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1523443675;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod && getMethod().getDeclaringClass() != Object.class) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,get,method,get,declaring,class,object,class,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1530174524;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod && getMethod().getDeclaringClass() != Object.class) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,get,method,get,declaring,class,object,class,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1530190293;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod && getMethod().getDeclaringClass() != Object.class) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,get,method,get,declaring,class,object,class,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1532091916;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod && getMethod().getDeclaringClass() != Object.class) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,get,method,get,declaring,class,object,class,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1532706365;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod && getMethod().getDeclaringClass() != Object.class) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,get,method,get,declaring,class,object,class,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1542468661;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.publicMethod && getMethod().getDeclaringClass() != Object.class) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,public,method,get,method,get,declaring,class,object,class,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1542747868;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.methodProxy != null) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,method,proxy,null,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> CglibMethodInvocation -> @Override 		protected Object invokeJoinpoint() throws Throwable;1550238806;Gives a marginal performance improvement versus using reflection to_invoke the target when invoking public methods.;@Override_		protected Object invokeJoinpoint() throws Throwable {_			if (this.methodProxy != null) {_				return this.methodProxy.invoke(this.target, this.arguments)__			}_			else {_				return super.invokeJoinpoint()__			}_		};gives,a,marginal,performance,improvement,versus,using,reflection,to,invoke,the,target,when,invoking,public,methods;override,protected,object,invoke,joinpoint,throws,throwable,if,this,method,proxy,null,return,this,method,proxy,invoke,this,target,this,arguments,else,return,super,invoke,joinpoint
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1496837955;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1496955179;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1497300858;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1498780456;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1501077477;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1523443675;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1530174524;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1530190293;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1532091916;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1532706365;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1542468661;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1542747868;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader);1550238806;Checks to see whether the supplied {@code Class} has already been validated and_validates it if not.;private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {_		if (logger.isWarnEnabled()) {_			synchronized (validatedClasses) {_				if (!validatedClasses.containsKey(proxySuperClass)) {_					doValidateClass(proxySuperClass, proxyClassLoader,_							ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass))__					validatedClasses.put(proxySuperClass, Boolean.TRUE)__				}_			}_		}_	};checks,to,see,whether,the,supplied,code,class,has,already,been,validated,and,validates,it,if,not;private,void,validate,class,if,necessary,class,proxy,super,class,nullable,class,loader,proxy,class,loader,if,logger,is,warn,enabled,synchronized,validated,classes,if,validated,classes,contains,key,proxy,super,class,do,validate,class,proxy,super,class,proxy,class,loader,class,utils,get,all,interfaces,for,class,as,set,proxy,super,class,validated,classes,put,proxy,super,class,boolean,true
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1492434133;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implmenting method [" + method + "] because " +_									"it is marked as final: Consider using interface-based proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implmenting,method,method,because,it,is,marked,as,final,consider,using,interface,based,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1492451244;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1495868221;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1496242568;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1344552803;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1351638660;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1356735495;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1357119239;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1368482696;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1374269779;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1379028754;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1385412762;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1386761699;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1388872086;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1391714711;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1397664430;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1432125256;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1434484897;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1445895817;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1448383082;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1449660489;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1450295040;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1467730834;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1481749241;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1487773939;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1492434133;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1492451244;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1495868221;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes);1496242568;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(Object[] constructorArgs, Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,object,constructor,args,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1496837955;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1496955179;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1497300858;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1498780456;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1501077477;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1523443675;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1530174524;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1530190293;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.warn("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.info("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,warn,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,info,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1532091916;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.info("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.debug("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.debug("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,info,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,debug,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,debug,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1532706365;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.info("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.debug("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.debug("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,info,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,debug,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,debug,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1542468661;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.info("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.debug("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.debug("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,info,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,debug,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,debug,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1542747868;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.info("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.debug("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.debug("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,info,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,debug,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,debug,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs);1550238806;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {_					if (Modifier.isFinal(mod)) {_						if (implementsInterface(method, ifcs)) {_							logger.info("Unable to proxy interface-implementing method [" + method + "] because " +_									"it is marked as final: Consider using interface-based JDK proxies instead!")__						}_						logger.debug("Final method [" + method + "] cannot get proxied via CGLIB: " +_								"Calls to this method will NOT be routed to the target instance and " +_								"might lead to NPEs against uninitialized fields in the proxy instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.debug("Method [" + method + "] is package-visible across different ClassLoaders " +_								"and cannot get proxied via CGLIB: Declare this method as public or protected " +_								"if you need to support invocations through the proxy.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,nullable,class,loader,proxy,class,loader,set,class,ifcs,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,modifier,is,private,mod,if,modifier,is,final,mod,if,implements,interface,method,ifcs,logger,info,unable,to,proxy,interface,implementing,method,method,because,it,is,marked,as,final,consider,using,interface,based,jdk,proxies,instead,logger,debug,final,method,method,cannot,get,proxied,via,cglib,calls,to,this,method,will,not,be,routed,to,the,target,instance,and,might,lead,to,npes,against,uninitialized,fields,in,the,proxy,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,debug,method,method,is,package,visible,across,different,class,loaders,and,cannot,get,proxied,via,cglib,declare,this,method,as,public,or,protected,if,you,need,to,support,invocations,through,the,proxy,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader,ifcs
CglibAopProxy -> ProxyCallbackFilter -> public int accept(Method method);1344552803;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return <code>this</code>_or when <code>ProxyFactory.getExposeProxy()</code> returns <code>false</code>,_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return <code>this</code> then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,code,or,when,code,proxy,factory,get,expose,proxy,code,returns,code,false,code,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,code,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> public int accept(Method method);1351638660;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return <code>this</code>_or when <code>ProxyFactory.getExposeProxy()</code> returns <code>false</code>,_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return <code>this</code> then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,code,or,when,code,proxy,factory,get,expose,proxy,code,returns,code,false,code,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,code,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> public int accept(Method method);1357119239;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> protected Enhancer createEnhancer();1344552803;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1351638660;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1356735495;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1357119239;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1368482696;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1374269779;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1379028754;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1385412762;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1386761699;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1388872086;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1391714711;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1397664430;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1432125256;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1434484897;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1445895817;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1448383082;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1449660489;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1450295040;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1467730834;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1481749241;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1487773939;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1492434133;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1492451244;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1495868221;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1496242568;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1496837955;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1496955179;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1497300858;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1498780456;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1501077477;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1523443675;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1530174524;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1530190293;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1532091916;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1532706365;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1542468661;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1542747868;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> protected Enhancer createEnhancer();1550238806;Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom_{@link Enhancer} implementation.;protected Enhancer createEnhancer() {_		return new Enhancer()__	};creates,the,cglib,link,enhancer,subclasses,may,wish,to,override,this,to,return,a,custom,link,enhancer,implementation;protected,enhancer,create,enhancer,return,new,enhancer
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1356735495;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1368482696;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1374269779;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1379028754;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1385412762;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1386761699;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1388872086;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1391714711;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1397664430;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1432125256;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1434484897;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1445895817;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1448383082;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1449660489;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1450295040;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1467730834;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1481749241;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1487773939;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimisations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimisations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass == returnType) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type same as target type (may return this) - using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_				else if (returnType.isPrimitive() || !returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								" has return type that ensures this cannot be returned- using DISPATCH_TARGET")__					}_					return DISPATCH_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method " + method +_								"has return type that is assignable from the target type (may return this) - " +_								"using INVOKE_TARGET")__					}_					return INVOKE_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimisations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimisations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,return,type,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,same,as,target,type,may,return,this,using,return,else,if,return,type,is,primitive,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,ensures,this,cannot,be,returned,using,return,else,if,logger,is,debug,enabled,logger,debug,method,method,has,return,type,that,is,assignable,from,the,target,type,may,return,this,using,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1492434133;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1492451244;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1495868221;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1496242568;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1496837955;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1496955179;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1497300858;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1498780456;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1501077477;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1523443675;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1530174524;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1530190293;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1532091916;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.debug("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isDebugEnabled()) {_					logger.debug("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				logger.debug("Found 'equals' method: " + method)__				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				logger.debug("Found 'hashCode' method: " + method)__				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isDebugEnabled()) {_						logger.debug("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isDebugEnabled()) {_						logger.debug("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,debug,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,debug,enabled,logger,debug,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,logger,debug,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,logger,debug,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,debug,enabled,logger,debug,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,debug,enabled,logger,debug,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,debug,enabled,logger,debug,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,debug,enabled,logger,debug,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,debug,enabled,logger,debug,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1532706365;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DyanmicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.trace("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'equals' method: " + method)__				}_				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'hashCode' method: " + method)__				}_				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isTraceEnabled()) {_						logger.trace("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dyanmic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,trace,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,trace,enabled,logger,trace,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,if,logger,is,trace,enabled,logger,trace,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,if,logger,is,trace,enabled,logger,trace,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,trace,enabled,logger,trace,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,trace,enabled,logger,trace,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,trace,enabled,logger,trace,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,trace,enabled,logger,trace,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,trace,enabled,logger,trace,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1542468661;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DynamicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.trace("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'equals' method: " + method)__				}_				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'hashCode' method: " + method)__				}_				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isTraceEnabled()) {_						logger.trace("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dynamic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,trace,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,trace,enabled,logger,trace,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,if,logger,is,trace,enabled,logger,trace,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,if,logger,is,trace,enabled,logger,trace,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,trace,enabled,logger,trace,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,trace,enabled,logger,trace,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,trace,enabled,logger,trace,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,trace,enabled,logger,trace,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,trace,enabled,logger,trace,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1542747868;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DynamicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.trace("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'equals' method: " + method)__				}_				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'hashCode' method: " + method)__				}_				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isTraceEnabled()) {_						logger.trace("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				String key = method.toString()__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dynamic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,trace,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,trace,enabled,logger,trace,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,if,logger,is,trace,enabled,logger,trace,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,if,logger,is,trace,enabled,logger,trace,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,trace,enabled,logger,trace,must,expose,proxy,on,advised,method,method,return,string,key,method,to,string,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,trace,enabled,logger,trace,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,trace,enabled,logger,trace,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,trace,enabled,logger,trace,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,trace,enabled,logger,trace,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> ProxyCallbackFilter -> @Override 		public int accept(Method method);1550238806;Implementation of CallbackFilter.accept() to return the index of the_callback we need._<p>The callbacks for each proxy are built up of a set of fixed callbacks_for general use and then a set of callbacks that are specific to a method_for use on static targets with a fixed advice chain._<p>The callback used is determined thus:_<dl>_<dt>For exposed proxies</dt>_<dd>Exposing the proxy requires code to execute before and after the_method/chain invocation. This means we must use_DynamicAdvisedInterceptor, since all other interceptors can avoid the_need for a try/catch block</dd>_<dt>For Object.finalize():</dt>_<dd>No override for this method is used.</dd>_<dt>For equals():</dt>_<dd>The EqualsInterceptor is used to redirect equals() calls to a_special handler to this proxy.</dd>_<dt>For methods on the Advised class:</dt>_<dd>the AdvisedDispatcher is used to dispatch the call directly to_the target</dd>_<dt>For advised methods:</dt>_<dd>If the target is static and the advice chain is frozen then a_FixedChainStaticTargetInterceptor specific to the method is used to_invoke the advice chain. Otherwise a DynamicAdvisedInterceptor is_used.</dd>_<dt>For non-advised methods:</dt>_<dd>Where it can be determined that the method will not return {@code this}_or when {@code ProxyFactory.getExposeProxy()} returns {@code false},_then a Dispatcher is used. For static targets, the StaticDispatcher is used__and for dynamic targets, a DynamicUnadvisedInterceptor is used._If it possible for the method to return {@code this} then a_StaticUnadvisedInterceptor is used for static targets - the_DynamicUnadvisedInterceptor already considers this.</dd>_</dl>;@Override_		public int accept(Method method) {_			if (AopUtils.isFinalizeMethod(method)) {_				logger.trace("Found finalize() method - using NO_OVERRIDE")__				return NO_OVERRIDE__			}_			if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() &&_					method.getDeclaringClass().isAssignableFrom(Advised.class)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Method is declared on Advised interface: " + method)__				}_				return DISPATCH_ADVISED__			}_			_			if (AopUtils.isEqualsMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'equals' method: " + method)__				}_				return INVOKE_EQUALS__			}_			_			if (AopUtils.isHashCodeMethod(method)) {_				if (logger.isTraceEnabled()) {_					logger.trace("Found 'hashCode' method: " + method)__				}_				return INVOKE_HASHCODE__			}_			Class<?> targetClass = this.advised.getTargetClass()__			_			List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)__			boolean haveAdvice = !chain.isEmpty()__			boolean exposeProxy = this.advised.isExposeProxy()__			boolean isStatic = this.advised.getTargetSource().isStatic()__			boolean isFrozen = this.advised.isFrozen()__			if (haveAdvice || !isFrozen) {_				_				if (exposeProxy) {_					if (logger.isTraceEnabled()) {_						logger.trace("Must expose proxy on advised method: " + method)__					}_					return AOP_PROXY__				}_				Method key = method__				_				_				if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method has advice and optimizations are enabled: " + method)__					}_					_					int index = this.fixedInterceptorMap.get(key)__					return (index + this.fixedInterceptorOffset)__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Unable to apply any optimizations to advised method: " + method)__					}_					return AOP_PROXY__				}_			}_			else {_				_				_				_				_				_				if (exposeProxy || !isStatic) {_					return INVOKE_TARGET__				}_				Class<?> returnType = method.getReturnType()__				if (targetClass != null && returnType.isAssignableFrom(targetClass)) {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type is assignable from target type and " +_								"may therefore return 'this' - using INVOKE_TARGET: " + method)__					}_					return INVOKE_TARGET__				}_				else {_					if (logger.isTraceEnabled()) {_						logger.trace("Method return type ensures 'this' cannot be returned - " +_								"using DISPATCH_TARGET: " + method)__					}_					return DISPATCH_TARGET__				}_			}_		};implementation,of,callback,filter,accept,to,return,the,index,of,the,callback,we,need,p,the,callbacks,for,each,proxy,are,built,up,of,a,set,of,fixed,callbacks,for,general,use,and,then,a,set,of,callbacks,that,are,specific,to,a,method,for,use,on,static,targets,with,a,fixed,advice,chain,p,the,callback,used,is,determined,thus,dl,dt,for,exposed,proxies,dt,dd,exposing,the,proxy,requires,code,to,execute,before,and,after,the,method,chain,invocation,this,means,we,must,use,dynamic,advised,interceptor,since,all,other,interceptors,can,avoid,the,need,for,a,try,catch,block,dd,dt,for,object,finalize,dt,dd,no,override,for,this,method,is,used,dd,dt,for,equals,dt,dd,the,equals,interceptor,is,used,to,redirect,equals,calls,to,a,special,handler,to,this,proxy,dd,dt,for,methods,on,the,advised,class,dt,dd,the,advised,dispatcher,is,used,to,dispatch,the,call,directly,to,the,target,dd,dt,for,advised,methods,dt,dd,if,the,target,is,static,and,the,advice,chain,is,frozen,then,a,fixed,chain,static,target,interceptor,specific,to,the,method,is,used,to,invoke,the,advice,chain,otherwise,a,dynamic,advised,interceptor,is,used,dd,dt,for,non,advised,methods,dt,dd,where,it,can,be,determined,that,the,method,will,not,return,code,this,or,when,code,proxy,factory,get,expose,proxy,returns,code,false,then,a,dispatcher,is,used,for,static,targets,the,static,dispatcher,is,used,and,for,dynamic,targets,a,dynamic,unadvised,interceptor,is,used,if,it,possible,for,the,method,to,return,code,this,then,a,static,unadvised,interceptor,is,used,for,static,targets,the,dynamic,unadvised,interceptor,already,considers,this,dd,dl;override,public,int,accept,method,method,if,aop,utils,is,finalize,method,method,logger,trace,found,finalize,method,using,return,if,this,advised,is,opaque,method,get,declaring,class,is,interface,method,get,declaring,class,is,assignable,from,advised,class,if,logger,is,trace,enabled,logger,trace,method,is,declared,on,advised,interface,method,return,if,aop,utils,is,equals,method,method,if,logger,is,trace,enabled,logger,trace,found,equals,method,method,return,if,aop,utils,is,hash,code,method,method,if,logger,is,trace,enabled,logger,trace,found,hash,code,method,method,return,class,target,class,this,advised,get,target,class,list,chain,this,advised,get,interceptors,and,dynamic,interception,advice,method,target,class,boolean,have,advice,chain,is,empty,boolean,expose,proxy,this,advised,is,expose,proxy,boolean,is,static,this,advised,get,target,source,is,static,boolean,is,frozen,this,advised,is,frozen,if,have,advice,is,frozen,if,expose,proxy,if,logger,is,trace,enabled,logger,trace,must,expose,proxy,on,advised,method,method,return,method,key,method,if,is,static,is,frozen,this,fixed,interceptor,map,contains,key,key,if,logger,is,trace,enabled,logger,trace,method,has,advice,and,optimizations,are,enabled,method,int,index,this,fixed,interceptor,map,get,key,return,index,this,fixed,interceptor,offset,else,if,logger,is,trace,enabled,logger,trace,unable,to,apply,any,optimizations,to,advised,method,method,return,else,if,expose,proxy,is,static,return,class,return,type,method,get,return,type,if,target,class,null,return,type,is,assignable,from,target,class,if,logger,is,trace,enabled,logger,trace,method,return,type,is,assignable,from,target,type,and,may,therefore,return,this,using,method,return,else,if,logger,is,trace,enabled,logger,trace,method,return,type,ensures,this,cannot,be,returned,using,method,return
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1397664430;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (!Object.class.equals(proxySuperClass)) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,equals,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1432125256;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1434484897;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1445895817;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1448383082;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1449660489;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1450295040;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1467730834;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1481749241;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (Object.class != proxySuperClass) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,object,class,proxy,super,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader);1487773939;Checks for final methods on the given {@code Class}, as well as package-visible_methods across ClassLoaders, and writes warnings to the log for each one found.;private void doValidateClass(Class<?> proxySuperClass, ClassLoader proxyClassLoader) {_		if (proxySuperClass != Object.class) {_			Method[] methods = proxySuperClass.getDeclaredMethods()__			for (Method method : methods) {_				int mod = method.getModifiers()__				if (!Modifier.isStatic(mod)) {_					if (Modifier.isFinal(mod)) {_						logger.info("Unable to proxy method [" + method + "] because it is final: " +_								"All calls to this method via a proxy will NOT be routed to the target instance.")__					}_					else if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&_							proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {_						logger.info("Unable to proxy method [" + method + "] because it is package-visible " +_								"across different ClassLoaders: All calls to this method via a proxy will " +_								"NOT be routed to the target instance.")__					}_				}_			}_			doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader)__		}_	};checks,for,final,methods,on,the,given,code,class,as,well,as,package,visible,methods,across,class,loaders,and,writes,warnings,to,the,log,for,each,one,found;private,void,do,validate,class,class,proxy,super,class,class,loader,proxy,class,loader,if,proxy,super,class,object,class,method,methods,proxy,super,class,get,declared,methods,for,method,method,methods,int,mod,method,get,modifiers,if,modifier,is,static,mod,if,modifier,is,final,mod,logger,info,unable,to,proxy,method,method,because,it,is,final,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,else,if,modifier,is,public,mod,modifier,is,protected,mod,modifier,is,private,mod,proxy,class,loader,null,proxy,super,class,get,class,loader,proxy,class,loader,logger,info,unable,to,proxy,method,method,because,it,is,package,visible,across,different,class,loaders,all,calls,to,this,method,via,a,proxy,will,not,be,routed,to,the,target,instance,do,validate,class,proxy,super,class,get,superclass,proxy,class,loader
CglibAopProxy -> @Nullable 	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal);1495868221;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,object,target,method,method,nullable,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> @Nullable 	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal);1496242568;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,object,target,method,method,nullable,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> @Nullable 	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal);1496955179;Process a return value. Wraps a return of {@code this} if necessary to be the_{@code proxy} and also verifies that {@code null} is not returned as a primitive.;@Nullable_	private static Object processReturnType(Object proxy, Object target, Method method, @Nullable Object retVal) {_		_		if (retVal != null && retVal == target &&_				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {_			_			_			retVal = proxy__		}_		Class<?> returnType = method.getReturnType()__		if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {_			throw new AopInvocationException(_					"Null return value from advice does not match primitive return type for: " + method)__		}_		return retVal__	};process,a,return,value,wraps,a,return,of,code,this,if,necessary,to,be,the,code,proxy,and,also,verifies,that,code,null,is,not,returned,as,a,primitive;nullable,private,static,object,process,return,type,object,proxy,object,target,method,method,nullable,object,ret,val,if,ret,val,null,ret,val,target,raw,target,access,class,is,assignable,from,method,get,declaring,class,ret,val,proxy,class,return,type,method,get,return,type,if,ret,val,null,return,type,void,type,return,type,is,primitive,throw,new,aop,invocation,exception,null,return,value,from,advice,does,not,match,primitive,return,type,for,method,return,ret,val
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1496837955;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1496955179;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1497300858;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1498780456;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1501077477;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1523443675;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1530174524;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1530190293;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1532091916;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1532706365;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1542468661;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1542747868;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
CglibAopProxy -> public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes);1550238806;Set constructor arguments to use for creating the proxy._@param constructorArgs the constructor argument values_@param constructorArgTypes the constructor argument types;public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {_		if (constructorArgs == null || constructorArgTypes == null) {_			throw new IllegalArgumentException("Both 'constructorArgs' and 'constructorArgTypes' need to be specified")__		}_		if (constructorArgs.length != constructorArgTypes.length) {_			throw new IllegalArgumentException("Number of 'constructorArgs' (" + constructorArgs.length +_					") must match number of 'constructorArgTypes' (" + constructorArgTypes.length + ")")__		}_		this.constructorArgs = constructorArgs__		this.constructorArgTypes = constructorArgTypes__	};set,constructor,arguments,to,use,for,creating,the,proxy,param,constructor,args,the,constructor,argument,values,param,constructor,arg,types,the,constructor,argument,types;public,void,set,constructor,arguments,nullable,object,constructor,args,nullable,class,constructor,arg,types,if,constructor,args,null,constructor,arg,types,null,throw,new,illegal,argument,exception,both,constructor,args,and,constructor,arg,types,need,to,be,specified,if,constructor,args,length,constructor,arg,types,length,throw,new,illegal,argument,exception,number,of,constructor,args,constructor,args,length,must,match,number,of,constructor,arg,types,constructor,arg,types,length,this,constructor,args,constructor,args,this,constructor,arg,types,constructor,arg,types
