commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Match all methods that <b>either</b> (or both) of the given pointcuts matches.  * @param pc1 the first Pointcut  * @param pc2 the second Pointcut  * @return a distinct Pointcut that matches all methods that either  * of the given Pointcuts matches  */ ;/**  * Match all methods that <b>either</b> (or both) of the given pointcuts matches.  * @param pc1 the first Pointcut  * @param pc2 the second Pointcut  * @return a distinct Pointcut that matches all methods that either  * of the given Pointcuts matches  */ public static Pointcut union(Pointcut pc1, Pointcut pc2) {     return new ComposablePointcut(pc1).union(pc2). }
true;public,static;2;3;/**  * Match all methods that <b>both</b> the given pointcuts match.  * @param pc1 the first Pointcut  * @param pc2 the second Pointcut  * @return a distinct Pointcut that matches all methods that both  * of the given Pointcuts match  */ ;/**  * Match all methods that <b>both</b> the given pointcuts match.  * @param pc1 the first Pointcut  * @param pc2 the second Pointcut  * @return a distinct Pointcut that matches all methods that both  * of the given Pointcuts match  */ public static Pointcut intersection(Pointcut pc1, Pointcut pc2) {     return new ComposablePointcut(pc1).intersection(pc2). }
true;public,static;4;15;/**  * Perform the least expensive check for a pointcut match.  * @param pointcut the pointcut to match  * @param method the candidate method  * @param targetClass the target class  * @param args arguments to the method  * @return whether there's a runtime match  */ ;/**  * Perform the least expensive check for a pointcut match.  * @param pointcut the pointcut to match  * @param method the candidate method  * @param targetClass the target class  * @param args arguments to the method  * @return whether there's a runtime match  */ public static boolean matches(Pointcut pointcut, Method method, Class<?> targetClass, Object... args) {     Assert.notNull(pointcut, "Pointcut must not be null").     if (pointcut == Pointcut.TRUE) {         return true.     }     if (pointcut.getClassFilter().matches(targetClass)) {         // Only check if it gets past first hurdle.         MethodMatcher mm = pointcut.getMethodMatcher().         if (mm.matches(method, targetClass)) {             // We may need additional runtime (argument) check.             return (!mm.isRuntime() || mm.matches(method, targetClass, args)).         }     }     return false. }
false;public;2;6;;@Override public boolean matches(Method method, Class<?> targetClass) {     return (method.getName().startsWith("set") && method.getParameterCount() == 1 && method.getReturnType() == Void.TYPE). }
false;private;0;3;;private Object readResolve() {     return INSTANCE. }
false;public;2;5;;@Override public boolean matches(Method method, Class<?> targetClass) {     return (method.getName().startsWith("get") && method.getParameterCount() == 0). }
false;private;0;3;;private Object readResolve() {     return INSTANCE. }
