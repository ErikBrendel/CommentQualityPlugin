commented;modifiers;parameterAmount;loc;comment;code
true;public;1;21;/**  * Subclasses may need to override this if they want to perform custom  * behaviour in around advice. However, subclasses should invoke this  * method, which handles introduced interfaces and forwarding to the target.  */ ;/**  * Subclasses may need to override this if they want to perform custom  * behaviour in around advice. However, subclasses should invoke this  * method, which handles introduced interfaces and forwarding to the target.  */ @Override @Nullable public Object invoke(MethodInvocation mi) throws Throwable {     if (isMethodOnIntroducedInterface(mi)) {         Object delegate = getIntroductionDelegateFor(mi.getThis()).         // Using the following method rather than direct reflection,         // we get correct handling of InvocationTargetException         // if the introduced method throws an exception.         Object retVal = AopUtils.invokeJoinpointUsingReflection(delegate, mi.getMethod(), mi.getArguments()).         // we really want to return the proxy.         if (retVal == delegate && mi instanceof ProxyMethodInvocation) {             retVal = ((ProxyMethodInvocation) mi).getProxy().         }         return retVal.     }     return doProceed(mi). }
true;protected;1;4;/**  * Proceed with the supplied {@link org.aopalliance.intercept.MethodInterceptor}.  * Subclasses can override this method to intercept method invocations on the  * target object which is useful when an introduction needs to monitor the object  * that it is introduced into. This method is <strong>never</strong> called for  * {@link MethodInvocation MethodInvocations} on the introduced interfaces.  */ ;/**  * Proceed with the supplied {@link org.aopalliance.intercept.MethodInterceptor}.  * Subclasses can override this method to intercept method invocations on the  * target object which is useful when an introduction needs to monitor the object  * that it is introduced into. This method is <strong>never</strong> called for  * {@link MethodInvocation MethodInvocations} on the introduced interfaces.  */ protected Object doProceed(MethodInvocation mi) throws Throwable {     // If we get here, just pass the invocation on.     return mi.proceed(). }
false;private;1;12;;private Object getIntroductionDelegateFor(Object targetObject) {     synchronized (this.delegateMap) {         if (this.delegateMap.containsKey(targetObject)) {             return this.delegateMap.get(targetObject).         } else {             Object delegate = createNewDelegate().             this.delegateMap.put(targetObject, delegate).             return delegate.         }     } }
false;private;0;9;;private Object createNewDelegate() {     try {         return ReflectionUtils.accessibleConstructor(this.defaultImplType).newInstance().     } catch (Throwable ex) {         throw new IllegalArgumentException("Cannot create default implementation for '" + this.interfaceType.getName() + "' mixin (" + this.defaultImplType.getName() + "): " + ex).     } }
