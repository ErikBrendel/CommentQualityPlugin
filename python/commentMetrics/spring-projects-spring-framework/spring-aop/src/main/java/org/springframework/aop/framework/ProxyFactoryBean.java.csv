commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the names of the interfaces we're proxying. If no interface  * is given, a CGLIB for the actual class will be created.  * <p>This is essentially equivalent to the "setInterfaces" method,  * but mirrors TransactionProxyFactoryBean's "setProxyInterfaces".  * @see #setInterfaces  * @see AbstractSingletonProxyFactoryBean#setProxyInterfaces  */ ;/**  * Set the names of the interfaces we're proxying. If no interface  * is given, a CGLIB for the actual class will be created.  * <p>This is essentially equivalent to the "setInterfaces" method,  * but mirrors TransactionProxyFactoryBean's "setProxyInterfaces".  * @see #setInterfaces  * @see AbstractSingletonProxyFactoryBean#setProxyInterfaces  */ public void setProxyInterfaces(Class<?>[] proxyInterfaces) throws ClassNotFoundException {     setInterfaces(proxyInterfaces). }
true;public;1;3;/**  * Set the list of Advice/Advisor bean names. This must always be set  * to use this factory bean in a bean factory.  * <p>The referenced beans should be of type Interceptor, Advisor or Advice  * The last entry in the list can be the name of any bean in the factory.  * If it's neither an Advice nor an Advisor, a new SingletonTargetSource  * is added to wrap it. Such a target bean cannot be used if the "target"  * or "targetSource" or "targetName" property is set, in which case the  * "interceptorNames" array must contain only Advice/Advisor bean names.  * <p><b>NOTE: Specifying a target bean as final name in the "interceptorNames"  * list is deprecated and will be removed in a future Spring version.</b>  * Use the {@link #setTargetName "targetName"} property instead.  * @see org.aopalliance.intercept.MethodInterceptor  * @see org.springframework.aop.Advisor  * @see org.aopalliance.aop.Advice  * @see org.springframework.aop.target.SingletonTargetSource  */ ;/**  * Set the list of Advice/Advisor bean names. This must always be set  * to use this factory bean in a bean factory.  * <p>The referenced beans should be of type Interceptor, Advisor or Advice  * The last entry in the list can be the name of any bean in the factory.  * If it's neither an Advice nor an Advisor, a new SingletonTargetSource  * is added to wrap it. Such a target bean cannot be used if the "target"  * or "targetSource" or "targetName" property is set, in which case the  * "interceptorNames" array must contain only Advice/Advisor bean names.  * <p><b>NOTE: Specifying a target bean as final name in the "interceptorNames"  * list is deprecated and will be removed in a future Spring version.</b>  * Use the {@link #setTargetName "targetName"} property instead.  * @see org.aopalliance.intercept.MethodInterceptor  * @see org.springframework.aop.Advisor  * @see org.aopalliance.aop.Advice  * @see org.springframework.aop.target.SingletonTargetSource  */ public void setInterceptorNames(String... interceptorNames) {     this.interceptorNames = interceptorNames. }
true;public;1;3;/**  * Set the name of the target bean. This is an alternative to specifying  * the target name at the end of the "interceptorNames" array.  * <p>You can also specify a target object or a TargetSource object  * directly, via the "target"/"targetSource" property, respectively.  * @see #setInterceptorNames(String[])  * @see #setTarget(Object)  * @see #setTargetSource(org.springframework.aop.TargetSource)  */ ;/**  * Set the name of the target bean. This is an alternative to specifying  * the target name at the end of the "interceptorNames" array.  * <p>You can also specify a target object or a TargetSource object  * directly, via the "target"/"targetSource" property, respectively.  * @see #setInterceptorNames(String[])  * @see #setTarget(Object)  * @see #setTargetSource(org.springframework.aop.TargetSource)  */ public void setTargetName(String targetName) {     this.targetName = targetName. }
true;public;1;3;/**  * Set whether to autodetect proxy interfaces if none specified.  * <p>Default is "true". Turn this flag off to create a CGLIB  * proxy for the full target class if no interfaces specified.  * @see #setProxyTargetClass  */ ;/**  * Set whether to autodetect proxy interfaces if none specified.  * <p>Default is "true". Turn this flag off to create a CGLIB  * proxy for the full target class if no interfaces specified.  * @see #setProxyTargetClass  */ public void setAutodetectInterfaces(boolean autodetectInterfaces) {     this.autodetectInterfaces = autodetectInterfaces. }
true;public;1;3;/**  * Set the value of the singleton property. Governs whether this factory  * should always return the same proxy instance (which implies the same target)  * or whether it should return a new prototype instance, which implies that  * the target and interceptors may be new instances also, if they are obtained  * from prototype bean definitions. This allows for fine control of  * independence/uniqueness in the object graph.  */ ;/**  * Set the value of the singleton property. Governs whether this factory  * should always return the same proxy instance (which implies the same target)  * or whether it should return a new prototype instance, which implies that  * the target and interceptors may be new instances also, if they are obtained  * from prototype bean definitions. This allows for fine control of  * independence/uniqueness in the object graph.  */ public void setSingleton(boolean singleton) {     this.singleton = singleton. }
true;public;1;3;/**  * Specify the AdvisorAdapterRegistry to use.  * Default is the global AdvisorAdapterRegistry.  * @see org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry  */ ;/**  * Specify the AdvisorAdapterRegistry to use.  * Default is the global AdvisorAdapterRegistry.  * @see org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry  */ public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) {     this.advisorAdapterRegistry = advisorAdapterRegistry. }
false;public;1;4;;@Override public void setFrozen(boolean frozen) {     this.freezeProxy = frozen. }
true;public;1;4;/**  * Set the ClassLoader to generate the proxy class in.  * <p>Default is the bean ClassLoader, i.e. the ClassLoader used by the  * containing BeanFactory for loading all bean classes. This can be  * overridden here for specific proxies.  */ ;/**  * Set the ClassLoader to generate the proxy class in.  * <p>Default is the bean ClassLoader, i.e. the ClassLoader used by the  * containing BeanFactory for loading all bean classes. This can be  * overridden here for specific proxies.  */ public void setProxyClassLoader(@Nullable ClassLoader classLoader) {     this.proxyClassLoader = classLoader.     this.classLoaderConfigured = (classLoader != null). }
false;public;1;6;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     if (!this.classLoaderConfigured) {         this.proxyClassLoader = classLoader.     } }
false;public;1;5;;@Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory.     checkInterceptorNames(). }
true;public;0;15;/**  * Return a proxy. Invoked when clients obtain beans from this factory bean.  * Create an instance of the AOP proxy to be returned by this factory.  * The instance will be cached for a singleton, and create on each call to  * {@code getObject()} for a proxy.  * @return a fresh AOP proxy reflecting the current state of this factory  */ ;/**  * Return a proxy. Invoked when clients obtain beans from this factory bean.  * Create an instance of the AOP proxy to be returned by this factory.  * The instance will be cached for a singleton, and create on each call to  * {@code getObject()} for a proxy.  * @return a fresh AOP proxy reflecting the current state of this factory  */ @Override @Nullable public Object getObject() throws BeansException {     initializeAdvisorChain().     if (isSingleton()) {         return getSingletonInstance().     } else {         if (this.targetName == null) {             logger.info("Using non-singleton proxies with singleton targets is often undesirable. " + "Enable prototype proxies by setting the 'targetName' property.").         }         return newPrototypeInstance().     } }
true;public;0;21;/**  * Return the type of the proxy. Will check the singleton instance if  * already created, else fall back to the proxy interface (in case of just  * a single one), the target bean type, or the TargetSource's target class.  * @see org.springframework.aop.TargetSource#getTargetClass  */ ;/**  * Return the type of the proxy. Will check the singleton instance if  * already created, else fall back to the proxy interface (in case of just  * a single one), the target bean type, or the TargetSource's target class.  * @see org.springframework.aop.TargetSource#getTargetClass  */ @Override public Class<?> getObjectType() {     synchronized (this) {         if (this.singletonInstance != null) {             return this.singletonInstance.getClass().         }     }     Class<?>[] ifcs = getProxiedInterfaces().     if (ifcs.length == 1) {         return ifcs[0].     } else if (ifcs.length > 1) {         return createCompositeInterface(ifcs).     } else if (this.targetName != null && this.beanFactory != null) {         return this.beanFactory.getType(this.targetName).     } else {         return getTargetClass().     } }
false;public;0;4;;@Override public boolean isSingleton() {     return this.singleton. }
true;protected;1;3;/**  * Create a composite interface Class for the given interfaces,  * implementing the given interfaces in one single Class.  * <p>The default implementation builds a JDK proxy class for the  * given interfaces.  * @param interfaces the interfaces to merge  * @return the merged interface as Class  * @see java.lang.reflect.Proxy#getProxyClass  */ ;/**  * Create a composite interface Class for the given interfaces,  * implementing the given interfaces in one single Class.  * <p>The default implementation builds a JDK proxy class for the  * given interfaces.  * @param interfaces the interfaces to merge  * @return the merged interface as Class  * @see java.lang.reflect.Proxy#getProxyClass  */ protected Class<?> createCompositeInterface(Class<?>[] interfaces) {     return ClassUtils.createCompositeInterface(interfaces, this.proxyClassLoader). }
true;private,synchronized;0;17;/**  * Return the singleton instance of this class's proxy object,  * lazily creating it if it hasn't been created already.  * @return the shared singleton proxy  */ ;/**  * Return the singleton instance of this class's proxy object,  * lazily creating it if it hasn't been created already.  * @return the shared singleton proxy  */ private synchronized Object getSingletonInstance() {     if (this.singletonInstance == null) {         this.targetSource = freshTargetSource().         if (this.autodetectInterfaces && getProxiedInterfaces().length == 0 && !isProxyTargetClass()) {             // Rely on AOP infrastructure to tell us what interfaces to proxy.             Class<?> targetClass = getTargetClass().             if (targetClass == null) {                 throw new FactoryBeanNotInitializedException("Cannot determine target class for proxy").             }             setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader)).         }         // Initialize the shared singleton instance.         super.setFrozen(this.freezeProxy).         this.singletonInstance = getProxy(createAopProxy()).     }     return this.singletonInstance. }
true;private,synchronized;0;27;/**  * Create a new prototype instance of this class's created proxy object,  * backed by an independent AdvisedSupport configuration.  * @return a totally independent proxy, whose advice we may manipulate in isolation  */ ;/**  * Create a new prototype instance of this class's created proxy object,  * backed by an independent AdvisedSupport configuration.  * @return a totally independent proxy, whose advice we may manipulate in isolation  */ private synchronized Object newPrototypeInstance() {     // but will have an independent copy.     if (logger.isTraceEnabled()) {         logger.trace("Creating copy of prototype ProxyFactoryBean config: " + this).     }     ProxyCreatorSupport copy = new ProxyCreatorSupport(getAopProxyFactory()).     // The copy needs a fresh advisor chain, and a fresh TargetSource.     TargetSource targetSource = freshTargetSource().     copy.copyConfigurationFrom(this, targetSource, freshAdvisorChain()).     if (this.autodetectInterfaces && getProxiedInterfaces().length == 0 && !isProxyTargetClass()) {         // Rely on AOP infrastructure to tell us what interfaces to proxy.         Class<?> targetClass = targetSource.getTargetClass().         if (targetClass != null) {             copy.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader)).         }     }     copy.setFrozen(this.freezeProxy).     if (logger.isTraceEnabled()) {         logger.trace("Using ProxyCreatorSupport copy: " + copy).     }     return getProxy(copy.createAopProxy()). }
true;protected;1;3;/**  * Return the proxy object to expose.  * <p>The default implementation uses a {@code getProxy} call with  * the factory's bean class loader. Can be overridden to specify a  * custom class loader.  * @param aopProxy the prepared AopProxy instance to get the proxy from  * @return the proxy object to expose  * @see AopProxy#getProxy(ClassLoader)  */ ;/**  * Return the proxy object to expose.  * <p>The default implementation uses a {@code getProxy} call with  * the factory's bean class loader. Can be overridden to specify a  * custom class loader.  * @param aopProxy the prepared AopProxy instance to get the proxy from  * @return the proxy object to expose  * @see AopProxy#getProxy(ClassLoader)  */ protected Object getProxy(AopProxy aopProxy) {     return aopProxy.getProxy(this.proxyClassLoader). }
true;private;0;20;/**  * Check the interceptorNames list whether it contains a target name as final element.  * If found, remove the final name from the list and set it as targetName.  */ ;/**  * Check the interceptorNames list whether it contains a target name as final element.  * If found, remove the final name from the list and set it as targetName.  */ private void checkInterceptorNames() {     if (!ObjectUtils.isEmpty(this.interceptorNames)) {         String finalName = this.interceptorNames[this.interceptorNames.length - 1].         if (this.targetName == null && this.targetSource == EMPTY_TARGET_SOURCE) {             // Unfortunately we don't know. we must look at type of the bean.             if (!finalName.endsWith(GLOBAL_SUFFIX) && !isNamedBeanAnAdvisorOrAdvice(finalName)) {                 // The target isn't an interceptor.                 this.targetName = finalName.                 if (logger.isDebugEnabled()) {                     logger.debug("Bean with name '" + finalName + "' concluding interceptor chain " + "is not an advisor class: treating it as a target or TargetSource").                 }                 String[] newNames = new String[this.interceptorNames.length - 1].                 System.arraycopy(this.interceptorNames, 0, newNames, 0, newNames.length).                 this.interceptorNames = newNames.             }         }     } }
true;private;1;13;/**  * Look at bean factory metadata to work out whether this bean name,  * which concludes the interceptorNames list, is an Advisor or Advice,  * or may be a target.  * @param beanName bean name to check  * @return {@code true} if it's an Advisor or Advice  */ ;/**  * Look at bean factory metadata to work out whether this bean name,  * which concludes the interceptorNames list, is an Advisor or Advice,  * or may be a target.  * @param beanName bean name to check  * @return {@code true} if it's an Advisor or Advice  */ private boolean isNamedBeanAnAdvisorOrAdvice(String beanName) {     Assert.state(this.beanFactory != null, "No BeanFactory set").     Class<?> namedBeanClass = this.beanFactory.getType(beanName).     if (namedBeanClass != null) {         return (Advisor.class.isAssignableFrom(namedBeanClass) || Advice.class.isAssignableFrom(namedBeanClass)).     }     // Treat it as an target bean if we can't tell.     if (logger.isDebugEnabled()) {         logger.debug("Could not determine type of bean with name '" + beanName + "' - assuming it is neither an Advisor nor an Advice").     }     return false. }
true;private,synchronized;0;52;/**  * Create the advisor (interceptor) chain. Advisors that are sourced  * from a BeanFactory will be refreshed each time a new prototype instance  * is added. Interceptors added programmatically through the factory API  * are unaffected by such changes.  */ ;/**  * Create the advisor (interceptor) chain. Advisors that are sourced  * from a BeanFactory will be refreshed each time a new prototype instance  * is added. Interceptors added programmatically through the factory API  * are unaffected by such changes.  */ private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException {     if (this.advisorChainInitialized) {         return.     }     if (!ObjectUtils.isEmpty(this.interceptorNames)) {         if (this.beanFactory == null) {             throw new IllegalStateException("No BeanFactory available anymore (probably due to serialization) " + "- cannot resolve interceptor names " + Arrays.asList(this.interceptorNames)).         }         // Globals can't be last unless we specified a targetSource using the property...         if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) && this.targetName == null && this.targetSource == EMPTY_TARGET_SOURCE) {             throw new AopConfigException("Target required after globals").         }         // Materialize interceptor chain from bean names.         for (String name : this.interceptorNames) {             if (logger.isTraceEnabled()) {                 logger.trace("Configuring advisor or advice '" + name + "'").             }             if (name.endsWith(GLOBAL_SUFFIX)) {                 if (!(this.beanFactory instanceof ListableBeanFactory)) {                     throw new AopConfigException("Can only use global advisors or interceptors with a ListableBeanFactory").                 }                 addGlobalAdvisor((ListableBeanFactory) this.beanFactory, name.substring(0, name.length() - GLOBAL_SUFFIX.length())).             } else {                 // If we get here, we need to add a named interceptor.                 // We must check if it's a singleton or prototype.                 Object advice.                 if (this.singleton || this.beanFactory.isSingleton(name)) {                     // Add the real Advisor/Advice to the chain.                     advice = this.beanFactory.getBean(name).                 } else {                     // It's a prototype Advice or Advisor: replace with a prototype.                     // Avoid unnecessary creation of prototype bean just for advisor chain initialization.                     advice = new PrototypePlaceholderAdvisor(name).                 }                 addAdvisorOnChainCreation(advice, name).             }         }     }     this.advisorChainInitialized = true. }
true;private;0;26;/**  * Return an independent advisor chain.  * We need to do this every time a new prototype instance is returned,  * to return distinct instances of prototype Advisors and Advices.  */ ;/**  * Return an independent advisor chain.  * We need to do this every time a new prototype instance is returned,  * to return distinct instances of prototype Advisors and Advices.  */ private List<Advisor> freshAdvisorChain() {     Advisor[] advisors = getAdvisors().     List<Advisor> freshAdvisors = new ArrayList<>(advisors.length).     for (Advisor advisor : advisors) {         if (advisor instanceof PrototypePlaceholderAdvisor) {             PrototypePlaceholderAdvisor pa = (PrototypePlaceholderAdvisor) advisor.             if (logger.isDebugEnabled()) {                 logger.debug("Refreshing bean named '" + pa.getBeanName() + "'").             }             // from a getBean() lookup             if (this.beanFactory == null) {                 throw new IllegalStateException("No BeanFactory available anymore (probably due to serialization) " + "- cannot resolve prototype advisor '" + pa.getBeanName() + "'").             }             Object bean = this.beanFactory.getBean(pa.getBeanName()).             Advisor refreshedAdvisor = namedBeanToAdvisor(bean).             freshAdvisors.add(refreshedAdvisor).         } else {             // Add the shared instance.             freshAdvisors.add(advisor).         }     }     return freshAdvisors. }
true;private;2;25;/**  * Add all global interceptors and pointcuts.  */ ;/**  * Add all global interceptors and pointcuts.  */ private void addGlobalAdvisor(ListableBeanFactory beanFactory, String prefix) {     String[] globalAdvisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, Advisor.class).     String[] globalInterceptorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, Interceptor.class).     List<Object> beans = new ArrayList<>(globalAdvisorNames.length + globalInterceptorNames.length).     Map<Object, String> names = new HashMap<>(beans.size()).     for (String name : globalAdvisorNames) {         Object bean = beanFactory.getBean(name).         beans.add(bean).         names.put(bean, name).     }     for (String name : globalInterceptorNames) {         Object bean = beanFactory.getBean(name).         beans.add(bean).         names.put(bean, name).     }     AnnotationAwareOrderComparator.sort(beans).     for (Object bean : beans) {         String name = names.get(bean).         if (name.startsWith(prefix)) {             addAdvisorOnChainCreation(bean, name).         }     } }
true;private;2;9;/**  * Invoked when advice chain is created.  * <p>Add the given advice, advisor or object to the interceptor list.  * Because of these three possibilities, we can't type the signature  * more strongly.  * @param next advice, advisor or target object  * @param name bean name from which we obtained this object in our owning  * bean factory  */ ;/**  * Invoked when advice chain is created.  * <p>Add the given advice, advisor or object to the interceptor list.  * Because of these three possibilities, we can't type the signature  * more strongly.  * @param next advice, advisor or target object  * @param name bean name from which we obtained this object in our owning  * bean factory  */ private void addAdvisorOnChainCreation(Object next, String name) {     // We need to convert to an Advisor if necessary so that our source reference     // matches what we find from superclass interceptors.     Advisor advisor = namedBeanToAdvisor(next).     if (logger.isTraceEnabled()) {         logger.trace("Adding advisor with name '" + name + "'").     }     addAdvisor(advisor). }
true;private;0;19;/**  * Return a TargetSource to use when creating a proxy. If the target was not  * specified at the end of the interceptorNames list, the TargetSource will be  * this class's TargetSource member. Otherwise, we get the target bean and wrap  * it in a TargetSource if necessary.  */ ;/**  * Return a TargetSource to use when creating a proxy. If the target was not  * specified at the end of the interceptorNames list, the TargetSource will be  * this class's TargetSource member. Otherwise, we get the target bean and wrap  * it in a TargetSource if necessary.  */ private TargetSource freshTargetSource() {     if (this.targetName == null) {         if (logger.isTraceEnabled()) {             logger.trace("Not refreshing target: Bean name not specified in 'interceptorNames'.").         }         return this.targetSource.     } else {         if (this.beanFactory == null) {             throw new IllegalStateException("No BeanFactory available anymore (probably due to serialization) " + "- cannot resolve target with name '" + this.targetName + "'").         }         if (logger.isDebugEnabled()) {             logger.debug("Refreshing target with name '" + this.targetName + "'").         }         Object target = this.beanFactory.getBean(this.targetName).         return (target instanceof TargetSource ? (TargetSource) target : new SingletonTargetSource(target)).     } }
true;private;1;12;/**  * Convert the following object sourced from calling getBean() on a name in the  * interceptorNames array to an Advisor or TargetSource.  */ ;/**  * Convert the following object sourced from calling getBean() on a name in the  * interceptorNames array to an Advisor or TargetSource.  */ private Advisor namedBeanToAdvisor(Object next) {     try {         return this.advisorAdapterRegistry.wrap(next).     } catch (UnknownAdviceTypeException ex) {         // but it wasn't. This is a configuration error.         throw new AopConfigException("Unknown advisor type " + next.getClass() + ". Can only include Advisor or Advice type beans in interceptorNames chain except for last entry," + "which may also be target or TargetSource", ex).     } }
true;protected;0;10;/**  * Blow away and recache singleton on an advice change.  */ ;/**  * Blow away and recache singleton on an advice change.  */ @Override protected void adviceChanged() {     super.adviceChanged().     if (this.singleton) {         logger.debug("Advice has changed. recaching singleton instance").         synchronized (this) {             this.singletonInstance = null.         }     } }
false;private;1;7;;// --------------------------------------------------------------------- // Serialization support // --------------------------------------------------------------------- private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     // Rely on default serialization. just initialize state after deserialization.     ois.defaultReadObject().     // Initialize transient fields.     this.proxyClassLoader = ClassUtils.getDefaultClassLoader(). }
false;public;0;3;;public String getBeanName() {     return this.beanName. }
false;public;0;4;;@Override public Advice getAdvice() {     throw new UnsupportedOperationException("Cannot invoke methods: " + this.message). }
false;public;0;4;;@Override public boolean isPerInstance() {     throw new UnsupportedOperationException("Cannot invoke methods: " + this.message). }
false;public;0;4;;@Override public String toString() {     return this.message. }
