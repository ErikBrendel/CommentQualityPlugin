commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the given object as target.  * Will create a SingletonTargetSource for the object.  * @see #setTargetSource  * @see org.springframework.aop.target.SingletonTargetSource  */ ;/**  * Set the given object as target.  * Will create a SingletonTargetSource for the object.  * @see #setTargetSource  * @see org.springframework.aop.target.SingletonTargetSource  */ public void setTarget(Object target) {     setTargetSource(new SingletonTargetSource(target)). }
false;public;1;4;;@Override public void setTargetSource(@Nullable TargetSource targetSource) {     this.targetSource = (targetSource != null ? targetSource : EMPTY_TARGET_SOURCE). }
false;public;0;4;;@Override public TargetSource getTargetSource() {     return this.targetSource. }
true;public;1;3;/**  * Set a target class to be proxied, indicating that the proxy  * should be castable to the given class.  * <p>Internally, an {@link org.springframework.aop.target.EmptyTargetSource}  * for the given target class will be used. The kind of proxy needed  * will be determined on actual creation of the proxy.  * <p>This is a replacement for setting a "targetSource" or "target",  * for the case where we want a proxy based on a target class  * (which can be an interface or a concrete class) without having  * a fully capable TargetSource available.  * @see #setTargetSource  * @see #setTarget  */ ;/**  * Set a target class to be proxied, indicating that the proxy  * should be castable to the given class.  * <p>Internally, an {@link org.springframework.aop.target.EmptyTargetSource}  * for the given target class will be used. The kind of proxy needed  * will be determined on actual creation of the proxy.  * <p>This is a replacement for setting a "targetSource" or "target",  * for the case where we want a proxy based on a target class  * (which can be an interface or a concrete class) without having  * a fully capable TargetSource available.  * @see #setTargetSource  * @see #setTarget  */ public void setTargetClass(@Nullable Class<?> targetClass) {     this.targetSource = EmptyTargetSource.forClass(targetClass). }
false;public;0;5;;@Override @Nullable public Class<?> getTargetClass() {     return this.targetSource.getTargetClass(). }
false;public;1;4;;@Override public void setPreFiltered(boolean preFiltered) {     this.preFiltered = preFiltered. }
false;public;0;4;;@Override public boolean isPreFiltered() {     return this.preFiltered. }
true;public;1;4;/**  * Set the advisor chain factory to use.  * <p>Default is a {@link DefaultAdvisorChainFactory}.  */ ;/**  * Set the advisor chain factory to use.  * <p>Default is a {@link DefaultAdvisorChainFactory}.  */ public void setAdvisorChainFactory(AdvisorChainFactory advisorChainFactory) {     Assert.notNull(advisorChainFactory, "AdvisorChainFactory must not be null").     this.advisorChainFactory = advisorChainFactory. }
true;public;0;3;/**  * Return the advisor chain factory to use (never {@code null}).  */ ;/**  * Return the advisor chain factory to use (never {@code null}).  */ public AdvisorChainFactory getAdvisorChainFactory() {     return this.advisorChainFactory. }
true;public;1;7;/**  * Set the interfaces to be proxied.  */ ;/**  * Set the interfaces to be proxied.  */ public void setInterfaces(Class<?>... interfaces) {     Assert.notNull(interfaces, "Interfaces must not be null").     this.interfaces.clear().     for (Class<?> ifc : interfaces) {         addInterface(ifc).     } }
true;public;1;10;/**  * Add a new proxied interface.  * @param intf the additional interface to proxy  */ ;/**  * Add a new proxied interface.  * @param intf the additional interface to proxy  */ public void addInterface(Class<?> intf) {     Assert.notNull(intf, "Interface must not be null").     if (!intf.isInterface()) {         throw new IllegalArgumentException("[" + intf.getName() + "] is not an interface").     }     if (!this.interfaces.contains(intf)) {         this.interfaces.add(intf).         adviceChanged().     } }
true;public;1;3;/**  * Remove a proxied interface.  * <p>Does nothing if the given interface isn't proxied.  * @param intf the interface to remove from the proxy  * @return {@code true} if the interface was removed. {@code false}  * if the interface was not found and hence could not be removed  */ ;/**  * Remove a proxied interface.  * <p>Does nothing if the given interface isn't proxied.  * @param intf the interface to remove from the proxy  * @return {@code true} if the interface was removed. {@code false}  * if the interface was not found and hence could not be removed  */ public boolean removeInterface(Class<?> intf) {     return this.interfaces.remove(intf). }
false;public;0;4;;@Override public Class<?>[] getProxiedInterfaces() {     return ClassUtils.toClassArray(this.interfaces). }
false;public;1;9;;@Override public boolean isInterfaceProxied(Class<?> intf) {     for (Class<?> proxyIntf : this.interfaces) {         if (intf.isAssignableFrom(proxyIntf)) {             return true.         }     }     return false. }
false;public,final;0;4;;@Override public final Advisor[] getAdvisors() {     return this.advisorArray. }
false;public;1;5;;@Override public void addAdvisor(Advisor advisor) {     int pos = this.advisors.size().     addAdvisor(pos, advisor). }
false;public;2;7;;@Override public void addAdvisor(int pos, Advisor advisor) throws AopConfigException {     if (advisor instanceof IntroductionAdvisor) {         validateIntroductionAdvisor((IntroductionAdvisor) advisor).     }     addAdvisorInternal(pos, advisor). }
false;public;1;11;;@Override public boolean removeAdvisor(Advisor advisor) {     int index = indexOf(advisor).     if (index == -1) {         return false.     } else {         removeAdvisor(index).         return true.     } }
false;public;1;23;;@Override public void removeAdvisor(int index) throws AopConfigException {     if (isFrozen()) {         throw new AopConfigException("Cannot remove Advisor: Configuration is frozen.").     }     if (index < 0 || index > this.advisors.size() - 1) {         throw new AopConfigException("Advisor index " + index + " is out of bounds: " + "This configuration only has " + this.advisors.size() + " advisors.").     }     Advisor advisor = this.advisors.get(index).     if (advisor instanceof IntroductionAdvisor) {         IntroductionAdvisor ia = (IntroductionAdvisor) advisor.         // We need to remove introduction interfaces.         for (int j = 0. j < ia.getInterfaces().length. j++) {             removeInterface(ia.getInterfaces()[j]).         }     }     this.advisors.remove(index).     updateAdvisorArray().     adviceChanged(). }
false;public;1;5;;@Override public int indexOf(Advisor advisor) {     Assert.notNull(advisor, "Advisor must not be null").     return this.advisors.indexOf(advisor). }
false;public;2;12;;@Override public boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException {     Assert.notNull(a, "Advisor a must not be null").     Assert.notNull(b, "Advisor b must not be null").     int index = indexOf(a).     if (index == -1) {         return false.     }     removeAdvisor(index).     addAdvisor(index, b).     return true. }
true;public;1;3;/**  * Add all of the given advisors to this proxy configuration.  * @param advisors the advisors to register  */ ;/**  * Add all of the given advisors to this proxy configuration.  * @param advisors the advisors to register  */ public void addAdvisors(Advisor... advisors) {     addAdvisors(Arrays.asList(advisors)). }
true;public;1;16;/**  * Add all of the given advisors to this proxy configuration.  * @param advisors the advisors to register  */ ;/**  * Add all of the given advisors to this proxy configuration.  * @param advisors the advisors to register  */ public void addAdvisors(Collection<Advisor> advisors) {     if (isFrozen()) {         throw new AopConfigException("Cannot add advisor: Configuration is frozen.").     }     if (!CollectionUtils.isEmpty(advisors)) {         for (Advisor advisor : advisors) {             if (advisor instanceof IntroductionAdvisor) {                 validateIntroductionAdvisor((IntroductionAdvisor) advisor).             }             Assert.notNull(advisor, "Advisor must not be null").             this.advisors.add(advisor).         }         updateAdvisorArray().         adviceChanged().     } }
false;private;1;8;;private void validateIntroductionAdvisor(IntroductionAdvisor advisor) {     advisor.validateInterfaces().     // If the advisor passed validation, we can make the change.     Class<?>[] ifcs = advisor.getInterfaces().     for (Class<?> ifc : ifcs) {         addInterface(ifc).     } }
false;private;2;13;;private void addAdvisorInternal(int pos, Advisor advisor) throws AopConfigException {     Assert.notNull(advisor, "Advisor must not be null").     if (isFrozen()) {         throw new AopConfigException("Cannot add advisor: Configuration is frozen.").     }     if (pos > this.advisors.size()) {         throw new IllegalArgumentException("Illegal position " + pos + " in advisor list with size " + this.advisors.size()).     }     this.advisors.add(pos, advisor).     updateAdvisorArray().     adviceChanged(). }
true;protected,final;0;3;/**  * Bring the array up to date with the list.  */ ;/**  * Bring the array up to date with the list.  */ protected final void updateAdvisorArray() {     this.advisorArray = this.advisors.toArray(new Advisor[0]). }
true;protected,final;0;3;/**  * Allows uncontrolled access to the {@link List} of {@link Advisor Advisors}.  * <p>Use with care, and remember to {@link #updateAdvisorArray() refresh the advisor array}  * and {@link #adviceChanged() fire advice changed events} when making any modifications.  */ ;/**  * Allows uncontrolled access to the {@link List} of {@link Advisor Advisors}.  * <p>Use with care, and remember to {@link #updateAdvisorArray() refresh the advisor array}  * and {@link #adviceChanged() fire advice changed events} when making any modifications.  */ protected final List<Advisor> getAdvisorsInternal() {     return this.advisors. }
false;public;1;5;;@Override public void addAdvice(Advice advice) throws AopConfigException {     int pos = this.advisors.size().     addAdvice(pos, advice). }
true;public;2;16;/**  * Cannot add introductions this way unless the advice implements IntroductionInfo.  */ ;/**  * Cannot add introductions this way unless the advice implements IntroductionInfo.  */ @Override public void addAdvice(int pos, Advice advice) throws AopConfigException {     Assert.notNull(advice, "Advice must not be null").     if (advice instanceof IntroductionInfo) {         // We don't need an IntroductionAdvisor for this kind of introduction:         // It's fully self-describing.         addAdvisor(pos, new DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice)).     } else if (advice instanceof DynamicIntroductionAdvice) {         // We need an IntroductionAdvisor for this kind of introduction.         throw new AopConfigException("DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor").     } else {         addAdvisor(pos, new DefaultPointcutAdvisor(advice)).     } }
false;public;1;11;;@Override public boolean removeAdvice(Advice advice) throws AopConfigException {     int index = indexOf(advice).     if (index == -1) {         return false.     } else {         removeAdvisor(index).         return true.     } }
false;public;1;11;;@Override public int indexOf(Advice advice) {     Assert.notNull(advice, "Advice must not be null").     for (int i = 0. i < this.advisors.size(). i++) {         Advisor advisor = this.advisors.get(i).         if (advisor.getAdvice() == advice) {             return i.         }     }     return -1. }
true;public;1;10;/**  * Is the given advice included in any advisor within this proxy configuration?  * @param advice the advice to check inclusion of  * @return whether this advice instance is included  */ ;/**  * Is the given advice included in any advisor within this proxy configuration?  * @param advice the advice to check inclusion of  * @return whether this advice instance is included  */ public boolean adviceIncluded(@Nullable Advice advice) {     if (advice != null) {         for (Advisor advisor : this.advisors) {             if (advisor.getAdvice() == advice) {                 return true.             }         }     }     return false. }
true;public;1;11;/**  * Count advices of the given class.  * @param adviceClass the advice class to check  * @return the count of the interceptors of this class or subclasses  */ ;/**  * Count advices of the given class.  * @param adviceClass the advice class to check  * @return the count of the interceptors of this class or subclasses  */ public int countAdvicesOfType(@Nullable Class<?> adviceClass) {     int count = 0.     if (adviceClass != null) {         for (Advisor advisor : this.advisors) {             if (adviceClass.isInstance(advisor.getAdvice())) {                 count++.             }         }     }     return count. }
true;public;2;10;/**  * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects  * for the given method, based on this configuration.  * @param method the proxied method  * @param targetClass the target class  * @return a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)  */ ;/**  * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects  * for the given method, based on this configuration.  * @param method the proxied method  * @param targetClass the target class  * @return a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)  */ public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass) {     MethodCacheKey cacheKey = new MethodCacheKey(method).     List<Object> cached = this.methodCache.get(cacheKey).     if (cached == null) {         cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass).         this.methodCache.put(cacheKey, cached).     }     return cached. }
true;protected;0;3;/**  * Invoked when advice has changed.  */ ;/**  * Invoked when advice has changed.  */ protected void adviceChanged() {     this.methodCache.clear(). }
true;protected;1;3;/**  * Call this method on a new instance created by the no-arg constructor  * to create an independent copy of the configuration from the given object.  * @param other the AdvisedSupport object to copy configuration from  */ ;/**  * Call this method on a new instance created by the no-arg constructor  * to create an independent copy of the configuration from the given object.  * @param other the AdvisedSupport object to copy configuration from  */ protected void copyConfigurationFrom(AdvisedSupport other) {     copyConfigurationFrom(other, other.targetSource, new ArrayList<>(other.advisors)). }
true;protected;3;15;/**  * Copy the AOP configuration from the given AdvisedSupport object,  * but allow substitution of a fresh TargetSource and a given interceptor chain.  * @param other the AdvisedSupport object to take proxy configuration from  * @param targetSource the new TargetSource  * @param advisors the Advisors for the chain  */ ;/**  * Copy the AOP configuration from the given AdvisedSupport object,  * but allow substitution of a fresh TargetSource and a given interceptor chain.  * @param other the AdvisedSupport object to take proxy configuration from  * @param targetSource the new TargetSource  * @param advisors the Advisors for the chain  */ protected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors) {     copyFrom(other).     this.targetSource = targetSource.     this.advisorChainFactory = other.advisorChainFactory.     this.interfaces = new ArrayList<>(other.interfaces).     for (Advisor advisor : advisors) {         if (advisor instanceof IntroductionAdvisor) {             validateIntroductionAdvisor((IntroductionAdvisor) advisor).         }         Assert.notNull(advisor, "Advisor must not be null").         this.advisors.add(advisor).     }     updateAdvisorArray().     adviceChanged(). }
true;;0;10;/**  * Build a configuration-only copy of this AdvisedSupport,  * replacing the TargetSource.  */ ;/**  * Build a configuration-only copy of this AdvisedSupport,  * replacing the TargetSource.  */ AdvisedSupport getConfigurationOnlyCopy() {     AdvisedSupport copy = new AdvisedSupport().     copy.copyFrom(this).     copy.targetSource = EmptyTargetSource.forClass(getTargetClass(), getTargetSource().isStatic()).     copy.advisorChainFactory = this.advisorChainFactory.     copy.interfaces = this.interfaces.     copy.advisors = this.advisors.     copy.updateAdvisorArray().     return copy. }
false;private;1;7;;// --------------------------------------------------------------------- // Serialization support // --------------------------------------------------------------------- private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     // Rely on default serialization. just initialize state after deserialization.     ois.defaultReadObject().     // Initialize transient fields.     this.methodCache = new ConcurrentHashMap<>(32). }
false;public;0;4;;@Override public String toProxyConfigString() {     return toString(). }
true;public;0;11;/**  * For debugging/diagnostic use.  */ ;/**  * For debugging/diagnostic use.  */ @Override public String toString() {     StringBuilder sb = new StringBuilder(getClass().getName()).     sb.append(": ").append(this.interfaces.size()).append(" interfaces ").     sb.append(ClassUtils.classNamesToString(this.interfaces)).append(". ").     sb.append(this.advisors.size()).append(" advisors ").     sb.append(this.advisors).append(". ").     sb.append("targetSource [").append(this.targetSource).append("]. ").     sb.append(super.toString()).     return sb.toString(). }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof MethodCacheKey && this.method == ((MethodCacheKey) other).method)). }
false;public;0;4;;@Override public int hashCode() {     return this.hashCode. }
false;public;0;4;;@Override public String toString() {     return this.method.toString(). }
false;public;1;8;;@Override public int compareTo(MethodCacheKey other) {     int result = this.method.getName().compareTo(other.method.getName()).     if (result == 0) {         result = this.method.toString().compareTo(other.method.toString()).     }     return result. }
