commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the ordering which will apply to this processor's implementation  * of {@link Ordered}, used when applying multiple processors.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @param order the ordering value  */ ;/**  * Set the ordering which will apply to this processor's implementation  * of {@link Ordered}, used when applying multiple processors.  * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.  * @param order the ordering value  */ public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
true;public;1;4;/**  * Set the ClassLoader to generate the proxy class in.  * <p>Default is the bean ClassLoader, i.e. the ClassLoader used by the containing  * {@link org.springframework.beans.factory.BeanFactory} for loading all bean classes.  * This can be overridden here for specific proxies.  */ ;/**  * Set the ClassLoader to generate the proxy class in.  * <p>Default is the bean ClassLoader, i.e. the ClassLoader used by the containing  * {@link org.springframework.beans.factory.BeanFactory} for loading all bean classes.  * This can be overridden here for specific proxies.  */ public void setProxyClassLoader(@Nullable ClassLoader classLoader) {     this.proxyClassLoader = classLoader.     this.classLoaderConfigured = (classLoader != null). }
true;protected;0;4;/**  * Return the configured proxy ClassLoader for this processor.  */ ;/**  * Return the configured proxy ClassLoader for this processor.  */ @Nullable protected ClassLoader getProxyClassLoader() {     return this.proxyClassLoader. }
false;public;1;6;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     if (!this.classLoaderConfigured) {         this.proxyClassLoader = classLoader.     } }
true;protected;2;20;/**  * Check the interfaces on the given bean class and apply them to the {@link ProxyFactory},  * if appropriate.  * <p>Calls {@link #isConfigurationCallbackInterface} and {@link #isInternalLanguageInterface}  * to filter for reasonable proxy interfaces, falling back to a target-class proxy otherwise.  * @param beanClass the class of the bean  * @param proxyFactory the ProxyFactory for the bean  */ ;/**  * Check the interfaces on the given bean class and apply them to the {@link ProxyFactory},  * if appropriate.  * <p>Calls {@link #isConfigurationCallbackInterface} and {@link #isInternalLanguageInterface}  * to filter for reasonable proxy interfaces, falling back to a target-class proxy otherwise.  * @param beanClass the class of the bean  * @param proxyFactory the ProxyFactory for the bean  */ protected void evaluateProxyInterfaces(Class<?> beanClass, ProxyFactory proxyFactory) {     Class<?>[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader()).     boolean hasReasonableProxyInterface = false.     for (Class<?> ifc : targetInterfaces) {         if (!isConfigurationCallbackInterface(ifc) && !isInternalLanguageInterface(ifc) && ifc.getMethods().length > 0) {             hasReasonableProxyInterface = true.             break.         }     }     if (hasReasonableProxyInterface) {         // Must allow for introductions. can't just set interfaces to the target's interfaces only.         for (Class<?> ifc : targetInterfaces) {             proxyFactory.addInterface(ifc).         }     } else {         proxyFactory.setProxyTargetClass(true).     } }
true;protected;1;4;/**  * Determine whether the given interface is just a container callback and  * therefore not to be considered as a reasonable proxy interface.  * <p>If no reasonable proxy interface is found for a given bean, it will get  * proxied with its full target class, assuming that as the user's intention.  * @param ifc the interface to check  * @return whether the given interface is just a container callback  */ ;/**  * Determine whether the given interface is just a container callback and  * therefore not to be considered as a reasonable proxy interface.  * <p>If no reasonable proxy interface is found for a given bean, it will get  * proxied with its full target class, assuming that as the user's intention.  * @param ifc the interface to check  * @return whether the given interface is just a container callback  */ protected boolean isConfigurationCallbackInterface(Class<?> ifc) {     return (InitializingBean.class == ifc || DisposableBean.class == ifc || Closeable.class == ifc || AutoCloseable.class == ifc || ObjectUtils.containsElement(ifc.getInterfaces(), Aware.class)). }
true;protected;1;5;/**  * Determine whether the given interface is a well-known internal language interface  * and therefore not to be considered as a reasonable proxy interface.  * <p>If no reasonable proxy interface is found for a given bean, it will get  * proxied with its full target class, assuming that as the user's intention.  * @param ifc the interface to check  * @return whether the given interface is an internal language interface  */ ;/**  * Determine whether the given interface is a well-known internal language interface  * and therefore not to be considered as a reasonable proxy interface.  * <p>If no reasonable proxy interface is found for a given bean, it will get  * proxied with its full target class, assuming that as the user's intention.  * @param ifc the interface to check  * @return whether the given interface is an internal language interface  */ protected boolean isInternalLanguageInterface(Class<?> ifc) {     return (ifc.getName().equals("groovy.lang.GroovyObject") || ifc.getName().endsWith(".cglib.proxy.Factory") || ifc.getName().endsWith(".bytebuddy.MockAccess")). }
