commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * The pointcut for Spring AOP to use.  * Actual behaviour of the pointcut will change depending on the state of the advice.  */ ;/**  * The pointcut for Spring AOP to use.  * Actual behaviour of the pointcut will change depending on the state of the advice.  */ @Override public Pointcut getPointcut() {     return this.pointcut. }
false;public;0;4;;@Override public boolean isLazy() {     return this.lazy. }
false;public,synchronized;0;4;;@Override public synchronized boolean isAdviceInstantiated() {     return (this.instantiatedAdvice != null). }
true;public,synchronized;0;7;/**  * Lazily instantiate advice if necessary.  */ ;/**  * Lazily instantiate advice if necessary.  */ @Override public synchronized Advice getAdvice() {     if (this.instantiatedAdvice == null) {         this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut).     }     return this.instantiatedAdvice. }
false;private;1;5;;private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {     Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut, this.aspectInstanceFactory, this.declarationOrder, this.aspectName).     return (advice != null ? advice : EMPTY_ADVICE). }
true;public;0;4;/**  * This is only of interest for Spring AOP: AspectJ instantiation semantics  * are much richer. In AspectJ terminology, all a return of {@code true}  * means here is that the aspect is not a SINGLETON.  */ ;/**  * This is only of interest for Spring AOP: AspectJ instantiation semantics  * are much richer. In AspectJ terminology, all a return of {@code true}  * means here is that the aspect is not a SINGLETON.  */ @Override public boolean isPerInstance() {     return (getAspectMetadata().getAjType().getPerClause().getKind() != PerClauseKind.SINGLETON). }
true;public;0;3;/**  * Return the AspectJ AspectMetadata for this advisor.  */ ;/**  * Return the AspectJ AspectMetadata for this advisor.  */ public AspectMetadata getAspectMetadata() {     return this.aspectInstanceFactory.getAspectMetadata(). }
false;public;0;3;;public MetadataAwareAspectInstanceFactory getAspectInstanceFactory() {     return this.aspectInstanceFactory. }
false;public;0;3;;public AspectJExpressionPointcut getDeclaredPointcut() {     return this.declaredPointcut. }
false;public;0;4;;@Override public int getOrder() {     return this.aspectInstanceFactory.getOrder(). }
false;public;0;4;;@Override public String getAspectName() {     return this.aspectName. }
false;public;0;4;;@Override public int getDeclarationOrder() {     return this.declarationOrder. }
false;public;0;7;;@Override public boolean isBeforeAdvice() {     if (this.isBeforeAdvice == null) {         determineAdviceType().     }     return this.isBeforeAdvice. }
false;public;0;7;;@Override public boolean isAfterAdvice() {     if (this.isAfterAdvice == null) {         determineAdviceType().     }     return this.isAfterAdvice. }
true;private;0;27;/**  * Duplicates some logic from getAdvice, but importantly does not force  * creation of the advice.  */ ;/**  * Duplicates some logic from getAdvice, but importantly does not force  * creation of the advice.  */ private void determineAdviceType() {     AspectJAnnotation<?> aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(this.aspectJAdviceMethod).     if (aspectJAnnotation == null) {         this.isBeforeAdvice = false.         this.isAfterAdvice = false.     } else {         switch(aspectJAnnotation.getAnnotationType()) {             case AtPointcut:             case AtAround:                 this.isBeforeAdvice = false.                 this.isAfterAdvice = false.                 break.             case AtBefore:                 this.isBeforeAdvice = true.                 this.isAfterAdvice = false.                 break.             case AtAfter:             case AtAfterReturning:             case AtAfterThrowing:                 this.isBeforeAdvice = false.                 this.isAfterAdvice = true.                 break.         }     } }
false;private;1;9;;private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {     inputStream.defaultReadObject().     try {         this.aspectJAdviceMethod = this.declaringClass.getMethod(this.methodName, this.parameterTypes).     } catch (NoSuchMethodException ex) {         throw new IllegalStateException("Failed to find advice method on deserialization", ex).     } }
false;public;0;6;;@Override public String toString() {     return "InstantiationModelAwarePointcutAdvisor: expression [" + getDeclaredPointcut().getExpression() + "]. advice method [" + this.aspectJAdviceMethod + "]. perClauseKind=" + this.aspectInstanceFactory.getAspectMetadata().getAjType().getPerClause().getKind(). }
false;public;2;7;;@Override public boolean matches(Method method, Class<?> targetClass) {     // or uninstantiated matching on either pointcut...     return (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass)) || this.preInstantiationPointcut.getMethodMatcher().matches(method, targetClass). }
false;public;3;5;;@Override public boolean matches(Method method, Class<?> targetClass, Object... args) {     // This can match only on declared pointcut.     return (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass)). }
false;private;0;3;;private boolean isAspectMaterialized() {     return (this.aspectInstanceFactory == null || this.aspectInstanceFactory.isMaterialized()). }
