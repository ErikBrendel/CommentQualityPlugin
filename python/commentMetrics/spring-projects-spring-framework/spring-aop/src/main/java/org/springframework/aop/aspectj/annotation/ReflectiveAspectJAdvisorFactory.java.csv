commented;modifiers;parameterAmount;loc;comment;code
false;public;1;35;;@Override public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {     Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass().     String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName().     validate(aspectClass).     // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator     // so that it will only instantiate once.     MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory).     List<Advisor> advisors = new ArrayList<>().     for (Method method : getAdvisorMethods(aspectClass)) {         Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName).         if (advisor != null) {             advisors.add(advisor).         }     }     // If it's a per target aspect, emit the dummy instantiating aspect.     if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {         Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory).         advisors.add(0, instantiationAdvisor).     }     // Find introduction fields.     for (Field field : aspectClass.getDeclaredFields()) {         Advisor advisor = getDeclareParentsAdvisor(field).         if (advisor != null) {             advisors.add(advisor).         }     }     return advisors. }
false;private;1;11;;private List<Method> getAdvisorMethods(Class<?> aspectClass) {     final List<Method> methods = new ArrayList<>().     ReflectionUtils.doWithMethods(aspectClass, method -> {         // Exclude pointcuts         if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {             methods.add(method).         }     }).     methods.sort(METHOD_COMPARATOR).     return methods. }
true;private;1;15;/**  * Build a {@link org.springframework.aop.aspectj.DeclareParentsAdvisor}  * for the given introduction field.  * <p>Resulting Advisors will need to be evaluated for targets.  * @param introductionField the field to introspect  * @return the Advisor instance, or {@code null} if not an Advisor  */ ;/**  * Build a {@link org.springframework.aop.aspectj.DeclareParentsAdvisor}  * for the given introduction field.  * <p>Resulting Advisors will need to be evaluated for targets.  * @param introductionField the field to introspect  * @return the Advisor instance, or {@code null} if not an Advisor  */ @Nullable private Advisor getDeclareParentsAdvisor(Field introductionField) {     DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class).     if (declareParents == null) {         // Not an introduction field         return null.     }     if (DeclareParents.class == declareParents.defaultImpl()) {         throw new IllegalStateException("'defaultImpl' attribute must be set on DeclareParents").     }     return new DeclareParentsAdvisor(introductionField.getType(), declareParents.value(), declareParents.defaultImpl()). }
false;public;4;16;;@Override @Nullable public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrderInAspect, String aspectName) {     validate(aspectInstanceFactory.getAspectMetadata().getAspectClass()).     AspectJExpressionPointcut expressionPointcut = getPointcut(candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass()).     if (expressionPointcut == null) {         return null.     }     return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, aspectName). }
false;private;2;16;;@Nullable private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {     AspectJAnnotation<?> aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod).     if (aspectJAnnotation == null) {         return null.     }     AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]).     ajexp.setExpression(aspectJAnnotation.getPointcutExpression()).     if (this.beanFactory != null) {         ajexp.setBeanFactory(this.beanFactory).     }     return ajexp. }
false;public;5;78;;@Override @Nullable public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {     Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass().     validate(candidateAspectClass).     AspectJAnnotation<?> aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod).     if (aspectJAnnotation == null) {         return null.     }     // Check that it's an AspectJ-annotated class     if (!isAspect(candidateAspectClass)) {         throw new AopConfigException("Advice must be declared inside an aspect type: " + "Offending method '" + candidateAdviceMethod + "' in class [" + candidateAspectClass.getName() + "]").     }     if (logger.isDebugEnabled()) {         logger.debug("Found AspectJ method: " + candidateAdviceMethod).     }     AbstractAspectJAdvice springAdvice.     switch(aspectJAnnotation.getAnnotationType()) {         case AtPointcut:             if (logger.isDebugEnabled()) {                 logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'").             }             return null.         case AtAround:             springAdvice = new AspectJAroundAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory).             break.         case AtBefore:             springAdvice = new AspectJMethodBeforeAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory).             break.         case AtAfter:             springAdvice = new AspectJAfterAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory).             break.         case AtAfterReturning:             springAdvice = new AspectJAfterReturningAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory).             AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation().             if (StringUtils.hasText(afterReturningAnnotation.returning())) {                 springAdvice.setReturningName(afterReturningAnnotation.returning()).             }             break.         case AtAfterThrowing:             springAdvice = new AspectJAfterThrowingAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory).             AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation().             if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {                 springAdvice.setThrowingName(afterThrowingAnnotation.throwing()).             }             break.         default:             throw new UnsupportedOperationException("Unsupported advice type on method: " + candidateAdviceMethod).     }     // Now to configure the advice...     springAdvice.setAspectName(aspectName).     springAdvice.setDeclarationOrder(declarationOrder).     String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod).     if (argNames != null) {         springAdvice.setArgumentNamesFromStringArray(argNames).     }     springAdvice.calculateArgumentBindings().     return springAdvice. }
