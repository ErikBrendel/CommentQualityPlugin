commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * If the test uses any of the this, target, at_this, at_target, and at_annotation vars,  * then it tests subtype sensitive vars.  */ ;/**  * If the test uses any of the this, target, at_this, at_target, and at_annotation vars,  * then it tests subtype sensitive vars.  */ public boolean testsSubtypeSensitiveVars() {     return (this.runtimeTest != null && new SubtypeSensitiveVarTypeTestVisitor().testsSubtypeSensitiveVars(this.runtimeTest)). }
false;public;1;4;;public boolean testThisInstanceOfResidue(Class<?> thisClass) {     return (this.runtimeTest != null && new ThisInstanceOfResidueTestVisitor(thisClass).thisInstanceOfMatches(this.runtimeTest)). }
false;public;1;4;;public boolean testTargetInstanceOfResidue(Class<?> targetClass) {     return (this.runtimeTest != null && new TargetInstanceOfResidueTestVisitor(targetClass).targetInstanceOfMatches(this.runtimeTest)). }
false;public;1;5;;@Override public void visit(And e) {     e.getLeft().accept(this).     e.getRight().accept(this). }
false;public;1;5;;@Override public void visit(Or e) {     e.getLeft().accept(this).     e.getRight().accept(this). }
false;public;1;4;;@Override public void visit(Not e) {     e.getBody().accept(this). }
false;public;1;3;;@Override public void visit(Instanceof i) { }
false;public;1;3;;@Override public void visit(Literal literal) { }
false;public;1;3;;@Override public void visit(Call call) { }
false;public;1;3;;@Override public void visit(FieldGetCall fieldGetCall) { }
false;public;1;3;;@Override public void visit(HasAnnotation hasAnnotation) { }
false;public;1;3;;@Override public void visit(MatchingContextBasedTest matchingContextTest) { }
false;protected;1;9;;protected int getVarType(ReflectionVar v) {     try {         ReflectionUtils.makeAccessible(varTypeField).         return (Integer) varTypeField.get(v).     } catch (IllegalAccessException ex) {         throw new IllegalStateException(ex).     } }
false;public;1;4;;public boolean instanceOfMatches(Test test) {     test.accept(this).     return this.matches. }
false;public;1;31;;@Override public void visit(Instanceof i) {     int varType = getVarType((ReflectionVar) i.getVar()).     if (varType != this.matchVarType) {         return.     }     Class<?> typeClass = null.     ResolvedType type = (ResolvedType) i.getType().     if (type instanceof ReferenceType) {         ReferenceTypeDelegate delegate = ((ReferenceType) type).getDelegate().         if (delegate instanceof ReflectionBasedReferenceTypeDelegate) {             try {                 ReflectionUtils.makeAccessible(myClassField).                 typeClass = (Class<?>) myClassField.get(delegate).             } catch (IllegalAccessException ex) {                 throw new IllegalStateException(ex).             }         }     }     try {         // Don't use ResolvedType.isAssignableFrom() as it won't be aware of (Spring) mixins         if (typeClass == null) {             typeClass = ClassUtils.forName(type.getName(), this.matchClass.getClassLoader()).         }         this.matches = typeClass.isAssignableFrom(this.matchClass).     } catch (ClassNotFoundException ex) {         this.matches = false.     } }
false;public;1;3;;public boolean targetInstanceOfMatches(Test test) {     return instanceOfMatches(test). }
true;public;1;3;// TODO: Optimization: Process only if this() specifies a type and not an identifier. ;// TODO: Optimization: Process only if this() specifies a type and not an identifier. public boolean thisInstanceOfMatches(Test test) {     return instanceOfMatches(test). }
false;public;1;4;;public boolean testsSubtypeSensitiveVars(Test aTest) {     aTest.accept(this).     return this.testsSubtypeSensitiveVars. }
false;public;1;8;;@Override public void visit(Instanceof i) {     ReflectionVar v = (ReflectionVar) i.getVar().     Object varUnderTest = v.getBindingAtJoinPoint(this.thisObj, this.targetObj, this.argsObjs).     if (varUnderTest == this.thisObj || varUnderTest == this.targetObj) {         this.testsSubtypeSensitiveVars = true.     } }
false;public;1;9;;@Override public void visit(HasAnnotation hasAnn) {     // If you thought things were bad before, now we sink to new levels of horror...     ReflectionVar v = (ReflectionVar) hasAnn.getVar().     int varType = getVarType(v).     if (varType == AT_THIS_VAR || varType == AT_TARGET_VAR || varType == AT_ANNOTATION_VAR) {         this.testsSubtypeSensitiveVars = true.     } }
