commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Set a list of regex patterns, matching eligible @AspectJ bean names.  * <p>Default is to consider all @AspectJ beans as eligible.  */ ;/**  * Set a list of regex patterns, matching eligible @AspectJ bean names.  * <p>Default is to consider all @AspectJ beans as eligible.  */ public void setIncludePatterns(List<String> patterns) {     this.includePatterns = new ArrayList<>(patterns.size()).     for (String patternText : patterns) {         this.includePatterns.add(Pattern.compile(patternText)).     } }
false;public;1;4;;public void setAspectJAdvisorFactory(AspectJAdvisorFactory aspectJAdvisorFactory) {     Assert.notNull(aspectJAdvisorFactory, "AspectJAdvisorFactory must not be null").     this.aspectJAdvisorFactory = aspectJAdvisorFactory. }
false;protected;1;9;;@Override protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) {     super.initBeanFactory(beanFactory).     if (this.aspectJAdvisorFactory == null) {         this.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory).     }     this.aspectJAdvisorsBuilder = new BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory). }
false;protected;0;10;;@Override protected List<Advisor> findCandidateAdvisors() {     // Add all the Spring advisors found according to superclass rules.     List<Advisor> advisors = super.findCandidateAdvisors().     // Build Advisors for all AspectJ aspects in the bean factory.     if (this.aspectJAdvisorsBuilder != null) {         advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()).     }     return advisors. }
false;protected;1;13;;@Override protected boolean isInfrastructureClass(Class<?> beanClass) {     // not advising aspects in the future.     return (super.isInfrastructureClass(beanClass) || (this.aspectJAdvisorFactory != null && this.aspectJAdvisorFactory.isAspect(beanClass))). }
true;protected;1;13;/**  * Check whether the given aspect bean is eligible for auto-proxying.  * <p>If no &lt.aop:include&gt. elements were used then "includePatterns" will be  * {@code null} and all beans are included. If "includePatterns" is non-null,  * then one of the patterns must match.  */ ;/**  * Check whether the given aspect bean is eligible for auto-proxying.  * <p>If no &lt.aop:include&gt. elements were used then "includePatterns" will be  * {@code null} and all beans are included. If "includePatterns" is non-null,  * then one of the patterns must match.  */ protected boolean isEligibleAspectBean(String beanName) {     if (this.includePatterns == null) {         return true.     } else {         for (Pattern pattern : this.includePatterns) {             if (pattern.matcher(beanName).matches()) {                 return true.             }         }         return false.     } }
false;protected;1;4;;@Override protected boolean isEligibleBean(String beanName) {     return AnnotationAwareAspectJAutoProxyCreator.this.isEligibleAspectBean(beanName). }
