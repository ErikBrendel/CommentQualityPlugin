commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether this post-processor's advisor is supposed to apply before  * existing advisors when encountering a pre-advised object.  * <p>Default is "false", applying the advisor after existing advisors, i.e.  * as close as possible to the target method. Switch this to "true" in order  * for this post-processor's advisor to wrap existing advisors as well.  * <p>Note: Check the concrete post-processor's javadoc whether it possibly  * changes this flag by default, depending on the nature of its advisor.  */ ;/**  * Set whether this post-processor's advisor is supposed to apply before  * existing advisors when encountering a pre-advised object.  * <p>Default is "false", applying the advisor after existing advisors, i.e.  * as close as possible to the target method. Switch this to "true" in order  * for this post-processor's advisor to wrap existing advisors as well.  * <p>Note: Check the concrete post-processor's javadoc whether it possibly  * changes this flag by default, depending on the nature of its advisor.  */ public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {     this.beforeExistingAdvisors = beforeExistingAdvisors. }
false;public;2;4;;@Override public Object postProcessBeforeInitialization(Object bean, String beanName) {     return bean. }
false;public;2;34;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) {     if (this.advisor == null || bean instanceof AopInfrastructureBean) {         // Ignore AOP infrastructure such as scoped proxies.         return bean.     }     if (bean instanceof Advised) {         Advised advised = (Advised) bean.         if (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {             // Add our local Advisor to the existing proxy's Advisor chain...             if (this.beforeExistingAdvisors) {                 advised.addAdvisor(0, this.advisor).             } else {                 advised.addAdvisor(this.advisor).             }             return bean.         }     }     if (isEligible(bean, beanName)) {         ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName).         if (!proxyFactory.isProxyTargetClass()) {             evaluateProxyInterfaces(bean.getClass(), proxyFactory).         }         proxyFactory.addAdvisor(this.advisor).         customizeProxyFactory(proxyFactory).         return proxyFactory.getProxy(getProxyClassLoader()).     }     // No proxy needed.     return bean. }
true;protected;2;3;/**  * Check whether the given bean is eligible for advising with this  * post-processor's {@link Advisor}.  * <p>Delegates to {@link #isEligible(Class)} for target class checking.  * Can be overridden e.g. to specifically exclude certain beans by name.  * <p>Note: Only called for regular bean instances but not for existing  * proxy instances which implement {@link Advised} and allow for adding  * the local {@link Advisor} to the existing proxy's {@link Advisor} chain.  * For the latter, {@link #isEligible(Class)} is being called directly,  * with the actual target class behind the existing proxy (as determined  * by {@link AopUtils#getTargetClass(Object)}).  * @param bean the bean instance  * @param beanName the name of the bean  * @see #isEligible(Class)  */ ;/**  * Check whether the given bean is eligible for advising with this  * post-processor's {@link Advisor}.  * <p>Delegates to {@link #isEligible(Class)} for target class checking.  * Can be overridden e.g. to specifically exclude certain beans by name.  * <p>Note: Only called for regular bean instances but not for existing  * proxy instances which implement {@link Advised} and allow for adding  * the local {@link Advisor} to the existing proxy's {@link Advisor} chain.  * For the latter, {@link #isEligible(Class)} is being called directly,  * with the actual target class behind the existing proxy (as determined  * by {@link AopUtils#getTargetClass(Object)}).  * @param bean the bean instance  * @param beanName the name of the bean  * @see #isEligible(Class)  */ protected boolean isEligible(Object bean, String beanName) {     return isEligible(bean.getClass()). }
true;protected;1;12;/**  * Check whether the given class is eligible for advising with this  * post-processor's {@link Advisor}.  * <p>Implements caching of {@code canApply} results per bean target class.  * @param targetClass the class to check against  * @see AopUtils#canApply(Advisor, Class)  */ ;/**  * Check whether the given class is eligible for advising with this  * post-processor's {@link Advisor}.  * <p>Implements caching of {@code canApply} results per bean target class.  * @param targetClass the class to check against  * @see AopUtils#canApply(Advisor, Class)  */ protected boolean isEligible(Class<?> targetClass) {     Boolean eligible = this.eligibleBeans.get(targetClass).     if (eligible != null) {         return eligible.     }     if (this.advisor == null) {         return false.     }     eligible = AopUtils.canApply(this.advisor, targetClass).     this.eligibleBeans.put(targetClass, eligible).     return eligible. }
true;protected;2;6;/**  * Prepare a {@link ProxyFactory} for the given bean.  * <p>Subclasses may customize the handling of the target instance and in  * particular the exposure of the target class. The default introspection  * of interfaces for non-target-class proxies and the configured advisor  * will be applied afterwards. {@link #customizeProxyFactory} allows for  * late customizations of those parts right before proxy creation.  * @param bean the bean instance to create a proxy for  * @param beanName the corresponding bean name  * @return the ProxyFactory, initialized with this processor's  * {@link ProxyConfig} settings and the specified bean  * @since 4.2.3  * @see #customizeProxyFactory  */ ;/**  * Prepare a {@link ProxyFactory} for the given bean.  * <p>Subclasses may customize the handling of the target instance and in  * particular the exposure of the target class. The default introspection  * of interfaces for non-target-class proxies and the configured advisor  * will be applied afterwards. {@link #customizeProxyFactory} allows for  * late customizations of those parts right before proxy creation.  * @param bean the bean instance to create a proxy for  * @param beanName the corresponding bean name  * @return the ProxyFactory, initialized with this processor's  * {@link ProxyConfig} settings and the specified bean  * @since 4.2.3  * @see #customizeProxyFactory  */ protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {     ProxyFactory proxyFactory = new ProxyFactory().     proxyFactory.copyFrom(this).     proxyFactory.setTarget(bean).     return proxyFactory. }
true;protected;1;2;/**  * Subclasses may choose to implement this: for example,  * to change the interfaces exposed.  * <p>The default implementation is empty.  * @param proxyFactory the ProxyFactory that is already configured with  * target, advisor and interfaces and will be used to create the proxy  * immediately after this method returns  * @since 4.2.3  * @see #prepareProxyFactory  */ ;/**  * Subclasses may choose to implement this: for example,  * to change the interfaces exposed.  * <p>The default implementation is empty.  * @param proxyFactory the ProxyFactory that is already configured with  * target, advisor and interfaces and will be used to create the proxy  * immediately after this method returns  * @since 4.2.3  * @see #prepareProxyFactory  */ protected void customizeProxyFactory(ProxyFactory proxyFactory) { }
