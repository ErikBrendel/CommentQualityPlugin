# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1447077603;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1447399860;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1467730834;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1500495740;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1530174524;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1534018807;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected ProxyFactory prepareProxyFactory(Object bean, String beanName);1534021857;Prepare a {@link ProxyFactory} for the given bean._<p>Subclasses may customize the handling of the target instance and in_particular the exposure of the target class. The default introspection_of interfaces for non-target-class proxies and the configured advisor_will be applied afterwards_ {@link #customizeProxyFactory} allows for_late customizations of those parts right before proxy creation._@param bean the bean instance to create a proxy for_@param beanName the corresponding bean name_@return the ProxyFactory, initialized with this processor's_{@link ProxyConfig} settings and the specified bean_@since 4.2.3_@see #customizeProxyFactory;protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {_		ProxyFactory proxyFactory = new ProxyFactory()__		proxyFactory.copyFrom(this)__		proxyFactory.setTarget(bean)__		return proxyFactory__	};prepare,a,link,proxy,factory,for,the,given,bean,p,subclasses,may,customize,the,handling,of,the,target,instance,and,in,particular,the,exposure,of,the,target,class,the,default,introspection,of,interfaces,for,non,target,class,proxies,and,the,configured,advisor,will,be,applied,afterwards,link,customize,proxy,factory,allows,for,late,customizations,of,those,parts,right,before,proxy,creation,param,bean,the,bean,instance,to,create,a,proxy,for,param,bean,name,the,corresponding,bean,name,return,the,proxy,factory,initialized,with,this,processor,s,link,proxy,config,settings,and,the,specified,bean,since,4,2,3,see,customize,proxy,factory;protected,proxy,factory,prepare,proxy,factory,object,bean,string,bean,name,proxy,factory,proxy,factory,new,proxy,factory,proxy,factory,copy,from,this,proxy,factory,set,target,bean,return,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1398779095;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1398791249;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1447077603;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1447399860;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1467730834;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1500495740;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		if (this.advisor == null) {_			return false__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,if,this,advisor,null,return,false,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1530174524;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		if (this.advisor == null) {_			return false__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,if,this,advisor,null,return,false,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1534018807;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		if (this.advisor == null) {_			return false__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,if,this,advisor,null,return,false,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Class<?> targetClass);1534021857;Check whether the given class is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._@param targetClass the class to check against_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Class<?> targetClass) {_		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		if (this.advisor == null) {_			return false__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,class,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,param,target,class,the,class,to,check,against,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,class,target,class,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,if,this,advisor,null,return,false,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1363208506;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1368482696;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1385412762;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1398779095;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1398791249;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1447077603;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1447399860;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1467730834;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1500495740;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1530174524;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1534018807;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors);1534021857;Set whether this post-processor's advisor is supposed to apply before_existing advisors when encountering a pre-advised object._<p>Default is "false", applying the advisor after existing advisors, i.e._as close as possible to the target method. Switch this to "true" in order_for this post-processor's advisor to wrap existing advisors as well._<p>Note: Check the concrete post-processor's javadoc whether it possibly_changes this flag by default, depending on the nature of its advisor.;public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {_		this.beforeExistingAdvisors = beforeExistingAdvisors__	};set,whether,this,post,processor,s,advisor,is,supposed,to,apply,before,existing,advisors,when,encountering,a,pre,advised,object,p,default,is,false,applying,the,advisor,after,existing,advisors,i,e,as,close,as,possible,to,the,target,method,switch,this,to,true,in,order,for,this,post,processor,s,advisor,to,wrap,existing,advisors,as,well,p,note,check,the,concrete,post,processor,s,javadoc,whether,it,possibly,changes,this,flag,by,default,depending,on,the,nature,of,its,advisor;public,void,set,before,existing,advisors,boolean,before,existing,advisors,this,before,existing,advisors,before,existing,advisors
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1352413278;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of <code>canApply</code> results per bean name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Boolean eligible = this.eligibleBeans.get(beanName)__		if (eligible != null) {_			return eligible__		}_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(beanName, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,code,results,per,bean,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,boolean,eligible,this,eligible,beans,get,bean,name,if,eligible,null,return,eligible,class,target,class,aop,utils,get,target,class,bean,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,bean,name,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1355352386;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of <code>canApply</code> results per bean name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Boolean eligible = this.eligibleBeans.get(beanName)__		if (eligible != null) {_			return eligible__		}_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(beanName, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,code,results,per,bean,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,boolean,eligible,this,eligible,beans,get,bean,name,if,eligible,null,return,eligible,class,target,class,aop,utils,get,target,class,bean,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,bean,name,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1356735495;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Boolean eligible = this.eligibleBeans.get(beanName)__		if (eligible != null) {_			return eligible__		}_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(beanName, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,boolean,eligible,this,eligible,beans,get,bean,name,if,eligible,null,return,eligible,class,target,class,aop,utils,get,target,class,bean,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,bean,name,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1357119239;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Boolean eligible = this.eligibleBeans.get(beanName)__		if (eligible != null) {_			return eligible__		}_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(beanName, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,boolean,eligible,this,eligible,beans,get,bean,name,if,eligible,null,return,eligible,class,target,class,aop,utils,get,target,class,bean,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,bean,name,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1362408075;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._Can be overridden e.g. to specifically exclude certain beans by name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#getTargetClass(Object)_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,get,target,class,object,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,class,target,class,aop,utils,get,target,class,bean,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1363208506;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._Can be overridden e.g. to specifically exclude certain beans by name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#getTargetClass(Object)_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,get,target,class,object,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,class,target,class,aop,utils,get,target,class,bean,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1368482696;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._Can be overridden e.g. to specifically exclude certain beans by name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#getTargetClass(Object)_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,get,target,class,object,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,class,target,class,aop,utils,get,target,class,bean,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1385412762;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Implements caching of {@code canApply} results per bean target class._Can be overridden e.g. to specifically exclude certain beans by name._@param bean the bean instance_@param beanName the name of the bean_@see AopUtils#getTargetClass(Object)_@see AopUtils#canApply(Advisor, Class);protected boolean isEligible(Object bean, String beanName) {_		Class<?> targetClass = AopUtils.getTargetClass(bean)__		Boolean eligible = this.eligibleBeans.get(targetClass)__		if (eligible != null) {_			return eligible__		}_		eligible = AopUtils.canApply(this.advisor, targetClass)__		this.eligibleBeans.put(targetClass, eligible)__		return eligible__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,implements,caching,of,code,can,apply,results,per,bean,target,class,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,aop,utils,get,target,class,object,see,aop,utils,can,apply,advisor,class;protected,boolean,is,eligible,object,bean,string,bean,name,class,target,class,aop,utils,get,target,class,bean,boolean,eligible,this,eligible,beans,get,target,class,if,eligible,null,return,eligible,eligible,aop,utils,can,apply,this,advisor,target,class,this,eligible,beans,put,target,class,eligible,return,eligible
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1398779095;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1398791249;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1447077603;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1447399860;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1467730834;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1500495740;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1530174524;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1534018807;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected boolean isEligible(Object bean, String beanName);1534021857;Check whether the given bean is eligible for advising with this_post-processor's {@link Advisor}._<p>Delegates to {@link #isEligible(Class)} for target class checking._Can be overridden e.g. to specifically exclude certain beans by name._<p>Note: Only called for regular bean instances but not for existing_proxy instances which implement {@link Advised} and allow for adding_the local {@link Advisor} to the existing proxy's {@link Advisor} chain._For the latter, {@link #isEligible(Class)} is being called directly,_with the actual target class behind the existing proxy (as determined_by {@link AopUtils#getTargetClass(Object)})._@param bean the bean instance_@param beanName the name of the bean_@see #isEligible(Class);protected boolean isEligible(Object bean, String beanName) {_		return isEligible(bean.getClass())__	};check,whether,the,given,bean,is,eligible,for,advising,with,this,post,processor,s,link,advisor,p,delegates,to,link,is,eligible,class,for,target,class,checking,can,be,overridden,e,g,to,specifically,exclude,certain,beans,by,name,p,note,only,called,for,regular,bean,instances,but,not,for,existing,proxy,instances,which,implement,link,advised,and,allow,for,adding,the,local,link,advisor,to,the,existing,proxy,s,link,advisor,chain,for,the,latter,link,is,eligible,class,is,being,called,directly,with,the,actual,target,class,behind,the,existing,proxy,as,determined,by,link,aop,utils,get,target,class,object,param,bean,the,bean,instance,param,bean,name,the,name,of,the,bean,see,is,eligible,class;protected,boolean,is,eligible,object,bean,string,bean,name,return,is,eligible,bean,get,class
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1447077603;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1447399860;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1467730834;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1500495740;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1530174524;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory the ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,the,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1534018807;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory the ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,the,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
AbstractAdvisingBeanPostProcessor -> protected void customizeProxyFactory(ProxyFactory proxyFactory);1534021857;Subclasses may choose to implement this: for example,_to change the interfaces exposed._<p>The default implementation is empty._@param proxyFactory the ProxyFactory that is already configured with_target, advisor and interfaces and will be used to create the proxy_immediately after this method returns_@since 4.2.3_@see #prepareProxyFactory;protected void customizeProxyFactory(ProxyFactory proxyFactory) {_	};subclasses,may,choose,to,implement,this,for,example,to,change,the,interfaces,exposed,p,the,default,implementation,is,empty,param,proxy,factory,the,proxy,factory,that,is,already,configured,with,target,advisor,and,interfaces,and,will,be,used,to,create,the,proxy,immediately,after,this,method,returns,since,4,2,3,see,prepare,proxy,factory;protected,void,customize,proxy,factory,proxy,factory,proxy,factory
