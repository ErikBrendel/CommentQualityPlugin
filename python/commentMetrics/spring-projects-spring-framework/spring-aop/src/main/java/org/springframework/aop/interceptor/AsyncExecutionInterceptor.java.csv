# id;timestamp;commentText;codeText;commentWords;codeWords
AsyncExecutionInterceptor -> @Override 	@Nullable 	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory);1502974979;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	@Nullable_	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,nullable,protected,executor,get,default,executor,nullable,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
AsyncExecutionInterceptor -> @Override 	@Nullable 	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory);1531589372;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	@Nullable_	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,nullable,protected,executor,get,default,executor,nullable,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1337516454;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1340831065;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1356735495;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1357119239;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1362408075;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1368482696;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor executor);1374672618;Create a new {@code AsyncExecutionInterceptor}._@param executor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to.;public AsyncExecutionInterceptor(Executor executor) {_		super(executor)__	};create,a,new,code,async,execution,interceptor,param,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to;public,async,execution,interceptor,executor,executor,super,executor
AsyncExecutionInterceptor -> public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler);1396443880;Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions_thrown by invoking asynchronous methods with a {@code void} return type.;public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {_		this.exceptionHandler = exceptionHandler__	};supply,the,link,async,uncaught,exception,handler,to,use,to,handle,exceptions,thrown,by,invoking,asynchronous,methods,with,a,code,void,return,type;public,void,set,exception,handler,async,uncaught,exception,handler,exception,handler,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler);1400157546;Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions_thrown by invoking asynchronous methods with a {@code void} return type.;public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {_		this.exceptionHandler = exceptionHandler__	};supply,the,link,async,uncaught,exception,handler,to,use,to,handle,exceptions,thrown,by,invoking,asynchronous,methods,with,a,code,void,return,type;public,void,set,exception,handler,async,uncaught,exception,handler,exception,handler,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler);1400166433;Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions_thrown by invoking asynchronous methods with a {@code void} return type.;public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {_		this.exceptionHandler = exceptionHandler__	};supply,the,link,async,uncaught,exception,handler,to,use,to,handle,exceptions,thrown,by,invoking,asynchronous,methods,with,a,code,void,return,type;public,void,set,exception,handler,async,uncaught,exception,handler,exception,handler,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler);1403788757;Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions_thrown by invoking asynchronous methods with a {@code void} return type.;public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {_		this.exceptionHandler = exceptionHandler__	};supply,the,link,async,uncaught,exception,handler,to,use,to,handle,exceptions,thrown,by,invoking,asynchronous,methods,with,a,code,void,return,type;public,void,set,exception,handler,async,uncaught,exception,handler,exception,handler,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(AsyncTaskExecutor asyncExecutor);1328020251;Create a new AsyncExecutionInterceptor._@param asyncExecutor the Spring AsyncTaskExecutor to delegate to;public AsyncExecutionInterceptor(AsyncTaskExecutor asyncExecutor) {_		Assert.notNull(asyncExecutor, "TaskExecutor must not be null")__		this.asyncExecutor = asyncExecutor__	};create,a,new,async,execution,interceptor,param,async,executor,the,spring,async,task,executor,to,delegate,to;public,async,execution,interceptor,async,task,executor,async,executor,assert,not,null,async,executor,task,executor,must,not,be,null,this,async,executor,async,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(AsyncTaskExecutor asyncExecutor);1335774711;Create a new AsyncExecutionInterceptor._@param asyncExecutor the Spring AsyncTaskExecutor to delegate to;public AsyncExecutionInterceptor(AsyncTaskExecutor asyncExecutor) {_		Assert.notNull(asyncExecutor, "TaskExecutor must not be null")__		this.asyncExecutor = asyncExecutor__	};create,a,new,async,execution,interceptor,param,async,executor,the,spring,async,task,executor,to,delegate,to;public,async,execution,interceptor,async,task,executor,async,executor,assert,not,null,async,executor,task,executor,must,not,be,null,this,async,executor,async,executor
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1356735495;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(_				new Callable<Object>() {_					@Override_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})__		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,future,result,this,determine,async,executor,invocation,get,method,submit,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1368482696;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		Future<?> result = determineAsyncExecutor(specificMethod).submit(_				new Callable<Object>() {_					@Override_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})___		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,specific,method,bridge,method,resolver,find,bridged,method,specific,method,future,result,determine,async,executor,specific,method,submit,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1374672618;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(specificMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Future<?> result = executor.submit(_				new Callable<Object>() {_					@Override_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})___		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,specific,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,specific,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,future,result,executor,submit,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1396443880;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method tmp = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method specificMethod = BridgeMethodResolver.findBridgedMethod(tmp)___		AsyncTaskExecutor executor = determineAsyncExecutor(specificMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Future<?> result = executor.submit(_				new Callable<Object>() {_					@Override_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							handleError(ex, specificMethod, invocation.getArguments())__						}_						return null__					}_				})___		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,tmp,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,specific,method,bridge,method,resolver,find,bridged,method,tmp,async,task,executor,executor,determine,async,executor,specific,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,future,result,executor,submit,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,handle,error,ex,specific,method,invocation,get,arguments,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1400157546;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method tmp = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method specificMethod = BridgeMethodResolver.findBridgedMethod(tmp)___		AsyncTaskExecutor executor = determineAsyncExecutor(specificMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Future<?> result = executor.submit(_				new Callable<Object>() {_					@Override_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							handleError(ex, specificMethod, invocation.getArguments())__						}_						return null__					}_				})___		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,tmp,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,specific,method,bridge,method,resolver,find,bridged,method,tmp,async,task,executor,executor,determine,async,executor,specific,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,future,result,executor,submit,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,handle,error,ex,specific,method,invocation,get,arguments,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1400166433;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Future<?> result = executor.submit(_				new Callable<Object>() {_					@Override_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							handleError(ex, userDeclaredMethod, invocation.getArguments())__						}_						return null__					}_				})___		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,future,result,executor,submit,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1403788757;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		Class<?> returnType = invocation.getMethod().getReturnType()__		if (ListenableFuture.class.isAssignableFrom(returnType)) {_			return ((AsyncListenableTaskExecutor) executor).submitListenable(task)__		}_		else if (Future.class.isAssignableFrom(returnType)) {_			return executor.submit(task)__		}_		else {_			executor.submit(task)__			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,class,return,type,invocation,get,method,get,return,type,if,listenable,future,class,is,assignable,from,return,type,return,async,listenable,task,executor,executor,submit,listenable,task,else,if,future,class,is,assignable,from,return,type,return,executor,submit,task,else,executor,submit,task,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1408351881;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		Class<?> returnType = invocation.getMethod().getReturnType()__		if (ListenableFuture.class.isAssignableFrom(returnType)) {_			return ((AsyncListenableTaskExecutor) executor).submitListenable(task)__		}_		else if (Future.class.isAssignableFrom(returnType)) {_			return executor.submit(task)__		}_		else {_			executor.submit(task)__			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,class,return,type,invocation,get,method,get,return,type,if,listenable,future,class,is,assignable,from,return,type,return,async,listenable,task,executor,executor,submit,listenable,task,else,if,future,class,is,assignable,from,return,type,return,executor,submit,task,else,executor,submit,task,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1433453118;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (ExecutionException ex) {_					handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		Class<?> returnType = invocation.getMethod().getReturnType()__		if (ListenableFuture.class.isAssignableFrom(returnType)) {_			return ((AsyncListenableTaskExecutor) executor).submitListenable(task)__		}_		else if (Future.class.isAssignableFrom(returnType)) {_			return executor.submit(task)__		}_		else {_			executor.submit(task)__			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,class,return,type,invocation,get,method,get,return,type,if,listenable,future,class,is,assignable,from,return,type,return,async,listenable,task,executor,executor,submit,listenable,task,else,if,future,class,is,assignable,from,return,type,return,executor,submit,task,else,executor,submit,task,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1434393348;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (ExecutionException ex) {_					handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		Class<?> returnType = invocation.getMethod().getReturnType()__		if (completableFuturePresent) {_			Future<Object> result = CompletableFutureDelegate.processCompletableFuture(returnType, task, executor)__			if (result != null) {_				return result__			}_		}_		if (ListenableFuture.class.isAssignableFrom(returnType)) {_			return ((AsyncListenableTaskExecutor) executor).submitListenable(task)__		}_		else if (Future.class.isAssignableFrom(returnType)) {_			return executor.submit(task)__		}_		else {_			executor.submit(task)__			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,class,return,type,invocation,get,method,get,return,type,if,completable,future,present,future,object,result,completable,future,delegate,process,completable,future,return,type,task,executor,if,result,null,return,result,if,listenable,future,class,is,assignable,from,return,type,return,async,listenable,task,executor,executor,submit,listenable,task,else,if,future,class,is,assignable,from,return,type,return,executor,submit,task,else,executor,submit,task,return,null
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1434925784;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (ExecutionException ex) {_					handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1457735038;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (ExecutionException ex) {_					handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1496837955;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = new Callable<Object>() {_			@Override_			public Object call() throws Exception {_				try {_					Object result = invocation.proceed()__					if (result instanceof Future) {_						return ((Future<?>) result).get()__					}_				}_				catch (ExecutionException ex) {_					handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__				}_				catch (Throwable ex) {_					handleError(ex, userDeclaredMethod, invocation.getArguments())__				}_				return null__			}_		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,new,callable,object,override,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1497341397;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = () -> {_			try {_				Object result = invocation.proceed()__				if (result instanceof Future) {_					return ((Future<?>) result).get()__				}_			}_			catch (ExecutionException ex) {_				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__			}_			catch (Throwable ex) {_				handleError(ex, userDeclaredMethod, invocation.getArguments())__			}_			return null__		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	public Object invoke(final MethodInvocation invocation) throws Throwable;1498517017;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = () -> {_			try {_				Object result = invocation.proceed()__				if (result instanceof Future) {_					return ((Future<?>) result).get()__				}_			}_			catch (ExecutionException ex) {_				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__			}_			catch (Throwable ex) {_				handleError(ex, userDeclaredMethod, invocation.getArguments())__			}_			return null__		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor);1496837955;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,nullable,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor);1497341397;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,nullable,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor);1498517017;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,nullable,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor);1500416137;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,nullable,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor);1502974979;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,nullable,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor);1531589372;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,nullable,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> @Override 	@Nullable 	public Object invoke(final MethodInvocation invocation) throws Throwable;1500416137;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	@Nullable_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = () -> {_			try {_				Object result = invocation.proceed()__				if (result instanceof Future) {_					return ((Future<?>) result).get()__				}_			}_			catch (ExecutionException ex) {_				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__			}_			catch (Throwable ex) {_				handleError(ex, userDeclaredMethod, invocation.getArguments())__			}_			return null__		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,nullable,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	@Nullable 	public Object invoke(final MethodInvocation invocation) throws Throwable;1502974979;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	@Nullable_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = () -> {_			try {_				Object result = invocation.proceed()__				if (result instanceof Future) {_					return ((Future<?>) result).get()__				}_			}_			catch (ExecutionException ex) {_				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__			}_			catch (Throwable ex) {_				handleError(ex, userDeclaredMethod, invocation.getArguments())__			}_			return null__		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,nullable,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	@Nullable 	public Object invoke(final MethodInvocation invocation) throws Throwable;1531589372;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;@Override_	@Nullable_	public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod)__		if (executor == null) {_			throw new IllegalStateException(_					"No executor specified and no default executor set on AsyncExecutionInterceptor either")__		}__		Callable<Object> task = () -> {_			try {_				Object result = invocation.proceed()__				if (result instanceof Future) {_					return ((Future<?>) result).get()__				}_			}_			catch (ExecutionException ex) {_				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments())__			}_			catch (Throwable ex) {_				handleError(ex, userDeclaredMethod, invocation.getArguments())__			}_			return null__		}___		return doSubmit(task, executor, invocation.getMethod().getReturnType())__	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;override,nullable,public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,final,method,user,declared,method,bridge,method,resolver,find,bridged,method,specific,method,async,task,executor,executor,determine,async,executor,user,declared,method,if,executor,null,throw,new,illegal,state,exception,no,executor,specified,and,no,default,executor,set,on,async,execution,interceptor,either,callable,object,task,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,execution,exception,ex,handle,error,ex,get,cause,user,declared,method,invocation,get,arguments,catch,throwable,ex,handle,error,ex,user,declared,method,invocation,get,arguments,return,null,return,do,submit,task,executor,invocation,get,method,get,return,type
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1337516454;{@inheritDoc}_<p>This implementation is a no-op for compatibility in Spring 3.2. Subclasses may_override to provide support for extracting qualifier information, e.g. via an_annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};inherit,doc,p,this,implementation,is,a,no,op,for,compatibility,in,spring,3,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1340831065;{@inheritDoc}_<p>This implementation is a no-op for compatibility in Spring 3.1.2. Subclasses may_override to provide support for extracting qualifier information, e.g. via an_annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};inherit,doc,p,this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1356735495;{@inheritDoc}_<p>This implementation is a no-op for compatibility in Spring 3.1.2. Subclasses may_override to provide support for extracting qualifier information, e.g. via an_annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};inherit,doc,p,this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1357119239;{@inheritDoc}_<p>This implementation is a no-op for compatibility in Spring 3.1.2. Subclasses may_override to provide support for extracting qualifier information, e.g. via an_annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};inherit,doc,p,this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1362408075;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1368482696;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1374672618;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1396443880;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@see #determineAsyncExecutor(Method)_@since 3.1.2;@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,see,determine,async,executor,method,since,3,1,2;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1400157546;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1400166433;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1403788757;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1408351881;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1433453118;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1434393348;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1434925784;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1457735038;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1496837955;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1497341397;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1498517017;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	protected String getExecutorQualifier(Method method);1500416137;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1396443880;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		this(defaultExecutor, new SimpleAsyncUncaughtExceptionHandler())__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,this,default,executor,new,simple,async,uncaught,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1400157546;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		this(defaultExecutor, new SimpleAsyncUncaughtExceptionHandler())__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,this,default,executor,new,simple,async,uncaught,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1400166433;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		this(defaultExecutor, new SimpleAsyncUncaughtExceptionHandler())__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,this,default,executor,new,simple,async,uncaught,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1403788757;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		this(defaultExecutor, new SimpleAsyncUncaughtExceptionHandler())__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,this,default,executor,new,simple,async,uncaught,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1408351881;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1433453118;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1434393348;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1434925784;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler;public,async,execution,interceptor,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor);1457735038;Create a new instance with a default {@link AsyncUncaughtExceptionHandler}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise;public AsyncExecutionInterceptor(Executor defaultExecutor) {_		super(defaultExecutor)__	};create,a,new,instance,with,a,default,link,async,uncaught,exception,handler,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise;public,async,execution,interceptor,executor,default,executor,super,default,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1396443880;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to._@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor)__		this.exceptionHandler = exceptionHandler__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1400157546;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to._@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor)__		this.exceptionHandler = exceptionHandler__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1400166433;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor)__		this.exceptionHandler = exceptionHandler__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1403788757;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor)__		this.exceptionHandler = exceptionHandler__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,this,exception,handler,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1408351881;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1433453118;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1434393348;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1434925784;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1457735038;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor asyncExecutor);1328020251;Create a new AsyncExecutionInterceptor._@param asyncExecutor the <code>java.util.concurrent</code> Executor_to delegate to (typically a {@link java.util.concurrent.ExecutorService};public AsyncExecutionInterceptor(Executor asyncExecutor) {_		this.asyncExecutor = new TaskExecutorAdapter(asyncExecutor)__	};create,a,new,async,execution,interceptor,param,async,executor,the,code,java,util,concurrent,code,executor,to,delegate,to,typically,a,link,java,util,concurrent,executor,service;public,async,execution,interceptor,executor,async,executor,this,async,executor,new,task,executor,adapter,async,executor
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(Executor asyncExecutor);1335774711;Create a new AsyncExecutionInterceptor._@param asyncExecutor the <code>java.util.concurrent</code> Executor_to delegate to (typically a {@link java.util.concurrent.ExecutorService};public AsyncExecutionInterceptor(Executor asyncExecutor) {_		this.asyncExecutor = new TaskExecutorAdapter(asyncExecutor)__	};create,a,new,async,execution,interceptor,param,async,executor,the,code,java,util,concurrent,code,executor,to,delegate,to,typically,a,link,java,util,concurrent,executor,service;public,async,execution,interceptor,executor,async,executor,this,async,executor,new,task,executor,adapter,async,executor
AsyncExecutionInterceptor -> @Override 	protected Executor getDefaultExecutor(BeanFactory beanFactory);1457735038;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	protected Executor getDefaultExecutor(BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,protected,executor,get,default,executor,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
AsyncExecutionInterceptor -> @Override 	protected Executor getDefaultExecutor(BeanFactory beanFactory);1496837955;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	protected Executor getDefaultExecutor(BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,protected,executor,get,default,executor,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
AsyncExecutionInterceptor -> @Override 	protected Executor getDefaultExecutor(BeanFactory beanFactory);1497341397;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	protected Executor getDefaultExecutor(BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,protected,executor,get,default,executor,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
AsyncExecutionInterceptor -> public Object invoke(final MethodInvocation invocation) throws Throwable;1337516454;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;public Object invoke(final MethodInvocation invocation) throws Throwable {_		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(_				new Callable<Object>() {_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})__		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;public,object,invoke,final,method,invocation,invocation,throws,throwable,future,result,this,determine,async,executor,invocation,get,method,submit,new,callable,object,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> public Object invoke(final MethodInvocation invocation) throws Throwable;1340831065;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;public Object invoke(final MethodInvocation invocation) throws Throwable {_		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(_				new Callable<Object>() {_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})__		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;public,object,invoke,final,method,invocation,invocation,throws,throwable,future,result,this,determine,async,executor,invocation,get,method,submit,new,callable,object,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> public Object invoke(final MethodInvocation invocation) throws Throwable;1357119239;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;public Object invoke(final MethodInvocation invocation) throws Throwable {_		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(_				new Callable<Object>() {_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})__		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;public,object,invoke,final,method,invocation,invocation,throws,throwable,future,result,this,determine,async,executor,invocation,get,method,submit,new,callable,object,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> public Object invoke(final MethodInvocation invocation) throws Throwable;1362408075;Intercept the given method invocation, submit the actual calling of the method to_the correct task executor and return immediately to the caller._@param invocation the method to intercept and make asynchronous_@return {@link Future} if the original method returns {@code Future}_ {@code null}_otherwise.;public Object invoke(final MethodInvocation invocation) throws Throwable {_		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null)__		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass)__		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)___		Future<?> result = determineAsyncExecutor(specificMethod).submit(_				new Callable<Object>() {_					public Object call() throws Exception {_						try {_							Object result = invocation.proceed()__							if (result instanceof Future) {_								return ((Future<?>) result).get()__							}_						}_						catch (Throwable ex) {_							ReflectionUtils.rethrowException(ex)__						}_						return null__					}_				})___		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {_			return result__		}_		else {_			return null__		}_	};intercept,the,given,method,invocation,submit,the,actual,calling,of,the,method,to,the,correct,task,executor,and,return,immediately,to,the,caller,param,invocation,the,method,to,intercept,and,make,asynchronous,return,link,future,if,the,original,method,returns,code,future,code,null,otherwise;public,object,invoke,final,method,invocation,invocation,throws,throwable,class,target,class,invocation,get,this,null,aop,utils,get,target,class,invocation,get,this,null,method,specific,method,class,utils,get,most,specific,method,invocation,get,method,target,class,specific,method,bridge,method,resolver,find,bridged,method,specific,method,future,result,determine,async,executor,specific,method,submit,new,callable,object,public,object,call,throws,exception,try,object,result,invocation,proceed,if,result,instanceof,future,return,future,result,get,catch,throwable,ex,reflection,utils,rethrow,exception,ex,return,null,if,future,class,is,assignable,from,invocation,get,method,get,return,type,return,result,else,return,null
AsyncExecutionInterceptor -> protected void handleError(Throwable ex, Method method, Object... params) throws Exception;1396443880;Handles a fatal error thrown while asynchronously invoking the specified_{@link Method}._<p>If the return type of the method is a {@link Future} object, the original_exception can be propagated by just throwing it at the higher level. However,_for all other cases, the exception will not be transmitted back to the client._In that later case, the current {@link AsyncUncaughtExceptionHandler} will be_used to manage such exception.__@param ex the exception to handle_@param method the method that was invoked_@param params the parameters used to invoke the method;protected void handleError(Throwable ex, Method method, Object... params) throws Exception {_		if (method.getReturnType().isAssignableFrom(Future.class)) {_			ReflectionUtils.rethrowException(ex)__		}_		else { _			try {_				exceptionHandler.handleUncaughtException(ex, method, params)__			}_			catch (Exception e) {_				logger.error("exception handler has thrown an unexpected " +_						"exception while invoking '" + method.toGenericString() + "'", e)__			}_		}_	};handles,a,fatal,error,thrown,while,asynchronously,invoking,the,specified,link,method,p,if,the,return,type,of,the,method,is,a,link,future,object,the,original,exception,can,be,propagated,by,just,throwing,it,at,the,higher,level,however,for,all,other,cases,the,exception,will,not,be,transmitted,back,to,the,client,in,that,later,case,the,current,link,async,uncaught,exception,handler,will,be,used,to,manage,such,exception,param,ex,the,exception,to,handle,param,method,the,method,that,was,invoked,param,params,the,parameters,used,to,invoke,the,method;protected,void,handle,error,throwable,ex,method,method,object,params,throws,exception,if,method,get,return,type,is,assignable,from,future,class,reflection,utils,rethrow,exception,ex,else,try,exception,handler,handle,uncaught,exception,ex,method,params,catch,exception,e,logger,error,exception,handler,has,thrown,an,unexpected,exception,while,invoking,method,to,generic,string,e
AsyncExecutionInterceptor -> protected void handleError(Throwable ex, Method method, Object... params) throws Exception;1400157546;Handles a fatal error thrown while asynchronously invoking the specified_{@link Method}._<p>If the return type of the method is a {@link Future} object, the original_exception can be propagated by just throwing it at the higher level. However,_for all other cases, the exception will not be transmitted back to the client._In that later case, the current {@link AsyncUncaughtExceptionHandler} will be_used to manage such exception._@param ex the exception to handle_@param method the method that was invoked_@param params the parameters used to invoke the method;protected void handleError(Throwable ex, Method method, Object... params) throws Exception {_		if (method.getReturnType().isAssignableFrom(Future.class)) {_			ReflectionUtils.rethrowException(ex)__		}_		else {_			_			try {_				this.exceptionHandler.handleUncaughtException(ex, method, params)__			}_			catch (Throwable ex2) {_				logger.error("Exception handler for async method '" + method.toGenericString() +_						"' threw unexpected exception itself", ex2)__			}_		}_	};handles,a,fatal,error,thrown,while,asynchronously,invoking,the,specified,link,method,p,if,the,return,type,of,the,method,is,a,link,future,object,the,original,exception,can,be,propagated,by,just,throwing,it,at,the,higher,level,however,for,all,other,cases,the,exception,will,not,be,transmitted,back,to,the,client,in,that,later,case,the,current,link,async,uncaught,exception,handler,will,be,used,to,manage,such,exception,param,ex,the,exception,to,handle,param,method,the,method,that,was,invoked,param,params,the,parameters,used,to,invoke,the,method;protected,void,handle,error,throwable,ex,method,method,object,params,throws,exception,if,method,get,return,type,is,assignable,from,future,class,reflection,utils,rethrow,exception,ex,else,try,this,exception,handler,handle,uncaught,exception,ex,method,params,catch,throwable,ex2,logger,error,exception,handler,for,async,method,method,to,generic,string,threw,unexpected,exception,itself,ex2
AsyncExecutionInterceptor -> protected void handleError(Throwable ex, Method method, Object... params) throws Exception;1400166433;Handles a fatal error thrown while asynchronously invoking the specified_{@link Method}._<p>If the return type of the method is a {@link Future} object, the original_exception can be propagated by just throwing it at the higher level. However,_for all other cases, the exception will not be transmitted back to the client._In that later case, the current {@link AsyncUncaughtExceptionHandler} will be_used to manage such exception._@param ex the exception to handle_@param method the method that was invoked_@param params the parameters used to invoke the method;protected void handleError(Throwable ex, Method method, Object... params) throws Exception {_		if (method.getReturnType().isAssignableFrom(Future.class)) {_			ReflectionUtils.rethrowException(ex)__		}_		else {_			_			try {_				this.exceptionHandler.handleUncaughtException(ex, method, params)__			}_			catch (Throwable ex2) {_				logger.error("Exception handler for async method '" + method.toGenericString() +_						"' threw unexpected exception itself", ex2)__			}_		}_	};handles,a,fatal,error,thrown,while,asynchronously,invoking,the,specified,link,method,p,if,the,return,type,of,the,method,is,a,link,future,object,the,original,exception,can,be,propagated,by,just,throwing,it,at,the,higher,level,however,for,all,other,cases,the,exception,will,not,be,transmitted,back,to,the,client,in,that,later,case,the,current,link,async,uncaught,exception,handler,will,be,used,to,manage,such,exception,param,ex,the,exception,to,handle,param,method,the,method,that,was,invoked,param,params,the,parameters,used,to,invoke,the,method;protected,void,handle,error,throwable,ex,method,method,object,params,throws,exception,if,method,get,return,type,is,assignable,from,future,class,reflection,utils,rethrow,exception,ex,else,try,this,exception,handler,handle,uncaught,exception,ex,method,params,catch,throwable,ex2,logger,error,exception,handler,for,async,method,method,to,generic,string,threw,unexpected,exception,itself,ex2
AsyncExecutionInterceptor -> protected void handleError(Throwable ex, Method method, Object... params) throws Exception;1403788757;Handles a fatal error thrown while asynchronously invoking the specified_{@link Method}._<p>If the return type of the method is a {@link Future} object, the original_exception can be propagated by just throwing it at the higher level. However,_for all other cases, the exception will not be transmitted back to the client._In that later case, the current {@link AsyncUncaughtExceptionHandler} will be_used to manage such exception._@param ex the exception to handle_@param method the method that was invoked_@param params the parameters used to invoke the method;protected void handleError(Throwable ex, Method method, Object... params) throws Exception {_		if (method.getReturnType().isAssignableFrom(Future.class)) {_			ReflectionUtils.rethrowException(ex)__		}_		else {_			_			try {_				this.exceptionHandler.handleUncaughtException(ex, method, params)__			}_			catch (Throwable ex2) {_				logger.error("Exception handler for async method '" + method.toGenericString() +_						"' threw unexpected exception itself", ex2)__			}_		}_	};handles,a,fatal,error,thrown,while,asynchronously,invoking,the,specified,link,method,p,if,the,return,type,of,the,method,is,a,link,future,object,the,original,exception,can,be,propagated,by,just,throwing,it,at,the,higher,level,however,for,all,other,cases,the,exception,will,not,be,transmitted,back,to,the,client,in,that,later,case,the,current,link,async,uncaught,exception,handler,will,be,used,to,manage,such,exception,param,ex,the,exception,to,handle,param,method,the,method,that,was,invoked,param,params,the,parameters,used,to,invoke,the,method;protected,void,handle,error,throwable,ex,method,method,object,params,throws,exception,if,method,get,return,type,is,assignable,from,future,class,reflection,utils,rethrow,exception,ex,else,try,this,exception,handler,handle,uncaught,exception,ex,method,params,catch,throwable,ex2,logger,error,exception,handler,for,async,method,method,to,generic,string,threw,unexpected,exception,itself,ex2
AsyncExecutionInterceptor -> @Override 	@Nullable 	protected String getExecutorQualifier(Method method);1502974979;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	@Nullable_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,nullable,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> @Override 	@Nullable 	protected String getExecutorQualifier(Method method);1531589372;This implementation is a no-op for compatibility in Spring 3.1.2._Subclasses may override to provide support for extracting qualifier information,_e.g. via an annotation on the given method._@return always {@code null}_@since 3.1.2_@see #determineAsyncExecutor(Method);@Override_	@Nullable_	protected String getExecutorQualifier(Method method) {_		return null__	};this,implementation,is,a,no,op,for,compatibility,in,spring,3,1,2,subclasses,may,override,to,provide,support,for,extracting,qualifier,information,e,g,via,an,annotation,on,the,given,method,return,always,code,null,since,3,1,2,see,determine,async,executor,method;override,nullable,protected,string,get,executor,qualifier,method,method,return,null
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1496837955;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,nullable,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1497341397;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,nullable,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1498517017;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,nullable,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1500416137;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,nullable,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1502974979;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,nullable,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler);1531589372;Create a new {@code AsyncExecutionInterceptor}._@param defaultExecutor the {@link Executor} (typically a Spring {@link AsyncTaskExecutor}_or {@link java.util.concurrent.ExecutorService}) to delegate to__as of 4.2.6, a local executor for this interceptor will be built otherwise_@param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use;public AsyncExecutionInterceptor(@Nullable Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler) {_		super(defaultExecutor, exceptionHandler)__	};create,a,new,code,async,execution,interceptor,param,default,executor,the,link,executor,typically,a,spring,link,async,task,executor,or,link,java,util,concurrent,executor,service,to,delegate,to,as,of,4,2,6,a,local,executor,for,this,interceptor,will,be,built,otherwise,param,exception,handler,the,link,async,uncaught,exception,handler,to,use;public,async,execution,interceptor,nullable,executor,default,executor,async,uncaught,exception,handler,exception,handler,super,default,executor,exception,handler
AsyncExecutionInterceptor -> @Override 	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory);1498517017;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,protected,executor,get,default,executor,nullable,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
AsyncExecutionInterceptor -> @Override 	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory);1500416137;This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}_bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise._If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),_this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instance_for local use if no default could be found._@see #DEFAULT_TASK_EXECUTOR_BEAN_NAME;@Override_	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {_		Executor defaultExecutor = super.getDefaultExecutor(beanFactory)__		return (defaultExecutor != null ? defaultExecutor : new SimpleAsyncTaskExecutor())__	};this,implementation,searches,for,a,unique,link,org,springframework,core,task,task,executor,bean,in,the,context,or,for,an,link,executor,bean,named,task,executor,otherwise,if,neither,of,the,two,is,resolvable,e,g,if,no,code,bean,factory,was,configured,at,all,this,implementation,falls,back,to,a,newly,created,link,simple,async,task,executor,instance,for,local,use,if,no,default,could,be,found,see;override,protected,executor,get,default,executor,nullable,bean,factory,bean,factory,executor,default,executor,super,get,default,executor,bean,factory,return,default,executor,null,default,executor,new,simple,async,task,executor
