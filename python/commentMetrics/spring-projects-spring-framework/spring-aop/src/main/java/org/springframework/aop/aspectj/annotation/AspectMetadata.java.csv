# id;timestamp;commentText;codeText;commentWords;codeWords
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1328020251;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType ajType = null__		while (!currClass.equals(Object.class)) {_			AjType ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		this.ajType = ajType__		if (this.ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}__		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON :_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET : case PERTHIS :_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation("@Aspect annotation on " + aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN :_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default :_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,equals,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,this,aj,type,aj,type,if,this,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,annotation,on,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1356735495;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType ajType = null__		while (!currClass.equals(Object.class)) {_			AjType ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		this.ajType = ajType__		if (this.ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}__		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON :_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET : case PERTHIS :_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation("@Aspect annotation on " + aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN :_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default :_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,equals,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,this,aj,type,aj,type,if,this,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,annotation,on,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1385412762;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType<?> ajType = null__		while (!currClass.equals(Object.class)) {_			AjType<?> ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		this.ajType = ajType__		if (this.ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}__		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON :_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET : case PERTHIS :_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation("@Aspect annotation on " + aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN :_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default :_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,equals,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,this,aj,type,aj,type,if,this,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,annotation,on,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1432125256;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType<?> ajType = null__		while (currClass != Object.class) {_			AjType<?> ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		this.ajType = ajType__		if (this.ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}__		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON :_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET : case PERTHIS :_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation("@Aspect annotation on " + aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN :_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default :_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,this,aj,type,aj,type,if,this,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,annotation,on,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1450815633;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType<?> ajType = null__		while (currClass != Object.class) {_			AjType<?> ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		if (ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}_		this.aspectClass = ajType.getJavaClass()__		this.ajType = ajType___		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON :_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET : case PERTHIS :_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation("@Aspect annotation on " + aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN :_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default :_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,if,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,this,aspect,class,aj,type,get,java,class,this,aj,type,aj,type,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,annotation,on,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1482422404;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType<?> ajType = null__		while (currClass != Object.class) {_			AjType<?> ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		if (ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}_		this.aspectClass = ajType.getJavaClass()__		this.ajType = ajType___		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON:_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET:_			case PERTHIS:_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation(aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				ajexp.setPointcutDeclarationScope(aspectClass)__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN:_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default:_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,if,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,this,aspect,class,aj,type,get,java,class,this,aj,type,aj,type,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,ajexp,set,pointcut,declaration,scope,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1514035228;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType<?> ajType = null__		while (currClass != Object.class) {_			AjType<?> ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		if (ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}_		this.aspectClass = ajType.getJavaClass()__		this.ajType = ajType___		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON:_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET:_			case PERTHIS:_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation(aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				ajexp.setPointcutDeclarationScope(aspectClass)__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN:_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default:_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,if,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,this,aspect,class,aj,type,get,java,class,this,aj,type,aj,type,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,ajexp,set,pointcut,declaration,scope,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> public AspectMetadata(Class<?> aspectClass, String aspectName);1519588127;Create a new AspectMetadata instance for the given aspect class._@param aspectClass the aspect class_@param aspectName the name of the aspect;public AspectMetadata(Class<?> aspectClass, String aspectName) {_		this.aspectName = aspectName___		Class<?> currClass = aspectClass__		AjType<?> ajType = null__		while (currClass != Object.class) {_			AjType<?> ajTypeToCheck = AjTypeSystem.getAjType(currClass)__			if (ajTypeToCheck.isAspect()) {_				ajType = ajTypeToCheck__				break__			}_			currClass = currClass.getSuperclass()__		}_		if (ajType == null) {_			throw new IllegalArgumentException("Class '" + aspectClass.getName() + "' is not an @AspectJ aspect")__		}_		if (ajType.getDeclarePrecedence().length > 0) {_			throw new IllegalArgumentException("DeclarePrecendence not presently supported in Spring AOP")__		}_		this.aspectClass = ajType.getJavaClass()__		this.ajType = ajType___		switch (this.ajType.getPerClause().getKind()) {_			case SINGLETON:_				this.perClausePointcut = Pointcut.TRUE__				return__			case PERTARGET:_			case PERTHIS:_				AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut()__				ajexp.setLocation(aspectClass.getName())__				ajexp.setExpression(findPerClause(aspectClass))__				ajexp.setPointcutDeclarationScope(aspectClass)__				this.perClausePointcut = ajexp__				return__			case PERTYPEWITHIN:_				_				this.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)))__				return__			default:_				throw new AopConfigException(_						"PerClause " + ajType.getPerClause().getKind() + " not supported by Spring AOP for " + aspectClass)__		}_	};create,a,new,aspect,metadata,instance,for,the,given,aspect,class,param,aspect,class,the,aspect,class,param,aspect,name,the,name,of,the,aspect;public,aspect,metadata,class,aspect,class,string,aspect,name,this,aspect,name,aspect,name,class,curr,class,aspect,class,aj,type,aj,type,null,while,curr,class,object,class,aj,type,aj,type,to,check,aj,type,system,get,aj,type,curr,class,if,aj,type,to,check,is,aspect,aj,type,aj,type,to,check,break,curr,class,curr,class,get,superclass,if,aj,type,null,throw,new,illegal,argument,exception,class,aspect,class,get,name,is,not,an,aspect,j,aspect,if,aj,type,get,declare,precedence,length,0,throw,new,illegal,argument,exception,declare,precendence,not,presently,supported,in,spring,aop,this,aspect,class,aj,type,get,java,class,this,aj,type,aj,type,switch,this,aj,type,get,per,clause,get,kind,case,singleton,this,per,clause,pointcut,pointcut,true,return,case,pertarget,case,perthis,aspect,jexpression,pointcut,ajexp,new,aspect,jexpression,pointcut,ajexp,set,location,aspect,class,get,name,ajexp,set,expression,find,per,clause,aspect,class,ajexp,set,pointcut,declaration,scope,aspect,class,this,per,clause,pointcut,ajexp,return,case,pertypewithin,this,per,clause,pointcut,new,composable,pointcut,new,type,pattern,class,filter,find,per,clause,aspect,class,return,default,throw,new,aop,config,exception,per,clause,aj,type,get,per,clause,get,kind,not,supported,by,spring,aop,for,aspect,class
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1328020251;Extract contents from String of form <code>pertarget(contents)</code>.;private String findPerClause(Class<?> aspectClass) {_		_		_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents,code;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1356735495;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		_		_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1385412762;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		_		_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1432125256;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		_		_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1450815633;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		_		_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1482422404;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1514035228;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf("(") + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> private String findPerClause(Class<?> aspectClass);1519588127;Extract contents from String of form {@code pertarget(contents)}.;private String findPerClause(Class<?> aspectClass) {_		String str = aspectClass.getAnnotation(Aspect.class).value()__		str = str.substring(str.indexOf('(') + 1)__		str = str.substring(0, str.length() - 1)__		return str__	};extract,contents,from,string,of,form,code,pertarget,contents;private,string,find,per,clause,class,aspect,class,string,str,aspect,class,get,annotation,aspect,class,value,str,str,substring,str,index,of,1,str,str,substring,0,str,length,1,return,str
AspectMetadata -> public boolean isLazilyInstantiated();1328020251;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1356735495;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1385412762;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1432125256;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1450815633;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1482422404;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1514035228;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public boolean isLazilyInstantiated();1519588127;Return whether the aspect needs to be lazily instantiated.;public boolean isLazilyInstantiated() {_		return (isPerThisOrPerTarget() || isPerTypeWithin())__	};return,whether,the,aspect,needs,to,be,lazily,instantiated;public,boolean,is,lazily,instantiated,return,is,per,this,or,per,target,is,per,type,within
AspectMetadata -> public Class<?> getAspectClass();1385412762;Return the aspect class.;public Class<?> getAspectClass() {_		return this.ajType.getJavaClass()__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aj,type,get,java,class
AspectMetadata -> public Class<?> getAspectClass();1432125256;Return the aspect class.;public Class<?> getAspectClass() {_		return this.ajType.getJavaClass()__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aj,type,get,java,class
AspectMetadata -> public Class<?> getAspectClass();1450815633;Return the aspect class.;public Class<?> getAspectClass() {_		return this.aspectClass__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aspect,class
AspectMetadata -> public Class<?> getAspectClass();1482422404;Return the aspect class.;public Class<?> getAspectClass() {_		return this.aspectClass__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aspect,class
AspectMetadata -> public Class<?> getAspectClass();1514035228;Return the aspect class.;public Class<?> getAspectClass() {_		return this.aspectClass__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aspect,class
AspectMetadata -> public Class<?> getAspectClass();1519588127;Return the aspect class.;public Class<?> getAspectClass() {_		return this.aspectClass__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aspect,class
AspectMetadata -> public Class getAspectClass();1328020251;Return the aspect class.;public Class getAspectClass() {_		return this.ajType.getJavaClass()__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aj,type,get,java,class
AspectMetadata -> public Class getAspectClass();1356735495;Return the aspect class.;public Class getAspectClass() {_		return this.ajType.getJavaClass()__	};return,the,aspect,class;public,class,get,aspect,class,return,this,aj,type,get,java,class
AspectMetadata -> public AjType getAjType();1328020251;Return AspectJ reflection information.;public AjType getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public AjType getAjType();1356735495;Return AspectJ reflection information.;public AjType getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public String getAspectName();1328020251;Return the aspect class.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,class;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1356735495;Return the aspect class.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,class;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1385412762;Return the aspect class.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,class;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1432125256;Return the aspect class.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,class;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1450815633;Return the aspect class.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,class;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1482422404;Return the aspect class.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,class;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1514035228;Return the aspect name.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,name;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public String getAspectName();1519588127;Return the aspect name.;public String getAspectName() {_		return this.aspectName__	};return,the,aspect,name;public,string,get,aspect,name,return,this,aspect,name
AspectMetadata -> public boolean isPerTypeWithin();1328020251;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1356735495;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1385412762;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1432125256;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1450815633;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1482422404;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1514035228;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public boolean isPerTypeWithin();1519588127;Return whether the aspect is defined as "pertypewithin".;public boolean isPerTypeWithin() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTYPEWITHIN)__	};return,whether,the,aspect,is,defined,as,pertypewithin;public,boolean,is,per,type,within,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertypewithin
AspectMetadata -> public AjType<?> getAjType();1385412762;Return AspectJ reflection information.;public AjType<?> getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public AjType<?> getAjType();1432125256;Return AspectJ reflection information.;public AjType<?> getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public AjType<?> getAjType();1450815633;Return AspectJ reflection information.;public AjType<?> getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public AjType<?> getAjType();1482422404;Return AspectJ reflection information.;public AjType<?> getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public AjType<?> getAjType();1514035228;Return AspectJ reflection information.;public AjType<?> getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public AjType<?> getAjType();1519588127;Return AspectJ reflection information.;public AjType<?> getAjType() {_		return this.ajType__	};return,aspect,j,reflection,information;public,aj,type,get,aj,type,return,this,aj,type
AspectMetadata -> public Pointcut getPerClausePointcut();1328020251;Return a Spring pointcut expression for a singleton aspect._(e.g. <code>Pointcut.TRUE</code> if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,code,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1356735495;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1385412762;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1432125256;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1450815633;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1482422404;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1514035228;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public Pointcut getPerClausePointcut();1519588127;Return a Spring pointcut expression for a singleton aspect._(e.g. {@code Pointcut.TRUE} if it's a singleton).;public Pointcut getPerClausePointcut() {_		return this.perClausePointcut__	};return,a,spring,pointcut,expression,for,a,singleton,aspect,e,g,code,pointcut,true,if,it,s,a,singleton;public,pointcut,get,per,clause,pointcut,return,this,per,clause,pointcut
AspectMetadata -> public boolean isPerThisOrPerTarget();1328020251;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1356735495;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1385412762;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1432125256;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1450815633;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1482422404;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1514035228;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
AspectMetadata -> public boolean isPerThisOrPerTarget();1519588127;Return whether the aspect is defined as "perthis" or "pertarget".;public boolean isPerThisOrPerTarget() {_		PerClauseKind kind = getAjType().getPerClause().getKind()__		return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS)__	};return,whether,the,aspect,is,defined,as,perthis,or,pertarget;public,boolean,is,per,this,or,per,target,per,clause,kind,kind,get,aj,type,get,per,clause,get,kind,return,kind,per,clause,kind,pertarget,kind,per,clause,kind,perthis
