commented;modifiers;parameterAmount;loc;comment;code
true;private;1;6;/**  * Extract contents from String of form {@code pertarget(contents)}.  */ ;/**  * Extract contents from String of form {@code pertarget(contents)}.  */ private String findPerClause(Class<?> aspectClass) {     String str = aspectClass.getAnnotation(Aspect.class).value().     str = str.substring(str.indexOf('(') + 1).     str = str.substring(0, str.length() - 1).     return str. }
true;public;0;3;/**  * Return AspectJ reflection information.  */ ;/**  * Return AspectJ reflection information.  */ public AjType<?> getAjType() {     return this.ajType. }
true;public;0;3;/**  * Return the aspect class.  */ ;/**  * Return the aspect class.  */ public Class<?> getAspectClass() {     return this.aspectClass. }
true;public;0;3;/**  * Return the aspect name.  */ ;/**  * Return the aspect name.  */ public String getAspectName() {     return this.aspectName. }
true;public;0;3;/**  * Return a Spring pointcut expression for a singleton aspect.  * (e.g. {@code Pointcut.TRUE} if it's a singleton).  */ ;/**  * Return a Spring pointcut expression for a singleton aspect.  * (e.g. {@code Pointcut.TRUE} if it's a singleton).  */ public Pointcut getPerClausePointcut() {     return this.perClausePointcut. }
true;public;0;4;/**  * Return whether the aspect is defined as "perthis" or "pertarget".  */ ;/**  * Return whether the aspect is defined as "perthis" or "pertarget".  */ public boolean isPerThisOrPerTarget() {     PerClauseKind kind = getAjType().getPerClause().getKind().     return (kind == PerClauseKind.PERTARGET || kind == PerClauseKind.PERTHIS). }
true;public;0;4;/**  * Return whether the aspect is defined as "pertypewithin".  */ ;/**  * Return whether the aspect is defined as "pertypewithin".  */ public boolean isPerTypeWithin() {     PerClauseKind kind = getAjType().getPerClause().getKind().     return (kind == PerClauseKind.PERTYPEWITHIN). }
true;public;0;3;/**  * Return whether the aspect needs to be lazily instantiated.  */ ;/**  * Return whether the aspect needs to be lazily instantiated.  */ public boolean isLazilyInstantiated() {     return (isPerThisOrPerTarget() || isPerTypeWithin()). }
false;private;1;4;;private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {     inputStream.defaultReadObject().     this.ajType = AjTypeSystem.getAjType(this.aspectClass). }
