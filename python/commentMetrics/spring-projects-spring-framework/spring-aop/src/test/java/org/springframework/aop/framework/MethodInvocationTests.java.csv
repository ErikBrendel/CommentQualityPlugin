commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Object invoke(MethodInvocation invocation) throws Throwable {     return returnValue. }
false;public;0;18;;@Test public void testValidInvocation() throws Throwable {     Method m = Object.class.getMethod("hashCode").     Object proxy = new Object().     final Object returnValue = new Object().     List<Object> is = new LinkedList<>().     is.add(new MethodInterceptor() {          @Override         public Object invoke(MethodInvocation invocation) throws Throwable {             return returnValue.         }     }).     ReflectiveMethodInvocation invocation = new // ?     ReflectiveMethodInvocation(// ?     proxy, // ?     null, // list     m, // list     null, // list     null, // list     is).     Object rv = invocation.proceed().     assertTrue("correct response", rv == returnValue). }
false;public;0;4;;@Override public String toString() {     throw new UnsupportedOperationException("toString"). }
true;public;0;19;/**  * toString on target can cause failure.  */ ;/**  * toString on target can cause failure.  */ @Test public void testToStringDoesntHitTarget() throws Throwable {     Object target = new TestBean() {          @Override         public String toString() {             throw new UnsupportedOperationException("toString").         }     }.     List<Object> is = new LinkedList<>().     Method m = Object.class.getMethod("hashCode").     Object proxy = new Object().     ReflectiveMethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, m, null, null, is).     // If it hits target, the test will fail with the UnsupportedOpException     // in the inner class above.     invocation.toString(). }
