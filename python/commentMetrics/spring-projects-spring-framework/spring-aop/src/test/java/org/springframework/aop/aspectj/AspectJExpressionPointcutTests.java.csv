commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setUp() throws NoSuchMethodException {     getAge = TestBean.class.getMethod("getAge").     setAge = TestBean.class.getMethod("setAge", int.class).     setSomeNumber = TestBean.class.getMethod("setSomeNumber", Number.class). }
false;public;0;17;;@Test public void testMatchExplicit() {     String expression = "execution(int org.springframework.tests.sample.beans.TestBean.getAge())".     Pointcut pointcut = getPointcut(expression).     ClassFilter classFilter = pointcut.getClassFilter().     MethodMatcher methodMatcher = pointcut.getMethodMatcher().     assertMatchesTestBeanClass(classFilter).     // not currently testable in a reliable fashion     // assertDoesNotMatchStringClass(classFilter).     assertFalse("Should not be a runtime match", methodMatcher.isRuntime()).     assertMatchesGetAge(methodMatcher).     assertFalse("Expression should match setAge() method", methodMatcher.matches(setAge, TestBean.class)). }
false;public;0;17;;@Test public void testMatchWithTypePattern() throws Exception {     String expression = "execution(* *..TestBean.*Age(..))".     Pointcut pointcut = getPointcut(expression).     ClassFilter classFilter = pointcut.getClassFilter().     MethodMatcher methodMatcher = pointcut.getMethodMatcher().     assertMatchesTestBeanClass(classFilter).     // not currently testable in a reliable fashion     // assertDoesNotMatchStringClass(classFilter).     assertFalse("Should not be a runtime match", methodMatcher.isRuntime()).     assertMatchesGetAge(methodMatcher).     assertTrue("Expression should match setAge(int) method", methodMatcher.matches(setAge, TestBean.class)). }
false;public;0;4;;@Test public void testThis() throws SecurityException, NoSuchMethodException {     testThisOrTarget("this"). }
false;public;0;4;;@Test public void testTarget() throws SecurityException, NoSuchMethodException {     testThisOrTarget("target"). }
true;private;1;14;/**  * This and target are equivalent. Really instanceof pointcuts.  * @param which this or target  */ ;/**  * This and target are equivalent. Really instanceof pointcuts.  * @param which this or target  */ private void testThisOrTarget(String which) throws SecurityException, NoSuchMethodException {     String matchesTestBean = which + "(org.springframework.tests.sample.beans.TestBean)".     String matchesIOther = which + "(org.springframework.tests.sample.beans.IOther)".     AspectJExpressionPointcut testBeanPc = new AspectJExpressionPointcut().     testBeanPc.setExpression(matchesTestBean).     AspectJExpressionPointcut iOtherPc = new AspectJExpressionPointcut().     iOtherPc.setExpression(matchesIOther).     assertTrue(testBeanPc.matches(TestBean.class)).     assertTrue(testBeanPc.matches(getAge, TestBean.class)).     assertTrue(iOtherPc.matches(OtherIOther.class.getMethod("absquatulate"), OtherIOther.class)).     assertFalse(testBeanPc.matches(OtherIOther.class.getMethod("absquatulate"), OtherIOther.class)). }
false;public;0;4;;@Test public void testWithinRootPackage() throws SecurityException, NoSuchMethodException {     testWithinPackage(false). }
false;public;0;4;;@Test public void testWithinRootAndSubpackages() throws SecurityException, NoSuchMethodException {     testWithinPackage(true). }
false;private;1;18;;private void testWithinPackage(boolean matchSubpackages) throws SecurityException, NoSuchMethodException {     String withinBeansPackage = "within(org.springframework.tests.sample.beans.".     // Subpackages are matched by **     if (matchSubpackages) {         withinBeansPackage += ".".     }     withinBeansPackage = withinBeansPackage + "*)".     AspectJExpressionPointcut withinBeansPc = new AspectJExpressionPointcut().     withinBeansPc.setExpression(withinBeansPackage).     assertTrue(withinBeansPc.matches(TestBean.class)).     assertTrue(withinBeansPc.matches(getAge, TestBean.class)).     assertEquals(matchSubpackages, withinBeansPc.matches(DeepBean.class)).     assertEquals(matchSubpackages, withinBeansPc.matches(DeepBean.class.getMethod("aMethod", String.class), DeepBean.class)).     assertFalse(withinBeansPc.matches(String.class)).     assertFalse(withinBeansPc.matches(OtherIOther.class.getMethod("absquatulate"), OtherIOther.class)). }
false;public;0;11;;@Test public void testFriendlyErrorOnNoLocationClassMatching() {     AspectJExpressionPointcut pc = new AspectJExpressionPointcut().     try {         pc.matches(ITestBean.class).         fail().     } catch (IllegalStateException ex) {         assertTrue(ex.getMessage().contains("expression")).     } }
false;public;0;11;;@Test public void testFriendlyErrorOnNoLocation2ArgMatching() {     AspectJExpressionPointcut pc = new AspectJExpressionPointcut().     try {         pc.matches(getAge, ITestBean.class).         fail().     } catch (IllegalStateException ex) {         assertTrue(ex.getMessage().contains("expression")).     } }
false;public;0;11;;@Test public void testFriendlyErrorOnNoLocation3ArgMatching() {     AspectJExpressionPointcut pc = new AspectJExpressionPointcut().     try {         pc.matches(getAge, ITestBean.class, (Object[]) null).         fail().     } catch (IllegalStateException ex) {         assertTrue(ex.getMessage().contains("expression")).     } }
false;public;0;20;;@Test public void testMatchWithArgs() throws Exception {     String expression = "execution(void org.springframework.tests.sample.beans.TestBean.setSomeNumber(Number)) && args(Double)".     Pointcut pointcut = getPointcut(expression).     ClassFilter classFilter = pointcut.getClassFilter().     MethodMatcher methodMatcher = pointcut.getMethodMatcher().     assertMatchesTestBeanClass(classFilter).     // not currently testable in a reliable fashion     // assertDoesNotMatchStringClass(classFilter).     assertTrue("Should match with setSomeNumber with Double input", methodMatcher.matches(setSomeNumber, TestBean.class, new Double(12))).     assertFalse("Should not match setSomeNumber with Integer input", methodMatcher.matches(setSomeNumber, TestBean.class, new Integer(11))).     assertFalse("Should not match getAge", methodMatcher.matches(getAge, TestBean.class)).     assertTrue("Should be a runtime match", methodMatcher.isRuntime()). }
false;public;0;12;;@Test public void testSimpleAdvice() {     String expression = "execution(int org.springframework.tests.sample.beans.TestBean.getAge())".     CallCountingInterceptor interceptor = new CallCountingInterceptor().     TestBean testBean = getAdvisedProxy(expression, interceptor).     assertEquals("Calls should be 0", 0, interceptor.getCount()).     testBean.getAge().     assertEquals("Calls should be 1", 1, interceptor.getCount()).     testBean.setAge(90).     assertEquals("Calls should still be 1", 1, interceptor.getCount()). }
false;public;0;13;;@Test public void testDynamicMatchingProxy() {     String expression = "execution(void org.springframework.tests.sample.beans.TestBean.setSomeNumber(Number)) && args(Double)".     CallCountingInterceptor interceptor = new CallCountingInterceptor().     TestBean testBean = getAdvisedProxy(expression, interceptor).     assertEquals("Calls should be 0", 0, interceptor.getCount()).     testBean.setSomeNumber(new Double(30)).     assertEquals("Calls should be 1", 1, interceptor.getCount()).     testBean.setSomeNumber(new Integer(90)).     assertEquals("Calls should be 1", 1, interceptor.getCount()). }
false;public;0;12;;@Test public void testInvalidExpression() {     String expression = "execution(void org.springframework.tests.sample.beans.TestBean.setSomeNumber(Number) && args(Double)".     try {         // call to getClassFilter forces resolution         getPointcut(expression).getClassFilter().         fail("Invalid expression should throw IllegalArgumentException").     } catch (IllegalArgumentException ex) {         assertTrue(true).     } }
false;private;2;15;;private TestBean getAdvisedProxy(String pointcutExpression, CallCountingInterceptor interceptor) {     TestBean target = new TestBean().     Pointcut pointcut = getPointcut(pointcutExpression).     DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor().     advisor.setAdvice(interceptor).     advisor.setPointcut(pointcut).     ProxyFactory pf = new ProxyFactory().     pf.setTarget(target).     pf.addAdvisor(advisor).     return (TestBean) pf.getProxy(). }
false;private;1;3;;private void assertMatchesGetAge(MethodMatcher methodMatcher) {     assertTrue("Expression should match getAge() method", methodMatcher.matches(getAge, TestBean.class)). }
false;private;1;3;;private void assertMatchesTestBeanClass(ClassFilter classFilter) {     assertTrue("Expression should match TestBean class", classFilter.matches(TestBean.class)). }
false;public;0;12;;@Test public void testWithUnsupportedPointcutPrimitive() {     String expression = "call(int org.springframework.tests.sample.beans.TestBean.getAge())".     try {         // call to getClassFilter forces resolution...         getPointcut(expression).getClassFilter().         fail("Should not support call pointcuts").     } catch (UnsupportedPointcutPrimitiveException ex) {         assertEquals("Should not support call pointcut", PointcutPrimitive.CALL, ex.getUnsupportedPrimitive()).     } }
false;public;0;6;;@Test public void testAndSubstitution() {     Pointcut pc = getPointcut("execution(* *(..)) and args(String)").     PointcutExpression expr = ((AspectJExpressionPointcut) pc).getPointcutExpression().     assertEquals("execution(* *(..)) && args(String)", expr.getPointcutExpression()). }
false;public;0;6;;@Test public void testMultipleAndSubstitutions() {     Pointcut pc = getPointcut("execution(* *(..)) and args(String) and this(Object)").     PointcutExpression expr = ((AspectJExpressionPointcut) pc).getPointcutExpression().     assertEquals("execution(* *(..)) && args(String) && this(Object)", expr.getPointcutExpression()). }
false;private;1;5;;private Pointcut getPointcut(String expression) {     AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut().     pointcut.setExpression(expression).     return pointcut. }
false;public;0;4;;@Override public void absquatulate() { // Empty }
false;public;1;5;;@Override public Object invoke(MethodInvocation methodInvocation) throws Throwable {     count++.     return methodInvocation.proceed(). }
false;public;0;3;;public int getCount() {     return count. }
false;public;0;3;;public void reset() {     this.count = 0. }
