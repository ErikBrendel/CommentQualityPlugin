commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;0;1;/**  * To be overridden by concrete test subclasses.  * @return the fixture  */ ;/**  * To be overridden by concrete test subclasses.  * @return the fixture  */ protected abstract AspectJAdvisorFactory getFixture().
false;public;0;11;;@Test public void testRejectsPerCflowAspect() {     try {         getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new PerCflowAspect(), "someBean")).         fail("Cannot accept cflow").     } catch (AopConfigException ex) {         assertTrue(ex.getMessage().contains("PERCFLOW")).     } }
false;public;0;11;;@Test public void testRejectsPerCflowBelowAspect() {     try {         getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new PerCflowBelowAspect(), "someBean")).         fail("Cannot accept cflowbelow").     } catch (AopConfigException ex) {         assertTrue(ex.getMessage().contains("PERCFLOWBELOW")).     } }
false;public;0;31;;@Test public void testPerTargetAspect() throws SecurityException, NoSuchMethodException {     TestBean target = new TestBean().     int realAge = 65.     target.setAge(realAge).     TestBean itb = (TestBean) createProxy(target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new PerTargetAspect(), "someBean")), TestBean.class).     assertEquals("Around advice must NOT apply", realAge, itb.getAge()).     Advised advised = (Advised) itb.     ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor sia = (ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor) advised.getAdvisors()[1].     assertTrue(sia.getPointcut().getMethodMatcher().matches(TestBean.class.getMethod("getSpouse"), null)).     InstantiationModelAwarePointcutAdvisorImpl imapa = (InstantiationModelAwarePointcutAdvisorImpl) advised.getAdvisors()[3].     LazySingletonAspectInstanceFactoryDecorator maaif = (LazySingletonAspectInstanceFactoryDecorator) imapa.getAspectInstanceFactory().     assertFalse(maaif.isMaterialized()).     // Check that the perclause pointcut is valid     assertTrue(maaif.getAspectMetadata().getPerClausePointcut().getMethodMatcher().matches(TestBean.class.getMethod("getSpouse"), null)).     assertNotSame(imapa.getDeclaredPointcut(), imapa.getPointcut()).     // Hit the method in the per clause to instantiate the aspect     itb.getSpouse().     assertTrue(maaif.isMaterialized()).     assertEquals("Around advice must apply", 0, itb.getAge()).     assertEquals("Around advice must apply", 1, itb.getAge()). }
false;public;0;27;;@Test public void testMultiplePerTargetAspects() throws SecurityException, NoSuchMethodException {     TestBean target = new TestBean().     int realAge = 65.     target.setAge(realAge).     List<Advisor> advisors = new LinkedList<>().     PerTargetAspect aspect1 = new PerTargetAspect().     aspect1.count = 100.     aspect1.setOrder(10).     advisors.addAll(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(aspect1, "someBean1"))).     PerTargetAspect aspect2 = new PerTargetAspect().     aspect2.setOrder(5).     advisors.addAll(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(aspect2, "someBean2"))).     Collections.sort(advisors, new OrderComparator()).     TestBean itb = (TestBean) createProxy(target, advisors, TestBean.class).     assertEquals("Around advice must NOT apply", realAge, itb.getAge()).     // Hit the method in the per clause to instantiate the aspect     itb.getSpouse().     assertEquals("Around advice must apply", 0, itb.getAge()).     assertEquals("Around advice must apply", 1, itb.getAge()). }
false;public;0;25;;@Test public void testMultiplePerTargetAspectsWithOrderAnnotation() throws SecurityException, NoSuchMethodException {     TestBean target = new TestBean().     int realAge = 65.     target.setAge(realAge).     List<Advisor> advisors = new LinkedList<>().     PerTargetAspectWithOrderAnnotation10 aspect1 = new PerTargetAspectWithOrderAnnotation10().     aspect1.count = 100.     advisors.addAll(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(aspect1, "someBean1"))).     PerTargetAspectWithOrderAnnotation5 aspect2 = new PerTargetAspectWithOrderAnnotation5().     advisors.addAll(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(aspect2, "someBean2"))).     Collections.sort(advisors, new OrderComparator()).     TestBean itb = (TestBean) createProxy(target, advisors, TestBean.class).     assertEquals("Around advice must NOT apply", realAge, itb.getAge()).     // Hit the method in the per clause to instantiate the aspect     itb.getSpouse().     assertEquals("Around advice must apply", 0, itb.getAge()).     assertEquals("Around advice must apply", 1, itb.getAge()). }
false;public;0;35;;@Test public void testPerThisAspect() throws SecurityException, NoSuchMethodException {     TestBean target = new TestBean().     int realAge = 65.     target.setAge(realAge).     TestBean itb = (TestBean) createProxy(target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new PerThisAspect(), "someBean")), TestBean.class).     assertEquals("Around advice must NOT apply", realAge, itb.getAge()).     Advised advised = (Advised) itb.     // Will be ExposeInvocationInterceptor, synthetic instantiation advisor, 2 method advisors     assertEquals(4, advised.getAdvisors().length).     ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor sia = (ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor) advised.getAdvisors()[1].     assertTrue(sia.getPointcut().getMethodMatcher().matches(TestBean.class.getMethod("getSpouse"), null)).     InstantiationModelAwarePointcutAdvisorImpl imapa = (InstantiationModelAwarePointcutAdvisorImpl) advised.getAdvisors()[2].     LazySingletonAspectInstanceFactoryDecorator maaif = (LazySingletonAspectInstanceFactoryDecorator) imapa.getAspectInstanceFactory().     assertFalse(maaif.isMaterialized()).     // Check that the perclause pointcut is valid     assertTrue(maaif.getAspectMetadata().getPerClausePointcut().getMethodMatcher().matches(TestBean.class.getMethod("getSpouse"), null)).     assertNotSame(imapa.getDeclaredPointcut(), imapa.getPointcut()).     // Hit the method in the per clause to instantiate the aspect     itb.getSpouse().     assertTrue(maaif.isMaterialized()).     assertTrue(imapa.getDeclaredPointcut().getMethodMatcher().matches(TestBean.class.getMethod("getAge"), null)).     assertEquals("Around advice must apply", 0, itb.getAge()).     assertEquals("Around advice must apply", 1, itb.getAge()). }
false;public;0;40;;@Test public void testPerTypeWithinAspect() throws SecurityException, NoSuchMethodException {     TestBean target = new TestBean().     int realAge = 65.     target.setAge(realAge).     PerTypeWithinAspectInstanceFactory aif = new PerTypeWithinAspectInstanceFactory().     TestBean itb = (TestBean) createProxy(target, getFixture().getAdvisors(aif), TestBean.class).     assertEquals("No method calls", 0, aif.getInstantiationCount()).     assertEquals("Around advice must now apply", 0, itb.getAge()).     Advised advised = (Advised) itb.     // Will be ExposeInvocationInterceptor, synthetic instantiation advisor, 2 method advisors     assertEquals(4, advised.getAdvisors().length).     ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor sia = (ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor) advised.getAdvisors()[1].     assertTrue(sia.getPointcut().getMethodMatcher().matches(TestBean.class.getMethod("getSpouse"), null)).     InstantiationModelAwarePointcutAdvisorImpl imapa = (InstantiationModelAwarePointcutAdvisorImpl) advised.getAdvisors()[2].     LazySingletonAspectInstanceFactoryDecorator maaif = (LazySingletonAspectInstanceFactoryDecorator) imapa.getAspectInstanceFactory().     assertTrue(maaif.isMaterialized()).     // Check that the perclause pointcut is valid     assertTrue(maaif.getAspectMetadata().getPerClausePointcut().getMethodMatcher().matches(TestBean.class.getMethod("getSpouse"), null)).     assertNotSame(imapa.getDeclaredPointcut(), imapa.getPointcut()).     // Hit the method in the per clause to instantiate the aspect     itb.getSpouse().     assertTrue(maaif.isMaterialized()).     assertTrue(imapa.getDeclaredPointcut().getMethodMatcher().matches(TestBean.class.getMethod("getAge"), null)).     assertEquals("Around advice must still apply", 1, itb.getAge()).     assertEquals("Around advice must still apply", 2, itb.getAge()).     TestBean itb2 = (TestBean) createProxy(target, getFixture().getAdvisors(aif), TestBean.class).     assertEquals(1, aif.getInstantiationCount()).     assertEquals("Around advice be independent for second instance", 0, itb2.getAge()).     assertEquals(2, aif.getInstantiationCount()). }
false;public;0;4;;@Test public void testNamedPointcutAspectWithFQN() {     testNamedPointcuts(new NamedPointcutAspectWithFQN()). }
false;public;0;4;;@Test public void testNamedPointcutAspectWithoutFQN() {     testNamedPointcuts(new NamedPointcutAspectWithoutFQN()). }
false;public;0;4;;@Test public void testNamedPointcutFromAspectLibrary() {     testNamedPointcuts(new NamedPointcutAspectFromLibrary()). }
false;public;0;11;;@Test public void testNamedPointcutFromAspectLibraryWithBinding() {     TestBean target = new TestBean().     ITestBean itb = (ITestBean) createProxy(target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new NamedPointcutAspectFromLibraryWithBinding(), "someBean")), ITestBean.class).     itb.setAge(10).     assertEquals("Around advice must apply", 20, itb.getAge()).     assertEquals(20, target.getAge()). }
false;private;1;10;;private void testNamedPointcuts(Object aspectInstance) {     TestBean target = new TestBean().     int realAge = 65.     target.setAge(realAge).     ITestBean itb = (ITestBean) createProxy(target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(aspectInstance, "someBean")), ITestBean.class).     assertEquals("Around advice must apply", -1, itb.getAge()).     assertEquals(realAge, target.getAge()). }
false;public;0;11;;@Test public void testBindingWithSingleArg() {     TestBean target = new TestBean().     ITestBean itb = (ITestBean) createProxy(target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new BindingAspectWithSingleArg(), "someBean")), ITestBean.class).     itb.setAge(10).     assertEquals("Around advice must apply", 20, itb.getAge()).     assertEquals(20, target.getAge()). }
false;public;0;16;;@Test public void testBindingWithMultipleArgsDifferentlyOrdered() {     ManyValuedArgs target = new ManyValuedArgs().     ManyValuedArgs mva = (ManyValuedArgs) createProxy(target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new ManyValuedArgs(), "someBean")), ManyValuedArgs.class).     String a = "a".     int b = 12.     int c = 25.     String d = "d".     StringBuffer e = new StringBuffer("stringbuf").     String expectedResult = a + b + c + d + e.     assertEquals(expectedResult, mva.mungeArgs(a, b, c, d, e)). }
true;public;0;32;/**  * In this case the introduction will be made.  */ ;/**  * In this case the introduction will be made.  */ @Test public void testIntroductionOnTargetNotImplementingInterface() {     NotLockable notLockableTarget = new NotLockable().     assertFalse(notLockableTarget instanceof Lockable).     NotLockable notLockable1 = (NotLockable) createProxy(notLockableTarget, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean")), NotLockable.class).     assertTrue(notLockable1 instanceof Lockable).     Lockable lockable = (Lockable) notLockable1.     assertFalse(lockable.locked()).     lockable.lock().     assertTrue(lockable.locked()).     NotLockable notLockable2Target = new NotLockable().     NotLockable notLockable2 = (NotLockable) createProxy(notLockable2Target, getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean")), NotLockable.class).     assertTrue(notLockable2 instanceof Lockable).     Lockable lockable2 = (Lockable) notLockable2.     assertFalse(lockable2.locked()).     notLockable2.setIntValue(1).     lockable2.lock().     try {         notLockable2.setIntValue(32).         fail().     } catch (IllegalStateException ex) {     }     assertTrue(lockable2.locked()). }
false;public;0;9;;@Test public void testIntroductionAdvisorExcludedFromTargetImplementingInterface() {     assertTrue(AopUtils.findAdvisorsThatCanApply(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean")), CannotBeUnlocked.class).isEmpty()).     assertEquals(2, AopUtils.findAdvisorsThatCanApply(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean")), NotLockable.class).size()). }
false;public;0;24;;@Test public void testIntroductionOnTargetImplementingInterface() {     CannotBeUnlocked target = new CannotBeUnlocked().     Lockable proxy = (Lockable) createProxy(target, // Ensure that we exclude     AopUtils.findAdvisorsThatCanApply(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean")), CannotBeUnlocked.class), CannotBeUnlocked.class).     assertThat(proxy, instanceOf(Lockable.class)).     Lockable lockable = proxy.     assertTrue("Already locked", lockable.locked()).     lockable.lock().     assertTrue("Real target ignores locking", lockable.locked()).     try {         lockable.unlock().         fail().     } catch (UnsupportedOperationException ex) {     // Ok     } }
false;public;0;11;;@Test public void testIntroductionOnTargetExcludedByTypePattern() {     LinkedList<Object> target = new LinkedList<>().     List<?> proxy = (List<?>) createProxy(target, AopUtils.findAdvisorsThatCanApply(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean")), List.class), List.class).     assertFalse("Type pattern must have excluded mixin", proxy instanceof Lockable). }
false;public;0;11;;@Test public void testIntroductionBasedOnAnnotationMatch_SPR5307() {     AnnotatedTarget target = new AnnotatedTargetImpl().     List<Advisor> advisors = getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeAnnotatedTypeModifiable(), "someBean")).     Object proxy = createProxy(target, advisors, AnnotatedTarget.class).     System.out.println(advisors.get(1)).     assertTrue(proxy instanceof Lockable).     Lockable lockable = (Lockable) proxy.     lockable.locked(). }
true;public;0;39;// TODO: Why does this test fail? It hasn't been run before, so it maybe never actually passed... ;// TODO: Why does this test fail? It hasn't been run before, so it maybe never actually passed... @Test @Ignore public void testIntroductionWithArgumentBinding() {     TestBean target = new TestBean().     List<Advisor> advisors = getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeITestBeanModifiable(), "someBean")).     advisors.addAll(getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new MakeLockable(), "someBean"))).     Modifiable modifiable = (Modifiable) createProxy(target, advisors, ITestBean.class).     assertThat(modifiable, instanceOf(Modifiable.class)).     Lockable lockable = (Lockable) modifiable.     assertFalse(lockable.locked()).     ITestBean itb = (ITestBean) modifiable.     assertFalse(modifiable.isModified()).     int oldAge = itb.getAge().     itb.setAge(oldAge + 1).     assertTrue(modifiable.isModified()).     modifiable.acceptChanges().     assertFalse(modifiable.isModified()).     itb.setAge(itb.getAge()).     assertFalse("Setting same value does not modify", modifiable.isModified()).     itb.setName("And now for something completely different").     assertTrue(modifiable.isModified()).     lockable.lock().     assertTrue(lockable.locked()).     try {         itb.setName("Else").         fail("Should be locked").     } catch (IllegalStateException ex) {     // Ok     }     lockable.unlock().     itb.setName("Tony"). }
false;public;0;17;;@Test public void testAspectMethodThrowsExceptionLegalOnSignature() {     TestBean target = new TestBean().     UnsupportedOperationException expectedException = new UnsupportedOperationException().     List<Advisor> advisors = getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new ExceptionAspect(expectedException), "someBean")).     assertEquals("One advice method was found", 1, advisors.size()).     ITestBean itb = (ITestBean) createProxy(target, advisors, ITestBean.class).     try {         itb.getAge().         fail().     } catch (UnsupportedOperationException ex) {         assertSame(expectedException, ex).     } }
true;public;0;17;// Is it different AspectJ behaviour, at least for checked exceptions? ;// TODO document this behaviour. // Is it different AspectJ behaviour, at least for checked exceptions? @Test public void testAspectMethodThrowsExceptionIllegalOnSignature() {     TestBean target = new TestBean().     RemoteException expectedException = new RemoteException().     List<Advisor> advisors = getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(new ExceptionAspect(expectedException), "someBean")).     assertEquals("One advice method was found", 1, advisors.size()).     ITestBean itb = (ITestBean) createProxy(target, advisors, ITestBean.class).     try {         itb.getAge().         fail().     } catch (UndeclaredThrowableException ex) {         assertSame(expectedException, ex.getCause()).     } }
false;protected;3;16;;protected Object createProxy(Object target, List<Advisor> advisors, Class<?>... interfaces) {     ProxyFactory pf = new ProxyFactory(target).     if (interfaces.length > 1 || interfaces[0].isInterface()) {         pf.setInterfaces(interfaces).     } else {         pf.setProxyTargetClass(true).     }     // Required everywhere we use AspectJ proxies     pf.addAdvice(ExposeInvocationInterceptor.INSTANCE).     pf.addAdvisors(advisors).     pf.setExposeProxy(true).     return pf.getProxy(). }
false;public;0;14;;@Test public void testTwoAdvicesOnOneAspect() {     TestBean target = new TestBean().     TwoAdviceAspect twoAdviceAspect = new TwoAdviceAspect().     List<Advisor> advisors = getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(twoAdviceAspect, "someBean")).     assertEquals("Two advice methods found", 2, advisors.size()).     ITestBean itb = (ITestBean) createProxy(target, advisors, ITestBean.class).     itb.setName("").     assertEquals(0, itb.getAge()).     int newAge = 32.     itb.setAge(newAge).     assertEquals(1, itb.getAge()). }
false;public;0;26;;@Test public void testAfterAdviceTypes() throws Exception {     Echo target = new Echo().     ExceptionHandling afterReturningAspect = new ExceptionHandling().     List<Advisor> advisors = getFixture().getAdvisors(new SingletonMetadataAwareAspectInstanceFactory(afterReturningAspect, "someBean")).     Echo echo = (Echo) createProxy(target, advisors, Echo.class).     assertEquals(0, afterReturningAspect.successCount).     assertEquals("", echo.echo("")).     assertEquals(1, afterReturningAspect.successCount).     assertEquals(0, afterReturningAspect.failureCount).     try {         echo.echo(new FileNotFoundException()).         fail().     } catch (FileNotFoundException ex) {     // Ok     } catch (Exception ex) {         fail().     }     assertEquals(1, afterReturningAspect.successCount).     assertEquals(1, afterReturningAspect.failureCount).     assertEquals(afterReturningAspect.failureCount + afterReturningAspect.successCount, afterReturningAspect.afterCount). }
false;public;0;9;;@Test public void testFailureWithoutExplicitDeclarePrecedence() {     TestBean target = new TestBean().     MetadataAwareAspectInstanceFactory aspectInstanceFactory = new SingletonMetadataAwareAspectInstanceFactory(new NoDeclarePrecedenceShouldFail(), "someBean").     ITestBean itb = (ITestBean) createProxy(target, getFixture().getAdvisors(aspectInstanceFactory), ITestBean.class).     itb.getAge(). }
false;public;0;7;;@Test(expected = IllegalArgumentException.class) public void testDeclarePrecedenceNotSupported() {     TestBean target = new TestBean().     MetadataAwareAspectInstanceFactory aspectInstanceFactory = new SingletonMetadataAwareAspectInstanceFactory(new DeclarePrecedenceShouldSucceed(), "someBean").     createProxy(target, getFixture().getAdvisors(aspectInstanceFactory), ITestBean.class). }
false;public;0;4;;@Around("execution(int *.getAge())") public int returnCountAsAge() {     return count++. }
false;public;0;4;;@Before("execution(void *.set*(int))") public void countSetter() {     ++count. }
false;public;0;4;;@Around("execution(int *.getAge())") public int returnCountAsAge() {     return count++. }
false;public;0;4;;@Before("execution(void *.set*(int))") public void countSetter() {     ++count. }
false;public;0;4;;@Around("execution(int *.getAge())") public int returnCountAsAge() {     return count++. }
false;public;0;4;;@Before("execution(void *.*(..))") public void countAnythingVoid() {     ++count. }
false;public;0;3;;public int getInstantiationCount() {     return this.count. }
false;public;0;5;;@Override public Object getAspectInstance() {     ++this.count.     return new PerTypeWithinAspect(). }
false;public;0;4;;@Override public ClassLoader getAspectClassLoader() {     return PerTypeWithinAspect.class.getClassLoader(). }
false;public;0;4;;@Override public AspectMetadata getAspectMetadata() {     return new AspectMetadata(PerTypeWithinAspect.class, "perTypeWithin"). }
false;public;0;4;;@Override public Object getAspectCreationMutex() {     return this. }
false;public;0;4;;@Override public int getOrder() {     return Ordered.LOWEST_PRECEDENCE. }
false;public;0;3;;@Pointcut("execution(* getAge())") public void getAge() { }
false;public;1;4;;@Around("org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.NamedPointcutAspectWithFQN.getAge()") public int changeReturnValue(ProceedingJoinPoint pjp) {     return -1. }
false;public;0;3;;@Pointcut("execution(* getAge())") public void getAge() { }
false;public;1;4;;@Around("getAge()") public int changeReturnValue(ProceedingJoinPoint pjp) {     return -1. }
false;public;1;4;;@Around("org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.propertyAccess()") public int changeReturnType(ProceedingJoinPoint pjp) {     return -1. }
false;public;2;4;;@Around(value = "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.integerArgOperation(x)", argNames = "x") public void doubleArg(ProceedingJoinPoint pjp, int x) throws Throwable {     pjp.proceed(new Object[] { x * 2 }). }
false;public;0;2;;@Pointcut("execution(!void get*())") public void propertyAccess() { }
false;public;1;2;;@Pointcut("execution(* *(..)) && args(i)") public void integerArgOperation(int i) { }
false;public;2;4;;@Around(value = "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.integerArgOperation(x)", argNames = "x") public void doubleArg(ProceedingJoinPoint pjp, int x) throws Throwable {     pjp.proceed(new Object[] { x * 2 }). }
false;public;1;2;;@Pointcut(value = "args(a)", argNames = "a") public void setAge(int a) { }
false;public;2;6;;@Around(value = "setAge(age)", argNames = "age") public // argNames should be supported in Around as it is in Pointcut void changeReturnType(ProceedingJoinPoint pjp, int age) throws Throwable {     pjp.proceed(new Object[] { age * 2 }). }
false;public;5;3;;public String mungeArgs(String a, int b, int c, String d, StringBuffer e) {     return a + b + c + d + e. }
false;public;6;5;;@Around(value = "execution(String mungeArgs(..)) && args(a, b, c, d, e)", argNames = "b,c,d,e,a") public String reverseAdvice(ProceedingJoinPoint pjp, int b, int c, String d, StringBuffer e, String a) throws Throwable {     assertEquals(a + b + c + d + e, pjp.proceed()).     return a + b + c + d + e. }
false;public;0;4;;@Before("execution(* getAge())") public void throwException() throws Exception {     throw ex. }
false;public;1;6;;public Object echo(Object o) throws Exception {     if (o instanceof Exception) {         throw (Exception) o.     }     return o. }
false;public;0;4;;@AfterReturning("execution(* echo(*))") public void succeeded() {     ++successCount. }
false;public;0;4;;@AfterThrowing("execution(* echo(*))") public void failed() {     ++failureCount. }
false;public;0;4;;@After("execution(* echo(*))") public void invoked() {     ++afterCount. }
false;public;0;3;;@Pointcut("execution(int *.getAge())") public void getAge() { }
false;public;0;4;;@Before("getAge()") public void blowUpButDoesntMatterBecauseAroundAdviceWontLetThisBeInvoked() {     throw new IllegalStateException(). }
false;public;1;4;;@Around("getAge()") public int preventExecution(ProceedingJoinPoint pjp) {     return 666. }
false;public;0;3;;@Pointcut("execution(int *.getAge())") public void getAge() { }
false;public;0;4;;@Before("getAge()") public void blowUpButDoesntMatterBecauseAroundAdviceWontLetThisBeInvoked() {     throw new IllegalStateException(). }
false;public;1;4;;@Around("getAge()") public int preventExecution(ProceedingJoinPoint pjp) {     return 666. }
false;;0;1;;void markDirty().
false;public;0;4;;@Override public void acceptChanges() {     modified = false. }
false;public;0;4;;@Override public boolean isModified() {     return modified. }
false;public;0;4;;@Override public void markDirty() {     this.modified = true. }
false;public;3;38;;@Before(value = "execution(void set*(*)) && this(modifiable) && args(newValue)", argNames = "modifiable,newValue") public void recordModificationIfSetterArgumentDiffersFromOldValue(JoinPoint jp, MutableModifiable mixin, Object newValue) {     if (mixin.isModified()) {         // System.out.println("changed").         return.     }     // Find the current raw value, by invoking the corresponding setter     Method correspondingGetter = getGetterFromSetter(((MethodSignature) jp.getSignature()).getMethod()).     boolean modified = true.     if (correspondingGetter != null) {         try {             Object oldValue = correspondingGetter.invoke(jp.getTarget()).             // System.out.println("Old value=" + oldValue + ". new=" + newValue).             modified = !ObjectUtils.nullSafeEquals(oldValue, newValue).         } catch (Exception ex) {             ex.printStackTrace().         // Don't sweat on exceptions. assume value was modified         }     } else {     // System.out.println("cannot get getter for " + jp).     }     if (modified) {         mixin.markDirty().     } }
false;private;1;10;;private Method getGetterFromSetter(Method setter) {     String getterName = setter.getName().replaceFirst("set", "get").     try {         return setter.getDeclaringClass().getMethod(getterName).     } catch (NoSuchMethodException ex) {         // must be write only         return null.     } }
false;public;1;8;;@Before(value = "execution(void set*(*)) && this(mixin)", argNames = "mixin") public void checkNotLocked(Lockable mixin) {     // Lockable mixin = (Lockable) jp.getThis().     if (mixin.locked()) {         throw new IllegalStateException().     } }
false;public;0;3;;@Override public void lock() { }
false;public;0;4;;@Override public void unlock() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public boolean locked() {     return true. }
false;public;1;4;;@Override public int compareTo(Object arg0) {     throw new UnsupportedOperationException(). }
false;;0;1;;boolean isModified().
false;;0;1;;void acceptChanges().
false;public;0;3;;public int getIntValue() {     return intValue. }
false;public;1;3;;public void setIntValue(int intValue) {     this.intValue = intValue. }
false;public;0;4;;@Around("execution(int *.getAge())") public int returnCountAsAge() {     return count++. }
false;public;0;4;;@Before("execution(void *.set*(int))") public void countSetter() {     ++count. }
