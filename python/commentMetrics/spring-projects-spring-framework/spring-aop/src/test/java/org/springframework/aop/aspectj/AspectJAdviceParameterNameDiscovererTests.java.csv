commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testNoArgs() {     assertParameterNames(getMethod("noArgs"), "execution(* *(..))", new String[0]). }
false;public;0;4;;@Test public void testJoinPointOnly() {     assertParameterNames(getMethod("tjp"), "execution(* *(..))", new String[] { "thisJoinPoint" }). }
false;public;0;4;;@Test public void testJoinPointStaticPartOnly() {     assertParameterNames(getMethod("tjpsp"), "execution(* *(..))", new String[] { "thisJoinPointStaticPart" }). }
false;public;0;5;;@Test public void testTwoJoinPoints() {     assertException(getMethod("twoJoinPoints"), "foo()", IllegalStateException.class, "Failed to bind all argument names: 1 argument(s) could not be bound"). }
false;public;0;4;;@Test public void testOneThrowable() {     assertParameterNames(getMethod("oneThrowable"), "foo()", null, "ex", new String[] { "ex" }). }
false;public;0;4;;@Test public void testOneJPAndOneThrowable() {     assertParameterNames(getMethod("jpAndOneThrowable"), "foo()", null, "ex", new String[] { "thisJoinPoint", "ex" }). }
false;public;0;5;;@Test public void testOneJPAndTwoThrowables() {     assertException(getMethod("jpAndTwoThrowables"), "foo()", null, "ex", AmbiguousBindingException.class, "Binding of throwing parameter 'ex' is ambiguous: could be bound to argument 1 or argument 2"). }
false;public;0;5;;@Test public void testThrowableNoCandidates() {     assertException(getMethod("noArgs"), "foo()", null, "ex", IllegalStateException.class, "Not enough arguments in method to satisfy binding of returning and throwing variables"). }
false;public;0;4;;@Test public void testReturning() {     assertParameterNames(getMethod("oneObject"), "foo()", "obj", null, new String[] { "obj" }). }
false;public;0;5;;@Test public void testAmbiguousReturning() {     assertException(getMethod("twoObjects"), "foo()", "obj", null, AmbiguousBindingException.class, "Binding of returning parameter 'obj' is ambiguous, there are 2 candidates."). }
false;public;0;5;;@Test public void testReturningNoCandidates() {     assertException(getMethod("noArgs"), "foo()", "obj", null, IllegalStateException.class, "Not enough arguments in method to satisfy binding of returning and throwing variables"). }
false;public;0;4;;@Test public void testThisBindingOneCandidate() {     assertParameterNames(getMethod("oneObject"), "this(x)", new String[] { "x" }). }
false;public;0;8;;@Test public void testThisBindingWithAlternateTokenizations() {     assertParameterNames(getMethod("oneObject"), "this( x )", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "this( x)", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "this (x )", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "this(x )", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "foo() && this(x)", new String[] { "x" }). }
false;public;0;5;;@Test public void testThisBindingTwoCandidates() {     assertException(getMethod("oneObject"), "this(x) || this(y)", AmbiguousBindingException.class, "Found 2 candidate this(), target() or args() variables but only one unbound argument slot"). }
false;public;0;7;;@Test public void testThisBindingWithBadPointcutExpressions() {     assertException(getMethod("oneObject"), "this(", IllegalStateException.class, "Failed to bind all argument names: 1 argument(s) could not be bound").     assertException(getMethod("oneObject"), "this(x && foo()", IllegalStateException.class, "Failed to bind all argument names: 1 argument(s) could not be bound"). }
false;public;0;4;;@Test public void testTargetBindingOneCandidate() {     assertParameterNames(getMethod("oneObject"), "target(x)", new String[] { "x" }). }
false;public;0;8;;@Test public void testTargetBindingWithAlternateTokenizations() {     assertParameterNames(getMethod("oneObject"), "target( x )", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "target( x)", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "target (x )", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "target(x )", new String[] { "x" }).     assertParameterNames(getMethod("oneObject"), "foo() && target(x)", new String[] { "x" }). }
false;public;0;5;;@Test public void testTargetBindingTwoCandidates() {     assertException(getMethod("oneObject"), "target(x) || target(y)", AmbiguousBindingException.class, "Found 2 candidate this(), target() or args() variables but only one unbound argument slot"). }
false;public;0;7;;@Test public void testTargetBindingWithBadPointcutExpressions() {     assertException(getMethod("oneObject"), "target(", IllegalStateException.class, "Failed to bind all argument names: 1 argument(s) could not be bound").     assertException(getMethod("oneObject"), "target(x && foo()", IllegalStateException.class, "Failed to bind all argument names: 1 argument(s) could not be bound"). }
false;public;0;4;;@Test public void testArgsBindingOneObject() {     assertParameterNames(getMethod("oneObject"), "args(x)", new String[] { "x" }). }
false;public;0;5;;@Test public void testArgsBindingOneObjectTwoCandidates() {     assertException(getMethod("oneObject"), "args(x,y)", AmbiguousBindingException.class, "Found 2 candidate this(), target() or args() variables but only one unbound argument slot"). }
false;public;0;5;;@Test public void testAmbiguousArgsBinding() {     assertException(getMethod("twoObjects"), "args(x,y)", AmbiguousBindingException.class, "Still 2 unbound args at this(),target(),args() binding stage, with no way to determine between them"). }
false;public;0;4;;@Test public void testArgsOnePrimitive() {     assertParameterNames(getMethod("onePrimitive"), "args(count)", new String[] { "count" }). }
false;public;0;5;;@Test public void testArgsOnePrimitiveOneObject() {     assertException(getMethod("oneObjectOnePrimitive"), "args(count,obj)", AmbiguousBindingException.class, "Found 2 candidate variable names but only one candidate binding slot when matching primitive args"). }
false;public;0;5;;@Test public void testThisAndPrimitive() {     assertParameterNames(getMethod("oneObjectOnePrimitive"), "args(count) && this(obj)", new String[] { "obj", "count" }). }
false;public;0;5;;@Test public void testTargetAndPrimitive() {     assertParameterNames(getMethod("oneObjectOnePrimitive"), "args(count) && target(obj)", new String[] { "obj", "count" }). }
false;public;0;5;;@Test public void testThrowingAndPrimitive() {     assertParameterNames(getMethod("oneThrowableOnePrimitive"), "args(count)", null, "ex", new String[] { "ex", "count" }). }
false;public;0;5;;@Test public void testAllTogetherNow() {     assertParameterNames(getMethod("theBigOne"), "this(foo) && args(x)", null, "ex", new String[] { "thisJoinPoint", "ex", "x", "foo" }). }
false;public;0;4;;@Test public void testReferenceBinding() {     assertParameterNames(getMethod("onePrimitive"), "somepc(foo)", new String[] { "foo" }). }
false;public;0;6;;@Test public void testReferenceBindingWithAlternateTokenizations() {     assertParameterNames(getMethod("onePrimitive"), "call(bar *) && somepc(foo)", new String[] { "foo" }).     assertParameterNames(getMethod("onePrimitive"), "somepc ( foo )", new String[] { "foo" }).     assertParameterNames(getMethod("onePrimitive"), "somepc( foo)", new String[] { "foo" }). }
false;protected;1;11;;protected Method getMethod(String name) {     // Assumes no overloading of test methods...     Method[] candidates = getClass().getMethods().     for (Method candidate : candidates) {         if (candidate.getName().equals(name)) {             return candidate.         }     }     fail("Bad test specification, no method '" + name + "' found in test class").     return null. }
false;protected;3;3;;protected void assertParameterNames(Method method, String pointcut, String[] parameterNames) {     assertParameterNames(method, pointcut, null, null, parameterNames). }
false;protected;5;27;;protected void assertParameterNames(Method method, String pointcut, String returning, String throwing, String[] parameterNames) {     assertEquals("bad test specification, must have same number of parameter names as method arguments", method.getParameterCount(), parameterNames.length).     AspectJAdviceParameterNameDiscoverer discoverer = new AspectJAdviceParameterNameDiscoverer(pointcut).     discoverer.setRaiseExceptions(true).     discoverer.setReturningName(returning).     discoverer.setThrowingName(throwing).     String[] discoveredNames = discoverer.getParameterNames(method).     String formattedExpectedNames = format(parameterNames).     String formattedActualNames = format(discoveredNames).     assertEquals("Expecting " + parameterNames.length + " parameter names in return set '" + formattedExpectedNames + "', but found " + discoveredNames.length + " '" + formattedActualNames + "'", parameterNames.length, discoveredNames.length).     for (int i = 0. i < discoveredNames.length. i++) {         assertNotNull("Parameter names must never be null", discoveredNames[i]).         assertEquals("Expecting parameter " + i + " to be named '" + parameterNames[i] + "' but was '" + discoveredNames[i] + "'", parameterNames[i], discoveredNames[i]).     } }
false;protected;4;3;;protected void assertException(Method method, String pointcut, Class<?> exceptionType, String message) {     assertException(method, pointcut, null, null, exceptionType, message). }
false;protected;6;18;;protected void assertException(Method method, String pointcut, String returning, String throwing, Class<?> exceptionType, String message) {     AspectJAdviceParameterNameDiscoverer discoverer = new AspectJAdviceParameterNameDiscoverer(pointcut).     discoverer.setRaiseExceptions(true).     discoverer.setReturningName(returning).     discoverer.setThrowingName(throwing).     try {         discoverer.getParameterNames(method).         fail("Expecting " + exceptionType.getName() + " with message '" + message + "'").     } catch (RuntimeException expected) {         assertEquals("Expecting exception of type " + exceptionType.getName(), exceptionType, expected.getClass()).         assertEquals("Exception message does not match expected", message, expected.getMessage()).     } }
false;private,static;1;12;;private static String format(String[] names) {     StringBuffer sb = new StringBuffer().     sb.append("(").     for (int i = 0. i < names.length. i++) {         sb.append(names[i]).         if ((i + 1) < names.length) {             sb.append(",").         }     }     sb.append(")").     return sb.toString(). }
false;public;0;2;;// Methods to discover parameter names for public void noArgs() { }
false;public;1;2;;public void tjp(JoinPoint jp) { }
false;public;1;2;;public void tjpsp(JoinPoint.StaticPart tjpsp) { }
false;public;2;2;;public void twoJoinPoints(JoinPoint jp1, JoinPoint jp2) { }
false;public;1;2;;public void oneThrowable(Exception ex) { }
false;public;2;2;;public void jpAndOneThrowable(JoinPoint jp, Exception ex) { }
false;public;3;2;;public void jpAndTwoThrowables(JoinPoint jp, Exception ex, Error err) { }
false;public;1;2;;public void oneObject(Object x) { }
false;public;2;2;;public void twoObjects(Object x, Object y) { }
false;public;1;2;;public void onePrimitive(int x) { }
false;public;2;2;;public void oneObjectOnePrimitive(Object x, int y) { }
false;public;2;2;;public void oneThrowableOnePrimitive(Throwable x, int y) { }
false;public;4;2;;public void theBigOne(JoinPoint jp, Throwable x, int y, Object foo) { }
