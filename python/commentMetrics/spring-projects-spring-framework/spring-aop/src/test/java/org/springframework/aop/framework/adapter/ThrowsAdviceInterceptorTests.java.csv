commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test(expected = IllegalArgumentException.class) public void testNoHandlerMethods() {     // should require one handler method at least     new ThrowsAdviceInterceptor(new Object()). }
false;public;0;10;;@Test public void testNotInvoked() throws Throwable {     MyThrowsHandler th = new MyThrowsHandler().     ThrowsAdviceInterceptor ti = new ThrowsAdviceInterceptor(th).     Object ret = new Object().     MethodInvocation mi = mock(MethodInvocation.class).     given(mi.proceed()).willReturn(ret).     assertEquals(ret, ti.invoke(mi)).     assertEquals(0, th.getCalls()). }
false;public;0;17;;@Test public void testNoHandlerMethodForThrowable() throws Throwable {     MyThrowsHandler th = new MyThrowsHandler().     ThrowsAdviceInterceptor ti = new ThrowsAdviceInterceptor(th).     assertEquals(2, ti.getHandlerMethodCount()).     Exception ex = new Exception().     MethodInvocation mi = mock(MethodInvocation.class).     given(mi.proceed()).willThrow(ex).     try {         ti.invoke(mi).         fail().     } catch (Exception caught) {         assertEquals(ex, caught).     }     assertEquals(0, th.getCalls()). }
false;public;0;19;;@Test public void testCorrectHandlerUsed() throws Throwable {     MyThrowsHandler th = new MyThrowsHandler().     ThrowsAdviceInterceptor ti = new ThrowsAdviceInterceptor(th).     FileNotFoundException ex = new FileNotFoundException().     MethodInvocation mi = mock(MethodInvocation.class).     given(mi.getMethod()).willReturn(Object.class.getMethod("hashCode")).     given(mi.getThis()).willReturn(new Object()).     given(mi.proceed()).willThrow(ex).     try {         ti.invoke(mi).         fail().     } catch (Exception caught) {         assertEquals(ex, caught).     }     assertEquals(1, th.getCalls()).     assertEquals(1, th.getCalls("ioException")). }
false;public;0;18;;@Test public void testCorrectHandlerUsedForSubclass() throws Throwable {     MyThrowsHandler th = new MyThrowsHandler().     ThrowsAdviceInterceptor ti = new ThrowsAdviceInterceptor(th).     // Extends RemoteException     ConnectException ex = new ConnectException("").     MethodInvocation mi = mock(MethodInvocation.class).     given(mi.proceed()).willThrow(ex).     try {         ti.invoke(mi).         fail().     } catch (Exception caught) {         assertEquals(ex, caught).     }     assertEquals(1, th.getCalls()).     assertEquals(1, th.getCalls("remoteException")). }
false;public;1;5;;@Override public void afterThrowing(RemoteException ex) throws Throwable {     super.afterThrowing(ex).     throw t. }
false;public;0;28;;@Test public void testHandlerMethodThrowsException() throws Throwable {     final Throwable t = new Throwable().     @SuppressWarnings("serial")     MyThrowsHandler th = new MyThrowsHandler() {          @Override         public void afterThrowing(RemoteException ex) throws Throwable {             super.afterThrowing(ex).             throw t.         }     }.     ThrowsAdviceInterceptor ti = new ThrowsAdviceInterceptor(th).     // Extends RemoteException     ConnectException ex = new ConnectException("").     MethodInvocation mi = mock(MethodInvocation.class).     given(mi.proceed()).willThrow(ex).     try {         ti.invoke(mi).         fail().     } catch (Throwable caught) {         assertEquals(t, caught).     }     assertEquals(1, th.getCalls()).     assertEquals(1, th.getCalls("remoteException")). }
true;public;4;3;// Full method signature ;// Full method signature public void afterThrowing(Method m, Object[] args, Object target, IOException ex) {     count("ioException"). }
false;public;1;3;;public void afterThrowing(RemoteException ex) throws Throwable {     count("remoteException"). }
true;public;2;3;/**  * Not valid, wrong number of arguments  */ ;/**  * Not valid, wrong number of arguments  */ public void afterThrowing(Method m, Exception ex) throws Throwable {     throw new UnsupportedOperationException("Shouldn't be called"). }
