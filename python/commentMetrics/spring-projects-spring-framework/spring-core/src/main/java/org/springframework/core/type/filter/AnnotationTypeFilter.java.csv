commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the {@link Annotation} that this instance is using to filter  * candidates.  * @since 5.0  */ ;/**  * Return the {@link Annotation} that this instance is using to filter  * candidates.  * @since 5.0  */ public final Class<? extends Annotation> getAnnotationType() {     return this.annotationType. }
false;protected;1;6;;@Override protected boolean matchSelf(MetadataReader metadataReader) {     AnnotationMetadata metadata = metadataReader.getAnnotationMetadata().     return metadata.hasAnnotation(this.annotationType.getName()) || (this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName())). }
false;protected;1;5;;@Override @Nullable protected Boolean matchSuperClass(String superClassName) {     return hasAnnotation(superClassName). }
false;protected;1;5;;@Override @Nullable protected Boolean matchInterface(String interfaceName) {     return hasAnnotation(interfaceName). }
false;protected;1;22;;@Nullable protected Boolean hasAnnotation(String typeName) {     if (Object.class.getName().equals(typeName)) {         return false.     } else if (typeName.startsWith("java")) {         if (!this.annotationType.getName().startsWith("java")) {             // skip any load attempt, in particular for Java language interfaces.             return false.         }         try {             Class<?> clazz = ClassUtils.forName(typeName, getClass().getClassLoader()).             return ((this.considerMetaAnnotations ? AnnotationUtils.getAnnotation(clazz, this.annotationType) : clazz.getAnnotation(this.annotationType)) != null).         } catch (Throwable ex) {         // Class not regularly loadable - can't determine a match that way.         }     }     return null. }
