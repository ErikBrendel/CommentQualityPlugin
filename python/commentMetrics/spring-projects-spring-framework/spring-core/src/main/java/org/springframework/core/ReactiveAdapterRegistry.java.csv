commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Whether the registry has any adapters which would be the case if any of  * Reactor, RxJava 2, or RxJava 1 (+ RxJava Reactive Streams bridge) are  * present on the classpath.  */ ;/**  * Whether the registry has any adapters which would be the case if any of  * Reactor, RxJava 2, or RxJava 1 (+ RxJava Reactive Streams bridge) are  * present on the classpath.  */ public boolean hasAdapters() {     return !this.adapters.isEmpty(). }
true;public;3;10;/**  * Register a reactive type along with functions to adapt to and from a  * Reactive Streams {@link Publisher}. The functions can assume their  * input is never be {@code null} nor {@link Optional}.  */ ;/**  * Register a reactive type along with functions to adapt to and from a  * Reactive Streams {@link Publisher}. The functions can assume their  * input is never be {@code null} nor {@link Optional}.  */ public void registerReactiveType(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {     if (this.reactorPresent) {         this.adapters.add(new ReactorAdapter(descriptor, toAdapter, fromAdapter)).     } else {         this.adapters.add(new ReactiveAdapter(descriptor, toAdapter, fromAdapter)).     } }
true;public;1;4;/**  * Get the adapter for the given reactive type.  */ ;/**  * Get the adapter for the given reactive type.  */ @Nullable public ReactiveAdapter getAdapter(Class<?> reactiveType) {     return getAdapter(reactiveType, null). }
true;public;2;19;/**  * Get the adapter for the given reactive type. Or if a "source" object is  * provided, its actual type is used instead.  * @param reactiveType the reactive type  * (may be {@code null} if a concrete source object is given)  * @param source an instance of the reactive type  * (i.e. to adapt from. may be {@code null} if the reactive type is specified)  */ ;/**  * Get the adapter for the given reactive type. Or if a "source" object is  * provided, its actual type is used instead.  * @param reactiveType the reactive type  * (may be {@code null} if a concrete source object is given)  * @param source an instance of the reactive type  * (i.e. to adapt from. may be {@code null} if the reactive type is specified)  */ @Nullable public ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {     Object sourceToUse = (source instanceof Optional ? ((Optional<?>) source).orElse(null) : source).     Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType).     if (clazz == null) {         return null.     }     for (ReactiveAdapter adapter : this.adapters) {         if (adapter.getReactiveType() == clazz) {             return adapter.         }     }     for (ReactiveAdapter adapter : this.adapters) {         if (adapter.getReactiveType().isAssignableFrom(clazz)) {             return adapter.         }     }     return null. }
true;public,static;0;13;/**  * Return a shared default {@code ReactiveAdapterRegistry} instance, lazily  * building it once needed.  * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured  * {@code ReactiveAdapterRegistry} instance for customization purposes.  * This accessor is only meant as a fallback for code paths that want to  * fall back on a default instance if one isn't provided.  * @return the shared {@code ReactiveAdapterRegistry} instance (never {@code null})  * @since 5.0.2  */ ;/**  * Return a shared default {@code ReactiveAdapterRegistry} instance, lazily  * building it once needed.  * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured  * {@code ReactiveAdapterRegistry} instance for customization purposes.  * This accessor is only meant as a fallback for code paths that want to  * fall back on a default instance if one isn't provided.  * @return the shared {@code ReactiveAdapterRegistry} instance (never {@code null})  * @since 5.0.2  */ public static ReactiveAdapterRegistry getSharedInstance() {     ReactiveAdapterRegistry registry = sharedInstance.     if (registry == null) {         synchronized (ReactiveAdapterRegistry.class) {             registry = sharedInstance.             if (registry == null) {                 registry = new ReactiveAdapterRegistry().                 sharedInstance = registry.             }         }     }     return registry. }
false;;1;29;;void registerAdapters(ReactiveAdapterRegistry registry) {     // Register Flux and Mono before Publisher...     registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty), source -> (Mono<?>) source, Mono::from).     registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty), source -> (Flux<?>) source, Flux::from).     registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty), source -> (Publisher<?>) source, source -> source).     registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(CompletableFuture.class, () -> {         CompletableFuture<?> empty = new CompletableFuture<>().         empty.complete(null).         return empty.     }), source -> Mono.fromFuture((CompletableFuture<?>) source), source -> Mono.from(source).toFuture()). }
false;;1;17;;void registerAdapters(ReactiveAdapterRegistry registry) {     registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(rx.Observable.class, rx.Observable::empty), source -> RxReactiveStreams.toPublisher((rx.Observable<?>) source), RxReactiveStreams::toObservable).     registry.registerReactiveType(ReactiveTypeDescriptor.singleRequiredValue(rx.Single.class), source -> RxReactiveStreams.toPublisher((rx.Single<?>) source), RxReactiveStreams::toSingle).     registry.registerReactiveType(ReactiveTypeDescriptor.noValue(rx.Completable.class, rx.Completable::complete), source -> RxReactiveStreams.toPublisher((rx.Completable) source), RxReactiveStreams::toCompletable). }
false;;1;27;;void registerAdapters(ReactiveAdapterRegistry registry) {     registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.Flowable.class, io.reactivex.Flowable::empty), source -> (io.reactivex.Flowable<?>) source, Flowable::fromPublisher).     registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.Observable.class, io.reactivex.Observable::empty), source -> ((io.reactivex.Observable<?>) source).toFlowable(BackpressureStrategy.BUFFER), source -> io.reactivex.Flowable.fromPublisher(source).toObservable()).     registry.registerReactiveType(ReactiveTypeDescriptor.singleRequiredValue(io.reactivex.Single.class), source -> ((io.reactivex.Single<?>) source).toFlowable(), source -> io.reactivex.Flowable.fromPublisher(source).toObservable().singleElement().toSingle()).     registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(io.reactivex.Maybe.class, io.reactivex.Maybe::empty), source -> ((io.reactivex.Maybe<?>) source).toFlowable(), source -> io.reactivex.Flowable.fromPublisher(source).toObservable().singleElement()).     registry.registerReactiveType(ReactiveTypeDescriptor.noValue(io.reactivex.Completable.class, io.reactivex.Completable::complete), source -> ((io.reactivex.Completable) source).toFlowable(), source -> io.reactivex.Flowable.fromPublisher(source).toObservable().ignoreElements()). }
false;;1;24;;void registerAdapter(ReactiveAdapterRegistry registry) {     try {         String publisherName = "java.util.concurrent.Flow.Publisher".         Class<?> publisherClass = ClassUtils.forName(publisherName, getClass().getClassLoader()).         String adapterName = "reactor.adapter.JdkFlowAdapter".         Class<?> flowAdapterClass = ClassUtils.forName(adapterName, getClass().getClassLoader()).         Method toFluxMethod = flowAdapterClass.getMethod("flowPublisherToFlux", publisherClass).         Method toFlowMethod = flowAdapterClass.getMethod("publisherToFlowPublisher", Publisher.class).         Object emptyFlow = ReflectionUtils.invokeMethod(toFlowMethod, null, Flux.empty()).         registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(publisherClass, () -> emptyFlow), source -> (Publisher<?>) ReflectionUtils.invokeMethod(toFluxMethod, null, source), publisher -> ReflectionUtils.invokeMethod(toFlowMethod, null, publisher)).     } catch (Throwable ex) {     // Ignore     } }
false;public;1;5;;@Override public <T> Publisher<T> toPublisher(@Nullable Object source) {     Publisher<T> publisher = super.toPublisher(source).     return (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher)). }
