commented;modifiers;parameterAmount;loc;comment;code
true;public;2;4;/**  * Replaces all placeholders of format {@code ${name}} with the corresponding  * property from the supplied {@link Properties}.  * @param value the value containing the placeholders to be replaced  * @param properties the {@code Properties} to use for replacement  * @return the supplied value with placeholders replaced inline  */ ;/**  * Replaces all placeholders of format {@code ${name}} with the corresponding  * property from the supplied {@link Properties}.  * @param value the value containing the placeholders to be replaced  * @param properties the {@code Properties} to use for replacement  * @return the supplied value with placeholders replaced inline  */ public String replacePlaceholders(String value, final Properties properties) {     Assert.notNull(properties, "'properties' must not be null").     return replacePlaceholders(value, properties::getProperty). }
true;public;2;4;/**  * Replaces all placeholders of format {@code ${name}} with the value returned  * from the supplied {@link PlaceholderResolver}.  * @param value the value containing the placeholders to be replaced  * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement  * @return the supplied value with placeholders replaced inline  */ ;/**  * Replaces all placeholders of format {@code ${name}} with the value returned  * from the supplied {@link PlaceholderResolver}.  * @param value the value containing the placeholders to be replaced  * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement  * @return the supplied value with placeholders replaced inline  */ public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {     Assert.notNull(value, "'value' must not be null").     return parseStringValue(value, placeholderResolver, new HashSet<>()). }
false;protected;3;57;;protected String parseStringValue(String value, PlaceholderResolver placeholderResolver, Set<String> visitedPlaceholders) {     StringBuilder result = new StringBuilder(value).     int startIndex = value.indexOf(this.placeholderPrefix).     while (startIndex != -1) {         int endIndex = findPlaceholderEndIndex(result, startIndex).         if (endIndex != -1) {             String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex).             String originalPlaceholder = placeholder.             if (!visitedPlaceholders.add(originalPlaceholder)) {                 throw new IllegalArgumentException("Circular placeholder reference '" + originalPlaceholder + "' in property definitions").             }             // Recursive invocation, parsing placeholders contained in the placeholder key.             placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders).             // Now obtain the value for the fully resolved key...             String propVal = placeholderResolver.resolvePlaceholder(placeholder).             if (propVal == null && this.valueSeparator != null) {                 int separatorIndex = placeholder.indexOf(this.valueSeparator).                 if (separatorIndex != -1) {                     String actualPlaceholder = placeholder.substring(0, separatorIndex).                     String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length()).                     propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder).                     if (propVal == null) {                         propVal = defaultValue.                     }                 }             }             if (propVal != null) {                 // Recursive invocation, parsing placeholders contained in the                 // previously resolved placeholder value.                 propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders).                 result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal).                 if (logger.isTraceEnabled()) {                     logger.trace("Resolved placeholder '" + placeholder + "'").                 }                 startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length()).             } else if (this.ignoreUnresolvablePlaceholders) {                 // Proceed with unprocessed value.                 startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length()).             } else {                 throw new IllegalArgumentException("Could not resolve placeholder '" + placeholder + "'" + " in value \"" + value + "\"").             }             visitedPlaceholders.remove(originalPlaceholder).         } else {             startIndex = -1.         }     }     return result.toString(). }
false;private;2;23;;private int findPlaceholderEndIndex(CharSequence buf, int startIndex) {     int index = startIndex + this.placeholderPrefix.length().     int withinNestedPlaceholder = 0.     while (index < buf.length()) {         if (StringUtils.substringMatch(buf, index, this.placeholderSuffix)) {             if (withinNestedPlaceholder > 0) {                 withinNestedPlaceholder--.                 index = index + this.placeholderSuffix.length().             } else {                 return index.             }         } else if (StringUtils.substringMatch(buf, index, this.simplePrefix)) {             withinNestedPlaceholder++.             index = index + this.simplePrefix.length().         } else {             index++.         }     }     return -1. }
true;;1;2;/**  * Resolve the supplied placeholder name to the replacement value.  * @param placeholderName the name of the placeholder to resolve  * @return the replacement value, or {@code null} if no replacement is to be made  */ ;/**  * Resolve the supplied placeholder name to the replacement value.  * @param placeholderName the name of the placeholder to resolve  * @return the replacement value, or {@code null} if no replacement is to be made  */ @Nullable String resolvePlaceholder(String placeholderName).
