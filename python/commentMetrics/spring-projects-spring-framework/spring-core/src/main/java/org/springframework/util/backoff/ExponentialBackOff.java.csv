commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * The initial interval in milliseconds.  */ ;/**  * The initial interval in milliseconds.  */ public void setInitialInterval(long initialInterval) {     this.initialInterval = initialInterval. }
true;public;0;3;/**  * Return the initial interval in milliseconds.  */ ;/**  * Return the initial interval in milliseconds.  */ public long getInitialInterval() {     return this.initialInterval. }
true;public;1;4;/**  * The value to multiply the current interval by for each retry attempt.  */ ;/**  * The value to multiply the current interval by for each retry attempt.  */ public void setMultiplier(double multiplier) {     checkMultiplier(multiplier).     this.multiplier = multiplier. }
true;public;0;3;/**  * Return the value to multiply the current interval by for each retry attempt.  */ ;/**  * Return the value to multiply the current interval by for each retry attempt.  */ public double getMultiplier() {     return this.multiplier. }
true;public;1;3;/**  * The maximum back off time.  */ ;/**  * The maximum back off time.  */ public void setMaxInterval(long maxInterval) {     this.maxInterval = maxInterval. }
true;public;0;3;/**  * Return the maximum back off time.  */ ;/**  * Return the maximum back off time.  */ public long getMaxInterval() {     return this.maxInterval. }
true;public;1;3;/**  * The maximum elapsed time in milliseconds after which a call to  * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.  */ ;/**  * The maximum elapsed time in milliseconds after which a call to  * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.  */ public void setMaxElapsedTime(long maxElapsedTime) {     this.maxElapsedTime = maxElapsedTime. }
true;public;0;3;/**  * Return the maximum elapsed time in milliseconds after which a call to  * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.  */ ;/**  * Return the maximum elapsed time in milliseconds after which a call to  * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.  */ public long getMaxElapsedTime() {     return this.maxElapsedTime. }
false;public;0;4;;@Override public BackOffExecution start() {     return new ExponentialBackOffExecution(). }
false;private;1;4;;private void checkMultiplier(double multiplier) {     Assert.isTrue(multiplier >= 1, () -> "Invalid multiplier '" + multiplier + "'. Should be greater than " + "or equal to 1. A multiplier of 1 is equivalent to a fixed interval."). }
false;public;0;10;;@Override public long nextBackOff() {     if (this.currentElapsedTime >= maxElapsedTime) {         return STOP.     }     long nextInterval = computeNextInterval().     this.currentElapsedTime += nextInterval.     return nextInterval. }
false;private;0;15;;private long computeNextInterval() {     long maxInterval = getMaxInterval().     if (this.currentInterval >= maxInterval) {         return maxInterval.     } else if (this.currentInterval < 0) {         long initialInterval = getInitialInterval().         this.currentInterval = (initialInterval < maxInterval ? initialInterval : maxInterval).     } else {         this.currentInterval = multiplyInterval(maxInterval).     }     return this.currentInterval. }
false;private;1;5;;private long multiplyInterval(long maxInterval) {     long i = this.currentInterval.     i *= getMultiplier().     return (i > maxInterval ? maxInterval : i). }
false;public;0;8;;@Override public String toString() {     StringBuilder sb = new StringBuilder("ExponentialBackOff{").     sb.append("currentInterval=").append(this.currentInterval < 0 ? "n/a" : this.currentInterval + "ms").     sb.append(", multiplier=").append(getMultiplier()).     sb.append('}').     return sb.toString(). }
