commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;13;;@SuppressWarnings("unchecked") @Nullable private static Class<? extends Annotation> getAnnotationType(String annotationType, @Nullable ClassLoader classLoader) {     if (classLoader != null) {         try {             return (Class<? extends Annotation>) classLoader.loadClass(annotationType).         } catch (ClassNotFoundException ex) {         // Annotation Class not resolvable         }     }     return null. }
true;public;0;4;/**  * Get the type of annotation represented by this {@code AnnotationAttributes}.  * @return the annotation type, or {@code null} if unknown  * @since 4.2  */ ;/**  * Get the type of annotation represented by this {@code AnnotationAttributes}.  * @return the annotation type, or {@code null} if unknown  * @since 4.2  */ @Nullable public Class<? extends Annotation> annotationType() {     return this.annotationType. }
true;public;1;3;/**  * Get the value stored under the specified {@code attributeName} as a string.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as a string.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ public String getString(String attributeName) {     return getRequiredAttribute(attributeName, String.class). }
true;public;1;3;/**  * Get the value stored under the specified {@code attributeName} as an  * array of strings.  * <p>If the value stored under the specified {@code attributeName} is  * a string, it will be wrapped in a single-element array before  * returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as an  * array of strings.  * <p>If the value stored under the specified {@code attributeName} is  * a string, it will be wrapped in a single-element array before  * returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ public String[] getStringArray(String attributeName) {     return getRequiredAttribute(attributeName, String[].class). }
true;public;1;3;/**  * Get the value stored under the specified {@code attributeName} as a boolean.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as a boolean.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ public boolean getBoolean(String attributeName) {     return getRequiredAttribute(attributeName, Boolean.class). }
true;public;1;4;/**  * Get the value stored under the specified {@code attributeName} as a number.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as a number.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ @SuppressWarnings("unchecked") public <N extends Number> N getNumber(String attributeName) {     return (N) getRequiredAttribute(attributeName, Number.class). }
true;public;1;4;/**  * Get the value stored under the specified {@code attributeName} as an enum.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as an enum.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ @SuppressWarnings("unchecked") public <E extends Enum<?>> E getEnum(String attributeName) {     return (E) getRequiredAttribute(attributeName, Enum.class). }
true;public;1;4;/**  * Get the value stored under the specified {@code attributeName} as a class.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as a class.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ @SuppressWarnings("unchecked") public <T> Class<? extends T> getClass(String attributeName) {     return getRequiredAttribute(attributeName, Class.class). }
true;public;1;3;/**  * Get the value stored under the specified {@code attributeName} as an  * array of classes.  * <p>If the value stored under the specified {@code attributeName} is a class,  * it will be wrapped in a single-element array before returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName} as an  * array of classes.  * <p>If the value stored under the specified {@code attributeName} is a class,  * it will be wrapped in a single-element array before returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ public Class<?>[] getClassArray(String attributeName) {     return getRequiredAttribute(attributeName, Class[].class). }
true;public;1;3;/**  * Get the {@link AnnotationAttributes} stored under the specified  * {@code attributeName}.  * <p>Note: if you expect an actual annotation, invoke  * {@link #getAnnotation(String, Class)} instead.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the {@code AnnotationAttributes}  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the {@link AnnotationAttributes} stored under the specified  * {@code attributeName}.  * <p>Note: if you expect an actual annotation, invoke  * {@link #getAnnotation(String, Class)} instead.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the {@code AnnotationAttributes}  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ public AnnotationAttributes getAnnotation(String attributeName) {     return getRequiredAttribute(attributeName, AnnotationAttributes.class). }
true;public;2;3;/**  * Get the annotation of type {@code annotationType} stored under the  * specified {@code attributeName}.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @param annotationType the expected annotation type. never {@code null}  * @return the annotation  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  * @since 4.2  */ ;/**  * Get the annotation of type {@code annotationType} stored under the  * specified {@code attributeName}.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @param annotationType the expected annotation type. never {@code null}  * @return the annotation  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  * @since 4.2  */ public <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {     return getRequiredAttribute(attributeName, annotationType). }
true;public;1;3;/**  * Get the array of {@link AnnotationAttributes} stored under the specified  * {@code attributeName}.  * <p>If the value stored under the specified {@code attributeName} is  * an instance of {@code AnnotationAttributes}, it will be wrapped in  * a single-element array before returning it.  * <p>Note: if you expect an actual array of annotations, invoke  * {@link #getAnnotationArray(String, Class)} instead.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the array of {@code AnnotationAttributes}  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the array of {@link AnnotationAttributes} stored under the specified  * {@code attributeName}.  * <p>If the value stored under the specified {@code attributeName} is  * an instance of {@code AnnotationAttributes}, it will be wrapped in  * a single-element array before returning it.  * <p>Note: if you expect an actual array of annotations, invoke  * {@link #getAnnotationArray(String, Class)} instead.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @return the array of {@code AnnotationAttributes}  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ public AnnotationAttributes[] getAnnotationArray(String attributeName) {     return getRequiredAttribute(attributeName, AnnotationAttributes[].class). }
true;public;2;5;/**  * Get the array of type {@code annotationType} stored under the specified  * {@code attributeName}.  * <p>If the value stored under the specified {@code attributeName} is  * an {@code Annotation}, it will be wrapped in a single-element array  * before returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @param annotationType the expected annotation type. never {@code null}  * @return the annotation array  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  * @since 4.2  */ ;/**  * Get the array of type {@code annotationType} stored under the specified  * {@code attributeName}.  * <p>If the value stored under the specified {@code attributeName} is  * an {@code Annotation}, it will be wrapped in a single-element array  * before returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @param annotationType the expected annotation type. never {@code null}  * @return the annotation array  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  * @since 4.2  */ @SuppressWarnings("unchecked") public <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {     Object array = Array.newInstance(annotationType, 0).     return (A[]) getRequiredAttribute(attributeName, array.getClass()). }
true;private;2;15;/**  * Get the value stored under the specified {@code attributeName},  * ensuring that the value is of the {@code expectedType}.  * <p>If the {@code expectedType} is an array and the value stored  * under the specified {@code attributeName} is a single element of the  * component type of the expected array type, the single element will be  * wrapped in a single-element array of the appropriate type before  * returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @param expectedType the expected type. never {@code null}  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ ;/**  * Get the value stored under the specified {@code attributeName},  * ensuring that the value is of the {@code expectedType}.  * <p>If the {@code expectedType} is an array and the value stored  * under the specified {@code attributeName} is a single element of the  * component type of the expected array type, the single element will be  * wrapped in a single-element array of the appropriate type before  * returning it.  * @param attributeName the name of the attribute to get.  * never {@code null} or empty  * @param expectedType the expected type. never {@code null}  * @return the value  * @throws IllegalArgumentException if the attribute does not exist or  * if it is not of the expected type  */ @SuppressWarnings("unchecked") private <T> T getRequiredAttribute(String attributeName, Class<T> expectedType) {     Assert.hasText(attributeName, "'attributeName' must not be null or empty").     Object value = get(attributeName).     assertAttributePresence(attributeName, value).     assertNotException(attributeName, value).     if (!expectedType.isInstance(value) && expectedType.isArray() && expectedType.getComponentType().isInstance(value)) {         Object array = Array.newInstance(expectedType.getComponentType(), 1).         Array.set(array, 0, value).         value = array.     }     assertAttributeType(attributeName, value, expectedType).     return (T) value. }
false;private;2;5;;private void assertAttributePresence(String attributeName, Object attributeValue) {     Assert.notNull(attributeValue, () -> String.format("Attribute '%s' not found in attributes for annotation [%s]", attributeName, this.displayName)). }
false;private;2;7;;private void assertNotException(String attributeName, Object attributeValue) {     if (attributeValue instanceof Exception) {         throw new IllegalArgumentException(String.format("Attribute '%s' for annotation [%s] was not resolvable due to exception [%s]", attributeName, this.displayName, attributeValue), (Exception) attributeValue).     } }
false;private;3;8;;private void assertAttributeType(String attributeName, Object attributeValue, Class<?> expectedType) {     if (!expectedType.isInstance(attributeValue)) {         throw new IllegalArgumentException(String.format("Attribute '%s' is of type %s, but %s was expected in attributes for annotation [%s]", attributeName, attributeValue.getClass().getSimpleName(), expectedType.getSimpleName(), this.displayName)).     } }
true;public;2;8;/**  * Store the supplied {@code value} in this map under the specified  * {@code key}, unless a value is already stored under the key.  * @param key the key under which to store the value  * @param value the value to store  * @return the current value stored in this map, or {@code null} if no  * value was previously stored in this map  * @see #get  * @see #put  * @since 4.2  */ ;/**  * Store the supplied {@code value} in this map under the specified  * {@code key}, unless a value is already stored under the key.  * @param key the key under which to store the value  * @param value the value to store  * @return the current value stored in this map, or {@code null} if no  * value was previously stored in this map  * @see #get  * @see #put  * @since 4.2  */ @Override public Object putIfAbsent(String key, Object value) {     Object obj = get(key).     if (obj == null) {         obj = put(key, value).     }     return obj. }
false;public;0;14;;@Override public String toString() {     Iterator<Map.Entry<String, Object>> entries = entrySet().iterator().     StringBuilder sb = new StringBuilder("{").     while (entries.hasNext()) {         Map.Entry<String, Object> entry = entries.next().         sb.append(entry.getKey()).         sb.append('=').         sb.append(valueToString(entry.getValue())).         sb.append(entries.hasNext() ? ", " : "").     }     sb.append("}").     return sb.toString(). }
false;private;1;9;;private String valueToString(Object value) {     if (value == this) {         return "(this Map)".     }     if (value instanceof Object[]) {         return "[" + StringUtils.arrayToDelimitedString((Object[]) value, ", ") + "]".     }     return String.valueOf(value). }
true;public,static;1;10;/**  * Return an {@link AnnotationAttributes} instance based on the given map.  * <p>If the map is already an {@code AnnotationAttributes} instance, it  * will be cast and returned immediately without creating a new instance.  * Otherwise a new instance will be created by passing the supplied map  * to the {@link #AnnotationAttributes(Map)} constructor.  * @param map original source of annotation attribute <em>key-value</em> pairs  */ ;/**  * Return an {@link AnnotationAttributes} instance based on the given map.  * <p>If the map is already an {@code AnnotationAttributes} instance, it  * will be cast and returned immediately without creating a new instance.  * Otherwise a new instance will be created by passing the supplied map  * to the {@link #AnnotationAttributes(Map)} constructor.  * @param map original source of annotation attribute <em>key-value</em> pairs  */ @Nullable public static AnnotationAttributes fromMap(@Nullable Map<String, Object> map) {     if (map == null) {         return null.     }     if (map instanceof AnnotationAttributes) {         return (AnnotationAttributes) map.     }     return new AnnotationAttributes(map). }
