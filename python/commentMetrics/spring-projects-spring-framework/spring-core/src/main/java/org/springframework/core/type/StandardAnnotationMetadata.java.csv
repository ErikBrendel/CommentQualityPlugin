commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public Set<String> getAnnotationTypes() {     Set<String> types = new LinkedHashSet<>().     for (Annotation ann : this.annotations) {         types.add(ann.annotationType().getName()).     }     return types. }
false;public;1;6;;@Override public Set<String> getMetaAnnotationTypes(String annotationName) {     return (this.annotations.length > 0 ? AnnotatedElementUtils.getMetaAnnotationTypes(getIntrospectedClass(), annotationName) : Collections.emptySet()). }
false;public;1;9;;@Override public boolean hasAnnotation(String annotationName) {     for (Annotation ann : this.annotations) {         if (ann.annotationType().getName().equals(annotationName)) {             return true.         }     }     return false. }
false;public;1;5;;@Override public boolean hasMetaAnnotation(String annotationName) {     return (this.annotations.length > 0 && AnnotatedElementUtils.hasMetaAnnotationTypes(getIntrospectedClass(), annotationName)). }
false;public;1;5;;@Override public boolean isAnnotated(String annotationName) {     return (this.annotations.length > 0 && AnnotatedElementUtils.isAnnotated(getIntrospectedClass(), annotationName)). }
false;public;1;4;;@Override public Map<String, Object> getAnnotationAttributes(String annotationName) {     return getAnnotationAttributes(annotationName, false). }
false;public;2;6;;@Override @Nullable public Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {     return (this.annotations.length > 0 ? AnnotatedElementUtils.getMergedAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, this.nestedAnnotationsAsMap) : null). }
false;public;1;5;;@Override @Nullable public MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName) {     return getAllAnnotationAttributes(annotationName, false). }
false;public;2;6;;@Override @Nullable public MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {     return (this.annotations.length > 0 ? AnnotatedElementUtils.getAllAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, this.nestedAnnotationsAsMap) : null). }
false;public;1;16;;@Override public boolean hasAnnotatedMethods(String annotationName) {     try {         Method[] methods = getIntrospectedClass().getDeclaredMethods().         for (Method method : methods) {             if (!method.isBridge() && method.getAnnotations().length > 0 && AnnotatedElementUtils.isAnnotated(method, annotationName)) {                 return true.             }         }         return false.     } catch (Throwable ex) {         throw new IllegalStateException("Failed to introspect annotated methods on " + getIntrospectedClass(), ex).     } }
false;public;1;17;;@Override public Set<MethodMetadata> getAnnotatedMethods(String annotationName) {     try {         Method[] methods = getIntrospectedClass().getDeclaredMethods().         Set<MethodMetadata> annotatedMethods = new LinkedHashSet<>(4).         for (Method method : methods) {             if (!method.isBridge() && method.getAnnotations().length > 0 && AnnotatedElementUtils.isAnnotated(method, annotationName)) {                 annotatedMethods.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap)).             }         }         return annotatedMethods.     } catch (Throwable ex) {         throw new IllegalStateException("Failed to introspect annotated methods on " + getIntrospectedClass(), ex).     } }
