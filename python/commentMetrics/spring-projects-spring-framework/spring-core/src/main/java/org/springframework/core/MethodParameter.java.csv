commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the wrapped Method, if any.  * <p>Note: Either Method or Constructor is available.  * @return the Method, or {@code null} if none  */ ;/**  * Return the wrapped Method, if any.  * <p>Note: Either Method or Constructor is available.  * @return the Method, or {@code null} if none  */ @Nullable public Method getMethod() {     return (this.executable instanceof Method ? (Method) this.executable : null). }
true;public;0;4;/**  * Return the wrapped Constructor, if any.  * <p>Note: Either Method or Constructor is available.  * @return the Constructor, or {@code null} if none  */ ;/**  * Return the wrapped Constructor, if any.  * <p>Note: Either Method or Constructor is available.  * @return the Constructor, or {@code null} if none  */ @Nullable public Constructor<?> getConstructor() {     return (this.executable instanceof Constructor ? (Constructor<?>) this.executable : null). }
true;public;0;3;/**  * Return the class that declares the underlying Method or Constructor.  */ ;/**  * Return the class that declares the underlying Method or Constructor.  */ public Class<?> getDeclaringClass() {     return this.executable.getDeclaringClass(). }
true;public;0;3;/**  * Return the wrapped member.  * @return the Method or Constructor as Member  */ ;/**  * Return the wrapped member.  * @return the Method or Constructor as Member  */ public Member getMember() {     return this.executable. }
true;public;0;3;/**  * Return the wrapped annotated element.  * <p>Note: This method exposes the annotations declared on the method/constructor  * itself (i.e. at the method/constructor level, not at the parameter level).  * @return the Method or Constructor as AnnotatedElement  */ ;/**  * Return the wrapped annotated element.  * <p>Note: This method exposes the annotations declared on the method/constructor  * itself (i.e. at the method/constructor level, not at the parameter level).  * @return the Method or Constructor as AnnotatedElement  */ public AnnotatedElement getAnnotatedElement() {     return this.executable. }
true;public;0;3;/**  * Return the wrapped executable.  * @return the Method or Constructor as Executable  * @since 5.0  */ ;/**  * Return the wrapped executable.  * @return the Method or Constructor as Executable  * @since 5.0  */ public Executable getExecutable() {     return this.executable. }
true;public;0;11;/**  * Return the {@link Parameter} descriptor for method/constructor parameter.  * @since 5.0  */ ;/**  * Return the {@link Parameter} descriptor for method/constructor parameter.  * @since 5.0  */ public Parameter getParameter() {     if (this.parameterIndex < 0) {         throw new IllegalStateException("Cannot retrieve Parameter descriptor for method return type").     }     Parameter parameter = this.parameter.     if (parameter == null) {         parameter = getExecutable().getParameters()[this.parameterIndex].         this.parameter = parameter.     }     return parameter. }
true;public;0;3;/**  * Return the index of the method/constructor parameter.  * @return the parameter index (-1 in case of the return type)  */ ;/**  * Return the index of the method/constructor parameter.  * @return the parameter index (-1 in case of the return type)  */ public int getParameterIndex() {     return this.parameterIndex. }
true;public;0;3;/**  * Increase this parameter's nesting level.  * @see #getNestingLevel()  */ ;/**  * Increase this parameter's nesting level.  * @see #getNestingLevel()  */ public void increaseNestingLevel() {     this.nestingLevel++. }
true;public;0;4;/**  * Decrease this parameter's nesting level.  * @see #getNestingLevel()  */ ;/**  * Decrease this parameter's nesting level.  * @see #getNestingLevel()  */ public void decreaseNestingLevel() {     getTypeIndexesPerLevel().remove(this.nestingLevel).     this.nestingLevel--. }
true;public;0;3;/**  * Return the nesting level of the target type  * (typically 1. e.g. in case of a List of Lists, 1 would indicate the  * nested List, whereas 2 would indicate the element of the nested List).  */ ;/**  * Return the nesting level of the target type  * (typically 1. e.g. in case of a List of Lists, 1 would indicate the  * nested List, whereas 2 would indicate the element of the nested List).  */ public int getNestingLevel() {     return this.nestingLevel. }
true;public;1;3;/**  * Set the type index for the current nesting level.  * @param typeIndex the corresponding type index  * (or {@code null} for the default type index)  * @see #getNestingLevel()  */ ;/**  * Set the type index for the current nesting level.  * @param typeIndex the corresponding type index  * (or {@code null} for the default type index)  * @see #getNestingLevel()  */ public void setTypeIndexForCurrentLevel(int typeIndex) {     getTypeIndexesPerLevel().put(this.nestingLevel, typeIndex). }
true;public;0;4;/**  * Return the type index for the current nesting level.  * @return the corresponding type index, or {@code null}  * if none specified (indicating the default type index)  * @see #getNestingLevel()  */ ;/**  * Return the type index for the current nesting level.  * @return the corresponding type index, or {@code null}  * if none specified (indicating the default type index)  * @see #getNestingLevel()  */ @Nullable public Integer getTypeIndexForCurrentLevel() {     return getTypeIndexForLevel(this.nestingLevel). }
true;public;1;4;/**  * Return the type index for the specified nesting level.  * @param nestingLevel the nesting level to check  * @return the corresponding type index, or {@code null}  * if none specified (indicating the default type index)  */ ;/**  * Return the type index for the specified nesting level.  * @param nestingLevel the nesting level to check  * @return the corresponding type index, or {@code null}  * if none specified (indicating the default type index)  */ @Nullable public Integer getTypeIndexForLevel(int nestingLevel) {     return getTypeIndexesPerLevel().get(nestingLevel). }
true;private;0;6;/**  * Obtain the (lazily constructed) type-indexes-per-level Map.  */ ;/**  * Obtain the (lazily constructed) type-indexes-per-level Map.  */ private Map<Integer, Integer> getTypeIndexesPerLevel() {     if (this.typeIndexesPerLevel == null) {         this.typeIndexesPerLevel = new HashMap<>(4).     }     return this.typeIndexesPerLevel. }
true;public;0;10;/**  * Return a variant of this {@code MethodParameter} which points to the  * same parameter but one nesting level deeper. This is effectively the  * same as {@link #increaseNestingLevel()}, just with an independent  * {@code MethodParameter} object (e.g. in case of the original being cached).  * @since 4.3  */ ;/**  * Return a variant of this {@code MethodParameter} which points to the  * same parameter but one nesting level deeper. This is effectively the  * same as {@link #increaseNestingLevel()}, just with an independent  * {@code MethodParameter} object (e.g. in case of the original being cached).  * @since 4.3  */ public MethodParameter nested() {     MethodParameter nestedParam = this.nestedMethodParameter.     if (nestedParam != null) {         return nestedParam.     }     nestedParam = clone().     nestedParam.nestingLevel = this.nestingLevel + 1.     this.nestedMethodParameter = nestedParam.     return nestedParam. }
true;public;0;6;/**  * Return whether this method indicates a parameter which is not required:  * either in the form of Java 8's {@link java.util.Optional}, any variant  * of a parameter-level {@code Nullable} annotation (such as from JSR-305  * or the FindBugs set of annotations), or a language-level nullable type  * declaration in Kotlin.  * @since 4.3  */ ;/**  * Return whether this method indicates a parameter which is not required:  * either in the form of Java 8's {@link java.util.Optional}, any variant  * of a parameter-level {@code Nullable} annotation (such as from JSR-305  * or the FindBugs set of annotations), or a language-level nullable type  * declaration in Kotlin.  * @since 4.3  */ public boolean isOptional() {     return (getParameterType() == Optional.class || hasNullableAnnotation() || (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(getContainingClass()) && KotlinDelegate.isOptional(this))). }
true;private;0;8;/**  * Check whether this method parameter is annotated with any variant of a  * {@code Nullable} annotation, e.g. {@code javax.annotation.Nullable} or  * {@code edu.umd.cs.findbugs.annotations.Nullable}.  */ ;/**  * Check whether this method parameter is annotated with any variant of a  * {@code Nullable} annotation, e.g. {@code javax.annotation.Nullable} or  * {@code edu.umd.cs.findbugs.annotations.Nullable}.  */ private boolean hasNullableAnnotation() {     for (Annotation ann : getParameterAnnotations()) {         if ("Nullable".equals(ann.annotationType().getSimpleName())) {             return true.         }     }     return false. }
true;public;0;3;/**  * Return a variant of this {@code MethodParameter} which points to  * the same parameter but one nesting level deeper in case of a  * {@link java.util.Optional} declaration.  * @since 4.3  * @see #isOptional()  * @see #nested()  */ ;/**  * Return a variant of this {@code MethodParameter} which points to  * the same parameter but one nesting level deeper in case of a  * {@link java.util.Optional} declaration.  * @since 4.3  * @see #isOptional()  * @see #nested()  */ public MethodParameter nestedIfOptional() {     return (getParameterType() == Optional.class ? nested() : this). }
true;;1;3;/**  * Set a containing class to resolve the parameter type against.  */ ;/**  * Set a containing class to resolve the parameter type against.  */ void setContainingClass(Class<?> containingClass) {     this.containingClass = containingClass. }
false;public;0;4;;public Class<?> getContainingClass() {     Class<?> containingClass = this.containingClass.     return (containingClass != null ? containingClass : getDeclaringClass()). }
true;;1;3;/**  * Set a resolved (generic) parameter type.  */ ;/**  * Set a resolved (generic) parameter type.  */ void setParameterType(@Nullable Class<?> parameterType) {     this.parameterType = parameterType. }
true;public;0;14;/**  * Return the type of the method/constructor parameter.  * @return the parameter type (never {@code null})  */ ;/**  * Return the type of the method/constructor parameter.  * @return the parameter type (never {@code null})  */ public Class<?> getParameterType() {     Class<?> paramType = this.parameterType.     if (paramType == null) {         if (this.parameterIndex < 0) {             Method method = getMethod().             paramType = (method != null ? method.getReturnType() : void.class).         } else {             paramType = this.executable.getParameterTypes()[this.parameterIndex].         }         this.parameterType = paramType.     }     return paramType. }
true;public;0;25;/**  * Return the generic type of the method/constructor parameter.  * @return the parameter type (never {@code null})  * @since 3.0  */ ;/**  * Return the generic type of the method/constructor parameter.  * @return the parameter type (never {@code null})  * @since 3.0  */ public Type getGenericParameterType() {     Type paramType = this.genericParameterType.     if (paramType == null) {         if (this.parameterIndex < 0) {             Method method = getMethod().             paramType = (method != null ? method.getGenericReturnType() : void.class).         } else {             Type[] genericParameterTypes = this.executable.getGenericParameterTypes().             int index = this.parameterIndex.             if (this.executable instanceof Constructor && ClassUtils.isInnerClass(this.executable.getDeclaringClass()) && genericParameterTypes.length == this.executable.getParameterCount() - 1) {                 // Bug in javac: type array excludes enclosing instance parameter                 // for inner classes with at least one generic constructor parameter,                 // so access it with the actual parameter index lowered by 1                 index = this.parameterIndex - 1.             }             paramType = (index >= 0 && index < genericParameterTypes.length ? genericParameterTypes[index] : getParameterType()).         }         this.genericParameterType = paramType.     }     return paramType. }
true;public;0;26;/**  * Return the nested type of the method/constructor parameter.  * @return the parameter type (never {@code null})  * @since 3.1  * @see #getNestingLevel()  */ ;/**  * Return the nested type of the method/constructor parameter.  * @return the parameter type (never {@code null})  * @since 3.1  * @see #getNestingLevel()  */ public Class<?> getNestedParameterType() {     if (this.nestingLevel > 1) {         Type type = getGenericParameterType().         for (int i = 2. i <= this.nestingLevel. i++) {             if (type instanceof ParameterizedType) {                 Type[] args = ((ParameterizedType) type).getActualTypeArguments().                 Integer index = getTypeIndexForLevel(i).                 type = args[index != null ? index : args.length - 1].             }         // TODO: Object.class if unresolvable         }         if (type instanceof Class) {             return (Class<?>) type.         } else if (type instanceof ParameterizedType) {             Type arg = ((ParameterizedType) type).getRawType().             if (arg instanceof Class) {                 return (Class<?>) arg.             }         }         return Object.class.     } else {         return getParameterType().     } }
true;public;0;16;/**  * Return the nested generic type of the method/constructor parameter.  * @return the parameter type (never {@code null})  * @since 4.2  * @see #getNestingLevel()  */ ;/**  * Return the nested generic type of the method/constructor parameter.  * @return the parameter type (never {@code null})  * @since 4.2  * @see #getNestingLevel()  */ public Type getNestedGenericParameterType() {     if (this.nestingLevel > 1) {         Type type = getGenericParameterType().         for (int i = 2. i <= this.nestingLevel. i++) {             if (type instanceof ParameterizedType) {                 Type[] args = ((ParameterizedType) type).getActualTypeArguments().                 Integer index = getTypeIndexForLevel(i).                 type = args[index != null ? index : args.length - 1].             }         }         return type.     } else {         return getGenericParameterType().     } }
true;public;0;3;/**  * Return the annotations associated with the target method/constructor itself.  */ ;/**  * Return the annotations associated with the target method/constructor itself.  */ public Annotation[] getMethodAnnotations() {     return adaptAnnotationArray(getAnnotatedElement().getAnnotations()). }
true;public;1;5;/**  * Return the method/constructor annotation of the given type, if available.  * @param annotationType the annotation type to look for  * @return the annotation object, or {@code null} if not found  */ ;/**  * Return the method/constructor annotation of the given type, if available.  * @param annotationType the annotation type to look for  * @return the annotation object, or {@code null} if not found  */ @Nullable public <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {     A annotation = getAnnotatedElement().getAnnotation(annotationType).     return (annotation != null ? adaptAnnotation(annotation) : null). }
true;public;1;3;/**  * Return whether the method/constructor is annotated with the given type.  * @param annotationType the annotation type to look for  * @since 4.3  * @see #getMethodAnnotation(Class)  */ ;/**  * Return whether the method/constructor is annotated with the given type.  * @param annotationType the annotation type to look for  * @since 4.3  * @see #getMethodAnnotation(Class)  */ public <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {     return getAnnotatedElement().isAnnotationPresent(annotationType). }
true;public;0;18;/**  * Return the annotations associated with the specific method/constructor parameter.  */ ;/**  * Return the annotations associated with the specific method/constructor parameter.  */ public Annotation[] getParameterAnnotations() {     Annotation[] paramAnns = this.parameterAnnotations.     if (paramAnns == null) {         Annotation[][] annotationArray = this.executable.getParameterAnnotations().         int index = this.parameterIndex.         if (this.executable instanceof Constructor && ClassUtils.isInnerClass(this.executable.getDeclaringClass()) && annotationArray.length == this.executable.getParameterCount() - 1) {             // Bug in javac in JDK <9: annotation array excludes enclosing instance parameter             // for inner classes, so access it with the actual parameter index lowered by 1             index = this.parameterIndex - 1.         }         paramAnns = (index >= 0 && index < annotationArray.length ? adaptAnnotationArray(annotationArray[index]) : EMPTY_ANNOTATION_ARRAY).         this.parameterAnnotations = paramAnns.     }     return paramAnns. }
true;public;0;3;/**  * Return {@code true} if the parameter has at least one annotation,  * {@code false} if it has none.  * @see #getParameterAnnotations()  */ ;/**  * Return {@code true} if the parameter has at least one annotation,  * {@code false} if it has none.  * @see #getParameterAnnotations()  */ public boolean hasParameterAnnotations() {     return (getParameterAnnotations().length != 0). }
true;public;1;11;/**  * Return the parameter annotation of the given type, if available.  * @param annotationType the annotation type to look for  * @return the annotation object, or {@code null} if not found  */ ;/**  * Return the parameter annotation of the given type, if available.  * @param annotationType the annotation type to look for  * @return the annotation object, or {@code null} if not found  */ @SuppressWarnings("unchecked") @Nullable public <A extends Annotation> A getParameterAnnotation(Class<A> annotationType) {     Annotation[] anns = getParameterAnnotations().     for (Annotation ann : anns) {         if (annotationType.isInstance(ann)) {             return (A) ann.         }     }     return null. }
true;public;1;3;/**  * Return whether the parameter is declared with the given annotation type.  * @param annotationType the annotation type to look for  * @see #getParameterAnnotation(Class)  */ ;/**  * Return whether the parameter is declared with the given annotation type.  * @param annotationType the annotation type to look for  * @see #getParameterAnnotation(Class)  */ public <A extends Annotation> boolean hasParameterAnnotation(Class<A> annotationType) {     return (getParameterAnnotation(annotationType) != null). }
true;public;1;3;/**  * Initialize parameter name discovery for this method parameter.  * <p>This method does not actually try to retrieve the parameter name at  * this point. it just allows discovery to happen when the application calls  * {@link #getParameterName()} (if ever).  */ ;/**  * Initialize parameter name discovery for this method parameter.  * <p>This method does not actually try to retrieve the parameter name at  * this point. it just allows discovery to happen when the application calls  * {@link #getParameterName()} (if ever).  */ public void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {     this.parameterNameDiscoverer = parameterNameDiscoverer. }
true;public;0;21;/**  * Return the name of the method/constructor parameter.  * @return the parameter name (may be {@code null} if no  * parameter name metadata is contained in the class file or no  * {@link #initParameterNameDiscovery ParameterNameDiscoverer}  * has been set to begin with)  */ ;/**  * Return the name of the method/constructor parameter.  * @return the parameter name (may be {@code null} if no  * parameter name metadata is contained in the class file or no  * {@link #initParameterNameDiscovery ParameterNameDiscoverer}  * has been set to begin with)  */ @Nullable public String getParameterName() {     if (this.parameterIndex < 0) {         return null.     }     ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer.     if (discoverer != null) {         String[] parameterNames = null.         if (this.executable instanceof Method) {             parameterNames = discoverer.getParameterNames((Method) this.executable).         } else if (this.executable instanceof Constructor) {             parameterNames = discoverer.getParameterNames((Constructor<?>) this.executable).         }         if (parameterNames != null) {             this.parameterName = parameterNames[this.parameterIndex].         }         this.parameterNameDiscoverer = null.     }     return this.parameterName. }
true;protected;1;3;/**  * A template method to post-process a given annotation instance before  * returning it to the caller.  * <p>The default implementation simply returns the given annotation as-is.  * @param annotation the annotation about to be returned  * @return the post-processed annotation (or simply the original one)  * @since 4.2  */ ;/**  * A template method to post-process a given annotation instance before  * returning it to the caller.  * <p>The default implementation simply returns the given annotation as-is.  * @param annotation the annotation about to be returned  * @return the post-processed annotation (or simply the original one)  * @since 4.2  */ protected <A extends Annotation> A adaptAnnotation(A annotation) {     return annotation. }
true;protected;1;3;/**  * A template method to post-process a given annotation array before  * returning it to the caller.  * <p>The default implementation simply returns the given annotation array as-is.  * @param annotations the annotation array about to be returned  * @return the post-processed annotation array (or simply the original one)  * @since 4.2  */ ;/**  * A template method to post-process a given annotation array before  * returning it to the caller.  * <p>The default implementation simply returns the given annotation array as-is.  * @param annotations the annotation array about to be returned  * @return the post-processed annotation array (or simply the original one)  * @since 4.2  */ protected Annotation[] adaptAnnotationArray(Annotation[] annotations) {     return annotations. }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof MethodParameter)) {         return false.     }     MethodParameter otherParam = (MethodParameter) other.     return (this.parameterIndex == otherParam.parameterIndex && getExecutable().equals(otherParam.getExecutable())). }
false;public;0;4;;@Override public int hashCode() {     return (getExecutable().hashCode() * 31 + this.parameterIndex). }
false;public;0;6;;@Override public String toString() {     Method method = getMethod().     return (method != null ? "method '" + method.getName() + "'" : "constructor") + " parameter " + this.parameterIndex. }
false;public;0;4;;@Override public MethodParameter clone() {     return new MethodParameter(this). }
true;public,static;2;8;/**  * Create a new MethodParameter for the given method or constructor.  * <p>This is a convenience factory method for scenarios where a  * Method or Constructor reference is treated in a generic fashion.  * @param methodOrConstructor the Method or Constructor to specify a parameter for  * @param parameterIndex the index of the parameter  * @return the corresponding MethodParameter instance  * @deprecated as of 5.0, in favor of {@link #forExecutable}  */ ;/**  * Create a new MethodParameter for the given method or constructor.  * <p>This is a convenience factory method for scenarios where a  * Method or Constructor reference is treated in a generic fashion.  * @param methodOrConstructor the Method or Constructor to specify a parameter for  * @param parameterIndex the index of the parameter  * @return the corresponding MethodParameter instance  * @deprecated as of 5.0, in favor of {@link #forExecutable}  */ @Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {     if (!(methodOrConstructor instanceof Executable)) {         throw new IllegalArgumentException("Given object [" + methodOrConstructor + "] is neither a Method nor a Constructor").     }     return forExecutable((Executable) methodOrConstructor, parameterIndex). }
true;public,static;2;11;/**  * Create a new MethodParameter for the given method or constructor.  * <p>This is a convenience factory method for scenarios where a  * Method or Constructor reference is treated in a generic fashion.  * @param executable the Method or Constructor to specify a parameter for  * @param parameterIndex the index of the parameter  * @return the corresponding MethodParameter instance  * @since 5.0  */ ;/**  * Create a new MethodParameter for the given method or constructor.  * <p>This is a convenience factory method for scenarios where a  * Method or Constructor reference is treated in a generic fashion.  * @param executable the Method or Constructor to specify a parameter for  * @param parameterIndex the index of the parameter  * @return the corresponding MethodParameter instance  * @since 5.0  */ public static MethodParameter forExecutable(Executable executable, int parameterIndex) {     if (executable instanceof Method) {         return new MethodParameter((Method) executable, parameterIndex).     } else if (executable instanceof Constructor) {         return new MethodParameter((Constructor<?>) executable, parameterIndex).     } else {         throw new IllegalArgumentException("Not a Method/Constructor: " + executable).     } }
true;public,static;1;3;/**  * Create a new MethodParameter for the given parameter descriptor.  * <p>This is a convenience factory method for scenarios where a  * Java 8 {@link Parameter} descriptor is already available.  * @param parameter the parameter descriptor  * @return the corresponding MethodParameter instance  * @since 5.0  */ ;/**  * Create a new MethodParameter for the given parameter descriptor.  * <p>This is a convenience factory method for scenarios where a  * Java 8 {@link Parameter} descriptor is already available.  * @param parameter the parameter descriptor  * @return the corresponding MethodParameter instance  * @since 5.0  */ public static MethodParameter forParameter(Parameter parameter) {     return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter)). }
false;protected,static;1;19;;protected static int findParameterIndex(Parameter parameter) {     Executable executable = parameter.getDeclaringExecutable().     Parameter[] allParams = executable.getParameters().     // Try first with identity checks for greater performance.     for (int i = 0. i < allParams.length. i++) {         if (parameter == allParams[i]) {             return i.         }     }     // conditions while invoking java.lang.reflect.Executable.getParameters().     for (int i = 0. i < allParams.length. i++) {         if (parameter.equals(allParams[i])) {             return i.         }     }     throw new IllegalArgumentException("Given parameter [" + parameter + "] does not match any parameter in the declaring executable"). }
false;private,static;2;6;;private static int validateIndex(Executable executable, int parameterIndex) {     int count = executable.getParameterCount().     Assert.isTrue(parameterIndex >= -1 && parameterIndex < count, () -> "Parameter index needs to be between -1 and " + (count - 1)).     return parameterIndex. }
true;public,static;1;32;/**  * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type  * or an optional parameter (with a default value in the Kotlin declaration).  */ ;/**  * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type  * or an optional parameter (with a default value in the Kotlin declaration).  */ public static boolean isOptional(MethodParameter param) {     Method method = param.getMethod().     Constructor<?> ctor = param.getConstructor().     int index = param.getParameterIndex().     if (method != null && index == -1) {         KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method).         return (function != null && function.getReturnType().isMarkedNullable()).     } else {         KFunction<?> function = null.         Predicate<KParameter> predicate = null.         if (method != null) {             function = ReflectJvmMapping.getKotlinFunction(method).             predicate = p -> KParameter.Kind.VALUE.equals(p.getKind()).         } else if (ctor != null) {             function = ReflectJvmMapping.getKotlinFunction(ctor).             predicate = p -> KParameter.Kind.VALUE.equals(p.getKind()) || KParameter.Kind.INSTANCE.equals(p.getKind()).         }         if (function != null) {             List<KParameter> parameters = function.getParameters().             KParameter parameter = parameters.stream().filter(predicate).collect(Collectors.toList()).get(index).             return (parameter.getType().isMarkedNullable() || parameter.isOptional()).         }     }     return false. }
