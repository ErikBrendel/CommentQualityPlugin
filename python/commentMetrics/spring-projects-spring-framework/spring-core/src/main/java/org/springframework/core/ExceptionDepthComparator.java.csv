commented;modifiers;parameterAmount;loc;comment;code
false;public;2;6;;@Override public int compare(Class<? extends Throwable> o1, Class<? extends Throwable> o2) {     int depth1 = getDepth(o1, this.targetException, 0).     int depth2 = getDepth(o2, this.targetException, 0).     return (depth1 - depth2). }
false;private;3;11;;private int getDepth(Class<?> declaredException, Class<?> exceptionToMatch, int depth) {     if (exceptionToMatch.equals(declaredException)) {         // Found it!         return depth.     }     // If we've gone as far as we can go and haven't found it...     if (exceptionToMatch == Throwable.class) {         return Integer.MAX_VALUE.     }     return getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + 1). }
true;public,static;2;11;/**  * Obtain the closest match from the given exception types for the given target exception.  * @param exceptionTypes the collection of exception types  * @param targetException the target exception to find a match for  * @return the closest matching exception type from the given collection  */ ;/**  * Obtain the closest match from the given exception types for the given target exception.  * @param exceptionTypes the collection of exception types  * @param targetException the target exception to find a match for  * @return the closest matching exception type from the given collection  */ public static Class<? extends Throwable> findClosestMatch(Collection<Class<? extends Throwable>> exceptionTypes, Throwable targetException) {     Assert.notEmpty(exceptionTypes, "Exception types must not be empty").     if (exceptionTypes.size() == 1) {         return exceptionTypes.iterator().next().     }     List<Class<? extends Throwable>> handledExceptions = new ArrayList<>(exceptionTypes).     handledExceptions.sort(new ExceptionDepthComparator(targetException)).     return handledExceptions.get(0). }
