commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public boolean evaluate(Object name) {     return reservedClassNames.contains(name). }
false;public;1;3;;public Object apply(AbstractClassGenerator gen) {     return gen.key. }
false;public;1;4;;public Object apply(AbstractClassGenerator gen) {     Class klass = gen.generate(ClassLoaderData.this).     return gen.wrapCachedClass(klass). }
false;public;0;3;;public ClassLoader getClassLoader() {     return classLoader.get(). }
false;public;1;3;;public void reserveName(String name) {     reservedClassNames.add(name). }
false;public;0;3;;public Predicate getUniqueNamePredicate() {     return uniqueNamePredicate. }
false;public;2;9;;public Object get(AbstractClassGenerator gen, boolean useCache) {     if (!useCache) {         return gen.generate(ClassLoaderData.this).     } else {         Object cachedValue = generatedClasses.get(gen).         return gen.unwrapCachedValue(cachedValue).     } }
false;protected;1;3;;protected T wrapCachedClass(Class klass) {     return (T) new WeakReference(klass). }
false;protected;1;3;;protected Object unwrapCachedValue(T cached) {     return ((WeakReference) cached).get(). }
false;protected;1;3;;protected void setNamePrefix(String namePrefix) {     this.namePrefix = namePrefix. }
false;final,protected;0;3;;final protected String getClassName() {     return className. }
false;private;1;3;;private void setClassName(String className) {     this.className = className. }
false;private;1;3;;private String generateClassName(Predicate nameTestPredicate) {     return namingPolicy.getClassName(namePrefix, source.name, key, nameTestPredicate). }
true;public;1;3;/**  * Set the <code>ClassLoader</code> in which the class will be generated.  * Concrete subclasses of <code>AbstractClassGenerator</code> (such as <code>Enhancer</code>)  * will try to choose an appropriate default if this is unset.  * <p>  * Classes are cached per-<code>ClassLoader</code> using a <code>WeakHashMap</code>, to allow  * the generated classes to be removed when the associated loader is garbage collected.  * @param classLoader the loader to generate the new class with, or null to use the default  */ ;/**  * Set the <code>ClassLoader</code> in which the class will be generated.  * Concrete subclasses of <code>AbstractClassGenerator</code> (such as <code>Enhancer</code>)  * will try to choose an appropriate default if this is unset.  * <p>  * Classes are cached per-<code>ClassLoader</code> using a <code>WeakHashMap</code>, to allow  * the generated classes to be removed when the associated loader is garbage collected.  * @param classLoader the loader to generate the new class with, or null to use the default  */ public void setClassLoader(ClassLoader classLoader) {     this.classLoader = classLoader. }
true;public;1;3;// SPRING PATCH BEGIN ;// SPRING PATCH BEGIN public void setContextClass(Class contextClass) {     this.contextClass = contextClass. }
true;public;1;5;/**  * Override the default naming policy.  * @param namingPolicy the custom policy, or null to use the default  * @see DefaultNamingPolicy  */ ;// SPRING PATCH END /**  * Override the default naming policy.  * @param namingPolicy the custom policy, or null to use the default  * @see DefaultNamingPolicy  */ public void setNamingPolicy(NamingPolicy namingPolicy) {     if (namingPolicy == null)         namingPolicy = DefaultNamingPolicy.INSTANCE.     this.namingPolicy = namingPolicy. }
true;public;0;3;/**  * @see #setNamingPolicy  */ ;/**  * @see #setNamingPolicy  */ public NamingPolicy getNamingPolicy() {     return namingPolicy. }
true;public;1;3;/**  * Whether use and update the static cache of generated classes  * for a class with the same properties. Default is <code>true</code>.  */ ;/**  * Whether use and update the static cache of generated classes  * for a class with the same properties. Default is <code>true</code>.  */ public void setUseCache(boolean useCache) {     this.useCache = useCache. }
true;public;0;3;/**  * @see #setUseCache  */ ;/**  * @see #setUseCache  */ public boolean getUseCache() {     return useCache. }
true;public;1;3;/**  * If set, CGLIB will attempt to load classes from the specified  * <code>ClassLoader</code> before generating them. Because generated  * class names are not guaranteed to be unique, the default is <code>false</code>.  */ ;/**  * If set, CGLIB will attempt to load classes from the specified  * <code>ClassLoader</code> before generating them. Because generated  * class names are not guaranteed to be unique, the default is <code>false</code>.  */ public void setAttemptLoad(boolean attemptLoad) {     this.attemptLoad = attemptLoad. }
false;public;0;3;;public boolean getAttemptLoad() {     return attemptLoad. }
true;public;1;5;/**  * Set the strategy to use to create the bytecode from this generator.  * By default an instance of {@see DefaultGeneratorStrategy} is used.  */ ;/**  * Set the strategy to use to create the bytecode from this generator.  * By default an instance of {@see DefaultGeneratorStrategy} is used.  */ public void setStrategy(GeneratorStrategy strategy) {     if (strategy == null)         strategy = DefaultGeneratorStrategy.INSTANCE.     this.strategy = strategy. }
true;public;0;3;/**  * @see #setStrategy  */ ;/**  * @see #setStrategy  */ public GeneratorStrategy getStrategy() {     return strategy. }
true;public,static;0;3;/**  * Used internally by CGLIB. Returns the <code>AbstractClassGenerator</code>  * that is being used to generate a class in the current thread.  */ ;/**  * Used internally by CGLIB. Returns the <code>AbstractClassGenerator</code>  * that is being used to generate a class in the current thread.  */ public static AbstractClassGenerator getCurrent() {     return (AbstractClassGenerator) CURRENT.get(). }
false;public;0;16;;public ClassLoader getClassLoader() {     ClassLoader t = classLoader.     if (t == null) {         t = getDefaultClassLoader().     }     if (t == null) {         t = getClass().getClassLoader().     }     if (t == null) {         t = Thread.currentThread().getContextClassLoader().     }     if (t == null) {         throw new IllegalStateException("Cannot determine classloader").     }     return t. }
false;abstract,protected;0;1;;abstract protected ClassLoader getDefaultClassLoader().
true;protected;0;3;/**  * Returns the protection domain to use when defining the class.  * <p>  * Default implementation returns <code>null</code> for using a default protection domain. Sub-classes may  * override to use a more specific protection domain.  * </p>  * @return the protection domain (<code>null</code> for using a default)  */ ;/**  * Returns the protection domain to use when defining the class.  * <p>  * Default implementation returns <code>null</code> for using a default protection domain. Sub-classes may  * override to use a more specific protection domain.  * </p>  * @return the protection domain (<code>null</code> for using a default)  */ protected ProtectionDomain getProtectionDomain() {     return null. }
false;protected;1;31;;protected Object create(Object key) {     try {         ClassLoader loader = getClassLoader().         Map<ClassLoader, ClassLoaderData> cache = CACHE.         ClassLoaderData data = cache.get(loader).         if (data == null) {             synchronized (AbstractClassGenerator.class) {                 cache = CACHE.                 data = cache.get(loader).                 if (data == null) {                     Map<ClassLoader, ClassLoaderData> newCache = new WeakHashMap<ClassLoader, ClassLoaderData>(cache).                     data = new ClassLoaderData(loader).                     newCache.put(loader, data).                     CACHE = newCache.                 }             }         }         this.key = key.         Object obj = data.get(this, getUseCache()).         if (obj instanceof Class) {             return firstInstance((Class) obj).         }         return nextInstance(obj).     } catch (RuntimeException | Error ex) {         throw ex.     } catch (Exception ex) {         throw new CodeGenerationException(ex).     } }
false;protected;1;45;;protected Class generate(ClassLoaderData data) {     Class gen.     Object save = CURRENT.get().     CURRENT.set(this).     try {         ClassLoader classLoader = data.getClassLoader().         if (classLoader == null) {             throw new IllegalStateException("ClassLoader is null while trying to define class " + getClassName() + ". It seems that the loader has been expired from a weak reference somehow. " + "Please file an issue at cglib's issue tracker.").         }         synchronized (classLoader) {             String name = generateClassName(data.getUniqueNamePredicate()).             data.reserveName(name).             this.setClassName(name).         }         if (attemptLoad) {             try {                 gen = classLoader.loadClass(getClassName()).                 return gen.             } catch (ClassNotFoundException e) {             // ignore             }         }         byte[] b = strategy.generate(this).         String className = ClassNameReader.getClassName(new ClassReader(b)).         ProtectionDomain protectionDomain = getProtectionDomain().         synchronized (classLoader) {             // just in case             // SPRING PATCH BEGIN             gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain, contextClass).         // SPRING PATCH END         }         return gen.     } catch (RuntimeException | Error ex) {         throw ex.     } catch (Exception ex) {         throw new CodeGenerationException(ex).     } finally {         CURRENT.set(save).     } }
false;abstract,protected;1;1;;abstract protected Object firstInstance(Class type) throws Exception.
false;abstract,protected;1;1;;abstract protected Object nextInstance(Object instance) throws Exception.
