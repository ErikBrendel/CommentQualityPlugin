commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;9;/**  * Copy the contents of the given InputStream into a new byte array.  * Leaves the stream open when done.  * @param in the stream to copy from (may be {@code null} or empty)  * @return the new byte array that has been copied to (possibly empty)  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given InputStream into a new byte array.  * Leaves the stream open when done.  * @param in the stream to copy from (may be {@code null} or empty)  * @return the new byte array that has been copied to (possibly empty)  * @throws IOException in case of I/O errors  */ public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException {     if (in == null) {         return new byte[0].     }     ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE).     copy(in, out).     return out.toByteArray(). }
true;public,static;2;14;/**  * Copy the contents of the given InputStream into a String.  * Leaves the stream open when done.  * @param in the InputStream to copy from (may be {@code null} or empty)  * @return the String that has been copied to (possibly empty)  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given InputStream into a String.  * Leaves the stream open when done.  * @param in the InputStream to copy from (may be {@code null} or empty)  * @return the String that has been copied to (possibly empty)  * @throws IOException in case of I/O errors  */ public static String copyToString(@Nullable InputStream in, Charset charset) throws IOException {     if (in == null) {         return "".     }     StringBuilder out = new StringBuilder().     InputStreamReader reader = new InputStreamReader(in, charset).     char[] buffer = new char[BUFFER_SIZE].     int bytesRead = -1.     while ((bytesRead = reader.read(buffer)) != -1) {         out.append(buffer, 0, bytesRead).     }     return out.toString(). }
true;public,static;2;6;/**  * Copy the contents of the given byte array to the given OutputStream.  * Leaves the stream open when done.  * @param in the byte array to copy from  * @param out the OutputStream to copy to  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given byte array to the given OutputStream.  * Leaves the stream open when done.  * @param in the byte array to copy from  * @param out the OutputStream to copy to  * @throws IOException in case of I/O errors  */ public static void copy(byte[] in, OutputStream out) throws IOException {     Assert.notNull(in, "No input byte array specified").     Assert.notNull(out, "No OutputStream specified").     out.write(in). }
true;public,static;3;9;/**  * Copy the contents of the given String to the given output OutputStream.  * Leaves the stream open when done.  * @param in the String to copy from  * @param charset the Charset  * @param out the OutputStream to copy to  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given String to the given output OutputStream.  * Leaves the stream open when done.  * @param in the String to copy from  * @param charset the Charset  * @param out the OutputStream to copy to  * @throws IOException in case of I/O errors  */ public static void copy(String in, Charset charset, OutputStream out) throws IOException {     Assert.notNull(in, "No input String specified").     Assert.notNull(charset, "No charset specified").     Assert.notNull(out, "No OutputStream specified").     Writer writer = new OutputStreamWriter(out, charset).     writer.write(in).     writer.flush(). }
true;public,static;2;14;/**  * Copy the contents of the given InputStream to the given OutputStream.  * Leaves both streams open when done.  * @param in the InputStream to copy from  * @param out the OutputStream to copy to  * @return the number of bytes copied  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given InputStream to the given OutputStream.  * Leaves both streams open when done.  * @param in the InputStream to copy from  * @param out the OutputStream to copy to  * @return the number of bytes copied  * @throws IOException in case of I/O errors  */ public static int copy(InputStream in, OutputStream out) throws IOException {     Assert.notNull(in, "No InputStream specified").     Assert.notNull(out, "No OutputStream specified").     int byteCount = 0.     byte[] buffer = new byte[BUFFER_SIZE].     int bytesRead = -1.     while ((bytesRead = in.read(buffer)) != -1) {         out.write(buffer, 0, bytesRead).         byteCount += bytesRead.     }     out.flush().     return byteCount. }
true;public,static;4;27;/**  * Copy a range of content of the given InputStream to the given OutputStream.  * <p>If the specified range exceeds the length of the InputStream, this copies  * up to the end of the stream and returns the actual number of copied bytes.  * <p>Leaves both streams open when done.  * @param in the InputStream to copy from  * @param out the OutputStream to copy to  * @param start the position to start copying from  * @param end the position to end copying  * @return the number of bytes copied  * @throws IOException in case of I/O errors  * @since 4.3  */ ;/**  * Copy a range of content of the given InputStream to the given OutputStream.  * <p>If the specified range exceeds the length of the InputStream, this copies  * up to the end of the stream and returns the actual number of copied bytes.  * <p>Leaves both streams open when done.  * @param in the InputStream to copy from  * @param out the OutputStream to copy to  * @param start the position to start copying from  * @param end the position to end copying  * @return the number of bytes copied  * @throws IOException in case of I/O errors  * @since 4.3  */ public static long copyRange(InputStream in, OutputStream out, long start, long end) throws IOException {     Assert.notNull(in, "No InputStream specified").     Assert.notNull(out, "No OutputStream specified").     long skipped = in.skip(start).     if (skipped < start) {         throw new IOException("Skipped only " + skipped + " bytes out of " + start + " required").     }     long bytesToCopy = end - start + 1.     byte[] buffer = new byte[StreamUtils.BUFFER_SIZE].     while (bytesToCopy > 0) {         int bytesRead = in.read(buffer).         if (bytesRead == -1) {             break.         } else if (bytesRead <= bytesToCopy) {             out.write(buffer, 0, bytesRead).             bytesToCopy -= bytesRead.         } else {             out.write(buffer, 0, (int) bytesToCopy).             bytesToCopy = 0.         }     }     return (end - start + 1 - bytesToCopy). }
true;public,static;1;10;/**  * Drain the remaining content of the given InputStream.  * Leaves the InputStream open when done.  * @param in the InputStream to drain  * @return the number of bytes read  * @throws IOException in case of I/O errors  * @since 4.3  */ ;/**  * Drain the remaining content of the given InputStream.  * Leaves the InputStream open when done.  * @param in the InputStream to drain  * @return the number of bytes read  * @throws IOException in case of I/O errors  * @since 4.3  */ public static int drain(InputStream in) throws IOException {     Assert.notNull(in, "No InputStream specified").     byte[] buffer = new byte[BUFFER_SIZE].     int bytesRead = -1.     int byteCount = 0.     while ((bytesRead = in.read(buffer)) != -1) {         byteCount += bytesRead.     }     return byteCount. }
true;public,static;0;3;/**  * Return an efficient empty {@link InputStream}.  * @return a {@link ByteArrayInputStream} based on an empty byte array  * @since 4.2.2  */ ;/**  * Return an efficient empty {@link InputStream}.  * @return a {@link ByteArrayInputStream} based on an empty byte array  * @since 4.2.2  */ public static InputStream emptyInput() {     return new ByteArrayInputStream(EMPTY_CONTENT). }
true;public,static;1;4;/**  * Return a variant of the given {@link InputStream} where calling  * {@link InputStream#close() close()} has no effect.  * @param in the InputStream to decorate  * @return a version of the InputStream that ignores calls to close  */ ;/**  * Return a variant of the given {@link InputStream} where calling  * {@link InputStream#close() close()} has no effect.  * @param in the InputStream to decorate  * @return a version of the InputStream that ignores calls to close  */ public static InputStream nonClosing(InputStream in) {     Assert.notNull(in, "No InputStream specified").     return new NonClosingInputStream(in). }
true;public,static;1;4;/**  * Return a variant of the given {@link OutputStream} where calling  * {@link OutputStream#close() close()} has no effect.  * @param out the OutputStream to decorate  * @return a version of the OutputStream that ignores calls to close  */ ;/**  * Return a variant of the given {@link OutputStream} where calling  * {@link OutputStream#close() close()} has no effect.  * @param out the OutputStream to decorate  * @return a version of the OutputStream that ignores calls to close  */ public static OutputStream nonClosing(OutputStream out) {     Assert.notNull(out, "No OutputStream specified").     return new NonClosingOutputStream(out). }
false;public;0;3;;@Override public void close() throws IOException { }
false;public;3;5;;@Override public void write(byte[] b, int off, int let) throws IOException {     // It is critical that we override this method for performance     this.out.write(b, off, let). }
false;public;0;3;;@Override public void close() throws IOException { }
