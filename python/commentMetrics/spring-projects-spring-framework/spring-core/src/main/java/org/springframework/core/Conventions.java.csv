# id;timestamp;commentText;codeText;commentWords;codeWords
Conventions -> private static Class getClassForValue(Object value);1328020251;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class getClassForValue(Object value) {_		Class valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class[] ifcs = valueClass.getInterfaces()__			for (Class ifc : ifcs) {_				if (!ignoredInterfaces.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,ignored,interfaces,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class getClassForValue(Object value);1356735495;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class getClassForValue(Object value) {_		Class valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class[] ifcs = valueClass.getInterfaces()__			for (Class ifc : ifcs) {_				if (!ignoredInterfaces.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,ignored,interfaces,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1385412762;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class.equals(resolvedType)) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,equals,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1432125256;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1467730834;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1474905889;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1477045587;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1481579380;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1485277217;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1492570843;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1492570843;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType___			ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__			if (adapter != null && !adapter.getDescriptor().isNoValue()) {_				reactiveSuffix = ClassUtils.getShortName(valueClass)__				valueClass = ResolvableType.forMethodReturnType(method).getGeneric(0).resolve()__			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,0,resolve,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value);1492572344;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection.__<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>__@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric(0).resolve()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,0,resolve,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> private static String pluralize(String name);1328020251;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1356735495;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1385412762;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1432125256;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1467730834;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1474905889;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1477045587;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1481579380;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1485277217;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1492570843;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1492570843;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1492572344;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1495868221;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1496837955;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1511215342;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1515431102;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1530190072;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1530532518;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> private static String pluralize(String name);1532520919;Pluralize the given name.;private static String pluralize(String name) {_		return name + PLURAL_SUFFIX__	};pluralize,the,given,name;private,static,string,pluralize,string,name,return,name
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1495868221;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1496837955;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1511215342;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1515431102;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1530190072;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1530532518;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, @Nullable Object value);1532520919;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, @Nullable Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,nullable,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1328020251;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1356735495;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1385412762;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1432125256;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1467730834;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1474905889;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1477045587;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1481579380;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = GenericCollectionTypeResolver.getCollectionParameterType(parameter)__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,generic,collection,type,resolver,get,collection,parameter,type,parameter,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1485277217;Determine the conventional variable name for the supplied parameter,_taking the generic collection type (if any) into account._@param parameter the method or constructor parameter to generate a variable name for_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1492570843;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account._@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1492570843;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account._@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()___			ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__			if (adapter != null && !adapter.getDescriptor().isNoValue()) {_				reactiveSuffix = ClassUtils.getShortName(valueClass)__				valueClass = parameter.nested().getNestedParameterType()__			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1492572344;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account.__<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>__@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1495868221;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account.__<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>__@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1496837955;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account.__<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>__@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1511215342;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account.__<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>__@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1515431102;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1530190072;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__			ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance()__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,reactive,adapter,registry,reactive,adapter,registry,reactive,adapter,registry,get,shared,instance,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1530532518;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__			ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance()__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,reactive,adapter,registry,reactive,adapter,registry,reactive,adapter,registry,get,shared,instance,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForParameter(MethodParameter parameter);1532520919;Determine the conventional variable name for the given parameter taking_the generic collection type, if any, into account._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param parameter the method or constructor parameter_@return the generated variable name;public static String getVariableNameForParameter(MethodParameter parameter) {_		Assert.notNull(parameter, "MethodParameter must not be null")__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (parameter.getParameterType().isArray()) {_			valueClass = parameter.getParameterType().getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {_			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric()__			if (valueClass == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for non-typed Collection parameter type")__			}_			pluralize = true__		}_		else {_			valueClass = parameter.getParameterType()__			ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance()__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = parameter.nested().getNestedParameterType()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,given,parameter,taking,the,generic,collection,type,if,any,into,account,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,parameter,the,method,or,constructor,parameter,return,the,generated,variable,name;public,static,string,get,variable,name,for,parameter,method,parameter,parameter,assert,not,null,parameter,method,parameter,must,not,be,null,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,parameter,get,parameter,type,is,array,value,class,parameter,get,parameter,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,parameter,get,parameter,type,value,class,resolvable,type,for,method,parameter,parameter,as,collection,resolve,generic,if,value,class,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,parameter,type,pluralize,true,else,value,class,parameter,get,parameter,type,reactive,adapter,registry,reactive,adapter,registry,reactive,adapter,registry,get,shared,instance,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,parameter,nested,get,nested,parameter,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class resolvedType, Object value);1328020251;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as <code>Object</code> or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be <code>null</code> if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class.equals(resolvedType)) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection collection = (Collection) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,code,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,code,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,equals,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableNameForReturnType(Method method, Class resolvedType, Object value);1356735495;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class resolvedType, Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class.equals(resolvedType)) {_			if (value == null) {_				throw new IllegalArgumentException("Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class valueClass__		boolean pluralize = false___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = GenericCollectionTypeResolver.getCollectionReturnType(method)__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and a non-Collection value")__				}_				Collection collection = (Collection) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException(_							"Cannot generate variable name for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,equals,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,generic,collection,type,resolver,get,collection,return,type,method,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getQualifiedAttributeName(Class enclosingClass, String attributeName);1328020251;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '<code>foo</code>' qualified by {@link Class} '<code>com.myapp.SomeClass</code>'_would be '<code>com.myapp.SomeClass.foo</code>';public static String getQualifiedAttributeName(Class enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + "." + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,code,qualified,by,link,class,code,com,myapp,some,class,code,would,be,code,com,myapp,some,class,foo,code;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class enclosingClass, String attributeName);1356735495;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + "." + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getVariableNameForReturnType(Method method);1328020251;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1356735495;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1385412762;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1432125256;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1467730834;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1474905889;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1477045587;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1481579380;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1485277217;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1492570843;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1492570843;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1492572344;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1495868221;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1496837955;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1511215342;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1515431102;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1530190072;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1530532518;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method);1532520919;Determine the conventional variable name for the return type of the_given method, taking the generic collection type, if any, into account._@param method the method to generate a variable name for_@return the generated variable name;public static String getVariableNameForReturnType(Method method) {_		return getVariableNameForReturnType(method, method.getReturnType(), null)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,param,method,the,method,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,return,get,variable,name,for,return,type,method,method,get,return,type,null
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1328020251;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as <code>Object</code> or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be <code>null</code> if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,code,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,code,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1356735495;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1385412762;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1432125256;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1467730834;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1474905889;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1477045587;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1481579380;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1485277217;Determine the conventional variable name for the return type of the supplied method,_taking the generic collection type (if any) into account, falling back to the_given return value if the method declaration is not specific enough (i.e. in case of_the return type being declared as {@code Object} or as untyped collection)._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,supplied,method,taking,the,generic,collection,type,if,any,into,account,falling,back,to,the,given,return,value,if,the,method,declaration,is,not,specific,enough,i,e,in,case,of,the,return,type,being,declared,as,code,object,or,as,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1492570843;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1492570843;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> public static String getVariableNameForReturnType(Method method, Object value);1492572344;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given actual return value if the method declaration is not_specific enough, e.g. {@code Object} return type or untyped collection._@param method the method to generate a variable name for_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Object value) {_		return getVariableNameForReturnType(method, method.getReturnType(), value)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,actual,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,param,method,the,method,to,generate,a,variable,name,for,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,object,value,return,get,variable,name,for,return,type,method,method,get,return,type,value
Conventions -> private static Class<?> getClassForValue(Object value);1385412762;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1432125256;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1467730834;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1474905889;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1477045587;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1481579380;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1485277217;Determines the class to use for naming a variable that contains_the given value._<p>Will return the class of the given value, except when_encountering a JDK proxy, in which case it will determine_the 'primary' interface implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determines,the,class,to,use,for,naming,a,variable,that,contains,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1492570843;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1492570843;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1492572344;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1495868221;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1496837955;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1511215342;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!IGNORED_INTERFACES.contains(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,contains,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1515431102;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!ClassUtils.isJavaLanguageInterface(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1530190072;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!ClassUtils.isJavaLanguageInterface(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1530532518;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!ClassUtils.isJavaLanguageInterface(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> private static Class<?> getClassForValue(Object value);1532520919;Determine the class to use for naming a variable containing the given value._<p>Will return the class of the given value, except when encountering a_JDK proxy, in which case it will determine the 'primary' interface_implemented by that proxy._@param value the value to check_@return the class to use for naming a variable;private static Class<?> getClassForValue(Object value) {_		Class<?> valueClass = value.getClass()__		if (Proxy.isProxyClass(valueClass)) {_			Class<?>[] ifcs = valueClass.getInterfaces()__			for (Class<?> ifc : ifcs) {_				if (!ClassUtils.isJavaLanguageInterface(ifc)) {_					return ifc__				}_			}_		}_		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {_			_			_			valueClass = valueClass.getSuperclass()__		}_		return valueClass__	};determine,the,class,to,use,for,naming,a,variable,containing,the,given,value,p,will,return,the,class,of,the,given,value,except,when,encountering,a,jdk,proxy,in,which,case,it,will,determine,the,primary,interface,implemented,by,that,proxy,param,value,the,value,to,check,return,the,class,to,use,for,naming,a,variable;private,static,class,get,class,for,value,object,value,class,value,class,value,get,class,if,proxy,is,proxy,class,value,class,class,ifcs,value,class,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,return,ifc,else,if,value,class,get,name,last,index,of,1,value,class,get,declaring,class,null,value,class,value,class,get,superclass,return,value,class
Conventions -> public static String getVariableName(Object value);1328020251;Determine the conventional variable name for the supplied_<code>Object</code> based on its concrete type. The convention_used is to return the uncapitalized short name of the <code>Class</code>,_according to JavaBeans property naming rules: So,_<code>com.myapp.Product</code> becomes <code>product</code>__<code>com.myapp.MyProduct</code> becomes <code>myProduct</code>__<code>com.myapp.UKProduct</code> becomes <code>UKProduct</code>._<p>For arrays, we use the pluralized version of the array component type._For <code>Collection</code>s we attempt to 'peek ahead' in the_<code>Collection</code> to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection collection = (Collection) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,code,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,code,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,code,becomes,code,product,code,code,com,myapp,my,product,code,becomes,code,my,product,code,code,com,myapp,ukproduct,code,becomes,code,ukproduct,code,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,code,s,we,attempt,to,peek,ahead,in,the,code,collection,code,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1356735495;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection collection = (Collection) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1385412762;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1432125256;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1467730834;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1474905889;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1477045587;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1481579380;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1485277217;Determine the conventional variable name for the supplied_{@code Object} based on its concrete type. The convention_used is to return the uncapitalized short name of the {@code Class},_according to JavaBeans property naming rules: So,_{@code com.myapp.Product} becomes {@code product}__{@code com.myapp.MyProduct} becomes {@code myProduct}__{@code com.myapp.UKProduct} becomes {@code UKProduct}._<p>For arrays, we use the pluralized version of the array component type._For {@code Collection}s we attempt to 'peek ahead' in the_{@code Collection} to determine the component type and_return the pluralized version of that component type._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException("Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,uncapitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,so,code,com,myapp,product,becomes,code,product,code,com,myapp,my,product,becomes,code,my,product,code,com,myapp,ukproduct,becomes,code,ukproduct,p,for,arrays,we,use,the,pluralized,version,of,the,array,component,type,for,code,collection,s,we,attempt,to,peek,ahead,in,the,code,collection,to,determine,the,component,type,and,return,the,pluralized,version,of,that,component,type,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1492570843;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules.__<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>__<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version.__@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1492570843;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules.__<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>__<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version.__@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1492572344;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules.__<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>__<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version.__@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1495868221;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules.__<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>__<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version.__@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1496837955;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules.__<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>__<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version.__@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1511215342;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules.__<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>__<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version.__@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1515431102;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules._<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>_<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1530190072;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules._<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>_<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1530532518;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules._<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>_<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> public static String getVariableName(Object value);1532520919;Determine the conventional variable name for the supplied {@code Object}_based on its concrete type. The convention used is to return the_un-capitalized short name of the {@code Class}, according to JavaBeans_property naming rules._<p>For example:<br>_{@code com.myapp.Product} becomes {@code "product"}<br>_{@code com.myapp.MyProduct} becomes {@code "myProduct"}<br>_{@code com.myapp.UKProduct} becomes {@code "UKProduct"}<br>_<p>For arrays the pluralized version of the array component type is used._For {@code Collection}s an attempt is made to 'peek ahead' to determine_the component type and return its pluralized version._@param value the value to generate a variable name for_@return the generated variable name;public static String getVariableName(Object value) {_		Assert.notNull(value, "Value must not be null")__		Class<?> valueClass__		boolean pluralize = false___		if (value.getClass().isArray()) {_			valueClass = value.getClass().getComponentType()__			pluralize = true__		}_		else if (value instanceof Collection) {_			Collection<?> collection = (Collection<?>) value__			if (collection.isEmpty()) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an empty Collection")__			}_			Object valueToCheck = peekAhead(collection)__			valueClass = getClassForValue(valueToCheck)__			pluralize = true__		}_		else {_			valueClass = getClassForValue(value)__		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name)__	};determine,the,conventional,variable,name,for,the,supplied,code,object,based,on,its,concrete,type,the,convention,used,is,to,return,the,un,capitalized,short,name,of,the,code,class,according,to,java,beans,property,naming,rules,p,for,example,br,code,com,myapp,product,becomes,code,product,br,code,com,myapp,my,product,becomes,code,my,product,br,code,com,myapp,ukproduct,becomes,code,ukproduct,br,p,for,arrays,the,pluralized,version,of,the,array,component,type,is,used,for,code,collection,s,an,attempt,is,made,to,peek,ahead,to,determine,the,component,type,and,return,its,pluralized,version,param,value,the,value,to,generate,a,variable,name,for,return,the,generated,variable,name;public,static,string,get,variable,name,object,value,assert,not,null,value,value,must,not,be,null,class,value,class,boolean,pluralize,false,if,value,get,class,is,array,value,class,value,get,class,get,component,type,pluralize,true,else,if,value,instanceof,collection,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,empty,collection,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,get,class,for,value,value,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name
Conventions -> private static <E> E peekAhead(Collection<E> collection);1385412762;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retreived will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retreived,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1432125256;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retreived will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retreived,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1467730834;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retreived will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retreived,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1474905889;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retreived will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retreived,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1477045587;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retreived will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retreived,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1481579380;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1485277217;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1492570843;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1492570843;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1492572344;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1495868221;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1496837955;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1511215342;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1515431102;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1530190072;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1530532518;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static <E> E peekAhead(Collection<E> collection);1532520919;Retrieve the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retrieved will depend_on the concrete {@code Collection} implementation.;private static <E> E peekAhead(Collection<E> collection) {_		Iterator<E> it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		E value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieve,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retrieved,will,depend,on,the,concrete,code,collection,implementation;private,static,e,e,peek,ahead,collection,e,collection,iterator,e,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,e,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1495868221;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection.__<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>__@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType___			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric(0).resolve()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,0,resolve,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1496837955;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric().resolve(Object.class)__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,resolve,object,class,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1511215342;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric().resolve(Object.class)__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,resolve,object,class,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1515431102;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric().resolve(Object.class)__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,resolve,object,class,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1530190072;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__			ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance()__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric().resolve(Object.class)__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,reactive,adapter,registry,reactive,adapter,registry,reactive,adapter,registry,get,shared,instance,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,resolve,object,class,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1530532518;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__			ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance()__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric().resolve(Object.class)__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,reactive,adapter,registry,reactive,adapter,registry,reactive,adapter,registry,get,shared,instance,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,resolve,object,class,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value);1532520919;Determine the conventional variable name for the return type of the given_method, taking the generic collection type, if any, into account, falling_back on the given return value if the method declaration is not specific_enough, e.g. {@code Object} return type or untyped collection._<p>As of 5.0 this method supports reactive types:<br>_{@code Mono<com.myapp.Product>} becomes {@code "productMono"}<br>_{@code Flux<com.myapp.MyProduct>} becomes {@code "myProductFlux"}<br>_{@code Observable<com.myapp.MyProduct>} becomes {@code "myProductObservable"}<br>_@param method the method to generate a variable name for_@param resolvedType the resolved return type of the method_@param value the return value (may be {@code null} if not available)_@return the generated variable name;public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {_		Assert.notNull(method, "Method must not be null")___		if (Object.class == resolvedType) {_			if (value == null) {_				throw new IllegalArgumentException(_						"Cannot generate variable name for an Object return type with null value")__			}_			return getVariableName(value)__		}__		Class<?> valueClass__		boolean pluralize = false__		String reactiveSuffix = ""___		if (resolvedType.isArray()) {_			valueClass = resolvedType.getComponentType()__			pluralize = true__		}_		else if (Collection.class.isAssignableFrom(resolvedType)) {_			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric()__			if (valueClass == null) {_				if (!(value instanceof Collection)) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and a non-Collection value")__				}_				Collection<?> collection = (Collection<?>) value__				if (collection.isEmpty()) {_					throw new IllegalArgumentException("Cannot generate variable name " +_							"for non-typed Collection return type and an empty Collection value")__				}_				Object valueToCheck = peekAhead(collection)__				valueClass = getClassForValue(valueToCheck)__			}_			pluralize = true__		}_		else {_			valueClass = resolvedType__			ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance()__			if (reactiveAdapterRegistry.hasAdapters()) {_				ReactiveAdapter adapter = reactiveAdapterRegistry.getAdapter(valueClass)__				if (adapter != null && !adapter.getDescriptor().isNoValue()) {_					reactiveSuffix = ClassUtils.getShortName(valueClass)__					valueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass()__				}_			}_		}__		String name = ClassUtils.getShortNameAsProperty(valueClass)__		return (pluralize ? pluralize(name) : name + reactiveSuffix)__	};determine,the,conventional,variable,name,for,the,return,type,of,the,given,method,taking,the,generic,collection,type,if,any,into,account,falling,back,on,the,given,return,value,if,the,method,declaration,is,not,specific,enough,e,g,code,object,return,type,or,untyped,collection,p,as,of,5,0,this,method,supports,reactive,types,br,code,mono,com,myapp,product,becomes,code,product,mono,br,code,flux,com,myapp,my,product,becomes,code,my,product,flux,br,code,observable,com,myapp,my,product,becomes,code,my,product,observable,br,param,method,the,method,to,generate,a,variable,name,for,param,resolved,type,the,resolved,return,type,of,the,method,param,value,the,return,value,may,be,code,null,if,not,available,return,the,generated,variable,name;public,static,string,get,variable,name,for,return,type,method,method,class,resolved,type,nullable,object,value,assert,not,null,method,method,must,not,be,null,if,object,class,resolved,type,if,value,null,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,an,object,return,type,with,null,value,return,get,variable,name,value,class,value,class,boolean,pluralize,false,string,reactive,suffix,if,resolved,type,is,array,value,class,resolved,type,get,component,type,pluralize,true,else,if,collection,class,is,assignable,from,resolved,type,value,class,resolvable,type,for,method,return,type,method,as,collection,resolve,generic,if,value,class,null,if,value,instanceof,collection,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,a,non,collection,value,collection,collection,collection,value,if,collection,is,empty,throw,new,illegal,argument,exception,cannot,generate,variable,name,for,non,typed,collection,return,type,and,an,empty,collection,value,object,value,to,check,peek,ahead,collection,value,class,get,class,for,value,value,to,check,pluralize,true,else,value,class,resolved,type,reactive,adapter,registry,reactive,adapter,registry,reactive,adapter,registry,get,shared,instance,if,reactive,adapter,registry,has,adapters,reactive,adapter,adapter,reactive,adapter,registry,get,adapter,value,class,if,adapter,null,adapter,get,descriptor,is,no,value,reactive,suffix,class,utils,get,short,name,value,class,value,class,resolvable,type,for,method,return,type,method,get,generic,to,class,string,name,class,utils,get,short,name,as,property,value,class,return,pluralize,pluralize,name,name,reactive,suffix
Conventions -> public static String attributeNameToPropertyName(String attributeName);1328020251;Convert <code>String</code>s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, <code>transaction-manager</code> is_converted into <code>transactionManager</code>.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,code,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,code,is,converted,into,code,transaction,manager,code;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1356735495;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1385412762;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1432125256;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1467730834;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1474905889;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1477045587;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1481579380;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1485277217;Convert {@code String}s in attribute name format (lowercase, hyphens separating words)_into property name format (camel-cased). For example, {@code transaction-manager} is_converted into {@code transactionManager}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,lowercase,hyphens,separating,words,into,property,name,format,camel,cased,for,example,code,transaction,manager,is,converted,into,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1492570843;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1492570843;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1492572344;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1495868221;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1496837955;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1511215342;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1515431102;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1530190072;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1530532518;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> public static String attributeNameToPropertyName(String attributeName);1532520919;Convert {@code String}s in attribute name format (e.g. lowercase, hyphens_separating words) into property name format (camel-case). For example_{@code transaction-manager} becomes {@code "transactionManager"}.;public static String attributeNameToPropertyName(String attributeName) {_		Assert.notNull(attributeName, "'attributeName' must not be null")__		if (!attributeName.contains("-")) {_			return attributeName__		}_		char[] chars = attributeName.toCharArray()__		char[] result = new char[chars.length -1]_ _		int currPos = 0__		boolean upperCaseNext = false__		for (char c : chars) {_			if (c == '-') {_				upperCaseNext = true__			}_			else if (upperCaseNext) {_				result[currPos++] = Character.toUpperCase(c)__				upperCaseNext = false__			}_			else {_				result[currPos++] = c__			}_		}_		return new String(result, 0, currPos)__	};convert,code,string,s,in,attribute,name,format,e,g,lowercase,hyphens,separating,words,into,property,name,format,camel,case,for,example,code,transaction,manager,becomes,code,transaction,manager;public,static,string,attribute,name,to,property,name,string,attribute,name,assert,not,null,attribute,name,attribute,name,must,not,be,null,if,attribute,name,contains,return,attribute,name,char,chars,attribute,name,to,char,array,char,result,new,char,chars,length,1,int,curr,pos,0,boolean,upper,case,next,false,for,char,c,chars,if,c,upper,case,next,true,else,if,upper,case,next,result,curr,pos,character,to,upper,case,c,upper,case,next,false,else,result,curr,pos,c,return,new,string,result,0,curr,pos
Conventions -> private static Object peekAhead(Collection collection);1328020251;Retrieves the <code>Class</code> of an element in the <code>Collection</code>._The exact element for which the <code>Class</code> is retreived will depend_on the concrete <code>Collection</code> implementation.;private static Object peekAhead(Collection collection) {_		Iterator it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		Object value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,code,of,an,element,in,the,code,collection,code,the,exact,element,for,which,the,code,class,code,is,retreived,will,depend,on,the,concrete,code,collection,code,implementation;private,static,object,peek,ahead,collection,collection,iterator,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,object,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> private static Object peekAhead(Collection collection);1356735495;Retrieves the {@code Class} of an element in the {@code Collection}._The exact element for which the {@code Class} is retreived will depend_on the concrete {@code Collection} implementation.;private static Object peekAhead(Collection collection) {_		Iterator it = collection.iterator()__		if (!it.hasNext()) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - no element found")__		}_		Object value = it.next()__		if (value == null) {_			throw new IllegalStateException(_					"Unable to peek ahead in non-empty collection - only null element found")__		}_		return value__	};retrieves,the,code,class,of,an,element,in,the,code,collection,the,exact,element,for,which,the,code,class,is,retreived,will,depend,on,the,concrete,code,collection,implementation;private,static,object,peek,ahead,collection,collection,iterator,it,collection,iterator,if,it,has,next,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,no,element,found,object,value,it,next,if,value,null,throw,new,illegal,state,exception,unable,to,peek,ahead,in,non,empty,collection,only,null,element,found,return,value
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1385412762;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + "." + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1432125256;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + "." + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1467730834;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + "." + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1474905889;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + "." + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1477045587;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1481579380;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1485277217;Return an attribute name qualified by the supplied enclosing {@link Class}. For example,_the attribute name '{@code foo}' qualified by {@link Class} '{@code com.myapp.SomeClass}'_would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,supplied,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1492570843;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1492570843;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1492572344;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1495868221;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1496837955;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1511215342;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1515431102;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1530190072;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1530532518;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
Conventions -> public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName);1532520919;Return an attribute name qualified by the given enclosing {@link Class}._For example the attribute name '{@code foo}' qualified by {@link Class}_'{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}';public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {_		Assert.notNull(enclosingClass, "'enclosingClass' must not be null")__		Assert.notNull(attributeName, "'attributeName' must not be null")__		return enclosingClass.getName() + '.' + attributeName__	};return,an,attribute,name,qualified,by,the,given,enclosing,link,class,for,example,the,attribute,name,code,foo,qualified,by,link,class,code,com,myapp,some,class,would,be,code,com,myapp,some,class,foo;public,static,string,get,qualified,attribute,name,class,enclosing,class,string,attribute,name,assert,not,null,enclosing,class,enclosing,class,must,not,be,null,assert,not,null,attribute,name,attribute,name,must,not,be,null,return,enclosing,class,get,name,attribute,name
