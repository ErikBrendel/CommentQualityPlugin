commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the value of this future. This method will return {@code true} if the  * value was set successfully, or {@code false} if the future has already been  * set or cancelled.  * @param value the value that will be set  * @return {@code true} if the value was successfully set, else {@code false}  */ ;/**  * Set the value of this future. This method will return {@code true} if the  * value was set successfully, or {@code false} if the future has already been  * set or cancelled.  * @param value the value that will be set  * @return {@code true} if the value was successfully set, else {@code false}  */ public boolean set(@Nullable T value) {     return this.settableTask.setResultValue(value). }
true;public;1;4;/**  * Set the exception of this future. This method will return {@code true} if the  * exception was set successfully, or {@code false} if the future has already been  * set or cancelled.  * @param exception the value that will be set  * @return {@code true} if the exception was successfully set, else {@code false}  */ ;/**  * Set the exception of this future. This method will return {@code true} if the  * exception was set successfully, or {@code false} if the future has already been  * set or cancelled.  * @param exception the value that will be set  * @return {@code true} if the exception was successfully set, else {@code false}  */ public boolean setException(Throwable exception) {     Assert.notNull(exception, "Exception must not be null").     return this.settableTask.setExceptionResult(exception). }
false;public;1;4;;@Override public void addCallback(ListenableFutureCallback<? super T> callback) {     this.settableTask.addCallback(callback). }
false;public;2;4;;@Override public void addCallback(SuccessCallback<? super T> successCallback, FailureCallback failureCallback) {     this.settableTask.addCallback(successCallback, failureCallback). }
false;public;0;4;;@Override public CompletableFuture<T> completable() {     return this.settableTask.completable(). }
false;public;1;8;;@Override public boolean cancel(boolean mayInterruptIfRunning) {     boolean cancelled = this.settableTask.cancel(mayInterruptIfRunning).     if (cancelled && mayInterruptIfRunning) {         interruptTask().     }     return cancelled. }
false;public;0;4;;@Override public boolean isCancelled() {     return this.settableTask.isCancelled(). }
false;public;0;4;;@Override public boolean isDone() {     return this.settableTask.isDone(). }
true;public;0;4;/**  * Retrieve the value.  * <p>This method returns the value if it has been set via {@link #set(Object)},  * throws an {@link java.util.concurrent.ExecutionException} if an exception has  * been set via {@link #setException(Throwable)}, or throws a  * {@link java.util.concurrent.CancellationException} if the future has been cancelled.  * @return the value associated with this future  */ ;/**  * Retrieve the value.  * <p>This method returns the value if it has been set via {@link #set(Object)},  * throws an {@link java.util.concurrent.ExecutionException} if an exception has  * been set via {@link #setException(Throwable)}, or throws a  * {@link java.util.concurrent.CancellationException} if the future has been cancelled.  * @return the value associated with this future  */ @Override public T get() throws InterruptedException, ExecutionException {     return this.settableTask.get(). }
true;public;2;4;/**  * Retrieve the value.  * <p>This method returns the value if it has been set via {@link #set(Object)},  * throws an {@link java.util.concurrent.ExecutionException} if an exception has  * been set via {@link #setException(Throwable)}, or throws a  * {@link java.util.concurrent.CancellationException} if the future has been cancelled.  * @param timeout the maximum time to wait  * @param unit the unit of the timeout argument  * @return the value associated with this future  */ ;/**  * Retrieve the value.  * <p>This method returns the value if it has been set via {@link #set(Object)},  * throws an {@link java.util.concurrent.ExecutionException} if an exception has  * been set via {@link #setException(Throwable)}, or throws a  * {@link java.util.concurrent.CancellationException} if the future has been cancelled.  * @param timeout the maximum time to wait  * @param unit the unit of the timeout argument  * @return the value associated with this future  */ @Override public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {     return this.settableTask.get(timeout, unit). }
true;protected;0;2;/**  * Subclasses can override this method to implement interruption of the future's  * computation. The method is invoked automatically by a successful call to  * {@link #cancel(boolean) cancel(true)}.  * <p>The default implementation is empty.  */ ;/**  * Subclasses can override this method to implement interruption of the future's  * computation. The method is invoked automatically by a successful call to  * {@link #cancel(boolean) cancel(true)}.  * <p>The default implementation is empty.  */ protected void interruptTask() { }
false;public;1;4;;public boolean setResultValue(@Nullable T value) {     set(value).     return checkCompletingThread(). }
false;public;1;4;;public boolean setExceptionResult(Throwable exception) {     setException(exception).     return checkCompletingThread(). }
false;protected;0;10;;@Override protected void done() {     if (!isCancelled()) {         // Implicitly invoked by set/setException: store current thread for         // determining whether the given result has actually triggered completion         // (since FutureTask.set/setException unfortunately don't expose that)         this.completingThread = Thread.currentThread().     }     super.done(). }
false;private;0;7;;private boolean checkCompletingThread() {     boolean check = (this.completingThread == Thread.currentThread()).     if (check) {         // only first match actually counts         this.completingThread = null.     }     return check. }
