commented;modifiers;parameterAmount;loc;comment;code
true;private;1;8;/**  * Checks the given token string for illegal characters, as defined in RFC 2616,  * section 2.2.  * @throws IllegalArgumentException in case of illegal characters  * @see <a href="http://tools.ietf.org/html/rfc2616#section-2.2">HTTP 1.1, section 2.2</a>  */ ;/**  * Checks the given token string for illegal characters, as defined in RFC 2616,  * section 2.2.  * @throws IllegalArgumentException in case of illegal characters  * @see <a href="http://tools.ietf.org/html/rfc2616#section-2.2">HTTP 1.1, section 2.2</a>  */ private void checkToken(String token) {     for (int i = 0. i < token.length(). i++) {         char ch = token.charAt(i).         if (!TOKEN.get(ch)) {             throw new IllegalArgumentException("Invalid token character '" + ch + "' in token \"" + token + "\"").         }     } }
false;protected;2;12;;protected void checkParameters(String attribute, String value) {     Assert.hasLength(attribute, "'attribute' must not be empty").     Assert.hasLength(value, "'value' must not be empty").     checkToken(attribute).     if (PARAM_CHARSET.equals(attribute)) {         value = unquote(value).         Charset.forName(value).     } else if (!isQuotedString(value)) {         checkToken(value).     } }
false;private;1;8;;private boolean isQuotedString(String s) {     if (s.length() < 2) {         return false.     } else {         return ((s.startsWith("\"") && s.endsWith("\"")) || (s.startsWith("'") && s.endsWith("'"))).     } }
false;protected;1;3;;protected String unquote(String s) {     return (isQuotedString(s) ? s.substring(1, s.length() - 1) : s). }
true;public;0;3;/**  * Indicates whether the {@linkplain #getType() type} is the wildcard character  * <code>&#42.</code> or not.  */ ;/**  * Indicates whether the {@linkplain #getType() type} is the wildcard character  * <code>&#42.</code> or not.  */ public boolean isWildcardType() {     return WILDCARD_TYPE.equals(getType()). }
true;public;0;3;/**  * Indicates whether the {@linkplain #getSubtype() subtype} is the wildcard  * character <code>&#42.</code> or the wildcard character followed by a suffix  * (e.g. <code>&#42.+xml</code>).  * @return whether the subtype is a wildcard  */ ;/**  * Indicates whether the {@linkplain #getSubtype() subtype} is the wildcard  * character <code>&#42.</code> or the wildcard character followed by a suffix  * (e.g. <code>&#42.+xml</code>).  * @return whether the subtype is a wildcard  */ public boolean isWildcardSubtype() {     return WILDCARD_TYPE.equals(getSubtype()) || getSubtype().startsWith("*+"). }
true;public;0;3;/**  * Indicates whether this MIME Type is concrete, i.e. whether neither the type  * nor the subtype is a wildcard character <code>&#42.</code>.  * @return whether this MIME Type is concrete  */ ;/**  * Indicates whether this MIME Type is concrete, i.e. whether neither the type  * nor the subtype is a wildcard character <code>&#42.</code>.  * @return whether this MIME Type is concrete  */ public boolean isConcrete() {     return !isWildcardType() && !isWildcardSubtype(). }
true;public;0;3;/**  * Return the primary type.  */ ;/**  * Return the primary type.  */ public String getType() {     return this.type. }
true;public;0;3;/**  * Return the subtype.  */ ;/**  * Return the subtype.  */ public String getSubtype() {     return this.subtype. }
true;public;0;5;/**  * Return the character set, as indicated by a {@code charset} parameter, if any.  * @return the character set, or {@code null} if not available  * @since 4.3  */ ;/**  * Return the character set, as indicated by a {@code charset} parameter, if any.  * @return the character set, or {@code null} if not available  * @since 4.3  */ @Nullable public Charset getCharset() {     String charset = getParameter(PARAM_CHARSET).     return (charset != null ? Charset.forName(unquote(charset)) : null). }
true;public;1;4;/**  * Return a generic parameter value, given a parameter name.  * @param name the parameter name  * @return the parameter value, or {@code null} if not present  */ ;/**  * Return a generic parameter value, given a parameter name.  * @param name the parameter name  * @return the parameter value, or {@code null} if not present  */ @Nullable public String getParameter(String name) {     return this.parameters.get(name). }
true;public;0;3;/**  * Return all generic parameter values.  * @return a read-only map (possibly empty, never {@code null})  */ ;/**  * Return all generic parameter values.  * @return a read-only map (possibly empty, never {@code null})  */ public Map<String, String> getParameters() {     return this.parameters. }
true;public;1;34;/**  * Indicate whether this MIME Type includes the given MIME Type.  * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},  * and {@code application/*+xml} includes {@code application/soap+xml}, etc.  * This method is <b>not</b> symmetric.  * @param other the reference MIME Type with which to compare  * @return {@code true} if this MIME Type includes the given MIME Type.  * {@code false} otherwise  */ ;/**  * Indicate whether this MIME Type includes the given MIME Type.  * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},  * and {@code application/*+xml} includes {@code application/soap+xml}, etc.  * This method is <b>not</b> symmetric.  * @param other the reference MIME Type with which to compare  * @return {@code true} if this MIME Type includes the given MIME Type.  * {@code false} otherwise  */ public boolean includes(@Nullable MimeType other) {     if (other == null) {         return false.     }     if (isWildcardType()) {         // */* includes anything         return true.     } else if (getType().equals(other.getType())) {         if (getSubtype().equals(other.getSubtype())) {             return true.         }         if (isWildcardSubtype()) {             // Wildcard with suffix, e.g. application/*+xml             int thisPlusIdx = getSubtype().lastIndexOf('+').             if (thisPlusIdx == -1) {                 return true.             } else {                 // application/*+xml includes application/soap+xml                 int otherPlusIdx = other.getSubtype().lastIndexOf('+').                 if (otherPlusIdx != -1) {                     String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx).                     String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1).                     String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1).                     if (thisSubtypeSuffix.equals(otherSubtypeSuffix) && WILDCARD_TYPE.equals(thisSubtypeNoSuffix)) {                         return true.                     }                 }             }         }     }     return false. }
true;public;1;32;/**  * Indicate whether this MIME Type is compatible with the given MIME Type.  * <p>For instance, {@code text/*} is compatible with {@code text/plain},  * {@code text/html}, and vice versa. In effect, this method is similar to  * {@link #includes}, except that it <b>is</b> symmetric.  * @param other the reference MIME Type with which to compare  * @return {@code true} if this MIME Type is compatible with the given MIME Type.  * {@code false} otherwise  */ ;/**  * Indicate whether this MIME Type is compatible with the given MIME Type.  * <p>For instance, {@code text/*} is compatible with {@code text/plain},  * {@code text/html}, and vice versa. In effect, this method is similar to  * {@link #includes}, except that it <b>is</b> symmetric.  * @param other the reference MIME Type with which to compare  * @return {@code true} if this MIME Type is compatible with the given MIME Type.  * {@code false} otherwise  */ public boolean isCompatibleWith(@Nullable MimeType other) {     if (other == null) {         return false.     }     if (isWildcardType() || other.isWildcardType()) {         return true.     } else if (getType().equals(other.getType())) {         if (getSubtype().equals(other.getSubtype())) {             return true.         }         // Wildcard with suffix? e.g. application/*+xml         if (isWildcardSubtype() || other.isWildcardSubtype()) {             int thisPlusIdx = getSubtype().lastIndexOf('+').             int otherPlusIdx = other.getSubtype().lastIndexOf('+').             if (thisPlusIdx == -1 && otherPlusIdx == -1) {                 return true.             } else if (thisPlusIdx != -1 && otherPlusIdx != -1) {                 String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx).                 String otherSubtypeNoSuffix = other.getSubtype().substring(0, otherPlusIdx).                 String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1).                 String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1).                 if (thisSubtypeSuffix.equals(otherSubtypeSuffix) && (WILDCARD_TYPE.equals(thisSubtypeNoSuffix) || WILDCARD_TYPE.equals(otherSubtypeNoSuffix))) {                     return true.                 }             }         }     }     return false. }
true;public;1;6;/**  * Similar to {@link #equals(Object)} but based on the type and subtype  * only, i.e. ignoring parameters.  * @param other the other mime type to compare to  * @return whether the two mime types have the same type and subtype  * @since 5.1.4  */ ;/**  * Similar to {@link #equals(Object)} but based on the type and subtype  * only, i.e. ignoring parameters.  * @param other the other mime type to compare to  * @return whether the two mime types have the same type and subtype  * @since 5.1.4  */ public boolean equalsTypeAndSubtype(@Nullable MimeType other) {     if (other == null) {         return false.     }     return this.type.equalsIgnoreCase(other.type) && this.subtype.equalsIgnoreCase(other.subtype). }
true;public;1;8;/**  * Unlike {@link Collection#contains(Object)} which relies on  * {@link MimeType#equals(Object)}, this method only checks the type and the  * subtype, but otherwise ignores parameters.  * @param mimeTypes the list of mime types to perform the check against  * @return whether the list contains the given mime type  * @since 5.1.4  */ ;/**  * Unlike {@link Collection#contains(Object)} which relies on  * {@link MimeType#equals(Object)}, this method only checks the type and the  * subtype, but otherwise ignores parameters.  * @param mimeTypes the list of mime types to perform the check against  * @return whether the list contains the given mime type  * @since 5.1.4  */ public boolean isPresentIn(Collection<? extends MimeType> mimeTypes) {     for (MimeType mimeType : mimeTypes) {         if (mimeType.equalsTypeAndSubtype(this)) {             return true.         }     }     return false. }
false;public;1;13;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof MimeType)) {         return false.     }     MimeType otherType = (MimeType) other.     return (this.type.equalsIgnoreCase(otherType.type) && this.subtype.equalsIgnoreCase(otherType.subtype) && parametersAreEqual(otherType)). }
true;private;1;22;/**  * Determine if the parameters in this {@code MimeType} and the supplied  * {@code MimeType} are equal, performing case-insensitive comparisons  * for {@link Charset Charsets}.  * @since 4.2  */ ;/**  * Determine if the parameters in this {@code MimeType} and the supplied  * {@code MimeType} are equal, performing case-insensitive comparisons  * for {@link Charset Charsets}.  * @since 4.2  */ private boolean parametersAreEqual(MimeType other) {     if (this.parameters.size() != other.parameters.size()) {         return false.     }     for (Map.Entry<String, String> entry : this.parameters.entrySet()) {         String key = entry.getKey().         if (!other.parameters.containsKey(key)) {             return false.         }         if (PARAM_CHARSET.equals(key)) {             if (!ObjectUtils.nullSafeEquals(getCharset(), other.getCharset())) {                 return false.             }         } else if (!ObjectUtils.nullSafeEquals(entry.getValue(), other.parameters.get(key))) {             return false.         }     }     return true. }
false;public;0;7;;@Override public int hashCode() {     int result = this.type.hashCode().     result = 31 * result + this.subtype.hashCode().     result = 31 * result + this.parameters.hashCode().     return result. }
false;public;0;11;;@Override public String toString() {     String value = this.toStringValue.     if (value == null) {         StringBuilder builder = new StringBuilder().         appendTo(builder).         value = builder.toString().         this.toStringValue = value.     }     return value. }
false;protected;1;6;;protected void appendTo(StringBuilder builder) {     builder.append(this.type).     builder.append('/').     builder.append(this.subtype).     appendTo(this.parameters, builder). }
false;private;2;8;;private void appendTo(Map<String, String> map, StringBuilder builder) {     map.forEach((key, val) -> {         builder.append('.').         builder.append(key).         builder.append('=').         builder.append(val).     }). }
true;public;1;60;/**  * Compares this MIME Type to another alphabetically.  * @param other the MIME Type to compare to  * @see MimeTypeUtils#sortBySpecificity(List)  */ ;/**  * Compares this MIME Type to another alphabetically.  * @param other the MIME Type to compare to  * @see MimeTypeUtils#sortBySpecificity(List)  */ @Override public int compareTo(MimeType other) {     int comp = getType().compareToIgnoreCase(other.getType()).     if (comp != 0) {         return comp.     }     comp = getSubtype().compareToIgnoreCase(other.getSubtype()).     if (comp != 0) {         return comp.     }     comp = getParameters().size() - other.getParameters().size().     if (comp != 0) {         return comp.     }     TreeSet<String> thisAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER).     thisAttributes.addAll(getParameters().keySet()).     TreeSet<String> otherAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER).     otherAttributes.addAll(other.getParameters().keySet()).     Iterator<String> thisAttributesIterator = thisAttributes.iterator().     Iterator<String> otherAttributesIterator = otherAttributes.iterator().     while (thisAttributesIterator.hasNext()) {         String thisAttribute = thisAttributesIterator.next().         String otherAttribute = otherAttributesIterator.next().         comp = thisAttribute.compareToIgnoreCase(otherAttribute).         if (comp != 0) {             return comp.         }         if (PARAM_CHARSET.equals(thisAttribute)) {             Charset thisCharset = getCharset().             Charset otherCharset = other.getCharset().             if (thisCharset != otherCharset) {                 if (thisCharset == null) {                     return -1.                 }                 if (otherCharset == null) {                     return 1.                 }                 comp = thisCharset.compareTo(otherCharset).                 if (comp != 0) {                     return comp.                 }             }         } else {             String thisValue = getParameters().get(thisAttribute).             String otherValue = other.getParameters().get(otherAttribute).             if (otherValue == null) {                 otherValue = "".             }             comp = thisValue.compareTo(otherValue).             if (comp != 0) {                 return comp.             }         }     }     return 0. }
true;public,static;1;3;/**  * Parse the given String value into a {@code MimeType} object,  * with this method name following the 'valueOf' naming convention  * (as supported by {@link org.springframework.core.convert.ConversionService}.  * @see MimeTypeUtils#parseMimeType(String)  */ ;/**  * Parse the given String value into a {@code MimeType} object,  * with this method name following the 'valueOf' naming convention  * (as supported by {@link org.springframework.core.convert.ConversionService}.  * @see MimeTypeUtils#parseMimeType(String)  */ public static MimeType valueOf(String value) {     return MimeTypeUtils.parseMimeType(value). }
false;private,static;2;5;;private static Map<String, String> addCharsetParameter(Charset charset, Map<String, String> parameters) {     Map<String, String> map = new LinkedHashMap<>(parameters).     map.put(PARAM_CHARSET, charset.name()).     return map. }
false;public;2;26;;@Override public int compare(T mimeType1, T mimeType2) {     if (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {         // */* < audio/*         return 1.     } else if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {         // audio/* > */*         return -1.     } else if (!mimeType1.getType().equals(mimeType2.getType())) {         // audio/basic == text/html         return 0.     } else {         // mediaType1.getType().equals(mediaType2.getType())         if (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {             // audio/* < audio/basic             return 1.         } else if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {             // audio/basic > audio/*             return -1.         } else if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {             // audio/basic == audio/wave             return 0.         } else {             // mediaType2.getSubtype().equals(mediaType2.getSubtype())             return compareParameters(mimeType1, mimeType2).         }     } }
false;protected;2;5;;protected int compareParameters(T mimeType1, T mimeType2) {     int paramsSize1 = mimeType1.getParameters().size().     int paramsSize2 = mimeType2.getParameters().size().     // audio/basic.level=1 < audio/basic     return Integer.compare(paramsSize2, paramsSize1). }
