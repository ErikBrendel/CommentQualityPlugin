commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the name of the analyzed class.  */ ;/**  * Return the name of the analyzed class.  */ public final String getClassName() {     return this.className. }
true;public,final;0;3;/**  * Return the number of constants exposed.  */ ;/**  * Return the number of constants exposed.  */ public final int getSize() {     return this.fieldCache.size(). }
true;protected,final;0;3;/**  * Exposes the field cache to subclasses:  * a Map from String field name to object value.  */ ;/**  * Exposes the field cache to subclasses:  * a Map from String field name to object value.  */ protected final Map<String, Object> getFieldCache() {     return this.fieldCache. }
true;public;1;7;/**  * Return a constant value cast to a Number.  * @param code the name of the field (never {@code null})  * @return the Number value  * @throws ConstantException if the field name wasn't found  * or if the type wasn't compatible with Number  * @see #asObject  */ ;/**  * Return a constant value cast to a Number.  * @param code the name of the field (never {@code null})  * @return the Number value  * @throws ConstantException if the field name wasn't found  * or if the type wasn't compatible with Number  * @see #asObject  */ public Number asNumber(String code) throws ConstantException {     Object obj = asObject(code).     if (!(obj instanceof Number)) {         throw new ConstantException(this.className, code, "not a Number").     }     return (Number) obj. }
true;public;1;3;/**  * Return a constant value as a String.  * @param code the name of the field (never {@code null})  * @return the String value  * Works even if it's not a string (invokes {@code toString()}).  * @throws ConstantException if the field name wasn't found  * @see #asObject  */ ;/**  * Return a constant value as a String.  * @param code the name of the field (never {@code null})  * @return the String value  * Works even if it's not a string (invokes {@code toString()}).  * @throws ConstantException if the field name wasn't found  * @see #asObject  */ public String asString(String code) throws ConstantException {     return asObject(code).toString(). }
true;public;1;9;/**  * Parse the given String (upper or lower case accepted) and return  * the appropriate value if it's the name of a constant field in the  * class that we're analysing.  * @param code the name of the field (never {@code null})  * @return the Object value  * @throws ConstantException if there's no such field  */ ;/**  * Parse the given String (upper or lower case accepted) and return  * the appropriate value if it's the name of a constant field in the  * class that we're analysing.  * @param code the name of the field (never {@code null})  * @return the Object value  * @throws ConstantException if there's no such field  */ public Object asObject(String code) throws ConstantException {     Assert.notNull(code, "Code must not be null").     String codeToUse = code.toUpperCase(Locale.ENGLISH).     Object val = this.fieldCache.get(codeToUse).     if (val == null) {         throw new ConstantException(this.className, codeToUse, "not found").     }     return val. }
true;public;1;10;/**  * Return all names of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code namePrefix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param namePrefix prefix of the constant names to search (may be {@code null})  * @return the set of constant names  */ ;/**  * Return all names of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code namePrefix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param namePrefix prefix of the constant names to search (may be {@code null})  * @return the set of constant names  */ public Set<String> getNames(@Nullable String namePrefix) {     String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : "").     Set<String> names = new HashSet<>().     for (String code : this.fieldCache.keySet()) {         if (code.startsWith(prefixToUse)) {             names.add(code).         }     }     return names. }
true;public;1;3;/**  * Return all names of the group of constants for the  * given bean property name.  * @param propertyName the name of the bean property  * @return the set of values  * @see #propertyToConstantNamePrefix  */ ;/**  * Return all names of the group of constants for the  * given bean property name.  * @param propertyName the name of the bean property  * @return the set of values  * @see #propertyToConstantNamePrefix  */ public Set<String> getNamesForProperty(String propertyName) {     return getNames(propertyToConstantNamePrefix(propertyName)). }
true;public;1;10;/**  * Return all names of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code nameSuffix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param nameSuffix suffix of the constant names to search (may be {@code null})  * @return the set of constant names  */ ;/**  * Return all names of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code nameSuffix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param nameSuffix suffix of the constant names to search (may be {@code null})  * @return the set of constant names  */ public Set<String> getNamesForSuffix(@Nullable String nameSuffix) {     String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : "").     Set<String> names = new HashSet<>().     for (String code : this.fieldCache.keySet()) {         if (code.endsWith(suffixToUse)) {             names.add(code).         }     }     return names. }
true;public;1;10;/**  * Return all values of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code namePrefix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param namePrefix prefix of the constant names to search (may be {@code null})  * @return the set of values  */ ;/**  * Return all values of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code namePrefix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param namePrefix prefix of the constant names to search (may be {@code null})  * @return the set of values  */ public Set<Object> getValues(@Nullable String namePrefix) {     String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : "").     Set<Object> values = new HashSet<>().     this.fieldCache.forEach((code, value) -> {         if (code.startsWith(prefixToUse)) {             values.add(value).         }     }).     return values. }
true;public;1;3;/**  * Return all values of the group of constants for the  * given bean property name.  * @param propertyName the name of the bean property  * @return the set of values  * @see #propertyToConstantNamePrefix  */ ;/**  * Return all values of the group of constants for the  * given bean property name.  * @param propertyName the name of the bean property  * @return the set of values  * @see #propertyToConstantNamePrefix  */ public Set<Object> getValuesForProperty(String propertyName) {     return getValues(propertyToConstantNamePrefix(propertyName)). }
true;public;1;10;/**  * Return all values of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code nameSuffix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param nameSuffix suffix of the constant names to search (may be {@code null})  * @return the set of values  */ ;/**  * Return all values of the given group of constants.  * <p>Note that this method assumes that constants are named  * in accordance with the standard Java convention for constant  * values (i.e. all uppercase). The supplied {@code nameSuffix}  * will be uppercased (in a locale-insensitive fashion) prior to  * the main logic of this method kicking in.  * @param nameSuffix suffix of the constant names to search (may be {@code null})  * @return the set of values  */ public Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {     String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : "").     Set<Object> values = new HashSet<>().     this.fieldCache.forEach((code, value) -> {         if (code.endsWith(suffixToUse)) {             values.add(value).         }     }).     return values. }
true;public;2;9;/**  * Look up the given value within the given group of constants.  * <p>Will return the first match.  * @param value constant value to look up  * @param namePrefix prefix of the constant names to search (may be {@code null})  * @return the name of the constant field  * @throws ConstantException if the value wasn't found  */ ;/**  * Look up the given value within the given group of constants.  * <p>Will return the first match.  * @param value constant value to look up  * @param namePrefix prefix of the constant names to search (may be {@code null})  * @return the name of the constant field  * @throws ConstantException if the value wasn't found  */ public String toCode(Object value, @Nullable String namePrefix) throws ConstantException {     String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : "").     for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {         if (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {             return entry.getKey().         }     }     throw new ConstantException(this.className, prefixToUse, value). }
true;public;2;3;/**  * Look up the given value within the group of constants for  * the given bean property name. Will return the first match.  * @param value constant value to look up  * @param propertyName the name of the bean property  * @return the name of the constant field  * @throws ConstantException if the value wasn't found  * @see #propertyToConstantNamePrefix  */ ;/**  * Look up the given value within the group of constants for  * the given bean property name. Will return the first match.  * @param value constant value to look up  * @param propertyName the name of the bean property  * @return the name of the constant field  * @throws ConstantException if the value wasn't found  * @see #propertyToConstantNamePrefix  */ public String toCodeForProperty(Object value, String propertyName) throws ConstantException {     return toCode(value, propertyToConstantNamePrefix(propertyName)). }
true;public;2;9;/**  * Look up the given value within the given group of constants.  * <p>Will return the first match.  * @param value constant value to look up  * @param nameSuffix suffix of the constant names to search (may be {@code null})  * @return the name of the constant field  * @throws ConstantException if the value wasn't found  */ ;/**  * Look up the given value within the given group of constants.  * <p>Will return the first match.  * @param value constant value to look up  * @param nameSuffix suffix of the constant names to search (may be {@code null})  * @return the name of the constant field  * @throws ConstantException if the value wasn't found  */ public String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {     String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : "").     for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {         if (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {             return entry.getKey().         }     }     throw new ConstantException(this.className, suffixToUse, value). }
true;public;1;14;/**  * Convert the given bean property name to a constant name prefix.  * <p>Uses a common naming idiom: turning all lower case characters to  * upper case, and prepending upper case characters with an underscore.  * <p>Example: "imageSize" -> "IMAGE_SIZE"<br>  * Example: "imagesize" -> "IMAGESIZE".<br>  * Example: "ImageSize" -> "_IMAGE_SIZE".<br>  * Example: "IMAGESIZE" -> "_I_M_A_G_E_S_I_Z_E"  * @param propertyName the name of the bean property  * @return the corresponding constant name prefix  * @see #getValuesForProperty  * @see #toCodeForProperty  */ ;/**  * Convert the given bean property name to a constant name prefix.  * <p>Uses a common naming idiom: turning all lower case characters to  * upper case, and prepending upper case characters with an underscore.  * <p>Example: "imageSize" -> "IMAGE_SIZE"<br>  * Example: "imagesize" -> "IMAGESIZE".<br>  * Example: "ImageSize" -> "_IMAGE_SIZE".<br>  * Example: "IMAGESIZE" -> "_I_M_A_G_E_S_I_Z_E"  * @param propertyName the name of the bean property  * @return the corresponding constant name prefix  * @see #getValuesForProperty  * @see #toCodeForProperty  */ public String propertyToConstantNamePrefix(String propertyName) {     StringBuilder parsedPrefix = new StringBuilder().     for (int i = 0. i < propertyName.length(). i++) {         char c = propertyName.charAt(i).         if (Character.isUpperCase(c)) {             parsedPrefix.append("_").             parsedPrefix.append(c).         } else {             parsedPrefix.append(Character.toUpperCase(c)).         }     }     return parsedPrefix.toString(). }
