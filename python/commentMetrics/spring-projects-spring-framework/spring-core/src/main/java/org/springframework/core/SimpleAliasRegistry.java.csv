commented;modifiers;parameterAmount;loc;comment;code
false;public;2;35;;@Override public void registerAlias(String name, String alias) {     Assert.hasText(name, "'name' must not be empty").     Assert.hasText(alias, "'alias' must not be empty").     synchronized (this.aliasMap) {         if (alias.equals(name)) {             this.aliasMap.remove(alias).             if (logger.isDebugEnabled()) {                 logger.debug("Alias definition '" + alias + "' ignored since it points to same name").             }         } else {             String registeredName = this.aliasMap.get(alias).             if (registeredName != null) {                 if (registeredName.equals(name)) {                     // An existing alias - no need to re-register                     return.                 }                 if (!allowAliasOverriding()) {                     throw new IllegalStateException("Cannot define alias '" + alias + "' for name '" + name + "': It is already registered for name '" + registeredName + "'.").                 }                 if (logger.isDebugEnabled()) {                     logger.debug("Overriding alias '" + alias + "' definition for registered name '" + registeredName + "' with new target name '" + name + "'").                 }             }             checkForAliasCircle(name, alias).             this.aliasMap.put(alias, name).             if (logger.isTraceEnabled()) {                 logger.trace("Alias definition '" + alias + "' registered for name '" + name + "'").             }         }     } }
true;protected;0;3;/**  * Return whether alias overriding is allowed.  * Default is {@code true}.  */ ;/**  * Return whether alias overriding is allowed.  * Default is {@code true}.  */ protected boolean allowAliasOverriding() {     return true. }
true;public;2;12;/**  * Determine whether the given name has the given alias registered.  * @param name the name to check  * @param alias the alias to look for  * @since 4.2.1  */ ;/**  * Determine whether the given name has the given alias registered.  * @param name the name to check  * @param alias the alias to look for  * @since 4.2.1  */ public boolean hasAlias(String name, String alias) {     for (Map.Entry<String, String> entry : this.aliasMap.entrySet()) {         String registeredName = entry.getValue().         if (registeredName.equals(name)) {             String registeredAlias = entry.getKey().             if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) {                 return true.             }         }     }     return false. }
false;public;1;9;;@Override public void removeAlias(String alias) {     synchronized (this.aliasMap) {         String name = this.aliasMap.remove(alias).         if (name == null) {             throw new IllegalStateException("No alias '" + alias + "' registered").         }     } }
false;public;1;4;;@Override public boolean isAlias(String name) {     return this.aliasMap.containsKey(name). }
false;public;1;8;;@Override public String[] getAliases(String name) {     List<String> result = new ArrayList<>().     synchronized (this.aliasMap) {         retrieveAliases(name, result).     }     return StringUtils.toStringArray(result). }
true;private;2;8;/**  * Transitively retrieve all aliases for the given name.  * @param name the target name to find aliases for  * @param result the resulting aliases list  */ ;/**  * Transitively retrieve all aliases for the given name.  * @param name the target name to find aliases for  * @param result the resulting aliases list  */ private void retrieveAliases(String name, List<String> result) {     this.aliasMap.forEach((alias, registeredName) -> {         if (registeredName.equals(name)) {             result.add(alias).             retrieveAliases(alias, result).         }     }). }
true;public;1;33;/**  * Resolve all alias target names and aliases registered in this  * factory, applying the given StringValueResolver to them.  * <p>The value resolver may for example resolve placeholders  * in target bean names and even in alias names.  * @param valueResolver the StringValueResolver to apply  */ ;/**  * Resolve all alias target names and aliases registered in this  * factory, applying the given StringValueResolver to them.  * <p>The value resolver may for example resolve placeholders  * in target bean names and even in alias names.  * @param valueResolver the StringValueResolver to apply  */ public void resolveAliases(StringValueResolver valueResolver) {     Assert.notNull(valueResolver, "StringValueResolver must not be null").     synchronized (this.aliasMap) {         Map<String, String> aliasCopy = new HashMap<>(this.aliasMap).         aliasCopy.forEach((alias, registeredName) -> {             String resolvedAlias = valueResolver.resolveStringValue(alias).             String resolvedName = valueResolver.resolveStringValue(registeredName).             if (resolvedAlias == null || resolvedName == null || resolvedAlias.equals(resolvedName)) {                 this.aliasMap.remove(alias).             } else if (!resolvedAlias.equals(alias)) {                 String existingName = this.aliasMap.get(resolvedAlias).                 if (existingName != null) {                     if (existingName.equals(resolvedName)) {                         // Pointing to existing alias - just remove placeholder                         this.aliasMap.remove(alias).                         return.                     }                     throw new IllegalStateException("Cannot register resolved alias '" + resolvedAlias + "' (original: '" + alias + "') for name '" + resolvedName + "': It is already registered for name '" + registeredName + "'.").                 }                 checkForAliasCircle(resolvedName, resolvedAlias).                 this.aliasMap.remove(alias).                 this.aliasMap.put(resolvedAlias, resolvedName).             } else if (!registeredName.equals(resolvedName)) {                 this.aliasMap.put(alias, resolvedName).             }         }).     } }
true;protected;2;7;/**  * Check whether the given name points back to the given alias as an alias  * in the other direction already, catching a circular reference upfront  * and throwing a corresponding IllegalStateException.  * @param name the candidate name  * @param alias the candidate alias  * @see #registerAlias  * @see #hasAlias  */ ;/**  * Check whether the given name points back to the given alias as an alias  * in the other direction already, catching a circular reference upfront  * and throwing a corresponding IllegalStateException.  * @param name the candidate name  * @param alias the candidate alias  * @see #registerAlias  * @see #hasAlias  */ protected void checkForAliasCircle(String name, String alias) {     if (hasAlias(alias, name)) {         throw new IllegalStateException("Cannot register alias '" + alias + "' for name '" + name + "': Circular reference - '" + name + "' is a direct or indirect alias for '" + alias + "' already").     } }
true;public;1;13;/**  * Determine the raw name, resolving aliases to canonical names.  * @param name the user-specified name  * @return the transformed name  */ ;/**  * Determine the raw name, resolving aliases to canonical names.  * @param name the user-specified name  * @return the transformed name  */ public String canonicalName(String name) {     String canonicalName = name.     // Handle aliasing...     String resolvedName.     do {         resolvedName = this.aliasMap.get(canonicalName).         if (resolvedName != null) {             canonicalName = resolvedName.         }     } while (resolvedName != null).     return canonicalName. }
