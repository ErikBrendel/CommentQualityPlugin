commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {     return super.canEncode(elementType, mimeType) && ResourceRegion.class.isAssignableFrom(elementType.toClass()). }
false;public;5;41;;@Override public Flux<DataBuffer> encode(Publisher<? extends ResourceRegion> inputStream, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Assert.notNull(inputStream, "'inputStream' must not be null").     Assert.notNull(bufferFactory, "'bufferFactory' must not be null").     Assert.notNull(elementType, "'elementType' must not be null").     if (inputStream instanceof Mono) {         return Mono.from(inputStream).flatMapMany(region -> {             if (!region.getResource().isReadable()) {                 return Flux.error(new EncodingException("Resource " + region.getResource() + " is not readable")).             }             return writeResourceRegion(region, bufferFactory, hints).         }).     } else {         final String boundaryString = Hints.getRequiredHint(hints, BOUNDARY_STRING_HINT).         byte[] startBoundary = getAsciiBytes("\r\n--" + boundaryString + "\r\n").         byte[] contentType = (mimeType != null ? getAsciiBytes("Content-Type: " + mimeType + "\r\n") : new byte[0]).         return Flux.from(inputStream).concatMap(region -> {             if (!region.getResource().isReadable()) {                 return Flux.error(new EncodingException("Resource " + region.getResource() + " is not readable")).             } else {                 return Flux.concat(getRegionPrefix(bufferFactory, startBoundary, contentType, region), writeResourceRegion(region, bufferFactory, hints)).             }         }).concatWith(getRegionSuffix(bufferFactory, boundaryString)).     } }
false;private;4;9;;private Flux<DataBuffer> getRegionPrefix(DataBufferFactory bufferFactory, byte[] startBoundary, byte[] contentType, ResourceRegion region) {     return Flux.defer(() -> Flux.just(bufferFactory.allocateBuffer(startBoundary.length).write(startBoundary), bufferFactory.allocateBuffer(contentType.length).write(contentType), bufferFactory.wrap(ByteBuffer.wrap(getContentRangeHeader(region))))). }
false;private;3;15;;private Flux<DataBuffer> writeResourceRegion(ResourceRegion region, DataBufferFactory bufferFactory, @Nullable Map<String, Object> hints) {     Resource resource = region.getResource().     long position = region.getPosition().     long count = region.getCount().     if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {         logger.debug(Hints.getLogPrefix(hints) + "Writing region " + position + "-" + (position + count) + " of [" + resource + "]").     }     Flux<DataBuffer> in = DataBufferUtils.read(resource, position, bufferFactory, this.bufferSize).     return DataBufferUtils.takeUntilByteCount(in, count). }
false;private;2;5;;private Flux<DataBuffer> getRegionSuffix(DataBufferFactory bufferFactory, String boundaryString) {     byte[] endBoundary = getAsciiBytes("\r\n--" + boundaryString + "--").     return Flux.defer(() -> Flux.just(bufferFactory.allocateBuffer(endBoundary.length).write(endBoundary))). }
false;private;1;3;;private byte[] getAsciiBytes(String in) {     return in.getBytes(StandardCharsets.US_ASCII). }
false;private;1;12;;private byte[] getContentRangeHeader(ResourceRegion region) {     long start = region.getPosition().     long end = start + region.getCount() - 1.     OptionalLong contentLength = contentLength(region.getResource()).     if (contentLength.isPresent()) {         long length = contentLength.getAsLong().         return getAsciiBytes("Content-Range: bytes " + start + '-' + end + '/' + length + "\r\n\r\n").     } else {         return getAsciiBytes("Content-Range: bytes " + start + '-' + end + "\r\n\r\n").     } }
true;private;1;12;/**  * Determine, if possible, the contentLength of the given resource without reading it.  * @param resource the resource instance  * @return the contentLength of the resource  */ ;/**  * Determine, if possible, the contentLength of the given resource without reading it.  * @param resource the resource instance  * @return the contentLength of the resource  */ private OptionalLong contentLength(Resource resource) {     // Note: custom InputStreamResource subclasses could provide a pre-calculated content length!     if (InputStreamResource.class != resource.getClass()) {         try {             return OptionalLong.of(resource.contentLength()).         } catch (IOException ignored) {         }     }     return OptionalLong.empty(). }
