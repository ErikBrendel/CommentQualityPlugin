commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the file path for this resource.  */ ;/**  * Return the file path for this resource.  */ public final String getPath() {     return this.path. }
true;public;0;4;/**  * This implementation returns whether the underlying file exists.  * @see java.io.File#exists()  */ ;/**  * This implementation returns whether the underlying file exists.  * @see java.io.File#exists()  */ @Override public boolean exists() {     return (this.file != null ? this.file.exists() : Files.exists(this.filePath)). }
true;public;0;5;/**  * This implementation checks whether the underlying file is marked as readable  * (and corresponds to an actual file with content, not to a directory).  * @see java.io.File#canRead()  * @see java.io.File#isDirectory()  */ ;/**  * This implementation checks whether the underlying file is marked as readable  * (and corresponds to an actual file with content, not to a directory).  * @see java.io.File#canRead()  * @see java.io.File#isDirectory()  */ @Override public boolean isReadable() {     return (this.file != null ? this.file.canRead() && !this.file.isDirectory() : Files.isReadable(this.filePath) && !Files.isDirectory(this.filePath)). }
true;public;0;9;/**  * This implementation opens a NIO file stream for the underlying file.  * @see java.io.FileInputStream  */ ;/**  * This implementation opens a NIO file stream for the underlying file.  * @see java.io.FileInputStream  */ @Override public InputStream getInputStream() throws IOException {     try {         return Files.newInputStream(this.filePath).     } catch (NoSuchFileException ex) {         throw new FileNotFoundException(ex.getMessage()).     } }
true;public;0;5;/**  * This implementation checks whether the underlying file is marked as writable  * (and corresponds to an actual file with content, not to a directory).  * @see java.io.File#canWrite()  * @see java.io.File#isDirectory()  */ ;/**  * This implementation checks whether the underlying file is marked as writable  * (and corresponds to an actual file with content, not to a directory).  * @see java.io.File#canWrite()  * @see java.io.File#isDirectory()  */ @Override public boolean isWritable() {     return (this.file != null ? this.file.canWrite() && !this.file.isDirectory() : Files.isWritable(this.filePath) && !Files.isDirectory(this.filePath)). }
true;public;0;4;/**  * This implementation opens a FileOutputStream for the underlying file.  * @see java.io.FileOutputStream  */ ;/**  * This implementation opens a FileOutputStream for the underlying file.  * @see java.io.FileOutputStream  */ @Override public OutputStream getOutputStream() throws IOException {     return Files.newOutputStream(this.filePath). }
true;public;0;4;/**  * This implementation returns a URL for the underlying file.  * @see java.io.File#toURI()  */ ;/**  * This implementation returns a URL for the underlying file.  * @see java.io.File#toURI()  */ @Override public URL getURL() throws IOException {     return (this.file != null ? this.file.toURI().toURL() : this.filePath.toUri().toURL()). }
true;public;0;4;/**  * This implementation returns a URI for the underlying file.  * @see java.io.File#toURI()  */ ;/**  * This implementation returns a URI for the underlying file.  * @see java.io.File#toURI()  */ @Override public URI getURI() throws IOException {     return (this.file != null ? this.file.toURI() : this.filePath.toUri()). }
true;public;0;4;/**  * This implementation always indicates a file.  */ ;/**  * This implementation always indicates a file.  */ @Override public boolean isFile() {     return true. }
true;public;0;4;/**  * This implementation returns the underlying File reference.  */ ;/**  * This implementation returns the underlying File reference.  */ @Override public File getFile() {     return (this.file != null ? this.file : this.filePath.toFile()). }
true;public;0;9;/**  * This implementation opens a FileChannel for the underlying file.  * @see java.nio.channels.FileChannel  */ ;/**  * This implementation opens a FileChannel for the underlying file.  * @see java.nio.channels.FileChannel  */ @Override public ReadableByteChannel readableChannel() throws IOException {     try {         return FileChannel.open(this.filePath, StandardOpenOption.READ).     } catch (NoSuchFileException ex) {         throw new FileNotFoundException(ex.getMessage()).     } }
true;public;0;4;/**  * This implementation opens a FileChannel for the underlying file.  * @see java.nio.channels.FileChannel  */ ;/**  * This implementation opens a FileChannel for the underlying file.  * @see java.nio.channels.FileChannel  */ @Override public WritableByteChannel writableChannel() throws IOException {     return FileChannel.open(this.filePath, StandardOpenOption.WRITE). }
true;public;0;19;/**  * This implementation returns the underlying File/Path length.  */ ;/**  * This implementation returns the underlying File/Path length.  */ @Override public long contentLength() throws IOException {     if (this.file != null) {         long length = this.file.length().         if (length == 0L && !this.file.exists()) {             throw new FileNotFoundException(getDescription() + " cannot be resolved in the file system for checking its content length").         }         return length.     } else {         try {             return Files.size(this.filePath).         } catch (NoSuchFileException ex) {             throw new FileNotFoundException(ex.getMessage()).         }     } }
true;public;0;14;/**  * This implementation returns the underlying File/Path last-modified time.  */ ;/**  * This implementation returns the underlying File/Path last-modified time.  */ @Override public long lastModified() throws IOException {     if (this.file != null) {         return super.lastModified().     } else {         try {             return Files.getLastModifiedTime(this.filePath).toMillis().         } catch (NoSuchFileException ex) {             throw new FileNotFoundException(ex.getMessage()).         }     } }
true;public;1;6;/**  * This implementation creates a FileSystemResource, applying the given path  * relative to the path of the underlying file of this resource descriptor.  * @see org.springframework.util.StringUtils#applyRelativePath(String, String)  */ ;/**  * This implementation creates a FileSystemResource, applying the given path  * relative to the path of the underlying file of this resource descriptor.  * @see org.springframework.util.StringUtils#applyRelativePath(String, String)  */ @Override public Resource createRelative(String relativePath) {     String pathToUse = StringUtils.applyRelativePath(this.path, relativePath).     return (this.file != null ? new FileSystemResource(pathToUse) : new FileSystemResource(this.filePath.getFileSystem(), pathToUse)). }
true;public;0;4;/**  * This implementation returns the name of the file.  * @see java.io.File#getName()  */ ;/**  * This implementation returns the name of the file.  * @see java.io.File#getName()  */ @Override public String getFilename() {     return (this.file != null ? this.file.getName() : this.filePath.getFileName().toString()). }
true;public;0;4;/**  * This implementation returns a description that includes the absolute  * path of the file.  * @see java.io.File#getAbsolutePath()  */ ;/**  * This implementation returns a description that includes the absolute  * path of the file.  * @see java.io.File#getAbsolutePath()  */ @Override public String getDescription() {     return "file [" + (this.file != null ? this.file.getAbsolutePath() : this.filePath.toAbsolutePath()) + "]". }
true;public;1;5;/**  * This implementation compares the underlying File references.  */ ;/**  * This implementation compares the underlying File references.  */ @Override public boolean equals(Object other) {     return (this == other || (other instanceof FileSystemResource && this.path.equals(((FileSystemResource) other).path))). }
true;public;0;4;/**  * This implementation returns the hash code of the underlying File reference.  */ ;/**  * This implementation returns the hash code of the underlying File reference.  */ @Override public int hashCode() {     return this.path.hashCode(). }
