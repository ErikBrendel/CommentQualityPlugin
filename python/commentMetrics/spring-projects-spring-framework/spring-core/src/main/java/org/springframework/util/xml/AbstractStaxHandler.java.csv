commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;11;;@Override public final void startDocument() throws SAXException {     removeAllNamespaceMappings().     newNamespaceMapping().     try {         startDocumentInternal().     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle startDocument: " + ex.getMessage(), ex).     } }
false;public,final;0;10;;@Override public final void endDocument() throws SAXException {     removeAllNamespaceMappings().     try {         endDocumentInternal().     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle endDocument: " + ex.getMessage(), ex).     } }
false;public,final;2;4;;@Override public final void startPrefixMapping(String prefix, String uri) {     currentNamespaceMapping().put(prefix, uri). }
false;public,final;1;3;;@Override public final void endPrefixMapping(String prefix) { }
false;public,final;4;10;;@Override public final void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {     try {         startElementInternal(toQName(uri, qName), atts, currentNamespaceMapping()).         newNamespaceMapping().     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle startElement: " + ex.getMessage(), ex).     } }
false;public,final;3;10;;@Override public final void endElement(String uri, String localName, String qName) throws SAXException {     try {         endElementInternal(toQName(uri, qName), currentNamespaceMapping()).         removeNamespaceMapping().     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle endElement: " + ex.getMessage(), ex).     } }
false;public,final;3;15;;@Override public final void characters(char[] ch, int start, int length) throws SAXException {     try {         String data = new String(ch, start, length).         if (!this.inCData) {             charactersInternal(data).         } else {             cDataInternal(data).         }     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle characters: " + ex.getMessage(), ex).     } }
false;public,final;3;10;;@Override public final void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {     try {         ignorableWhitespaceInternal(new String(ch, start, length)).     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle ignorableWhitespace:" + ex.getMessage(), ex).     } }
false;public,final;2;9;;@Override public final void processingInstruction(String target, String data) throws SAXException {     try {         processingInstructionInternal(target, data).     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle processingInstruction: " + ex.getMessage(), ex).     } }
false;public,final;1;9;;@Override public final void skippedEntity(String name) throws SAXException {     try {         skippedEntityInternal(name).     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle skippedEntity: " + ex.getMessage(), ex).     } }
false;public,final;3;22;;@Override public final void startDTD(String name, @Nullable String publicId, String systemId) throws SAXException {     try {         StringBuilder builder = new StringBuilder("<!DOCTYPE ").         builder.append(name).         if (publicId != null) {             builder.append(" PUBLIC \"").             builder.append(publicId).             builder.append("\" \"").         } else {             builder.append(" SYSTEM \"").         }         builder.append(systemId).         builder.append("\">").         dtdInternal(builder.toString()).     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle startDTD: " + ex.getMessage(), ex).     } }
false;public,final;0;3;;@Override public final void endDTD() throws SAXException { }
false;public,final;0;4;;@Override public final void startCDATA() throws SAXException {     this.inCData = true. }
false;public,final;0;4;;@Override public final void endCDATA() throws SAXException {     this.inCData = false. }
false;public,final;3;9;;@Override public final void comment(char[] ch, int start, int length) throws SAXException {     try {         commentInternal(new String(ch, start, length)).     } catch (XMLStreamException ex) {         throw new SAXException("Could not handle comment: " + ex.getMessage(), ex).     } }
false;public;1;3;;@Override public void startEntity(String name) throws SAXException { }
false;public;1;3;;@Override public void endEntity(String name) throws SAXException { }
true;protected;2;11;/**  * Convert a namespace URI and DOM or SAX qualified name to a {@code QName}. The  * qualified name can have the form {@code prefix:localname} or {@code localName}.  * @param namespaceUri the namespace URI  * @param qualifiedName the qualified name  * @return a QName  */ ;/**  * Convert a namespace URI and DOM or SAX qualified name to a {@code QName}. The  * qualified name can have the form {@code prefix:localname} or {@code localName}.  * @param namespaceUri the namespace URI  * @param qualifiedName the qualified name  * @return a QName  */ protected QName toQName(String namespaceUri, String qualifiedName) {     int idx = qualifiedName.indexOf(':').     if (idx == -1) {         return new QName(namespaceUri, qualifiedName).     } else {         String prefix = qualifiedName.substring(0, idx).         String localPart = qualifiedName.substring(idx + 1).         return new QName(namespaceUri, localPart, prefix).     } }
false;protected;1;6;;protected boolean isNamespaceDeclaration(QName qName) {     String prefix = qName.getPrefix().     String localPart = qName.getLocalPart().     return (XMLConstants.XMLNS_ATTRIBUTE.equals(localPart) && prefix.isEmpty()) || (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) && !localPart.isEmpty()). }
false;private;0;3;;private Map<String, String> currentNamespaceMapping() {     return this.namespaceMappings.get(this.namespaceMappings.size() - 1). }
false;private;0;3;;private void newNamespaceMapping() {     this.namespaceMappings.add(new HashMap<>()). }
false;private;0;3;;private void removeNamespaceMapping() {     this.namespaceMappings.remove(this.namespaceMappings.size() - 1). }
false;private;0;3;;private void removeAllNamespaceMappings() {     this.namespaceMappings.clear(). }
false;protected,abstract;0;1;;protected abstract void startDocumentInternal() throws XMLStreamException.
false;protected,abstract;0;1;;protected abstract void endDocumentInternal() throws XMLStreamException.
false;protected,abstract;3;2;;protected abstract void startElementInternal(QName name, Attributes attributes, Map<String, String> namespaceMapping) throws XMLStreamException.
false;protected,abstract;2;2;;protected abstract void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException.
false;protected,abstract;1;1;;protected abstract void charactersInternal(String data) throws XMLStreamException.
false;protected,abstract;1;1;;protected abstract void cDataInternal(String data) throws XMLStreamException.
false;protected,abstract;1;1;;protected abstract void ignorableWhitespaceInternal(String data) throws XMLStreamException.
false;protected,abstract;2;2;;protected abstract void processingInstructionInternal(String target, String data) throws XMLStreamException.
false;protected,abstract;1;1;;protected abstract void skippedEntityInternal(String name) throws XMLStreamException.
false;protected,abstract;1;1;;protected abstract void dtdInternal(String dtd) throws XMLStreamException.
false;protected,abstract;1;1;;protected abstract void commentInternal(String comment) throws XMLStreamException.
