# id;timestamp;commentText;codeText;commentWords;codeWords
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1368540172;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			try {_				_				Class<?> type = clazz__				while (type.getSuperclass() != null && !Object.class.equals(type.getSuperclass())) {_					Type genericType = type.getGenericSuperclass()__					if (genericType instanceof ParameterizedType) {_						ParameterizedType pt = (ParameterizedType) genericType__						populateTypeMapFromParameterizedType(pt, typeVariableMap)__					}_					extractTypeVariablesFromGenericInterfaces(type.getSuperclass().getGenericInterfaces(), typeVariableMap)__					type = type.getSuperclass()__				}_			}_			catch (MalformedParameterizedTypeException ex) {_				_			}__			try {_				_				Class<?> type = clazz__				while (type.isMemberClass()) {_					Type genericType = type.getGenericSuperclass()__					if (genericType instanceof ParameterizedType) {_						ParameterizedType pt = (ParameterizedType) genericType__						populateTypeMapFromParameterizedType(pt, typeVariableMap)__					}_					type = type.getEnclosingClass()__				}_			}_			catch (MalformedParameterizedTypeException ex) {_				_			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,try,class,type,clazz,while,type,get,superclass,null,object,class,equals,type,get,superclass,type,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,superclass,get,generic,interfaces,type,variable,map,type,type,get,superclass,catch,malformed,parameterized,type,exception,ex,try,class,type,clazz,while,type,is,member,class,type,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,catch,malformed,parameterized,type,exception,ex,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1377020217;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			try {_				_				Class<?> type = clazz__				while (type.getSuperclass() != null && !Object.class.equals(type.getSuperclass())) {_					Type genericType = type.getGenericSuperclass()__					if (genericType instanceof ParameterizedType) {_						ParameterizedType pt = (ParameterizedType) genericType__						populateTypeMapFromParameterizedType(pt, typeVariableMap)__					}_					extractTypeVariablesFromGenericInterfaces(type.getSuperclass().getGenericInterfaces(), typeVariableMap)__					type = type.getSuperclass()__				}_			}_			catch (MalformedParameterizedTypeException ex) {_				_			}__			try {_				_				Class<?> type = clazz__				while (type.isMemberClass()) {_					Type genericType = type.getGenericSuperclass()__					if (genericType instanceof ParameterizedType) {_						ParameterizedType pt = (ParameterizedType) genericType__						populateTypeMapFromParameterizedType(pt, typeVariableMap)__					}_					type = type.getEnclosingClass()__				}_			}_			catch (MalformedParameterizedTypeException ex) {_				_			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,try,class,type,clazz,while,type,get,superclass,null,object,class,equals,type,get,superclass,type,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,superclass,get,generic,interfaces,type,variable,map,type,type,get,superclass,catch,malformed,parameterized,type,exception,ex,try,class,type,clazz,while,type,is,member,class,type,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,catch,malformed,parameterized,type,exception,ex,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1381389591;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0 use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1381788683;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1381842545;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1381843307;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1381992351;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1382716358;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1382747217;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1383229700;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1385412762;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParam);1399392386;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		return methodParam.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,return,method,param,get,generic,parameter,type
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1491898149;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1495868221;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1496837955;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1502974979;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1530174524;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1530532518;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1532520919;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}._Searches all super types, enclosing types and interfaces._@see #resolveType(Type, Map);@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,see,resolve,type,type,map;suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Type resolveType(Type genericType, @Nullable Class<?> contextClass);1496837955;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					Class<?> resolved = resolvedTypeVariable.resolve()__					if (resolved != null) {_						return resolved__					}_				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					Class<?> rawClass = resolvedType.getRawClass()__					if (rawClass != null) {_						return ResolvableType.forClassWithGenerics(rawClass, generics).getType()__					}_				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,nullable,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,class,resolved,resolved,type,variable,resolve,if,resolved,null,return,resolved,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,class,raw,class,resolved,type,get,raw,class,if,raw,class,null,return,resolvable,type,for,class,with,generics,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Type resolveType(Type genericType, @Nullable Class<?> contextClass);1502974979;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					Class<?> resolved = resolvedTypeVariable.resolve()__					if (resolved != null) {_						return resolved__					}_				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					Class<?> rawClass = resolvedType.getRawClass()__					if (rawClass != null) {_						return ResolvableType.forClassWithGenerics(rawClass, generics).getType()__					}_				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,nullable,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,class,resolved,resolved,type,variable,resolve,if,resolved,null,return,resolved,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,class,raw,class,resolved,type,get,raw,class,if,raw,class,null,return,resolvable,type,for,class,with,generics,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Type resolveType(Type genericType, @Nullable Class<?> contextClass);1530174524;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					Class<?> resolved = resolvedTypeVariable.resolve()__					if (resolved != null) {_						return resolved__					}_				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					Class<?> rawClass = resolvedType.getRawClass()__					if (rawClass != null) {_						return ResolvableType.forClassWithGenerics(rawClass, generics).getType()__					}_				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,nullable,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,class,resolved,resolved,type,variable,resolve,if,resolved,null,return,resolved,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,class,raw,class,resolved,type,get,raw,class,if,raw,class,null,return,resolvable,type,for,class,with,generics,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Type resolveType(Type genericType, @Nullable Class<?> contextClass);1530532518;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					Class<?> resolved = resolvedTypeVariable.resolve()__					if (resolved != null) {_						return resolved__					}_				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					Class<?> rawClass = resolvedType.getRawClass()__					if (rawClass != null) {_						return ResolvableType.forClassWithGenerics(rawClass, generics).getType()__					}_				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,nullable,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,class,resolved,resolved,type,variable,resolve,if,resolved,null,return,resolved,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,class,raw,class,resolved,type,get,raw,class,if,raw,class,null,return,resolvable,type,for,class,with,generics,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Type resolveType(Type genericType, @Nullable Class<?> contextClass);1532520919;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					Class<?> resolved = resolvedTypeVariable.resolve()__					if (resolved != null) {_						return resolved__					}_				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					Class<?> rawClass = resolvedType.getRawClass()__					if (rawClass != null) {_						return ResolvableType.forClassWithGenerics(rawClass, generics).getType()__					}_				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,nullable,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,class,resolved,resolved,type,variable,resolve,if,resolved,null,return,resolved,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,class,raw,class,resolved,type,get,raw,class,if,raw,class,null,return,resolvable,type,for,class,with,generics,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1340122048;Determine the target type for the generic return type of the given method,_where the type variable is declared on the given class.__@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveParameterizedReturnType;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,the,type,variable,is,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,parameterized,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1344186578;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class.__@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1351982790;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class.__@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1353522416;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class.__@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1356735495;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class.__@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1362408075;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1367955086;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1368540172;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1377020217;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Type genericType = method.getGenericReturnType()__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class<?>) rawType : method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,type,generic,type,method,get,generic,return,type,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1381389591;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturn(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1381788683;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1381842545;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1381843307;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1381992351;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1382716358;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1382747217;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1383229700;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1385412762;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1399392386;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1449143598;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1467730834;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1468334463;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1485277217;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type_@see #resolveReturnTypeForGenericMethod;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type,see,resolve,return,type,for,generic,method;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1491831389;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1491898149;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1495868221;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1496837955;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1502974979;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1530174524;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1530532518;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnType(Method method, Class<?> clazz);1532520919;Determine the target type for the generic return type of the given method,_where formal type variables are declared on the given class._@param method the method to introspect_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveReturnType(Method method, Class<?> clazz) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(clazz, "Class must not be null")__		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType())__	};determine,the,target,type,for,the,generic,return,type,of,the,given,method,where,formal,type,variables,are,declared,on,the,given,class,param,method,the,method,to,introspect,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,return,type,method,method,class,clazz,assert,not,null,method,method,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,return,resolvable,type,for,method,return,type,method,clazz,resolve,method,get,return,type
GenericTypeResolver -> public static Type resolveType(Type genericType, Class<?> contextClass);1491831389;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					return resolvedTypeVariable.resolve()__				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					return ResolvableType.forClassWithGenerics(resolvedType.getRawClass(), generics).getType()__				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,return,resolved,type,variable,resolve,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,return,resolvable,type,for,class,with,generics,resolved,type,get,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Type resolveType(Type genericType, Class<?> contextClass);1491898149;Resolve the given generic type against the given context class,_substituting type variables as far as possible._@param genericType the (potentially) generic type_@param contextClass a context class for the target type, for example a class_in which the target type appears in a method signature (can be {@code null})_@return the resolved type (possibly the given generic type as-is)_@since 5.0;public static Type resolveType(Type genericType, Class<?> contextClass) {_		if (contextClass != null) {_			if (genericType instanceof TypeVariable) {_				ResolvableType resolvedTypeVariable = resolveVariable(_						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass))__				if (resolvedTypeVariable != ResolvableType.NONE) {_					return resolvedTypeVariable.resolve()__				}_			}_			else if (genericType instanceof ParameterizedType) {_				ResolvableType resolvedType = ResolvableType.forType(genericType)__				if (resolvedType.hasUnresolvableGenerics()) {_					ParameterizedType parameterizedType = (ParameterizedType) genericType__					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length]__					Type[] typeArguments = parameterizedType.getActualTypeArguments()__					for (int i = 0_ i < typeArguments.length_ i++) {_						Type typeArgument = typeArguments[i]__						if (typeArgument instanceof TypeVariable) {_							ResolvableType resolvedTypeArgument = resolveVariable(_									(TypeVariable<?>) typeArgument, ResolvableType.forClass(contextClass))__							if (resolvedTypeArgument != ResolvableType.NONE) {_								generics[i] = resolvedTypeArgument.resolve()__							}_							else {_								generics[i] = ResolvableType.forType(typeArgument).resolve()__							}_						}_						else {_							generics[i] = ResolvableType.forType(typeArgument).resolve()__						}_					}_					return ResolvableType.forClassWithGenerics(resolvedType.getRawClass(), generics).getType()__				}_			}_		}_		return genericType__	};resolve,the,given,generic,type,against,the,given,context,class,substituting,type,variables,as,far,as,possible,param,generic,type,the,potentially,generic,type,param,context,class,a,context,class,for,the,target,type,for,example,a,class,in,which,the,target,type,appears,in,a,method,signature,can,be,code,null,return,the,resolved,type,possibly,the,given,generic,type,as,is,since,5,0;public,static,type,resolve,type,type,generic,type,class,context,class,if,context,class,null,if,generic,type,instanceof,type,variable,resolvable,type,resolved,type,variable,resolve,variable,type,variable,generic,type,resolvable,type,for,class,context,class,if,resolved,type,variable,resolvable,type,none,return,resolved,type,variable,resolve,else,if,generic,type,instanceof,parameterized,type,resolvable,type,resolved,type,resolvable,type,for,type,generic,type,if,resolved,type,has,unresolvable,generics,parameterized,type,parameterized,type,parameterized,type,generic,type,class,generics,new,class,parameterized,type,get,actual,type,arguments,length,type,type,arguments,parameterized,type,get,actual,type,arguments,for,int,i,0,i,type,arguments,length,i,type,type,argument,type,arguments,i,if,type,argument,instanceof,type,variable,resolvable,type,resolved,type,argument,resolve,variable,type,variable,type,argument,resolvable,type,for,class,context,class,if,resolved,type,argument,resolvable,type,none,generics,i,resolved,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,else,generics,i,resolvable,type,for,type,type,argument,resolve,return,resolvable,type,for,class,with,generics,resolved,type,get,raw,class,generics,get,type,return,generic,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1368540172;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1377020217;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1381389591;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1381788683;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1381842545;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1381843307;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1381992351;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1382716358;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1382747217;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1383229700;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1385412762;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1399392386;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1449143598;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1467730834;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1468334463;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1485277217;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1491831389;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1491898149;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1381389591;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVaraibleMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,varaible,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1381788683;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1381842545;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1381843307;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1381992351;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1382716358;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1382747217;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1383229700;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1328020251;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or <code>Object.class</code> otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class) rawType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,code,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1340122048;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or <code>Object.class</code> otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class) rawType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,code,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1344186578;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or <code>Object.class</code> otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class) rawType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,code,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1351982790;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or <code>Object.class</code> otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type rawType = getRawType(genericType, typeVariableMap)__		return (rawType instanceof Class ? (Class) rawType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,code,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,raw,type,get,raw,type,generic,type,type,variable,map,return,raw,type,instanceof,class,class,raw,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1353522416;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or <code>Object.class</code> otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = getRawType(genericType, typeVariableMap)__		if (resolvedType instanceof GenericArrayType) {_			Type componentType = ((GenericArrayType) resolvedType).getGenericComponentType()__			Class<?> componentClass = resolveType(componentType, typeVariableMap)__			resolvedType = Array.newInstance(componentClass, 0).getClass()__		}_		return (resolvedType instanceof Class ? (Class) resolvedType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,code,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,get,raw,type,generic,type,type,variable,map,if,resolved,type,instanceof,generic,array,type,type,component,type,generic,array,type,resolved,type,get,generic,component,type,class,component,class,resolve,type,component,type,type,variable,map,resolved,type,array,new,instance,component,class,0,get,class,return,resolved,type,instanceof,class,class,resolved,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1356735495;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = getRawType(genericType, typeVariableMap)__		if (resolvedType instanceof GenericArrayType) {_			Type componentType = ((GenericArrayType) resolvedType).getGenericComponentType()__			Class<?> componentClass = resolveType(componentType, typeVariableMap)__			resolvedType = Array.newInstance(componentClass, 0).getClass()__		}_		return (resolvedType instanceof Class ? (Class) resolvedType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,get,raw,type,generic,type,type,variable,map,if,resolved,type,instanceof,generic,array,type,type,component,type,generic,array,type,resolved,type,get,generic,component,type,class,component,class,resolve,type,component,type,type,variable,map,resolved,type,array,new,instance,component,class,0,get,class,return,resolved,type,instanceof,class,class,resolved,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1362408075;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = getRawType(genericType, typeVariableMap)__		if (resolvedType instanceof GenericArrayType) {_			Type componentType = ((GenericArrayType) resolvedType).getGenericComponentType()__			Class<?> componentClass = resolveType(componentType, typeVariableMap)__			resolvedType = Array.newInstance(componentClass, 0).getClass()__		}_		return (resolvedType instanceof Class ? (Class) resolvedType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,get,raw,type,generic,type,type,variable,map,if,resolved,type,instanceof,generic,array,type,type,component,type,generic,array,type,resolved,type,get,generic,component,type,class,component,class,resolve,type,component,type,type,variable,map,resolved,type,array,new,instance,component,class,0,get,class,return,resolved,type,instanceof,class,class,resolved,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1367955086;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = getRawType(genericType, typeVariableMap)__		if (resolvedType instanceof GenericArrayType) {_			Type componentType = ((GenericArrayType) resolvedType).getGenericComponentType()__			Class<?> componentClass = resolveType(componentType, typeVariableMap)__			resolvedType = Array.newInstance(componentClass, 0).getClass()__		}_		return (resolvedType instanceof Class ? (Class) resolvedType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,get,raw,type,generic,type,type,variable,map,if,resolved,type,instanceof,generic,array,type,type,component,type,generic,array,type,resolved,type,get,generic,component,type,class,component,class,resolve,type,component,type,type,variable,map,resolved,type,array,new,instance,component,class,0,get,class,return,resolved,type,instanceof,class,class,resolved,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1368540172;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = getRawType(genericType, typeVariableMap)__		if (resolvedType instanceof GenericArrayType) {_			Type componentType = ((GenericArrayType) resolvedType).getGenericComponentType()__			Class<?> componentClass = resolveType(componentType, typeVariableMap)__			resolvedType = Array.newInstance(componentClass, 0).getClass()__		}_		return (resolvedType instanceof Class ? (Class) resolvedType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,get,raw,type,generic,type,type,variable,map,if,resolved,type,instanceof,generic,array,type,type,component,type,generic,array,type,resolved,type,get,generic,component,type,class,component,class,resolve,type,component,type,type,variable,map,resolved,type,array,new,instance,component,class,0,get,class,return,resolved,type,instanceof,class,class,resolved,type,object,class
GenericTypeResolver -> public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1377020217;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = getRawType(genericType, typeVariableMap)__		if (resolvedType instanceof GenericArrayType) {_			Type componentType = ((GenericArrayType) resolvedType).getGenericComponentType()__			Class<?> componentClass = resolveType(componentType, typeVariableMap)__			resolvedType = Array.newInstance(componentClass, 0).getClass()__		}_		return (resolvedType instanceof Class ? (Class) resolvedType : Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,get,raw,type,generic,type,type,variable,map,if,resolved,type,instanceof,generic,array,type,type,component,type,generic,array,type,resolved,type,get,generic,component,type,class,component,class,resolve,type,component,type,type,variable,map,resolved,type,array,new,instance,component,class,0,get,class,return,resolved,type,instanceof,class,class,resolved,type,object,class
GenericTypeResolver -> @Nullable 	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1495868221;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;@Nullable_	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1496837955;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;@Nullable_	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1502974979;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;@Nullable_	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1530174524;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;@Nullable_	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1530532518;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;@Nullable_	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc);1532520919;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;@Nullable_	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc)__		if (!resolvableType.hasGenerics()) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,resolvable,type,resolvable,type,resolvable,type,for,class,clazz,as,generic,ifc,if,resolvable,type,has,generics,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1328020251;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '<code>FooImpl</code>' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,code,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1340122048;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '<code>FooImpl</code>' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,code,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1344186578;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '<code>FooImpl</code>' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,code,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1351982790;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '<code>FooImpl</code>' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,code,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1353522416;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '<code>FooImpl</code>' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,code,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1356735495;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '{@code FooImpl}' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1362408075;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '{@code FooImpl}' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1367955086;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '{@code FooImpl}' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1368540172;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '{@code FooImpl}' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap);1377020217;Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}_and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} ->_concrete type to the supplied {@link Map}._<p>Consider this case:_<pre class="code>_public interface Foo<S, T> {____public class FooImpl implements Foo<String, Integer> {__}</pre>_For '{@code FooImpl}' the following mappings would be added to the {@link Map}:_{S=java.lang.String, T=java.lang.Integer}.;private static void populateTypeMapFromParameterizedType(ParameterizedType type, Map<TypeVariable, Type> typeVariableMap) {_		if (type.getRawType() instanceof Class) {_			Type[] actualTypeArguments = type.getActualTypeArguments()__			TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters()__			for (int i = 0_ i < actualTypeArguments.length_ i++) {_				Type actualTypeArgument = actualTypeArguments[i]__				TypeVariable variable = typeVariables[i]__				if (actualTypeArgument instanceof Class) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof GenericArrayType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof ParameterizedType) {_					typeVariableMap.put(variable, actualTypeArgument)__				}_				else if (actualTypeArgument instanceof TypeVariable) {_					_					_					TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument__					Type resolvedType = typeVariableMap.get(typeVariableArgument)__					if (resolvedType == null) {_						resolvedType = extractBoundForTypeVariable(typeVariableArgument)__					}_					typeVariableMap.put(variable, resolvedType)__				}_			}_		}_	};read,the,link,type,variable,type,variables,from,the,supplied,link,parameterized,type,and,add,mappings,corresponding,to,the,link,type,variable,get,name,type,variable,name,concrete,type,to,the,supplied,link,map,p,consider,this,case,pre,class,code,public,interface,foo,s,t,public,class,foo,impl,implements,foo,string,integer,pre,for,code,foo,impl,the,following,mappings,would,be,added,to,the,link,map,s,java,lang,string,t,java,lang,integer;private,static,void,populate,type,map,from,parameterized,type,parameterized,type,type,map,type,variable,type,type,variable,map,if,type,get,raw,type,instanceof,class,type,actual,type,arguments,type,get,actual,type,arguments,type,variable,type,variables,class,type,get,raw,type,get,type,parameters,for,int,i,0,i,actual,type,arguments,length,i,type,actual,type,argument,actual,type,arguments,i,type,variable,variable,type,variables,i,if,actual,type,argument,instanceof,class,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,generic,array,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,parameterized,type,type,variable,map,put,variable,actual,type,argument,else,if,actual,type,argument,instanceof,type,variable,type,variable,type,variable,argument,type,variable,actual,type,argument,type,resolved,type,type,variable,map,get,type,variable,argument,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,type,variable,argument,type,variable,map,put,variable,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1328020251;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1340122048;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1344186578;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1351982790;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1353522416;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1356735495;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1362408075;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1367955086;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1368540172;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1377020217;Determine the raw type for the given generic parameter type._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the resolved raw type;static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		Type resolvedType = genericType__		if (genericType instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) genericType__			resolvedType = typeVariableMap.get(tv)__			if (resolvedType == null) {_				resolvedType = extractBoundForTypeVariable(tv)__			}_		}_		if (resolvedType instanceof ParameterizedType) {_			return ((ParameterizedType) resolvedType).getRawType()__		}_		else {_			return resolvedType__		}_	};determine,the,raw,type,for,the,given,generic,parameter,type,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,resolved,raw,type;static,type,get,raw,type,type,generic,type,map,type,variable,type,type,variable,map,type,resolved,type,generic,type,if,generic,type,instanceof,type,variable,type,variable,tv,type,variable,generic,type,resolved,type,type,variable,map,get,tv,if,resolved,type,null,resolved,type,extract,bound,for,type,variable,tv,if,resolved,type,instanceof,parameterized,type,return,parameterized,type,resolved,type,get,raw,type,else,return,resolved,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1328020251;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or <code>null</code>_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return GenericTypeResolver.resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,code,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,generic,type,resolver,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1340122048;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or <code>null</code>_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,code,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1344186578;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or <code>null</code>_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,code,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1351982790;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or <code>null</code>_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,code,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1353522416;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or <code>null</code>_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,code,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1356735495;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1362408075;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1367955086;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1368540172;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1377020217;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		Type returnType = method.getReturnType()__		Type genericReturnType = method.getGenericReturnType()__		if (returnType.equals(genericIfc)) {_			if (genericReturnType instanceof ParameterizedType) {_				ParameterizedType targetType = (ParameterizedType) genericReturnType__				Type[] actualTypeArguments = targetType.getActualTypeArguments()__				Type typeArg = actualTypeArguments[0]__				if (!(typeArg instanceof WildcardType)) {_					return (Class<?>) typeArg__				}_			}_			else {_				return null__			}_		}_		return resolveTypeArgument((Class<?>) returnType, genericIfc)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,type,return,type,method,get,return,type,type,generic,return,type,method,get,generic,return,type,if,return,type,equals,generic,ifc,if,generic,return,type,instanceof,parameterized,type,parameterized,type,target,type,parameterized,type,generic,return,type,type,actual,type,arguments,target,type,get,actual,type,arguments,type,type,arg,actual,type,arguments,0,if,type,arg,instanceof,wildcard,type,return,class,type,arg,else,return,null,return,resolve,type,argument,class,return,type,generic,ifc
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1381389591;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturn(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1381788683;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1381842545;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1381843307;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1381992351;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1382716358;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1382747217;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1383229700;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1385412762;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1399392386;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1449143598;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1467730834;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1468334463;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1485277217;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1491831389;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1491898149;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1381788683;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1381842545;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1381843307;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1381992351;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1382716358;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1382747217;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1383229700;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1385412762;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1399392386;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1449143598;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1467730834;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1468334463;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader);1485277217;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(may be {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String && classLoader != null) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specific class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,may,be,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,class,loader,null,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specific,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1385412762;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1399392386;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1449143598;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1467730834;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1468334463;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1485277217;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1491898149;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1495868221;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1496837955;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1502974979;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1530174524;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1530532518;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @SuppressWarnings("rawtypes") 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1532520919;Resolve the specified generic type against the given TypeVariable map._<p>Used by Spring Data._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise;@SuppressWarnings("rawtypes")_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).toClass()__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,p,used,by,spring,data,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise;suppress,warnings,rawtypes,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,to,class
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1368540172;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class<?> result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1377020217;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class<?> result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1381389591;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.resolveClass = clazz__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam, clazz).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,resolve,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,clazz,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1381788683;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1381842545;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1381843307;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1381992351;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1382716358;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1382747217;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1383229700;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1385412762;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz);1399392386;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		Assert.notNull(clazz, "Class must not be null")__		methodParam.setContainingClass(clazz)__		methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve())__		return methodParam.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,assert,not,null,method,param,method,parameter,must,not,be,null,assert,not,null,clazz,class,must,not,be,null,method,param,set,containing,class,clazz,method,param,set,parameter,type,resolvable,type,for,method,parameter,method,param,resolve,return,method,param,get,parameter,type
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1381389591;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		TypeVariableResolver variableResolver = new TypeVariableMapResolver(typeVariableMap)__		Class<?> resolved = ResolvableType.forType(genericType, variableResolver).resolve()__		return (resolved == null ? Object.class : resolved)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,variable,resolver,variable,resolver,new,type,variable,map,resolver,type,variable,map,class,resolved,resolvable,type,for,type,generic,type,variable,resolver,resolve,return,resolved,null,object,class,resolved
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1381788683;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		TypeVariableResolver variableResolver = new TypeVariableMapResolver(typeVariableMap)__		Class<?> resolved = ResolvableType.forType(genericType, variableResolver).resolve()__		return (resolved == null ? Object.class : resolved)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,variable,resolver,variable,resolver,new,type,variable,map,resolver,type,variable,map,class,resolved,resolvable,type,for,type,generic,type,variable,resolver,resolve,return,resolved,null,object,class,resolved
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1381842545;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		TypeVariableResolver variableResolver = new TypeVariableMapResolver(typeVariableMap)__		Class<?> resolved = ResolvableType.forType(genericType, variableResolver).resolve()__		return (resolved == null ? Object.class : resolved)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,variable,resolver,variable,resolver,new,type,variable,map,resolver,type,variable,map,class,resolved,resolvable,type,for,type,generic,type,variable,resolver,resolve,return,resolved,null,object,class,resolved
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap);1381843307;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param typeVariableMap the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> typeVariableMap) {_		TypeVariableResolver variableResolver = new TypeVariableMapResolver(typeVariableMap)__		Class<?> resolved = ResolvableType.forType(genericType, variableResolver).resolve()__		return (resolved == null ? Object.class : resolved)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,type,variable,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,type,variable,map,type,variable,resolver,variable,resolver,new,type,variable,map,resolver,type,variable,map,class,resolved,resolvable,type,for,type,generic,type,variable,resolver,resolve,return,resolved,null,object,class,resolved
GenericTypeResolver -> @Nullable 	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1495868221;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;@Nullable_	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;nullable,public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1496837955;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;@Nullable_	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;nullable,public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1502974979;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;@Nullable_	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;nullable,public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1530174524;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;@Nullable_	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;nullable,public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1530532518;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;@Nullable_	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "Method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;nullable,public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> @Nullable 	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc);1532520919;Resolve the single type argument of the given generic interface against the given_target method which is assumed to return the given interface or an implementation_of it._@param method the target method to check the return type of_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved parameter type of the method return type, or {@code null}_if not resolvable or if the single argument is of type {@link WildcardType}.;@Nullable_	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {_		Assert.notNull(method, "Method must not be null")__		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc)__		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {_			return null__		}_		return getSingleGeneric(resolvableType)__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,method,which,is,assumed,to,return,the,given,interface,or,an,implementation,of,it,param,method,the,target,method,to,check,the,return,type,of,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,parameter,type,of,the,method,return,type,or,code,null,if,not,resolvable,or,if,the,single,argument,is,of,type,link,wildcard,type;nullable,public,static,class,resolve,return,type,argument,method,method,class,generic,ifc,assert,not,null,method,method,must,not,be,null,resolvable,type,resolvable,type,resolvable,type,for,method,return,type,method,as,generic,ifc,if,resolvable,type,has,generics,resolvable,type,get,type,instanceof,wildcard,type,return,null,return,get,single,generic,resolvable,type
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1328020251;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1340122048;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1344186578;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1351982790;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1353522416;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1356735495;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1362408075;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class extractClass(Class ownerClass, Type arg);1367955086;Extract a class instance from given Type.;private static Class extractClass(Class ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParameter);1449143598;Determine the target type for the given parameter specification._@param methodParameter the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		return methodParameter.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,parameter,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,return,method,parameter,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParameter);1467730834;Determine the target type for the given parameter specification._@param methodParameter the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		return methodParameter.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,parameter,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,return,method,parameter,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParameter);1468334463;Determine the target type for the given parameter specification._@param methodParameter the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		return methodParameter.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,parameter,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,return,method,parameter,get,generic,parameter,type
GenericTypeResolver -> @Deprecated 	public static Type getTargetType(MethodParameter methodParameter);1485277217;Determine the target type for the given parameter specification._@param methodParameter the method parameter specification_@return the corresponding generic parameter type_@deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()};@Deprecated_	public static Type getTargetType(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		return methodParameter.getGenericParameterType()__	};determine,the,target,type,for,the,given,parameter,specification,param,method,parameter,the,method,parameter,specification,return,the,corresponding,generic,parameter,type,deprecated,as,of,spring,4,0,use,link,method,parameter,get,generic,parameter,type;deprecated,public,static,type,get,target,type,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,return,method,parameter,get,generic,parameter,type
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1368540172;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1377020217;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1381389591;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if(!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1381788683;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1381842545;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1381843307;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1381992351;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1382716358;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1382747217;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> @Nullable 	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1495868221;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;@Nullable_	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> @Nullable 	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1496837955;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;@Nullable_	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> @Nullable 	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1502974979;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;@Nullable_	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> @Nullable 	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1530174524;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;@Nullable_	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> @Nullable 	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1530532518;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;@Nullable_	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> @Nullable 	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1532520919;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;@Nullable_	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;nullable,public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1344186578;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself.__<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}.__<pre>{@code public static <T> T createProxy(Class<T> clazz)}</pre>__<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>__@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or_{@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "method must not be null")__		Assert.notNull(args, "args must not be null")___		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",_				method.toGenericString(), ObjectUtils.nullSafeToString(args)))__		}__		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		final Type genericReturnType = method.getGenericReturnType()__		final Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				if (logger.isDebugEnabled()) {_					logger.debug(String.format(_						"Found declared type variable [%s] that matches the target return type [%s].",_						currentTypeVariable, genericReturnType))__				}_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				final Type currentMethodArgumentType = methodArgumentTypes[i]___				if (currentMethodArgumentType.equals(genericReturnType)) {_					if (logger.isDebugEnabled()) {_						logger.debug(String.format(_							"Found method argument type at index [%s] that matches the target return type.", i))__					}_					return args[i].getClass()__				}__				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()___					for (int j = 0_ j < actualTypeArguments.length_ j++) {_						final Type typeArg = actualTypeArguments[j]___						if (typeArg.equals(genericReturnType)) {_							if (logger.isDebugEnabled()) {_								logger.debug(String.format(_									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",_									i))__							}__							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							} else {_								_								_								logger.info(String.format(_									"Could not determine the target type for type argument [%s] for method [%s].",_									typeArg, method.toGenericString()))___								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,args,must,not,be,null,if,logger,is,debug,enabled,logger,debug,string,format,resolving,return,type,for,s,with,concrete,method,arguments,s,method,to,generic,string,object,utils,null,safe,to,string,args,final,type,variable,method,declared,type,variables,method,get,type,parameters,final,type,generic,return,type,method,get,generic,return,type,final,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,declared,type,variable,s,that,matches,the,target,return,type,s,current,type,variable,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,final,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,matches,the,target,return,type,i,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,int,j,0,j,actual,type,arguments,length,j,final,type,type,arg,actual,type,arguments,j,if,type,arg,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,is,parameterized,with,a,type,argument,that,matches,the,target,return,type,i,if,args,i,instanceof,class,return,class,args,i,else,logger,info,string,format,could,not,determine,the,target,type,for,type,argument,s,for,method,s,type,arg,method,to,generic,string,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1351982790;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself.__<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}.__<pre>{@code public static <T> T createProxy(Class<T> clazz)}</pre>__<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>__@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or_{@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "method must not be null")__		Assert.notNull(args, "args must not be null")___		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",_				method.toGenericString(), ObjectUtils.nullSafeToString(args)))__		}__		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		final Type genericReturnType = method.getGenericReturnType()__		final Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				if (logger.isDebugEnabled()) {_					logger.debug(String.format(_						"Found declared type variable [%s] that matches the target return type [%s].",_						currentTypeVariable, genericReturnType))__				}_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				final Type currentMethodArgumentType = methodArgumentTypes[i]___				if (currentMethodArgumentType.equals(genericReturnType)) {_					if (logger.isDebugEnabled()) {_						logger.debug(String.format(_							"Found method argument type at index [%s] that matches the target return type.", i))__					}_					return args[i].getClass()__				}__				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()___					for (int j = 0_ j < actualTypeArguments.length_ j++) {_						final Type typeArg = actualTypeArguments[j]___						if (typeArg.equals(genericReturnType)) {_							if (logger.isDebugEnabled()) {_								logger.debug(String.format(_									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",_									i))__							}__							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							} else {_								_								_								logger.info(String.format(_									"Could not determine the target type for type argument [%s] for method [%s].",_									typeArg, method.toGenericString()))___								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,args,must,not,be,null,if,logger,is,debug,enabled,logger,debug,string,format,resolving,return,type,for,s,with,concrete,method,arguments,s,method,to,generic,string,object,utils,null,safe,to,string,args,final,type,variable,method,declared,type,variables,method,get,type,parameters,final,type,generic,return,type,method,get,generic,return,type,final,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,declared,type,variable,s,that,matches,the,target,return,type,s,current,type,variable,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,final,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,matches,the,target,return,type,i,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,int,j,0,j,actual,type,arguments,length,j,final,type,type,arg,actual,type,arguments,j,if,type,arg,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,is,parameterized,with,a,type,argument,that,matches,the,target,return,type,i,if,args,i,instanceof,class,return,class,args,i,else,logger,info,string,format,could,not,determine,the,target,type,for,type,argument,s,for,method,s,type,arg,method,to,generic,string,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1353522416;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself.__<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}.__<pre>{@code public static <T> T createProxy(Class<T> clazz)}</pre>__<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>__@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or_{@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "method must not be null")__		Assert.notNull(args, "args must not be null")___		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",_				method.toGenericString(), ObjectUtils.nullSafeToString(args)))__		}__		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		final Type genericReturnType = method.getGenericReturnType()__		final Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				if (logger.isDebugEnabled()) {_					logger.debug(String.format(_						"Found declared type variable [%s] that matches the target return type [%s].",_						currentTypeVariable, genericReturnType))__				}_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				final Type currentMethodArgumentType = methodArgumentTypes[i]___				if (currentMethodArgumentType.equals(genericReturnType)) {_					if (logger.isDebugEnabled()) {_						logger.debug(String.format(_							"Found method argument type at index [%s] that matches the target return type.", i))__					}_					return args[i].getClass()__				}__				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()___					for (int j = 0_ j < actualTypeArguments.length_ j++) {_						final Type typeArg = actualTypeArguments[j]___						if (typeArg.equals(genericReturnType)) {_							if (logger.isDebugEnabled()) {_								logger.debug(String.format(_									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",_									i))__							}__							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							} else {_								_								_								logger.info(String.format(_									"Could not determine the target type for type argument [%s] for method [%s].",_									typeArg, method.toGenericString()))___								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,args,must,not,be,null,if,logger,is,debug,enabled,logger,debug,string,format,resolving,return,type,for,s,with,concrete,method,arguments,s,method,to,generic,string,object,utils,null,safe,to,string,args,final,type,variable,method,declared,type,variables,method,get,type,parameters,final,type,generic,return,type,method,get,generic,return,type,final,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,declared,type,variable,s,that,matches,the,target,return,type,s,current,type,variable,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,final,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,matches,the,target,return,type,i,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,int,j,0,j,actual,type,arguments,length,j,final,type,type,arg,actual,type,arguments,j,if,type,arg,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,is,parameterized,with,a,type,argument,that,matches,the,target,return,type,i,if,args,i,instanceof,class,return,class,args,i,else,logger,info,string,format,could,not,determine,the,target,type,for,type,argument,s,for,method,s,type,arg,method,to,generic,string,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1356735495;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself.__<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}.__<pre>{@code public static <T> T createProxy(Class<T> clazz)}</pre>__<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>__@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or_{@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "method must not be null")__		Assert.notNull(args, "args must not be null")___		if (logger.isDebugEnabled()) {_			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",_				method.toGenericString(), ObjectUtils.nullSafeToString(args)))__		}__		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		final Type genericReturnType = method.getGenericReturnType()__		final Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				if (logger.isDebugEnabled()) {_					logger.debug(String.format(_						"Found declared type variable [%s] that matches the target return type [%s].",_						currentTypeVariable, genericReturnType))__				}_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				final Type currentMethodArgumentType = methodArgumentTypes[i]___				if (currentMethodArgumentType.equals(genericReturnType)) {_					if (logger.isDebugEnabled()) {_						logger.debug(String.format(_							"Found method argument type at index [%s] that matches the target return type.", i))__					}_					return args[i].getClass()__				}__				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()___					for (int j = 0_ j < actualTypeArguments.length_ j++) {_						final Type typeArg = actualTypeArguments[j]___						if (typeArg.equals(genericReturnType)) {_							if (logger.isDebugEnabled()) {_								logger.debug(String.format(_									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",_									i))__							}__							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							} else {_								_								_								logger.info(String.format(_									"Could not determine the target type for type argument [%s] for method [%s].",_									typeArg, method.toGenericString()))___								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,args,must,not,be,null,if,logger,is,debug,enabled,logger,debug,string,format,resolving,return,type,for,s,with,concrete,method,arguments,s,method,to,generic,string,object,utils,null,safe,to,string,args,final,type,variable,method,declared,type,variables,method,get,type,parameters,final,type,generic,return,type,method,get,generic,return,type,final,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,declared,type,variable,s,that,matches,the,target,return,type,s,current,type,variable,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,final,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,matches,the,target,return,type,i,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,int,j,0,j,actual,type,arguments,length,j,final,type,type,arg,actual,type,arguments,j,if,type,arg,equals,generic,return,type,if,logger,is,debug,enabled,logger,debug,string,format,found,method,argument,type,at,index,s,that,is,parameterized,with,a,type,argument,that,matches,the,target,return,type,i,if,args,i,instanceof,class,return,class,args,i,else,logger,info,string,format,could,not,determine,the,target,type,for,type,argument,s,for,method,s,type,arg,method,to,generic,string,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1362408075;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre>{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,args,i,instanceof,class,return,class,args,i,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1367955086;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,args,i,instanceof,class,return,class,args,i,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1368540172;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,args,i,instanceof,class,return,class,args,i,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1377020217;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,args,i,instanceof,class,return,class,args,i,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args);1381389591;Determine the target type for the generic return type of the given_<em>generic method</em>, where formal type variables are declared on_the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect, never {@code null}_@param args the arguments that will be supplied to the method when it is_invoked, never {@code null}_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2_@see #resolveReturnType;public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (args[i] instanceof Class) {_								return (Class<?>) args[i]__							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,see,resolve,return,type;public,static,class,resolve,return,type,for,generic,method,method,method,object,args,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,args,i,instanceof,class,return,class,args,i,else,return,method,get,return,type,return,method,get,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1328020251;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1340122048;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1344186578;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1351982790;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1353522416;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1356735495;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1362408075;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1367955086;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1368540172;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> public static Type getTargetType(MethodParameter methodParam);1377020217;Determine the target type for the given parameter specification._@param methodParam the method parameter specification_@return the corresponding generic parameter type;public static Type getTargetType(MethodParameter methodParam) {_		Assert.notNull(methodParam, "MethodParameter must not be null")__		if (methodParam.getConstructor() != null) {_			return methodParam.getConstructor().getGenericParameterTypes()[methodParam.getParameterIndex()]__		}_		else {_			if (methodParam.getParameterIndex() >= 0) {_				return methodParam.getMethod().getGenericParameterTypes()[methodParam.getParameterIndex()]__			}_			else {_				return methodParam.getMethod().getGenericReturnType()__			}_		}_	};determine,the,target,type,for,the,given,parameter,specification,param,method,param,the,method,parameter,specification,return,the,corresponding,generic,parameter,type;public,static,type,get,target,type,method,parameter,method,param,assert,not,null,method,param,method,parameter,must,not,be,null,if,method,param,get,constructor,null,return,method,param,get,constructor,get,generic,parameter,types,method,param,get,parameter,index,else,if,method,param,get,parameter,index,0,return,method,param,get,method,get,generic,parameter,types,method,param,get,parameter,index,else,return,method,param,get,method,get,generic,return,type
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1328020251;Extracts the bound <code>Type</code> for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,code,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1340122048;Extracts the bound <code>Type</code> for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,code,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1344186578;Extracts the bound <code>Type</code> for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,code,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1351982790;Extracts the bound <code>Type</code> for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,code,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1353522416;Extracts the bound <code>Type</code> for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,code,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1356735495;Extracts the bound {@code Type} for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1362408075;Extracts the bound {@code Type} for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1367955086;Extracts the bound {@code Type} for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1368540172;Extracts the bound {@code Type} for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> static Type extractBoundForTypeVariable(TypeVariable typeVariable);1377020217;Extracts the bound {@code Type} for a given {@link TypeVariable}.;static Type extractBoundForTypeVariable(TypeVariable typeVariable) {_		Type[] bounds = typeVariable.getBounds()__		if (bounds.length == 0) {_			return Object.class__		}_		Type bound = bounds[0]__		if (bound instanceof TypeVariable) {_			bound = extractBoundForTypeVariable((TypeVariable) bound)__		}_		return bound__	};extracts,the,bound,code,type,for,a,given,link,type,variable;static,type,extract,bound,for,type,variable,type,variable,type,variable,type,bounds,type,variable,get,bounds,if,bounds,length,0,return,object,class,type,bound,bounds,0,if,bound,instanceof,type,variable,bound,extract,bound,for,type,variable,type,variable,bound,return,bound
GenericTypeResolver -> private static Class<?> extractClass(Class<?> ownerClass, Type arg);1368540172;Extract a class instance from given Type.;private static Class<?> extractClass(Class<?> ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__			}_			else {_				arg = extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,instance,from,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,else,arg,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> private static Class<?> extractClass(Class<?> ownerClass, Type arg);1377020217;Extract a Class from the given Type.;private static Class<?> extractClass(Class<?> ownerClass, Type arg) {_		if (arg instanceof ParameterizedType) {_			return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__		}_		else if (arg instanceof GenericArrayType) {_			GenericArrayType gat = (GenericArrayType) arg__			Type gt = gat.getGenericComponentType()__			Class<?> componentClass = extractClass(ownerClass, gt)__			return Array.newInstance(componentClass, 0).getClass()__		}_		else if (arg instanceof TypeVariable) {_			TypeVariable tv = (TypeVariable) arg__			arg = getTypeVariableMap(ownerClass).get(tv)__			if (arg == null) {_				arg = extractBoundForTypeVariable(tv)__				if (arg instanceof ParameterizedType) {_					return extractClass(ownerClass, ((ParameterizedType) arg).getRawType())__				}_			}_			else {_				return extractClass(ownerClass, arg)__			}_		}_		return (arg instanceof Class ? (Class) arg : Object.class)__	};extract,a,class,from,the,given,type;private,static,class,extract,class,class,owner,class,type,arg,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,if,arg,instanceof,generic,array,type,generic,array,type,gat,generic,array,type,arg,type,gt,gat,get,generic,component,type,class,component,class,extract,class,owner,class,gt,return,array,new,instance,component,class,0,get,class,else,if,arg,instanceof,type,variable,type,variable,tv,type,variable,arg,arg,get,type,variable,map,owner,class,get,tv,if,arg,null,arg,extract,bound,for,type,variable,tv,if,arg,instanceof,parameterized,type,return,extract,class,owner,class,parameterized,type,arg,get,raw,type,else,return,extract,class,owner,class,arg,return,arg,instanceof,class,class,arg,object,class
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1328020251;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1340122048;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1344186578;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1351982790;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1353522416;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1356735495;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1362408075;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz);1367955086;Determine the target type for the given generic parameter type._@param methodParam the method parameter specification_@param clazz the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParam, Class clazz) {_		Type genericType = getTargetType(methodParam)__		Assert.notNull(clazz, "Class must not be null")__		Map<TypeVariable, Type> typeVariableMap = getTypeVariableMap(clazz)__		Type rawType = getRawType(genericType, typeVariableMap)__		Class result = (rawType instanceof Class ? (Class) rawType : methodParam.getParameterType())__		methodParam.setParameterType(result)__		methodParam.typeVariableMap = typeVariableMap__		return result__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,param,the,method,parameter,specification,param,clazz,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,param,class,clazz,type,generic,type,get,target,type,method,param,assert,not,null,clazz,class,must,not,be,null,map,type,variable,type,type,variable,map,get,type,variable,map,clazz,type,raw,type,get,raw,type,generic,type,type,variable,map,class,result,raw,type,instanceof,class,class,raw,type,method,param,get,parameter,type,method,param,set,parameter,type,result,method,param,type,variable,map,type,variable,map,return,result
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1328020251;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or <code>null</code> if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1340122048;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or <code>null</code> if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1344186578;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or <code>null</code> if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1351982790;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or <code>null</code> if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1353522416;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or <code>null</code> if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1356735495;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1362408075;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> public static Class[] resolveTypeArguments(Class clazz, Class genericIfc);1367955086;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class[] resolveTypeArguments(Class clazz, Class genericIfc) {_		return doResolveTypeArguments(clazz, clazz, genericIfc)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,return,do,resolve,type,arguments,clazz,clazz,generic,ifc
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1382716358;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1382747217;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map);1383229700;Resolve the specified generic type against the given TypeVariable map._@param genericType the generic type to resolve_@param map the TypeVariable Map to resolved against_@return the type if it resolves to a Class, or {@code Object.class} otherwise_@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {_		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).resolve(Object.class)__	};resolve,the,specified,generic,type,against,the,given,type,variable,map,param,generic,type,the,generic,type,to,resolve,param,map,the,type,variable,map,to,resolved,against,return,the,type,if,it,resolves,to,a,class,or,code,object,class,otherwise,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,public,static,class,resolve,type,type,generic,type,map,type,variable,type,map,return,resolvable,type,for,type,generic,type,new,type,variable,map,variable,resolver,map,resolve,object,class
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1385412762;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1399392386;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1449143598;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1467730834;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1468334463;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> @Deprecated 	@SuppressWarnings("rawtypes") 	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz);1485277217;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces._@deprecated as of Spring 4.0 in favor of {@link ResolvableType};@Deprecated_	@SuppressWarnings("rawtypes")_	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)__		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<>()__			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap)__			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap))__		}_		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces,deprecated,as,of,spring,4,0,in,favor,of,link,resolvable,type;deprecated,suppress,warnings,rawtypes,public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,build,type,variable,map,resolvable,type,for,class,clazz,type,variable,map,type,variable,cache,put,clazz,collections,unmodifiable,map,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1328020251;Build a mapping of {@link TypeVariable#getName TypeVariable names} to concrete_{@link Class} for the specified {@link Class}. Searches all super types,_enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Reference<Map<TypeVariable, Type>> ref = typeVariableCache.get(clazz)__		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref.get() : null)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, new WeakReference<Map<TypeVariable, Type>>(typeVariableMap))__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,concrete,link,class,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,reference,map,type,variable,type,ref,type,variable,cache,get,clazz,map,type,variable,type,type,variable,map,ref,null,ref,get,null,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,new,weak,reference,map,type,variable,type,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1340122048;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Reference<Map<TypeVariable, Type>> ref = typeVariableCache.get(clazz)__		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref.get() : null)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, new WeakReference<Map<TypeVariable, Type>>(typeVariableMap))__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,reference,map,type,variable,type,ref,type,variable,cache,get,clazz,map,type,variable,type,type,variable,map,ref,null,ref,get,null,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,new,weak,reference,map,type,variable,type,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1344186578;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Reference<Map<TypeVariable, Type>> ref = typeVariableCache.get(clazz)__		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref.get() : null)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, new WeakReference<Map<TypeVariable, Type>>(typeVariableMap))__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,reference,map,type,variable,type,ref,type,variable,cache,get,clazz,map,type,variable,type,type,variable,map,ref,null,ref,get,null,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,new,weak,reference,map,type,variable,type,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1351982790;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Map<TypeVariable, Type> ref = typeVariableCache.get(clazz)__		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref : null)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,ref,type,variable,cache,get,clazz,map,type,variable,type,type,variable,map,ref,null,ref,null,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1353522416;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Map<TypeVariable, Type> ref = typeVariableCache.get(clazz)__		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref : null)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,ref,type,variable,cache,get,clazz,map,type,variable,type,type,variable,map,ref,null,ref,null,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1356735495;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Map<TypeVariable, Type> ref = typeVariableCache.get(clazz)__		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref : null)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,ref,type,variable,cache,get,clazz,map,type,variable,type,type,variable,map,ref,null,ref,null,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1362408075;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz);1367955086;Build a mapping of {@link TypeVariable#getName TypeVariable names} to_{@link Class concrete classes} for the specified {@link Class}. Searches_all super types, enclosing types and interfaces.;public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {_		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz)___		if (typeVariableMap == null) {_			typeVariableMap = new HashMap<TypeVariable, Type>()___			_			extractTypeVariablesFromGenericInterfaces(clazz.getGenericInterfaces(), typeVariableMap)___			_			Type genericType = clazz.getGenericSuperclass()__			Class type = clazz.getSuperclass()__			while (type != null && !Object.class.equals(type)) {_				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap)__				genericType = type.getGenericSuperclass()__				type = type.getSuperclass()__			}__			_			type = clazz__			while (type.isMemberClass()) {_				genericType = type.getGenericSuperclass()__				if (genericType instanceof ParameterizedType) {_					ParameterizedType pt = (ParameterizedType) genericType__					populateTypeMapFromParameterizedType(pt, typeVariableMap)__				}_				type = type.getEnclosingClass()__			}__			typeVariableCache.put(clazz, typeVariableMap)__		}__		return typeVariableMap__	};build,a,mapping,of,link,type,variable,get,name,type,variable,names,to,link,class,concrete,classes,for,the,specified,link,class,searches,all,super,types,enclosing,types,and,interfaces;public,static,map,type,variable,type,get,type,variable,map,class,clazz,map,type,variable,type,type,variable,map,type,variable,cache,get,clazz,if,type,variable,map,null,type,variable,map,new,hash,map,type,variable,type,extract,type,variables,from,generic,interfaces,clazz,get,generic,interfaces,type,variable,map,type,generic,type,clazz,get,generic,superclass,class,type,clazz,get,superclass,while,type,null,object,class,equals,type,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,extract,type,variables,from,generic,interfaces,type,get,generic,interfaces,type,variable,map,generic,type,type,get,generic,superclass,type,type,get,superclass,type,clazz,while,type,is,member,class,generic,type,type,get,generic,superclass,if,generic,type,instanceof,parameterized,type,parameterized,type,pt,parameterized,type,generic,type,populate,type,map,from,parameterized,type,pt,type,variable,map,type,type,get,enclosing,class,type,variable,cache,put,clazz,type,variable,map,return,type,variable,map
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1449143598;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1467730834;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1468334463;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1485277217;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1491831389;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1491898149;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1495868221;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1496837955;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1502974979;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1530174524;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1530532518;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass);1532520919;Determine the target type for the given generic parameter type._@param methodParameter the method parameter specification_@param implementationClass the class to resolve type variables against_@return the corresponding generic parameter or return type;public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		Assert.notNull(implementationClass, "Class must not be null")__		methodParameter.setContainingClass(implementationClass)__		ResolvableType.resolveMethodParameter(methodParameter)__		return methodParameter.getParameterType()__	};determine,the,target,type,for,the,given,generic,parameter,type,param,method,parameter,the,method,parameter,specification,param,implementation,class,the,class,to,resolve,type,variables,against,return,the,corresponding,generic,parameter,or,return,type;public,static,class,resolve,parameter,type,method,parameter,method,parameter,class,implementation,class,assert,not,null,method,parameter,method,parameter,must,not,be,null,assert,not,null,implementation,class,class,must,not,be,null,method,parameter,set,containing,class,implementation,class,resolvable,type,resolve,method,parameter,method,parameter,return,method,parameter,get,parameter,type
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1328020251;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or <code>null</code> if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1340122048;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or <code>null</code> if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1344186578;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or <code>null</code> if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1351982790;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or <code>null</code> if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1353522416;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or <code>null</code> if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,code,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1356735495;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1362408075;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc);1367955086;Resolve the single type argument of the given generic interface against_the given target class which is assumed to implement the generic interface_and possibly declare a concrete type for its type variable._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of the argument, or {@code null} if not resolvable;public static Class<?> resolveTypeArgument(Class clazz, Class genericIfc) {_		Class[] typeArgs = resolveTypeArguments(clazz, genericIfc)__		if (typeArgs == null) {_			return null__		}_		if (typeArgs.length != 1) {_			throw new IllegalArgumentException("Expected 1 type argument on generic interface [" +_					genericIfc.getName() + "] but found " + typeArgs.length)__		}_		return typeArgs[0]__	};resolve,the,single,type,argument,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,a,concrete,type,for,its,type,variable,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,the,argument,or,code,null,if,not,resolvable;public,static,class,resolve,type,argument,class,clazz,class,generic,ifc,class,type,args,resolve,type,arguments,clazz,generic,ifc,if,type,args,null,return,null,if,type,args,length,1,throw,new,illegal,argument,exception,expected,1,type,argument,on,generic,interface,generic,ifc,get,name,but,found,type,args,length,return,type,args,0
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1383229700;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.hasUnresolvableGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,has,unresolvable,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1385412762;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.hasUnresolvableGenerics()) {_			return null__		}_		return type.resolveGenerics()__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,has,unresolvable,generics,return,null,return,type,resolve,generics
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1399392386;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1449143598;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1467730834;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1468334463;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1485277217;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1491831389;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
GenericTypeResolver -> public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc);1491898149;Resolve the type arguments of the given generic interface against the given_target class which is assumed to implement the generic interface and possibly_declare concrete types for its type variables._@param clazz the target class to check against_@param genericIfc the generic interface or superclass to resolve the type argument from_@return the resolved type of each argument, with the array size matching the_number of actual type arguments, or {@code null} if not resolvable;public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {_		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc)__		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {_			return null__		}_		return type.resolveGenerics(Object.class)__	};resolve,the,type,arguments,of,the,given,generic,interface,against,the,given,target,class,which,is,assumed,to,implement,the,generic,interface,and,possibly,declare,concrete,types,for,its,type,variables,param,clazz,the,target,class,to,check,against,param,generic,ifc,the,generic,interface,or,superclass,to,resolve,the,type,argument,from,return,the,resolved,type,of,each,argument,with,the,array,size,matching,the,number,of,actual,type,arguments,or,code,null,if,not,resolvable;public,static,class,resolve,type,arguments,class,clazz,class,generic,ifc,resolvable,type,type,resolvable,type,for,class,clazz,as,generic,ifc,if,type,has,generics,type,is,entirely,unresolvable,return,null,return,type,resolve,generics,object,class
